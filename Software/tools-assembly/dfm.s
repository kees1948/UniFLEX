       nam   dfm dump file as memory* dump file as memory       info  UniFLEX dfm, dump file as memory       info  (c) 1985 W. Lekkerkerker       opt   nol       lib   sysdef       opt   lisstdout equ   1stderr equ   2linsiz equ   72          output line lengthascii  equ   55          start of ascii columnlowlim equ   $1f         non printable asciiuplim  equ   $7f         non printable asciinotch  equ   '.          non printable charactersubsch equ   '-          hex substitute characterdfm    leax  4,s       stx   argpntmain   ldx   argpnt       ldd   ,x++        get name pointer       lbeq  done       stx   argpnt       std   statnm       std   openam       clr   filflg      no files open       sys   ind,istat   get filetype       lbes  stater       lda   statbf+4    mode       cmpa  #1          regular file?       lbne  badfil       sys   ind,iopen   open file       lbes  opener       std   fileds       inc   filflg      set opened* fileds still in d       sys   read,readbf,bufsiz       lbes  reader       cmpd  #0       lbeq  gocls       zero length?       addd  #readbf       std   bufend       ldd   readbf+16   info size       std   infosz       ldx   #readbf+24  point past header       stx   bufpnt       ldx   #clrbeginitia clr   ,x+       cmpx  #clrend       blo   initia       lda   readbf       cmpa  #2          binary?       lbne  badfil       ldd   bufend       cmpd  #readbf+24  header ok?       lblo  badfil       lda   readbf+1    binary type       cmpa  #$12        absolute binary?       bne   segtst      test if segmented       ldx   #absstr       stx   messtr       inc   mesflg       bra   dolinsegtst cmpa  #$11        segmented?       beq   segmen       cmpa  #$10        shared text?       lbne  badfil* segmented type binarysegmen sta   segflg      set segmented type       ldd   readbf+2    text size       std   textsz       ldd   readbf+4    data size       std   datasz* do a line* clear bufferdolin  ldx   #linbuf       lda   #$20        spaceclrlin sta   ,x+       cmpx  #linbuf+linsiz-1       blo   clrlin       lda   #$d         cr       sta   ,x       ldx   #linbuf     x = output line pointer       leau  ascii,x     u = ascii pointer* print the line       tst   pflag       char byte printed?       beq   newbyt       tst   recflg      all records closed?       lbne  gocls       if all done       bra   isread      print the bytenewbyt lbsr  getbyt      read first byte       beq   goclsisread tst   mesflg      print segment message?       beq   paddr       if not       ldd   #stdout       sys   ind,meswrt  write message       lbes  writer       clr   mesflgpaddr  ldd   loadad       andb  #$f0        modulus 16       tfr   d,y         y = address       tst   infflg      info?       beq   paddr2       leax  6,x         skip address if info       bra   paddr3paddr2 lbsr  out4h       print address       leax  2,x         2 spacespaddr3 clrb       bra   bloop2bloop  lbsr  getbytbloop2 cmpy  loadad      byte in file?       beq   bloop3substi lda   #subsch     substitute byte       sta   pflag       sta   ,x+       sta   ,x++       incb       cmpb  #16       bhs   wline       leay  1,y         next address       cmpy  loadad      this byte in file?       bne   substibloop3 lda   char       lbsr  out2h       print hex byte       clr   pflag       leax  1,x       lda   char       anda  #$7f       cmpa  #lowlim       bls   dosubs       cmpa  #uplim       blo   bloop4dosubs lda   #notchbloop4 sta   b,u       incb       cmpb  #16       bhs   wline       leay  1,y       bra   bloopwline  ldd   #stdout       sys   write,linbuf,linsiz       bes   writer       lbra  dolin* close filegocls  ldd   fileds       sys   close       lbra  main* end of programdone   ldd   #0done2  sys   term* error handlers* status errorstater ldd   #stderr       sys   write,sters,sterl stat error       bra   erend* can't open erroropener ldd   #stderr       sys   write,nopstr,noperl       bra   erend* read errorreader ldd   #stderr       sys   write,reastr,realngerend  bsr   prinam      print file name       ldd   #stderr       sys   write,dotstr,dotlng dot and cr       tst   filflg      file open?       lbeq  main       bra   gocls* not regular file errorbadfil bsr   prinam       ldd   #stderr       sys   write,nofstr,noflng       lbra  main* write errorwriter pshs  d       ldd   #stderr       sys   write,wristr,wrilng       puls  d       bra   done* print filenameprinam ldx   statnm      filename       stx   strpnt      put in write call       clrblen    lda   ,x+         read string       beq   len2       incb              count length       bra   lenlen2   std   strlen      set length in write call       ldd   #stderr       sys   ind,iwrite       rts* get byte from filegetbyt pshs  b,x,y,ugetb0  ldx   reclng      count length       beq   getb1       ldx   loadad       leax  1,x       stx   loadad       bra   getb2getb1  bsr   openrc       beq   getb3       if at eofgetb2  lbsr  inbytegetb3  pshs  cc       ldx   reclng       leax  -1,x       stx   reclng       puls  cc,b,x,y,u,pc* open recordopenrc tst   segflg      segmented?       beq   nosegs* set next segment* d = new load address* x = current segment flag* y = new record size* u = segment string address       ldx   curseg      text segment?       bne   dattst       leax  1,x       inc   mesflg      set print message       ldu   #txtstr       ldd   #0          load at 0       ldy   textsz       bne   setsiz      if textdattst cmpx  #1          data segment?       bhi   inftst       leax  1,x       ldy   datasz       beq   inftst      if no data       inc   mesflg      set print message       ldu   #datstr       ldd   textsz      next block after text       addd  #$fff       anda  #$f0       clrb       bra   setsizinftst cmpx  #2          info record?       bhi   clradr      if done       leax  1,x       ldy   infosz       beq   clradr       inc   mesflg       inc   infflg      no address print       ldu   #infstr       ldd   #0          zero address       bra   setsizclradr ldd   #0       ldy   #0       inc   recflgsetsiz std   loadad      set address       stx   curseg       stu   messtr      message string       sty   reclng      test zero cond.       rts* read absolute record headernosegs ldx   #reclng     length + load addr.       ldb   #4openr2 bsr   inbyte       beq   openr4       sta   ,x+       decb       bne   openr2       ldd   reclng      end of file?       bne   openr3       ldd   loadad       beq   openr4openr3 rtsopenr4 ldx   #2          info record       inc   segflg      simulate segments       bra   inftst* get byte from bufferinbyte ldu   bufpnt       cmpu  bufend      at end?       blo   inbyt2       ldd   fileds       sys   read,readbf,bufsiz       lbes  reader       cmpd  #0       beq   inbyt3      if eof       addd  #readbf       std   bufend       ldu   #readbfinbyt2 lda   ,u+       stu   bufpnt       sta   char       clz   set not equalinbyt3 rts* output 4 hex characters in Dout4h  bsr   out2h       tfr   b,a* output 2 hex charactersout2h  pshs  a       bsr   outhl       puls  a       bra   outhrouthl  lsra       lsra       lsra       lsraouthr  anda  #$f       adda  #'0       cmpa  #'9       bls   outhr2       adda  #7outhr2 sta   ,x+         put in buffer       rtssters  fcc   "dfm: can't find "sterl  equ   *-stersnopstr fcc   "dfm: can't open "noperl equ   *-nopstrreastr fcc   "dfm: error reading "realng equ   *-reastrdotstr fcc   ".",$ddotlng equ   *-dotstrnofstr fcc   " is not a binary file.",$dnoflng equ   *-nofstrwristr fcc   "dfm: error during write.",$dwrilng equ   *-wristrabsstr fcc      "absolute binary",$dmeslng equ      *-absstrtxtstr fcc      "text segment   "datstr fcc   $d,"data segment  "infstr fcc   $d,"info record   ",$d* indirect system callsistat  fcb   statusstatnm fdb   0       fdb   statbfiwrite fcb   writestrpnt fdb   0strlen fdb   0iopen  fcb   openopenam fdb   0       fdb   0           for readmeswrt fcb   writemesstr fdb   0       fdb   meslng* variables buffersargpnt rmb   2           arguments pointerfilflg rmb   1           file opened flagfileds rmb   2           file descriptorbufend rmb   2           end of bufferbufpnt rmb   2           read buffer pointerclrbeg equ   *recflg rmb   1           last record flag* next 2 cannot be separated!!reclng rmb   2           record lengthloadad rmb   2           load addressinfflg rmb   1           no address flagpflag  rmb   1           data to be printed flagmesflg rmb   1           print message flagsegflg rmb   1           segmented binary flagcurseg rmb   2           current segmentclrend equ   *textsz rmb   2           text segment sizedatasz rmb   2           data segment sizeinfosz rmb   2           info part sizechar   rmb   1           read from bufferlinbuf rmb   linsiz      output line bufferstatbf rmb   21       org   (*+$1ff)&$fe00readbf equ   *nxtblk equ   (*+$fff)&$f000bufsiz equ   nxtblk-readbf       end   dfm