          ttl     Network Boot          sttl    boots kernel from 'boot/root' server          pag          info    Bootstrap  for CPU09GPP/09NET          lib     nwp_unibug.h          lib     nwpboot.h          opt     exp* UniFLEX Bootstrap Loader for CPU09GPP/09NET** Assumptions:* 'Boot' resides in to lower 65K blocks on the disk* boot from drive 0, first image** the local network device has been setup after reset* with the settings found in the nwp ROM** the connection to the remote server is coded in* wz8ipad and wz8port settings*nbootorg  equ     $0800    space for boot code* Special core locationscorcnt    equ     $13lstmem    equ     $14DATMAP    equ     $F40A      Map for $A000* Equatesffmap     equ     17         file map offset in fdnbhxfr     equ     10         transfer address offset in headerBHDSIZ    equ     24         binary file header size** the UniFLEX kernel has some pointers at start of code** 5000   fdb  unidat            relic from "install"* 5002   fdb  parttbl (unidat2)* 5004   fdb  unikey            relic from "install"* 5006   fdb  unisrn* 5008   fdb  contabparttbl  equ  $5002             tell boot where to find pointer*********************************************************************************************************************************************************** Temporary storage* will be overwritten when kernel intializes          org     nbootorg-32     in low memory, past memory tablesdirect    rmb     1         index in mapmapptr    rmb     2fdnbkn    rmb     3entrys    rmb     2         entries in directoryxfradr    rmb     2wzsock    rmb     2          rmb     2********************************************* Start of program,********************************************          org nbootorg* Lookup "Boot" in directory** on entry U holds the controller base address* D holds drive select info*uboot     lbra    uboot0     skip disk type bytes********************************************************* settings for /dev/netblk0 in booted kernel**wz8ipad fcb     192,168,1,155 255,255,255,255wz8port fdb     31000         $ffff********************************************************** filename for bootingbootn   fcb     $0dbtname  fcc     'uniflexn'      can't be choosen from commandlineextchar fcb 0                   extra character for name        fcb     0,0,0,0,0      14 in totalcrlf    fcb     $0d,$0a,0*uboot0  ldx     #bootn     show bootname        jsr     [rpdata]          ldx     #crlf          jsr     [rpdata]*          lda     $010A      check block $A000 mapped in          cmpa    #BLKHOL    black hole?          bne     uboot2          dec     corcnt     decrease number of pages available          ldx     lstmem     pick up last page pointer          lda     ,-x        get a page          stx     lstmem          sta     $010A      set up map          sta     DATMAP     map it in for us************************************************************** do initialization of things here*************************************************************          ldx     #fio_dba    fifo          ldu     #fifo_us0          addr    X,U        X+U > U          stu     wzsock     (wzsock8)          lda     wzfsta,u          ora     #WZBUSY          sta     wzfsta,u          ldd     #AF_INET          std     wzfaml,u      family          ldd     #SK_STRM|SK_SPONCL          std     wztype,u          ldd     #0          std     wzprot,u          ldb     #S_OPEN          jsr     nw_msg        open socket* test error          ldd    wz8ipad          std    wzipad,u  std  $03b0,x          ldd    wz8ipad+2          std    wzipad+2,u  std  $03b2,x          ldd    wz8port          std    wzdprt,u  std  $03b4,x          ldb    #S_CONNECT          jsr    nw_msg* test error** socket for bootfile has been setup*************************************************************** here the actual boot process starts*************************************************************uboot2    ldd     #1         root directory fdn no.          jsr    fdnblk     read in fdn          ldd     7,y        find size of directory          jsr    divby8          lsra          rorb          std     entrys     save entry countread1     jsr    rdblk      read data block          lbne    noboot     exit if error*lookup    leax    2,u        point to filespec          ldd     0,u        check for deleted entry          beq     nxtent     skip deleted files          ldy     #btname point to boot file name          ldb     #14        set name lengthcmpnam    lda     0,x+          cmpa    0,y+       is this boot file entry?          bne     nxtent     if not, skip to next          decb          bne     cmpnam          ldd     0,u        found it, get fdn          bra     load       go load uniflex*nxtent    ldx     entrys          leax    -1,x       decrement count          stx     entrys     end of directory?          beq     noboot     error if so          leau    16,u       point to next entry          cmpu    #buffer+512 past current block?          bne     lookup     check entry if not          bra     read1      else, get another block**************************************************************** found it, Load Boot Imageload      bsr     fdnblk     read in uniflex fdn          jsr     rdblk      read 1st block of the file          bne     noboot     exit if error          ldd     bhxfr,u    get transfer address          std     xfradr     save it          leau    BHDSIZ,u   skip binary file headergetrc1    bsr     getchr     get record length in x          tfr     b,a          bsr     getchr          cmpd    #0         terminator?          beq     done       start uniflex if so          tfr     d,x          bsr     getchr     get load address in y          tfr     b,a          bsr     getchr          tfr     d,ygetrc2    bsr     getchr     get a data byte          stb     0,y+       put in memory          leax    -1,x       decrement the count          bne     getrc2     loop if not end of record          bra     getrc1     else, get next record**************************************************************** Boot is loaded, next  finish things up***************************************************************done      ldu   wzsock          clr   wzfsta,u   release wzsock*********************************************************************************************************************************          jmp     [xfradr]   jump to transfer addressbooterr  equ    *        lda     #'?        jsr     [routch]        tfr     b,a        jsr     [rhexbyt]        swi                     force reset***************************************************************** artificial blockno of boot sector on disk*bootno    fcb     0,0,0      we need it for mread**************************************************************** Divide contents of D by 8divby8    lsra          rorb          lsra          rorb          lsra          rorb          rts**************************************************************** Get single character from binary filegetchr    cmpu    #buffer+512 more data in buffer?          bne     getch2     skip if so          pshs    a,x,y          bsr     rdblk      else, read another block          puls    a,x,y          bne     nbootx     exit if errorgetch2    ldb     0,u+       get character, advance ptr          rts**************************************************************** Uniflex file was not foundnbootx    puls    d          fix stacknoboot    bra    booterr    return to monitor ROM**************************************************************** Read fdn specified in Dfdnblk    pshs    d          save fdn number          addd    #15        convert to block number          bsr     divby8          std     fdnbkn+1          clr     fdnbkn          ldy     #fdnbkn          bsr    mread      read a block          puls    d          restore fdn number          bne     nbootx     exit if error          decb    calculate  buffer offset          andb    #$07          lda     #64          mul     offset=(fdn&7)*64          addd    #map          tfr     d,y        fdn pointer in y          addd    #9         point to ffmap          std     mapptr     save map pointer          lda     #10        get direct block count          sta     direct     initialize indirect flag          rts**************************************************************** Read a block from filerdblk     tst     direct     a direct block?          beq     chgind     change to indirect          dec     direct     dec. direct count          ldy     mapptr     get file map pointer          ldx     #buffer    setup buffer address          bsr     xread      read the sector          pshs    cc          sty     mapptr          puls    cc,pcchgind    ldy     mapptr     get file map pointer          bsr     mread      read block of indirects          bne     nbootx     exit if error          stu     mapptr     reset file map pointer          lda     #128       set new direct count          sta     direct          bra     rdblk      now read data block***************************************************** Read the specified map block (low level)****************************************************mread     ldx     #map       address of buffer for block***************************************************** LOW level drivers for IDE* in PIO mode hibyte is don't care**   X - Buffer Address*   Y - Block # Pointer (updated)****************************************************** Read a single sectorxread     pshs     x,u          stx      2,s          U should return buffer          ldu      wzsock          ldx      #fio_dba          ldd      1,y          block #          std      fifo_us3,x          leay     3,y          tot next entry          ldd      #$ff00       force READ          std      fifo_us2,x   which clear hhh byte for blocks          ldd      #BUFSIZ          std      wzrqln,u          ldb      #S_RQRBLK          bsr      nw_msg* test error          cmpb     #R_RQRBLK          bne      xrderr          ldb      #S_RDRBLK          bsr      nw_msg* test error          cmpb     #R_RDRBLK          bne      xrderr*          ldwx     wzxfer,2     IU!!          leax     fifo,x          ldu      0,s          buffer address          tfm1     X,U          puls     x,u,pcxrderr    puls     x,u          leas     2,s          lbra      booterr      error****************************************************** DPR access, X=fio_dba, B=cmd, U=wzsock*****************************************************nw_msg    pshs    x,u          stb     cpu_fio,x     set command          stu     cpu_fio3,x    set device info*          ldu     #fio_dsz          leau    -1,u          addr    X,U          X+U > U          stb     0,u          cpio_fioF*01        ldb     0,u          bne     01b*02        ldb     -1,u          fio_cpuF          beq     02b           B has status          clr     -1,u          erase flag          puls    x,u,pc****************************************************          if      (*-uboot)>512          err     Bootstrap Overflow!          else          rzb     512-(*-uboot)          endif* Buffersbuffer    rmb     512map       rmb     512          end