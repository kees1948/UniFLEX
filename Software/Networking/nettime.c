#include <stdio.h>#include <net.h>#include <sgtty.h>#include <time.h>char buffer[128];uint32_t mytime;uint32_t mktime();static uint32_t mkgmtime();#define TZ_OFFSET 6  /* CET */#define EPO 315532800L /* first test with fixed IP time-d-b.nist.gov*/#define MYSERVER "132.163.96.4"#define MYPORT "13"int main(argc, argv)int argc;char **argv;{    int sfdn, i=0, count =0, errflag=0;    struct sockaddr_in server;    struct tm myt;    pflinit();    if((sfdn = socket(AF_INET, SOCK_STREAM, 0)) < 0)    {        fprintf(stderr,"Socket open error\n");        exit (-1);    }    bzero(&server, sizeof(struct server));    server.sin_family = AF_INET;    server.sin_port = atoi (MYPORT);    server.sin_addr = (uint32_t) inet_addr(MYSERVER) ;    i = connect(sfdn,(struct sockaddrin*) &server, sizeof(server));    if (i == -1)    {        printf ("Connect error!\n");        exit(1);    }    bzero(&myt, sizeof(struct myt));/* we ignore the first reply */    buffer[0] = 0x0d;    buffer[1] = '\0';    write (sfdn, buffer, 2);    i = read(sfdn, buffer, 64);    if (i < 0)        errflag =1;/* the second response holds our date */    buffer[0] = 0x0d;    buffer[1] = '\0';    write (sfdn, buffer, 2);    i = read(sfdn, buffer, 64);    if (i < 0)        errflag =1;    sscanf(buffer,"%*d %02d-%02d-%02d %02d:%02d:%02d",    &myt.tm_year, &myt.tm_mon, &myt.tm_mday,    &myt.tm_hour, &myt.tm_min, &myt.tm_secs);    myt.tm_mon--;    mytime = (uint32_t) mktime((uint32_t*) &myt);    myt.tm_mon++;    mytime -= EPO;    if (errflag == 0)    /* only with valid date */        stime(mytime);    close(sfdn);}/* * mktime.c -- converts a struct tm into a time_t * * Copyright (C) 1997 Free Software Foundation, Inc. * * This program is free software; you can redistribute it and/or modify it under * the terms of the GNU General Public License as published by the Free * Software Foundation; either version 2, or (at your option) any later * version. * * This program is distributed in the hope that it will be useful, but WITHOUT * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for * more details.[ * * You should have received a copy of the GNU General Public License along with * this program; if not, write to the Free Software Foundation, Inc., 59 * Temple Place - Suite 330, Boston, MA 02111-1307, USA. *//* Written by Philippe De Muyter <phdm@macqel.be>.  */static uint32_t mkgmtime(t)struct tm *t;{    uint16_t month, year;    uint32_t result;    static int m_to_d[12]= {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};    month = t->tm_mon;    year = t->tm_year + month / 12 ;    month %= 12;    if (month < 0) {        year -= 1;        month += 12;    }    result = (uint32_t)(year - 1970) * 365L + (uint32_t)(m_to_d[month]);    if (month <= 1)        year -= 1;    result += (uint32_t)((year - 1968) / 4);    result -= (uint32_t)((year - 1900) / 100);    result += (uint32_t)((year - 1600) / 400);    result += (uint32_t)(t->tm_mday);    result -= 1L;    result *= 24L;    result += (uint32_t)(t->tm_hour);    result *= 60L;    result += (uint32_t)(t->tm_min);    result *= 60L;    result += (uint32_t)(t->tm_secs);    return (uint32_t)(result);}/* *  mktime -- convert tm struct to uint32_t *              if tm_isdst >= 0 use it, else compute it */uint32_t mktime(t)struct tm* t;{    uint32_t result; /*   tzset();  */    result = mkgmtime(t) + (uint32_t)(3600 * TZ_OFFSET); /* + timezone; */    return (uint32_t) (result);}