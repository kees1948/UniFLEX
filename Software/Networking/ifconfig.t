** ifconfig, display or set the network device settings*            lib     sysdef            lib     syserrors            lib     macdefsstart       equ     *            ldd     0,s     check arg count            cmpd    #1      usage?            lbeq    ifusag*            ldx     4,s            ldy     #netdev+5    '/dev/'  skip directory path            ldd     0,x++            cmpd    0,y++            lbne    namerr            ldd     0,x            cmpd    0,y            lbne    namerr** read in current info*            jsr     readnd            lbne    filerr***            ldd     0,s            cmpd    #2      only display?            lbls    ifdisp** with arguments, start processing those*            leax    6,s        first arg            stx     argptr10          ldx     argptr            ldx     0,x            lbeq    wadone*            ldu     #tokens    match,func,data04          pshs    u            ldy     0,u        name pointer            lbeq    tokerr02          lda     0,y+            beq     03f        end of token            cmpa    0,x+            beq     02b            puls    u            leau    6,u         next token            ldx     argptr            ldx     0,x         reset argument            bra     04b* end of name full match03          puls    u            jsr     [2,u]            ldx     argptr            leax    2,x            stx     argptr            bra     10bwadone      sys     open,netdev,2            lbes    err1            std     netfdn            sys     write,netprm,NETDLEN            lbes    err2            ldd     netfdn            sys     close            clrd            sys     term** we should collect a valid IP address*d_maskd_gatwd_inet* we should get a valid IP address now, parse argument* X=arg pointer to token* U is token pointer, 0,u is token, 2,u is *func, 4,u is *datainp3ip      ldx     argptr            leax    2,x         advance to data            stx     argptr            ldx     0,x         *data            ldy     4,u         *destination            ldb     #405          pshs    b           counter            clr     0,-s        work space*04          lda     0,x+            beq     02f         end of input            cmpa    #'.         separetor            beq     02f            ldb     0,s            lsl     0,s            lsl     0,s            lsl     0,s            lslb            addb    0,s            stb     0,s         * 10            suba    #'0            lbmi    err4         invalid decimal            adda    0,s            sta     0,s            lbcs    err4            bra     04b02          lda     0,s+            sta     0,y+            puls    b            decb            bne     05b            rts** we should get a valid MAC address now, parse argument* X=arg pointer to token* U is token pointer, 0,u is token, 2,u is *func, 4,u is *datad_maca      ldx     argptr            leax    2,x         advance to data            stx     argptr            ldx     0,x         *data            ldy     4,u         *destination            ldb     #605          pshs    b           counter            clr     0,-s        work space*04          lda     0,x+            beq     02f         end of input            cmpa    #':         separetor            beq     02f            ora     #$20        mask lower case            suba    #'0            lbmi    tokerr            cmpa    #9            bls     08f            suba    #$27        make hex a-f08          cmpa    #15            lbhi    tokerr            adda    0,s            sta     0,s*            lda     0,x+            lbeq    tokerr      end of input            cmpa    #':         separetor            lbeq    tokerr            ldb     0,s            lslb            lslb            lslb            lslb            stb     0,s            ora     #$20        mask lower case            suba    #'0            lbmi    tokerr            cmpa    #9            bls     08f            suba    #$27        make hex a-f08          cmpa    #15            lbhi    tokerr            adda    0,s            sta     0,s            bra     04b*02          lda     0,s+            sta     0,y+            puls    b            decb            bne     05b            rtsd_doup      lda     #$ff            sta     [4,u]            rtsd_ddwn      clra            sta     [4,u]            rts** show usage message*ifusag      equ     *            ldd     #2            sys     write,usgmsg,usglen*            clrd            sys     term** read netdevice info from driver*readnd      sys     open,netdev,0            bes     01f            std     netfdn*            sys     read,netprm,NETDLEN            bes     02f            ldd     netfdn            sys     close            clra            rts01          lda     #1            bra     03f02          lda     #203          rts** display current settings*ifdisp      equ     *** we got: gwad(4), mask(4), IPAD(4), hwad(6)*            ldd     #1      stdout            sys     write,ipad,ipal text            ldx     #netprm  data pointer            jsr     prtip*            ldd     #1            sys     write,mask,mskl            leax    4,x            jsr     prtip*            ldd     #1            tst     ndvsta            beq     01f            sys     write,upmsg,upmsgl            bra     02f01          sys     write,dwnmsg,dwnmsgl02          jsr     pcrlf*            ldd     #1            sys     write,gwad,gwal            leax    4,x            jsr     prtip*            ldd     #1            sys     write,mcad,mcal            leax    4,x            jsr     prtmac*            jsr     pcrlf*            ldd     #0            sys     term** print byte in max 3 decimal number*prtip       pshs    x,y            ldb     #4          # of items            pshs    b01          lda     0,x+            bsr     prtadec print a in decimal            dec     0,s            beq     02f            ldd     #1            sys     write,decpnt,1            bra     01b02          leas    1,s         cleanup            puls    x,y,pc** convert byte in max 3 decimals*prtadec     pshs   d,x,u            ldx     #dectab     decimal converison table            leas    -4,s            tfr     s,u*            ldb     #1          minimal 1 digit i.e. '0'            stb     3,u*            clrb                character index            stb     0,u         erase work space            stb     1,u            stb     2,u***02          tsta                are we done?            beq     03f*            cmpa    0,x         check against table            blo     01f            suba    0,x         table values            inc     b,u         count            pshs    b           when table length setting            ldb     1,x         is higher take it            cmpb    3,u            bls     09f            stb     3,u         set # digits09          puls    b            bra     02b***01          leax    2,x         next table entry            pshs    b           check if index > # digits            incb                index should not pass max #digits            cmpb    3,u            puls    b            bhs     02b            incb                up the index            bra     02b***03          ldb     3,u         take the length            pshs    b            clrb04          lda     b,u         make ascii            adda    #'0            sta     b,u            incb            cmpb    0,s            bne     04b            puls    b* we have chars in stack pointed by U05          clra            pshs    d            pshs    u            lda     #write            pshs    a            ldd     #1         stdout            tfr     s,x            sys     indx            leas    5+4,s   cleanup stack            puls    d,x,u,pc* table has check value and max digits countdectab      fcb     100,3,10,2,1,1decpnt      fcb     '.pcrlf       ldd     #1            sys     write,crlf,crlfl            rts** print mac address XX:XX:XX:XX:XX:XX*prtmac      pshs    x,u           remember origin            leas    -17,s         buffer            tfr     s,u            clrb04          lda     0,x            lsra            lsra            lsra            lsra            adda    #'0           one (hex) character            cmpa    #'9            bls     01f            adda    #701          sta     b,u            incb            lda     0,x+          next (hex) character            anda    #$0f            adda    #'0            cmpa    #'9            bls     02f            adda    #702          sta     b,u            incb            cmpb    #17            bhs     03f            lda     #':           separator            sta     b,u            incb            bra     04b*03          clra            pshs    d            pshs    u            lda     #write            pshs    a            ldd     #1            tfr     s,x            sys     indx            leas    17+5,s      empty stack            puls    x,u,pc*tokerr      ldd     #2            sys     write,tokene,tokenl            bra     errext*namerr      ldd     #2            sys     write,noname,nonaml            bra     errexterr4        ldd     #2            sys     write,former,formel            bra     errext*filerr      cmpa    #2            beq     err2err1        ldd     #2            sys     write,opener,openel            bra     errexterr2        ldd     #2            sys     write,reader,readel*errext      ldd     #1            sys     term** names and tables*noname      fcc     "*** can't open device ",$dnonaml      equ     *-nonameusgmsg      fcc     "Usage:  ifconfig <device> [<command> <data>] ",$dusglen      equ     *-usgmsgformer      fcc     "invalid IP address",$dformel      equ     *-formeripad        fcc     "inet      "ipal        equ     *-ipadn_inet      fcc     "inet",0n_mask      fcc     "netmask",0n_gatw      fcc     "gateway",0n_maca      fcc     "ether",0n_dup       fcc     "up",0n_dwn       fcc     "down",0mask        fcc     "  netmask "mskl        equ     *-maskgwad        fcc     "gateway   "gwal        equ     *-gwadmcad        fcc     "  ether   "mcal        equ     *-mcadopener      fcc     "*** Can't open device",$dopenel      equ     *-openerreader      fcc     "*** Error reading device",$dreadel      equ     *-readercrlf        fcb     $d,0crlfl       equ     *-crlfnetdev      fcc     "/dev/net0",0tokene      fcc     "*** syntax error ",$dtokenl      equ     *-tokeneupmsg       fcc     "    up"upmsgl      equ     *-upmsgdwnmsg      fcc     "    down"dwnmsgl     equ     *-dwnmsgtokens      equ     *            fdb     n_inet,d_inet,ipaddr            fdb     n_mask,d_mask,ipmask            fdb     n_gatw,d_gatw,ipgatw            fdb     n_maca,d_maca,macadd            fdb     n_dup,d_doup,ndvsta            fdb     n_dwn,d_ddwn,ndvsta            fdb     0netprm      equ     *ipaddr      rzb     4ipmask      rzb     4ipgatw      rzb     4macadd      rzb     6ndvsta      rzb     1            rzb     3NETDLEN     equ     *-netprmargptr      rzb     2netfdn      rzb     2            end     start