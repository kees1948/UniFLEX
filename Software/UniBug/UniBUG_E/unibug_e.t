         ttl     UniFLEX Monitor ROM         sttl     Equates         pag         lib        unibug_d4.h         opt        exp         abs        setdp   0** Monitor ROM for booting UniFLEX and handling the UniFLEX* interrupt processing.* 2020-12-19  added init  step voor kernel debgger 0.08** 2021-08-07  adapted the hirom code for handling the stacksize* differences between 63X09 and 68X09** 2021-10-24  set stackpointer in DATBOX at first** 2022-03-01  added floppy boot for CPU09GPP/09FLP** 2022-11-23  fixed a nasty bug in kfirq** 2023-04-01  restructured the interrupt handlers** 2024-05-01  clear changemap added** 2024-06-20 added netboot code 'N' opt* 2024-10-15 made fio_msg better* 2025-10-30 fixed subtle bug(s) in high level interrupt*            floppy boot returns to unibug on error*            ide boot returns to unibug on error*            changed the way memory is checked for*            presence, any mix of memory components allowed*** low ram interrupt vectors org sysseg<<12irqvec     rmb     2         maskable interruptswivec     rmb     2         swi 1sw2vec     rmb     2         swi 2sw3vec     rmb     2         swi 3nmivec     rmb     2         non-maskable interruptfrqvec     rmb     2         fast interrupt* low memory system storagecputyp     rmb     1         cpu typecpumod     rmb     1         cpu mode 63/68usrtop     rmb     1         current user segmentkernel     rmb     1         kernel/user state (-1 = user address space)chpflg     rmb     1         change process flagchtask     rmb     2         change process vectorcorcnt     rmb     1         core segment countlstmem     rmb     2         mem table end markerteluch     rmb     1         user change flagmemmsk     rmb     1         dat cell maskromspr     rmb     1         spare byte for rom* System and global memory maps org (sysseg<<12)+$100sysmap     rmb     segadr     system memory mapcormap     rmb     segmax     available memory list* User block definitions org (usrseg<<12)+$f38ubasea     set     (usrseg<<12)+$f00ubasdp     set     ubasea/256*sysstk     equ *             system stack starts hereudummy     rmb     3         spareustksz     rmb     1         save interrupt stack depthuargp      rmb     2         user argv pointeruswi2v     rmb     2         swi2 vector save* this _SHOULD_ be at ff40usp        rmb     2         user stack pointerurelod     rmb     1         map reload flagumapno     rmb     1         task map numberusrmap     rmb     segadr     user task memory map*usercc     rmb     1         condition codesuserd      rmb     2         D registeruserx      rmb     2         X registeruserpc     rmb     2         PC registeruserpb     rmb     1         sys call post byte           sttl     Initial ROM Processing           pag** Rom code starts here*           org     romadr** I/O Vectors*           fdb     rinit        cold start monitor           fdb     tinit        console init           fdb     inchck       test console character ready           fdb     inch         read one character fromconsoleterminal           fdb     outch        write one character to console           fdb     pdata        print a string (X)           fdb     hexbyt       print one hex byte (A)           fcc    "UniBUG (_e)  2025-06-08"** bring monitor to life, stack in top of DATBOX*rinit      seti         clra         tfr     a,dp         lds     #DATSTK       if re-called.... or from extern         jsr     tinit          setup console port********************************************************************************* setting the hardware memory tables from scratch** put the initial table somewhere in the DATBOX** only after memory has been found, setup the kernel tables* in the lowest regions of the kernel memory** in DATBOX:** DATSTK  initial kernel stack** DATTBL  initial memory table* DATCOR  initial memory core count** DATMAP  (initial) kernel memory map* XX XX XX XX XX XX XX XX XX XX XX XX XX FE FF********************************************************************************         clrb         ldy     #DATTBL        initial memory table in DATBOX         lda     #$ff           fill with 'invalid' pattern01       sta     0,y+           256 bytes         decb         bne     01b            all entries set to invalid* Y is at end         ldx     #tstpat       test pattern         ldb     #LSTPAG       maximum virtual memory page for kernel* work backwards over all possible virtual memory05       jsr     getpag        set in DXXX         stx     tstloc        D000 + offset         cmpx    tstloc        is it ram?         bne     02f           no* test for mirroring         pshs    b             check all other pages03       jsr     getpag         stb     tstloc+1      mirror mem?         subb    #1         bcc     03b         puls    b             restore         jsr     getpag        reselect page         cmpb    tstloc+1      is memory there?         bne     02f* we found real memory page04       sta     0,-y          put in table02       subb    #1            try all         bcc     05b** we checked all possible memory pages for their presence*         leax   0,y            keep pointer* setup system pages        bsr     getnxt         get a memory page from table        lbeq    memfal***************************************************************************** we found at least 4K memory to start with** first we start to setup the kernel tables page****************************************************************************        sta     datbox+sysres  set memory for first kernel page* erase all contents        bsr     erapag         erase the page***************************************************************************** fill kernel memory table with blackholes****************************************************************************        ldu     #sysmap         kernel memory table* fill sysmap with black holes first        pshs    a,u        ldb     #nomap          blackholes        lda     #segadr         segments / page09      stb     0,u+        deca        bne     09b        puls    a,u*        sta     sysseg,u        update kernel memory table        sta     datbox+sysseg*        ldd     datbox+ioseg    already setup        std     ioseg,u         set IO and ROM*        bsr     getnxt          kernel stack page        lbeq    memfal*        sta     usrseg,u        set usertop page for kernel        sta     datbox+usrseg        bsr     erapag          erase contents**************************************************************************** kernel zero page and kernel stack page has been setup***************************************************************************** copy pages from initial memory table into kernel memory table*        ldy     #cormap         start of kernel memory pool table11      bsr     getnxt        beq     12f        sta     0,y+        inc     corcnt          was mass erased        bra     11b* kernel memory pool setup12      sty     lstmem          pointer just byond last loc        bra     wrmstrt** memory pages handlers** map in a memory pagegetpag   tfr     b,a         get page number         sta     datbox+tfrseg map into address space         rts                 return* get next valid memory segmentgetnxt   cmpx     #DATTBL+segmax end of map?         beq     getnx2         lda     0,x+         get next page         cmpa    #$ff         empty         beq     getnxt       keep looking if zerogetnx2   rts                return* erase datbox+tfrseg completelyerapag   pshs   y         sta    datbox+tfrseg         clr    0,-s         ldy    #tfrmap       buffer address         ldwi   segsiz         tfm4   S,Y         puls   b,y,pc********************************************************************************* now, do remainder of setup********************************************************************************wrmstrt lds     #romstk     set stack*        clra                 set dp        tfr     a,dp** preset DATBOX with blackholes, skip kernel table*        ldx      #datbox+segadr    fill datbox with blackholes        ldy      #datsiz-segadr        lda      #nomap     black holerinit9  sta      0,xrinit8  leax     1,x        leay    -1,y        bne      rinit9*        ldx     #sysmap     copy table for kernel to DATBOX        ldy     #DATBOX01      ldd     0,x++        std     0,y++        cmpx    #sysmap+segadr        blo     01b** memory table build, kernel allocated* DATBOX fully setup*         clr     tlatch       initializes latch to task 0* init debugger hardware (if present)         ldx    dbsign        check if kernel debug present         cmpx   #DEBSIG       special pattern         bne    rinod         no, just return         jsr    [debini]      init debugger** set trap PIA and LED and TIMER*rinod    lda     #$04           select data register         sta     monpcra         sta     monpcrb         clra                   all output         sta     monpdrb        LEDS off         sta     monpdra        timer stop         sta     monpcra        dir register         sta     monpcrb         lda     #$0f           select timer/rom control         sta     monpdra         lda     #$ff         sta     monpdrb         lda     #$04           select data register         sta     monpcra         sta     monpcrb        disabled mem trap irq*         jsr     tinit         init the terminal         ldx     #hello         point to string         jsr     pdata         print the string         ldy     #irqvec     point to int vectors         ldx     #unhand     and unhandeled routine         ldb     #6             set countrinit4   stx     0,y++         store vector         leax     7,x         point to next panic         decb         bne     rinit4         stx     chtask         set change task vector         sttl     Main Monitor Loop         pag** Main monitor loop (command processor)** Loop starts heremontor         lds     #romstk         leau     0,s        mark stack         leas     -dlen,s    make temp spacenxtcmd   ldx     #prompt     point to prompt string         jsr     pdata       output it         jsr     inch        get response         jsr     outsp       output space         ldx     #commnd     point to command table         bsr     search      search for command         jsr     [1,x]       execute command         bra     montor      repeat* Search command table for commandsearch     cmpa     0,x         is it this guy?         beq     searc2         leax     3,x         skip this one         tst     0,x         end of list?         bne     searchsearc2     rts     return* Command tablecommnd     fcb     $d             carriage return         fdb     dummy         fcb     'C             Configure command         fdb     figlef         fcb     'D             Disk boot (0/1)         fdb     dboot         fcb     'E             Examine         fdb     examine         fcb     'M             memory modify         fdb     modify         fcb     'V             Mapper         fdb     mapper         fcb     'J             jump to location         fdb     jumpprg         fcb     'F             floppy boot F (0/1)         fdb     fboot         fcb     'N             network boot         fdb     nboot         fcb     'K            free memory         fdb     dspmem         fcb     0             end of table         fdb     badcmd* Configure the system commandfiglef   jsr     config         do configuration         lda     corcnt         get core count         adda     #7            2 system pages 5 kernel pages         sta     count,u     save it         bra     figle1*dspmem   lda     corcnt         set count to 0         adda    #2             2 block already assigned         sta     count,ufigle1   ldd     #0figle2   adda    #4             covert to decimal         daa         adcb    #0             add in carry         dec     count,u         bne     figle2         finished?         tstb                   more than 99K of memory?         beq     figle4         exg     a,b           do upper digit now         adda     #$30         jsr     outch         output it         exg     b,a           get low backfigle4   jsr     hexbyt         output byte         jsr     outsp         output space         lda     #'K           output 'K'figle5   jmp     outch** Disk boot commands* IDE boot*dboot     jsr     config         configure system*          ldu     #brdbas0          bsr     getctl*dboot3    jsr     loadip         load the ipl sector          bra     bootex** get controller*getctl    clrb          ldy     #20000getct1    jsr     inchck         key pressed          bcs     getct2          lbsr    delay          leay    -1,y          bne     getct1          bra     getct3*getct2    jsr     inch           get character from keyboard          cmpa    #$0d           ENTER?          beq     getct3          cmpa    #'1          bhi     getct3         invalid          suba    #'0          tfr     a,bgetct3    rts* floppy bootfboot     jsr     config         configure system*          ldu     #gppbase       floppy interface          bsr     getctl*fboot3    jsr     loadif         load the ipl sector*bootex    beq     fboot4          jsr     hexbyt          rts*fboot4   jmp     0,x         go do the boot** N - netboot*        lib     unibug_n.h      learn about hardware*nboot   equ     *        jsr     config          setup memory*        ldd     fio_dba         is hardware present        bne     01f        ldd     fio_dba+2       IS cleared only after reset        beq     02f* not found01      lda     #'?             tell user        jsr     outch        rts** bring netboot code into memory*02      ldu     #fio_dba        hardware address        ldd     #$ffff        std     cpu_fio1,u      fake sequence        ldx     #bootorg        set execute address        pshs    x        clra        ldb     #%01111110      memory page to copy from GPPROM        bsr     rdmemb        rts                     goto to it** subroutine to copy fifo data to kernel memory*rdmemb  pshs    d,x        std     fifo_us3,u        ldb     #S_PG2FIFO      command, copy block to fifo        stb     cpu_fio,u        ldx     #fio_dsz        device size        addr    U,X             U+X >X        leax    -2,x            find interrupt flag locations        stb     1,x             cpu_fioF   tell GPP        lda     #'+        jsr     outch12      ldb     1,x        bne     12b             wait until taken*03      ldb     0,x             fio_cpuF   read GPP        beq     03b        cmpb    #R_RDOK         right response?        beq     07f*        jsr     01b             something wrong!* stack contains: D,X,PC,X2,PC        leas    8,s             skip registers and return address        rts                     to UniBUG*07      lda     #'=             tell answer came        jsr     outch        pshs    x,y,u        ldwi    fio_fsz         count = fifo size        ldx     8,s             destination        leay    fifo,u          source        tfm1    Y,X             transfer        puls    x,y,u        clr     0,x             fio_cpuF, tell GPP we took it        puls    d,x,pc* Bad commandbadcmd    ldx     #sorry         point to string         jsr     pdata         output itdummy     rts     return         sttl     Memory Examine Command         pag** Examine memory (system)*examine         jsr     getadr         get low address         bcs     exam99         std     lowadr,u     save low limit         lda     #'-         jsr     outch         jsr     getadr         get high address         bcs     exam99         std     hiadr,u     save high limit         ldx     lowadr,u     set up for dump         ldy     hiadr,u         jsr     dumpXY         go print dumpexam99     rts** dumpXY - Dump memory from (X) to (Y)*    (X) - Lowest address to dump*    (Y) - Highest address to dump*    jsr dumpXY*dumpXY     pshs     x,y,u         save registers** Print one line (16 bytes) of data*dump10     jsr     pcrlf         start a new print line         lda     0,s         print address         jsr     hexbyt         lda     1,s         jsr     hexbyt         jsr     outsp         jsr     outsp         ldx     0,s         ldb     #16         print 16 bytes         pshs     bdump20     lda     ,x+         get next byte to print         jsr     hexbyt         jsr     outsp         dec     0,s         done?         bne     dump20         no - go back         ldx     1,s         now print characters         jsr     outsp         jsr     outsp         ldb     #16         stb     0,sdump30     lda     ,x+         get next byte         cmpa     #$20         printable?         blo     dump35         no         cmpa     #$7F         blo     dump40         go print characterdump35     lda     #'.         print period for unprintabledump40     jsr     outch         print character         dec     0,s         done?         bne     dump30         leas     1,s         clean up stack         jsr     inchck         abort if character struck         bcs     dump99         stx     0,s         update address         cmpx     2,s         any more?         bls     dump10         yes - go to itdump99     bsr     pcrlf         puls     x,y,u,pc     return** pcrlf - print carriage return/line feed*pcrlf     pshs     d,x         save registers         ldx     #CRLF         jsr     pdata         puls     d,x,pc         returnCRLF     fcc     $d,0** Map memory into buffer ($d000)*mapper     jsr     getbyt get byte         bcs     mappe8         sta     datbox+$dmappe8     rts     return        sttl    IDE Bootstrap**   IDE Bootstrap*   reset the stack and set up direct addressing*   U contains controller base address*   B contains drive select bits*loadip      seti     irq,firq       disable irq and firq            pshs     b              save dest drive            andb     #%00000001            pshs     b              save drive bits            beq      loadi1            lda      #IDE_DSL       drive select bit            sta      0,sloadi1**   quiesce the dma (in case it is active)*            clr        dmaltc,u            disable everything*            ldd        #IDE_LBA            orb        0,s                 drive select bit            std        ideadr3,u           LBA 24...27, drive 0*            ldd        idecmst,u           read status            cmpb        #(IDERDY+IDEDSC)    idle            bne        loadxit            drive not ready*            ldd        #IDERSTR            std        idecmst,u          restore drivewaitrst     lbsr       delay*isnrdy      lbsr       delay            ldd        idecmst,u          check if done            bitb       #IDEBSY            bne        isnrdy*            ldd        #1            std        idescnt,u          sector count            clrb                        LBA 0            std        ideadr0,u          first sector LBA 0...7            std        ideadr1,u         LBA 8...15            std        ideadr2,u         LBA 16...23            ldd        #IDE_LBA            orb        0,s              drive select bit            std        ideadr3,u           LBA 24...27, drive 0            ldd        #bootorg        load real boot address            jsr        xltadr           translate to virtual            stx        dmaadh,u        into A.X            ora        #L_DREAD+L_DMAEN            sta        dmaltc,u            set high addr            ldb        #IDEDRD            std        idecmst,uider1       lda        idestat,u            bita       #IDEINTR            beq        ider1            wait for done            ldd        idecmst,u            read status            bitb       #IDEERR            beq        doboot            tfr        b,a* faillureloadxit     stb        1,s              save status            lda        #$ff             set bad            sta        0,s            puls       d,pc*doboot      ldx        #bootorg        where boot is loaded            clra                       set status            puls    d,pc                D has drive select info*delay      lda     #64                 set up a delay counterdel        deca                        decrement the delay count           bne     del                 hang in there for the count           rts        sttl    FLP BootstrapCMDRSC  equ     %00010001       read sector**   FLP Bootstrap*   reset the stack and set up direct addressing*   U contains controller base address*   B contains drive selectloadif  seti     irq,firq       disable irq and firq        pshs    b        ldb     #16        ldx     #flpdpr+16          check if controoler there        lda     0,xldif01  adda    0,x+                if these locations are all 0        decb        bne     ldif01        tsta        beq     ldfl10              assume controller present        puls    b        ldd     #$3f3f        rtsldfl10  clrd        pshs   d                   dens/5=8" mode** stack holds drive select info*ldfl00   clrd         std    flblkm,u         sta    flblkh,u         ldd    #$200               PAGSIZ         std    fltsiz,u         ldb    2,s                 drive select         andb   #%00000011         stb    fldriv,u         asra         sta    flnwop,u         ldd    0,s         std    fltsid,u            start single side/dens/8"         lda    #CMDRSC         sta    flrflg,u         lda    #$ff         sta    flptel,u*ldfl01   lda    flpint,u         beq    ldfl01         clr    flpint,u         lda    flstat,u         beq    ldfl02          no error, copy to memory*         lda    1,s         eora   #1         sta    1,s         bne    ldfl00         lda    0,s         eora   #$40            set 5"         sta    0,s         bne    ldfl00* error         leas   3,s             drive info + D         ldd    #$3f3f         rts* OKldfl02   ldd    #$200         trfr   D,W         ldx    #bootorg         leay   flpfifo,u         tfm1   Y,X*         ldx    #bootorg        where boot is loaded         leas   3,s           drive + D         clrd                   set status         rts         sttl     System Configuration         pag** Configure the system [U=local stack vars]** code starts hereconfig   pshs   u         ldu     #sysmap+txtseg     check allocation         lda     corcnt         cmpa    #kpages            kernel pages         lblo    memfal* alocate memory for kernel of not yet done         ldy     lstmem02       ldb     0,u         cmpb    #nomap         bne     01f         lda     0,-y         dec     corcnt         sty     lstmem         sta     0,u01       leau    1,u         cmpu    #sysmap+txtseg+kpages         bne    02b*         ldx     #sysmap         ldy     #DATBOX03       ldd     0,x++         std     0,y++         cmpx   #sysmap+segadr         blo     03b* test timer         clra                enable timer         sta     monpdra         lda     monpdra     read value         pshs    a         clrbsystm1   lbsr    delay         incb         bne     systm1      256 loops         puls    a         suba    monpdra     is it running         beq     notimr         puls    u,pc        return** translate memadr [D] into virtual address [A.X]*xltadr  pshs    d         ldx    #sysmap      kernel map         lsra         lsra         lsra         lsra         lda    a,x             get page#         ldb    #16         mul         pshs   a               A19...A16 B=A15...A8         lda    1,s             old A         anda   #$0f            leave A11...A8         sta    1,s             save         orb    1,s             combine A15...A12         stb    1,s         puls   a,x,pc** Terminal I/O and bad interrupt handlers*notimr   bsr     panic          report timer         fcc     'Timer not Running!',0* Report unhandled interrupts, fixed sequence.unhand     bsr     panic         fcc     'IRQ ',0unswi     bsr     panic         fcc     'SWI ',0unswi2     bsr     panic         fcc     'SWI2',0unswi3     bsr     panic         fcc     'SWI3',0unnmi     bsr     panic         fcc     'NMI ',0unfirq     bsr     panic         fcc     'FIRQ',0         bsr     panic         fcc     'CHPR',0*cputrp    bsr     panic         fcc     'TRAP',0* Panic processingpanic     seti                     mask ints         ldx     #panicy         point to string         bsr     pdata             print it         puls     x                 get message         bsr     pdata             print it         jmp     montor          command loop** No memory panicmemfal   bsr     panic2          report panic         fcc     'Not Enough Memory!  ',0panic2  seti        ldx     #panicy        bsr     pdata        puls    x               string address        bsr     pdata        lds     #DATSTK        jmp     rinit pag* String display routinenewlin     jsr     outch             output cr         lda     #$a             setup line feedputch     jsr     outch             output itpdata     lda     0,x+             get string character         beq     pdata2             end of string?         cmpa     #$d             is it cr?         beq     newlin         bra     putch             go output charpdata2     rts     return* Output a spaceoutsp     pshs     a                 save a         lda     #$20             setup space         bsr     outch             output it         puls     a,pc             return* Output hex wordhexwrd     bsr     hexbyt         tfr     b,a* Output a hex bytehexbyt     pshs     a                 save byte         lsra                     shift right 4 bits         lsra         lsra         lsra         bsr     hexdig             output it         puls     a                 restore digit* Output a digit in hexhexdig     anda     #$0f             mask low bits         adda     #'0             make ascii digit         cmpa     #'9             is it digit?         bls     outch         adda     #7                 add letter bias         bra     outch* Test for an input characterinchck    pshs     a                 save a         lda     acia             get status         lsra                     check status bit         puls     a,pc             return* Input a character with echoinch     lda     acia             get status         lsra                     check bit         bcc     inch             wait for character         lda     acia+1             get character         anda     #$7f             mask parity         beq     inch             ignore nulls         cmpa     #'a             is it lower case?         blo     outch         cmpa     #'z         bhi     outch         suba     #$20             make upper case* Output character routineoutch     pshs     a                 save characteroutchw     lda     acia             get status         bita     #2                 check status         beq     outchw         puls     a                 get character         sta     acia+1             output it         rts                     return* Get addressgetadr     bsr     getbyt             get byte         sta     0,--s             save on stack         bcs     getext         bsr     getbyt             get byte         sta     1,sgetext     puls     d,pc             return* Get bytegetbyt     leas     -1,s         bsr     gethex             input hex digit         bcs     hexit         lsla         lsla         lsla         lsla         sta     0,s         bsr     gethex             get hex digit         bcs     hexit         ora     0,shexit     leas     1,s             clean stack         rts     return* Get hex digitgethex     jsr     inch             get character         cmpa     #'0             is it digit?         blo     nothex         cmpa     #'9         bls     idigit         cmpa     #'A         blo     nothex         cmpa     #'F         bhi     nothex         suba     #'A-'0-10idigit     suba     #'0         rts                     returnnothex     sec                     set carry         rts                     return         sttl     Memory Modify Command         pag** Modify system memory*modify         lbsr     getadr         get starting address         bcs     mod99         exit if error         std     lowadr,u     save address*mod10     ldx     #modm00         jsr     pdata         lda     lowadr,u     print address         jsr     hexbyt         lda     lowadr+1,u         jsr     hexbyt         jsr     outsp         ldx     lowadr,u     get byte address         lda     0,x         get value         pshs     a             save current value         jsr     hexbyt         output it         jsr     outsp         print a space         jsr     gethex         get a hex digit         bcs     mod30         jump if error         asla         asla         asla         asla         sta     0,s         update value         jsr     gethex         get second hex digit         bcs     mod40         exit if error         ora     ,s+         compute total valuemod20     ldx     lowadr,u     get memory address         sta     ,x+         update memory         stx     lowadr,u     update address         bra     mod10         continue with next bytemod50    puls    a         ldx     lowadr,u         leax     -1,x         stx     lowadr,u         bra     mod10*mod30    cmpa     #'^          is it "go back" char?         beq      mod50         cmpa     #'.         is it "go on" char?         bne     mod40         no - exit         puls     a             restore original value         bra     mod20         yes - move to next address*mod40     leas     1,s         clean up stackmod99     rts                 return*modm00     fcc     $d,'  - ',0** J - Jump to user program*jumpprg         jsr     getadr         get routine address         bcs     jump99         exit if error         tfr     d,x         get address         jsr     0,x         call routinejump99     rts         sttl     High-Level Interrupt Handling Area         pag******************************************************************* High Level Interrupt handling code - Context Switching** Should match with int hander code in your kernel******************************************************************          org        hlirom******************************************************************* first 16 locations are NOT in rom* they hold special hardware on the CPU board******************************************************************uisctr    rmb       1       user process stack depth    (read)cuddwn    rmb       1       hardware irq counter/fuse   (write)k_u_map   rmb       1       kernel map/user map select  (write)tlatch    rmb       1       task select register        (write)none      rmb       12      non existent, open bus****************************************************************** Process firq, ensure long stack frame** either CC,PC or CC....PC (in 6809 or 6309 stack format)** remember, this is all done in USER PROCESS STACK**     short        long  long*      firq extend 6309  6809*   13 PCL  PCL    PCL*   12 PCH  PCH    PCH*   11 CC   CC     UL    PCL*   10      -1,S   UH    PCH*   9       YL     YL    UL*   8       YH     YH    UH*   7       XL     XL    YL*   6       XH     XH    YH*   5       DP     DP    XL*   4       F      F     XH*   3       E      E     DP*   2       B      B     B*   1       A      A     A*   0       CC     CC    CC** E an F set in new CCufirq     leas    -1,s         make room on stack          pshs    dp,x,y       push all regs like irq          tfr     a,dp         create working register*          lda     uisctr       actual stack depth          cmpa    #STK6809     63X09 or 68X09 long stack          blo     10f          leas    6,s          clean up stack, already ok          bra     01f** we don't know the USER cpu mode, but we SET it for 63X09* if we are wrong, the user process is the victim :-)* should stay out of CPU mode register......*10        pshsw          tfr     dp,a         restore a          pshs    cc,d         push all regs like irq* restore CC from original          lda     11,s         get old cc, user stack          stu     10,s         store proper U reg          ora     #$80         set entire bit in cc          sta     0,s          user stack*01        ldx     #frqvec      point to firq vector          bra     process** Process a USER SWI type interrupt, ints are disabled* only E and I are set*uswi      ldx     #swivec     get vector          bra     process     process the int** Process an USER TRAP interrupt (63X09 protection)* E, I and F bits are set now*utrap    ldb     #DIVZI         bitmd   %10000000         bne     01f         ldb     #BARGI      illegal instruction01       ldx     #nmivec     set for nmi vector         bra     process       set int masks** Process USER NMI, this IS a process TRAP* due to that hardware protection kicks in* E, I and F bits are set now* process will be terminated*unmi         lda    0,s          get old CC*         ldb     #FALTI      set fault         bita    #$10        still old CC, were ints masked?         beq     01f         ldb     #TIMEI      set timeout, interrupts disabled too long01       ldx     #nmivec     set vector         bra     process** swi2 processor  USER SWI2* E bit is set*uswi2    ldx     #sw2vec     set vector         bra     process** Process an IRQ type interrupt, ints are disabled*uirq     ldx     #irqvec     get vector** switch context! map in kernel memory* Process the user interrupt* B has FAULT CODE for NMI* X has function address*process  bra    doint** Handle swi3 - system call interrupt* E bit is set*uswi3    seti                set I and F bit         tfr     d,u         free A.B         lda     0,s         from caller stack!         anda    #%11111110  clear carry bit* switch context!, mapto kernel         clr     k_u_map     switch context*         sta     usercc      save cc         stu     userd       save d register         stx     userx       save x register*         anda    #%10101111  erase I and F         tfr     a,dp         ldx     #sw3vec         bra     icontd** E, I and F are set* common code for interrupt handling* B holds NMI fault code*doint    equ     *         tfr     cc,dp       save caller interrupt state         seti                disable all interrupts* start context switch to kernel         clr     k_u_map     switch context** DP holds old interrupt status*icontd   sts     usp         save user stack pointer         lds     #sysstk     set system stack         lda     uisctr      what was cpu mode?         sta     ustksz      all old context has been saved         clra                set dp to 0         exg     a,dp        A holds final interrupt state*         clr     <kernel     tell kernel code we are here         ldmd    $03         force 63X09 and long FIRQ* context switch completed         tfr     a,cc       restore caller interrupt flags** for NMI, it is essential that the B register has been retained*         jsr     [0,x]        execute handler** common return from interrupt handler*retint   seti                 mask ints         lda     <chpflg      change tasks?         beq     reti35** change tasks, scheduling*         jsr     [chtask]     change tasks** here prepare to setup user task again*reti35   dec     <kernel** kernel runs as 63X09*         lda    ustksz        was it 6909 or 6309         cmpa   #STK6809         bne    uirt01        if not, leave it 63X09* 68X09 emulation with long FIRQ         ldmd    $02          force 68X09 but with long FIRQ** does process map need update*uirt01   tst     urelod       new task?         beq     usrrti** Load Memory Mapper registers for new task*remap    clra         sta     urelod        erase the flag!         ldb     #segadr       set segment size (16)         trfr    D,W         ldu     #datbox       point to DATBOX         lda     umapno        get task number         beq     ufail         mul                   calculate DATBOX location         leau    d,u           point to it         ldx     #usrmap       mem table for user process         tfm1    X,U           udate this entry, copy whole task map** map in user task memory, but set SP first*usrrti   lds     usp           reset to user stack         lda     umapno        get current task         beq     ufail         blowup if 0 map number         sta     tlatch        set task mapper for return** set user task memory map, switch CONTEXT.*         lda     #%10000000    select user map / vector set         sta     k_u_map       set user map** UniBUG FE00-FFFF still mapped in,* release that also just after fetching RTI opcode*krnrti   sta     cuddwn        adjust int count/fuse         rti** we should never get here. If so there is a serious hardware* problem*hfail    jsr     panic         hardware rti failure         fcc     'Hardware RTI failure ',0ufail    jsr     panic         blowup on 0 map number         fcc     'Zero map ',0** interrupt in kernel mode, IRQ*kirq     clra         tfr     a,dp         FORCE DP to ZERO         inc     <kernel         jsr     [irqvec]     process interrupt         dec     <kernel         bra     krnrti** interrupt in kernel mode, NMI* could be from kernel debug module*knmi     ldx    dbsign        check if kernel debug present         cmpx   #DEBSIG       special pattern         bne    knmix         no, just return         jsr    [debnmi]      enter debuggerknmix    bra    krnrti        return** interrupt in kernel mode, FIRQ* on stack (possibly) CC, PCH, PCL** E,F,I are set in new CCkfirq     seti                  disable ALL interrupts          leas    -1,s         make room on stack for 'U'          pshs    dp,x,y       push all regs like irq          tfr     a,dp          lda     uisctr       actual stack depth          cmpa    #STK6809     63x09 or 68x09          blo     10f* full stack present, either 6809 or 6309          leas    6,s          clean up          bra     01f** build full stack 6309  DP,XH,XL,YH,YL,XX,CC,PCH,PCL* already on stack*10        pshsw          tfr     dp,a         restore old A          pshs    cc,d         push all regs like irq*          lda     11,s         get old cc          stu     10,s         store proper u reg          ora     #$80         set 'E' bit in cc          sta     0,s* stack ready01        clrb          tfr     b,dp         SET DP to ZERO          inc     <kernel          jsr     [frqvec]     do firq handler          dec     <kernel          lbra    krnrti* Initialize the terminaltinit     pshs     d                 save reg         lda     #$3             reset acia         sta     acia         lda     #$15             set up bits & stuff         sta     acia         ldd     #15000             delay some heretinit2     subd     #1         bne     tinit2         puls     d,pc             return* messageshello     fcb     $d         fcc 'UniFLEX Boot ROM [E] (CPU09 :0.80)',$d,0prompt     fcb     $d         fcc     '%',0sorry     fcc     '??',0panicy     fcb     $d         fcc     'Panic -> ',0** System reset, COLD start. initial stack in DATBOX!*kreset   clra         lds       #DATSTK       here is RAM for sure         sta       cuddwn        undo reset fetch* only HW level 0 allows for acces DAT         sta       tlatch        select default 0         sta       k_u_map       map in kernel         ldd       #rommap       setup kernel memory map E000-FFFF         std       datbox+ioseg  set E...+F...*         ldx       dbsign        check if kernel debug present         cmpx      #DEBSIG       special pattern         bne       kresetx       no, just return         jsr       [debini]*kresetx  jmp       rinit         do sys init, find system RAM** System interrupts (unhandled), should NEVER happen*kswi      jmp     unswikswi2     jmp     unswi2kswi3     jmp     unswi3ktrap     jmp     cputrp** interrupt vector definitions*         org     usrvec* user mode vectors         fdb     utrap         fdb     uswi3         fdb     uswi2         fdb     ufirq         fdb     uirq         fdb     uswi         fdb     unmi         fdb     kreset  (should not happen)         org     vector* kernel mode vectors         fdb     ktrap         fdb     kswi3         fdb     kswi2         fdb     kfirq         fdb     kirq         fdb     kswi         fdb     knmi         fdb     kreset        end