         ttl     UniFLEX Monitor ROM         sttl     Equates         pag         lib        unibug.h         opt        exp         abs** Monitor ROM for booting UniFLEX and handling the UniFLEX* interrupt processing.* 2020-12-19  added init  step voor kernel debgger 0.08** 2021-08-07  adapted the hirom code for handling the stacksize* differences between 63X09 and 68X09** 2021-10-24  set stackpointer in DATBOX at first** 2022-03-01  added floppy boot for CPU09GPP/09FLP** 2022-11-23  fixed a nasty bug in kfirq** 2023-04-01  restructured the interrupt handlers** 2024-05-01  clear changemap added** low ram interrupt vectors org sysseg<<12irqvec     rmb     2         maskable interruptswivec     rmb     2         swi 1sw2vec     rmb     2         swi 2sw3vec     rmb     2         swi 3nmivec     rmb     2         non-maskable interruptfrqvec     rmb     2         fast interrupt* low memory system storagecputyp     rmb     1         cpu typecpumod     rmb     1         cpu mode 63/68usrtop     rmb     1         current user segmentkernel     rmb     1         kernel/user state (-1 = user address space)chpflg     rmb     1         change process flagchtask     rmb     2         change process vectorcorcnt     rmb     1         core segment countlstmem     rmb     2         mem table end markerteluch     rmb     1         user change flagmemmsk     rmb     1         dat cell maskromspr     rmb     1         spare byte for rom* System and global memory maps org (sysseg<<12)+$100sysmap     rmb     segadr     system memory mapcormap     rmb     segmax     available memory list* User block definitions org (usrseg<<12)+$f38ubasea     set     (usrseg<<12)+$f00ubasdp     set     ubasea/256*sysstk     equ *             system stack starts hereudummy     rmb     3         spareustksz     rmb     1         save interrupt stack depthuargp      rmb     2         user argv pointeruswi2v     rmb     2         swi2 vector save* this _should_ be at ff40.usp        rmb     2         user stack pointerurelod     rmb     1         map reload flagumapno     rmb     1         task map numberusrmap     rmb     segadr     user task memory map*usercc     rmb     1         condition codesuserd      rmb     2         D registeruserx      rmb     2         X registeruserpc     rmb     2         PC registeruserpb     rmb     1         sys call post byte           sttl     Initial ROM Processing           pag** Rom code starts here*           org     romadr** I/O Vectors*           fdb     rinit        cold start monitor           fdb     tinit        console init           fdb     inchck       test console character ready           fdb     inch         read one character fromconsoleterminal           fdb     outch        write one character to console           fdb     pdata        print a string (X)           fdb     hexbyt       print one hex byte (A)** bring monitor to life*rinit      seti        lds     #romstk     set stack*        clra                 set dp        tfr     a,dp*        ldx        #datbox    fill datbox with blackholes        ldy        #datsiz        lda        #nomap     black holerinit9   cmpx     #datbox+romseg don't vanish myself        beq         rinit8        sta      0,xrinit8    leax     1,x        leay    -1,y        bne     rinit9*         ldd     #rammap         sta     datbox+usrseg  setup user and system segments         stb     datbox+sysseg         lda     #nomap         fill system map with blackholes         ldb     #segadr     get length of map         ldx     #sysmap+segadr point to maprinit2     sta     0,-x         stuff into map cell         decb                 dec the count         bne     rinit2*         ldd     #rommap     complete the initial map         std     ioseg,x     set io and rom         std     datbox+ioseg         ldd     #rammap         sta     usrseg,x     set user segment         sta     usrtop         stb     sysseg,x     set system segment         clra                 init the direct page registers         sta     cputyp         clear cpu type         sta     cpumod         sta     chpflg         clear change task flag         sta     corcnt         zero core count         sta     urelod         sta     umapno         sta     memmsk         sta     teluch* all memory set        sta     tlatch          initializes latch to 0* init debugger hardware (if present)         ldx    dbsign        check if kernel debug present         cmpx   #DEBSIG       special pattern         bne    rinod         no, just return         jsr    [debini]      init debugger* set trap PIA and LED and TIMERrinod    lda     #$04           select data register         sta     monpcra         sta     monpcrb         clra                   all output         sta     monpdrb        LEDS off         sta     monpdra        timer stop         sta     monpcra        dir register         sta     monpcrb         lda     #$0f           select timer/rom control         sta     monpdra         lda     #$ff         sta     monpdrb         lda     #$04           select data register         sta     monpcra         sta     monpcrb        disabled mem trap irq*         jsr     tinit         init the terminal         ldx     #hello         point to string         jsr     pdata         print the string         ldy     #irqvec     point to int vectors         ldx     #unhand     and unhandeled routine         ldb     #6             set countrinit4     stx     0,y++         store vector         leax     7,x         point to next panic         decb         bne     rinit4         stx     chtask         set change task vector         sttl     Main Monitor Loop         pag** Main monitor loop (command processor)** Loop starts heremontor         lds     #romstk         leau     0,s        mark stack         leas     -dlen,s    make temp spacenxtcmd   ldx     #prompt     point to prompt string         jsr     pdata       output it         jsr     inch        get response         jsr     outsp       output space         ldx     #commnd     point to command table         bsr     search      search for command         jsr     [1,x]       execute command         bra     montor      repeat* Search command table for commandsearch     cmpa     0,x         is it this guy?         beq     searc2         leax     3,x         skip this one         tst     0,x         end of list?         bne     searchsearc2     rts     return* Command tablecommnd     fcb     $d             carriage return         fdb     dummy         fcb     'C             Configure command         fdb     figlef         fcb     'D             Disk boot         fdb     dboot         fcb     'E             Examine         fdb     examine         fcb     'M         fdb     modify         fcb     'V             Mapper         fdb     mapper         fcb     'J         fdb     jumpprg         fcb     'F         fdb     fboot         fcb     0             end of table         fdb     badcmd* Configure the system commandfiglef   jsr     config         do configuration         lda     corcnt         get core count         adda     #7             add in system core count         sta     count,u     save it         ldd     #0             set count to 0figle2   adda     #4             covert to decimal         daa         adcb     #0             add in carry         dec     count,u         bne     figle2         finished?         tstb                 more than 99K of memory?         beq     figle4         exg     a,b         do upper digit now         adda     #$30         jsr     outch         output it         exg     b,a         get low backfigle4   jsr     hexbyt         output byte         jsr     outsp         output space         lda     #'K         output 'K'figle5   jmp     outch* Disk boot commands* IDE bootdboot     jsr     config         configure system*          clrb          ldu     #brdbas0          ldy     #20000dboot1    jsr     inchck         key pressed          bcs     dboot2          lbsr    delay          leay    -1,y          bne     dboot1          bra     dboot3*dboot2    jsr     inch           get character from keyboard          cmpa    #$0d           ENTER?          beq     dboot3          cmpa    #'1          bhi     dboot3              invalid          suba    #'0          tfr     a,b*dboot3    jsr     loadip         load the ipl sector          beq     dboot4          jsr     hexbyt          rts*dboot4    lds     #sysstk     setup UniFLEX stack          jmp     0,x         go do the boot* floppy bootfboot     jsr     config         configure system*          clrb          ldu     #gppbase       floppy interface          ldy     #20000fboot1    jsr     inchck         key pressed          bcs     fboot2          lbsr    delay          leay    -1,y          bne     fboot1          bra     fboot3*fboot2    jsr     inch           get character from keyboard          cmpa    #$0d           ENTER?          beq     fboot3          cmpa    #'1          bhi     fboot3              invalid          suba    #'0          tfr     a,b*fboot3    jsr     loadif         load the ipl sector          beq     fboot4          jsr     hexbyt          rts*fboot4    lds     #sysstk     setup UniFLEX stack          jmp     0,x         go do the boot* Bad commandbadcmd    ldx     #sorry         point to string         jsr     pdata         output itdummy     rts     return         sttl     Memory Examine Command         pag** Examine memory (system)*examine         jsr     getadr         get low address         bcs     exam99         std     lowadr,u     save low limit         lda     #'-         jsr     outch         jsr     getadr         get high address         bcs     exam99         std     hiadr,u     save high limit         ldx     lowadr,u     set up for dump         ldy     hiadr,u         jsr     dumpXY         go print dumpexam99     rts** dumpXY - Dump memory from (X) to (Y)*    (X) - Lowest address to dump*    (Y) - Highest address to dump*    jsr dumpXY*dumpXY     pshs     x,y,u         save registers** Print one line (16 bytes) of data*dump10     jsr     pcrlf         start a new print line         lda     0,s         print address         jsr     hexbyt         lda     1,s         jsr     hexbyt         jsr     outsp         jsr     outsp         ldx     0,s         ldb     #16         print 16 bytes         pshs     bdump20     lda     ,x+         get next byte to print         jsr     hexbyt         jsr     outsp         dec     0,s         done?         bne     dump20         no - go back         ldx     1,s         now print characters         jsr     outsp         jsr     outsp         ldb     #16         stb     0,sdump30     lda     ,x+         get next byte         cmpa     #$20         printable?         blo     dump35         no         cmpa     #$7F         blo     dump40         go print characterdump35     lda     #'.         print period for unprintabledump40     jsr     outch         print character         dec     0,s         done?         bne     dump30         leas     1,s         clean up stack         jsr     inchck         abort if character struck         bcs     dump99         stx     0,s         update address         cmpx     2,s         any more?         bls     dump10         yes - go to itdump99     bsr     pcrlf         puls     x,y,u,pc     return** pcrlf - print carriage return/line feed*pcrlf     pshs     d,x         save registers         ldx     #CRLF         jsr     pdata         puls     d,x,pc         returnCRLF     fcc     $d,0** Map memory into buffer ($d000)*mapper     jsr     getbyt get byte         bcs     mappe8         sta     datbox+$dmappe8     rts     return        sttl    IDE Bootstrap**   IDE Bootstrap*   reset the stack and set up direct addressing*   U contains controller base address*   B contains drive select bits*loadip      seti     irq,firq       disable irq and firq            pshs     b              save dest drive            andb     #%00000001            pshs     b              save drive bits            beq      loadi1            lda      #IDE_DSL       drive select bit            sta      0,sloadi1**   quiesce the dma (in case it is active)*            clr        dmaltc,u            disable everything*            ldd        #IDE_LBA            orb        0,s                 drive select bit            std        ideadr3,u           LBA 24...27, drive 0*            ldd        idecmst,u           read status            cmpb        #(IDERDY+IDEDSC)    idle            bne        loadxit            drive not ready*            ldd        #IDERSTR            std        idecmst,u          restore drivewaitrst     lbsr       delay*            ldd        idecmst,u*            bitb       #IDEBSY            drive busy?*            beq        waitrst*isnrdy      lbsr       delay            ldd        idecmst,u          check if done            bitb       #IDEBSY            bne        isnrdy*            ldd        #1            std        idescnt,u          sector count            clrb                        LBA 0            std        ideadr0,u          first sector LBA 0...7            std        ideadr1,u         LBA 8...15            std        ideadr2,u         LBA 16...23            ldd        #IDE_LBA            orb        0,s              drive select bit            std        ideadr3,u           LBA 24...27, drive 0            ldd        #bootorg        load real boot address            std        dmaadh,u            lda        #L_DREAD+L_DMAEN            sta        dmaltc,u            set high addr            ldb        #IDEDRD            std        idecmst,uider1       lda        idestat,u            bita       #IDEINTR            beq        ider1            wait for done            ldd        idecmst,u            read status            bitb       #IDEERR            beq        doboot            tfr        b,a* faillureloadxit     stb        1,s              save status            lda        #$ff             set bad            sta        0,s            puls       d,pc*doboot      ldx        #bootorg        where boot is loaded            clra                       set status            puls    d,pc                D has drive select info*delay      lda     #64                 set up a delay counterdel        deca                        decrement the delay count           bne     del                 hang in there for the count           rts        sttl    FLP BootstrapCMDRSC  equ     %00010001       read sector**   FLP Bootstrap*   reset the stack and set up direct addressing*   U contains controller base address*loadif      seti     irq,firq       disable irq and firq        ldb     #16        ldx     #flpdpr+16          check if controoler there        lda     0,xldif01  adda    0,x+                if these locations are all 0        decb        bne     ldif01        tsta        beq     ldif02              assume controller present        ldd     #$ff        rtsldif02   ldd    #0         pshs   d***ldfl00   ldd    #0         std    flblkm,u         sta    flblkh,u         ldd    #$200               PAGSIZ         std    fltsiz,u         stb    fldriv,u         asra         sta    flnwop,u         ldd    0,s         std    fltsid,u            start single side/dens/8"         lda    #CMDRSC         sta    flrflg,u         lda    #$ff         sta    flptel,u*ldfl01   lda    flpint,u         beq    ldfl01         clr    flpint,u         lda    flstat,u         beq    ldfl02          no error, copy to memory         lda    1,s         eora   #1         sta    1,s         bne    ldfl00         lda    0,s         eora   #$40            set 5"         sta    0,s         bne    ldfl00* error         ldd    #$ffff         std    0,s         puls   d,pc* OKldfl02   ldd    #$200         trfr   D,W         ldx    #bootorg         leay   flpfifo,u         tfm1   Y,X*         ldx    #bootorg        where boot is loaded         clra                   set status         puls    d,pc         sttl     System Configuration         pag** Configure the system** code starts hereconfig   ldx     #tstpat     setup pattern         ldy     #cormap+segmax setup page table pointer         ldb     #LSTPAG     setup max page number*check    jsr     getpag      map in a page         stx     tstloc      write test pattern         cmpx     tstloc     is memory there?         bne     nomem         pshs     b          save countcheck2   jsr     getpag      map in all other pages         stb     tstloc+1    write index         subb     #1         dec count by 1         bcc     check2         puls     b         jsr     getpag      reselect the page         cmpb     tstloc+1   is memory there?         beq     gotmem* here if no memorynomem    clra                set page number to zero* here for memory foundgotmem   sta     0,-y        store into mem table         subb     #1         dec the count         bcc     check*         leax     0,y        point to start of table* setup system address spacesyssup   clr     sysres,x     clear out system and user pages         clr     useres,x         ldy     #sysmap+txtseg point to user segment         ldb     #5             set length ** changed from 5 for moresyssu2     bsr     getnxt         get next segment         lbeq     memfal         crash if no memory!         sta     0,y+         save in map         decb                 dec the count         bne     syssu2         clr     corcnt         set core count to zero         ldy     #cormap     point to core mapsyssu4     bsr     getnxt         get next page         beq     syssu5         no more?         sta     0,y+         save in table         inc     corcnt         bump core counter         bra     syssu4         repeatsyssu5     sty     lstmem         save last mem pointer         ldx     #sysmap     point to system map         ldy     #datbox     point to datbox         ldb     #segadr     get segment countsyssu6     lda     0,x+         reload datbox from map         sta     0,y+         decb                 dec the count         bne     syssu6* test timer         clra                enable timer         sta     monpdra         lda     monpdra     read value         pshs    a         clrbsystm1   lbsr    delay         incb         bne     systm1      256 loops         puls    a         suba    monpdra     is it running         beq     notimr         rts                 return* map in a memory pagegetpag     tfr     b,a         get page number         sta     datbox+tfrseg map into address space         rts                 return* get next valid memory segmentgetnxt     cmpx     #cormap+segmax end of map?         beq     getnx2         lda     0,x+         get next page         beq     getnxt         keep looking if zerogetnx2     rts                 return* No memory panicmemfal     jsr     panic         report panic         fcc     'Not Enough Memory!',0notimr   jsr     panic          report timer         fcc     'Timer not Running!',0** Terminal I/O and bad interrupt handlers** Report unhandled interrupts, fixed sequence.unhand     bsr     panic         fcc     'IRQ ',0unswi     bsr     panic         fcc     'SWI ',0unswi2     bsr     panic         fcc     'SWI2',0unswi3     bsr     panic         fcc     'SWI3',0unnmi     bsr     panic         fcc     'NMI ',0unfirq     bsr     panic         fcc     'FIRQ',0         bsr     panic         fcc     'CHPR',0*cputrp    bsr     panic         fcc     'TRAP',0* Panic processingpanic     seti                     mask ints         ldx     #panicy         point to string         bsr     pdata             print it         puls     x                 get message         bsr     pdata             print it         lds     #romstk         set rom stack         jmp     montor             init rom pag* String display routinenewlin     jsr     outch             output cr         lda     #$a             setup line feedputch     jsr     outch             output itpdata     lda     0,x+             get string character         beq     pdata2             end of string?         cmpa     #$d             is it cr?         beq     newlin         bra     putch             go output charpdata2     rts     return* Output a spaceoutsp     pshs     a                 save a         lda     #$20             setup space         bsr     outch             output it         puls     a,pc             return* Output hex wordhexwrd     bsr     hexbyt         tfr     b,a* Output a hex bytehexbyt     pshs     a                 save byte         lsra                     shift right 4 bits         lsra         lsra         lsra         bsr     hexdig             output it         puls     a                 restore digit* Output a digit in hexhexdig     anda     #$0f             mask low bits         adda     #'0             make ascii digit         cmpa     #'9             is it digit?         bls     outch         adda     #7                 add letter bias         bra     outch* Test for an input characterinchck    pshs     a                 save a         lda     acia             get status         lsra                     check status bit         puls     a,pc             return* Input a character with echoinch     lda     acia             get status         lsra                     check bit         bcc     inch             wait for character         lda     acia+1             get character         anda     #$7f             mask parity         beq     inch             ignore nulls         cmpa     #'a             is it lower case?         blo     outch         cmpa     #'z         bhi     outch         suba     #$20             make upper case* Output character routineoutch     pshs     a                 save characteroutchw     lda     acia             get status         bita     #2                 check status         beq     outchw         puls     a                 get character         sta     acia+1             output it         rts                     return* Get addressgetadr     bsr     getbyt             get byte         sta     0,--s             save on stack         bcs     getext         bsr     getbyt             get byte         sta     1,sgetext     puls     d,pc             return* Get bytegetbyt     leas     -1,s         bsr     gethex             input hex digit         bcs     hexit         lsla         lsla         lsla         lsla         sta     0,s         bsr     gethex             get hex digit         bcs     hexit         ora     0,shexit     leas     1,s             clean stack         rts     return* Get hex digitgethex     jsr     inch             get character         cmpa     #'0             is it digit?         blo     nothex         cmpa     #'9         bls     idigit         cmpa     #'A         blo     nothex         cmpa     #'F         bhi     nothex         suba     #'A-'0-10idigit     suba     #'0         rts                     returnnothex     sec                     set carry         rts                     return* Initialize the terminaltinit     pshs     d                 save reg         lda     #$3             reset acia         sta     acia         lda     #$15             set up bits & stuff         sta     acia         ldd     #15000             delay some heretinit2     subd     #1         bne     tinit2         puls     d,pc             return* messageshello     fcb     $d         fcc 'UniFLEX Boot ROM (CPU09:MMU/IDE/MON/FLP:0.50)',$d,0prompt     fcb     $d         fcc     '%',0sorry     fcc     '??',0panicy     fcb     $d         fcc     'Panic -> ',0         sttl     Memory Modify Command         pag** Modify system memory*modify         lbsr     getadr         get starting address         bcs     mod99         exit if error         std     lowadr,u     save address*mod10     ldx     #modm00         jsr     pdata         lda     lowadr,u     print address         jsr     hexbyt         lda     lowadr+1,u         jsr     hexbyt         jsr     outsp         ldx     lowadr,u     get byte address         lda     0,x         get value         pshs     a             save current value         jsr     hexbyt         output it         jsr     outsp         print a space         jsr     gethex         get a hex digit         bcs     mod30         jump if error         asla         asla         asla         asla         sta     0,s         update value         jsr     gethex         get second hex digit         bcs     mod40         exit if error         ora     ,s+         compute total valuemod20     ldx     lowadr,u     get memory address         sta     ,x+         update memory         stx     lowadr,u     update address         bra     mod10         continue with next bytemod50    puls    a         ldx     lowadr,u         leax     -1,x         stx     lowadr,u         bra     mod10*mod30    cmpa     #'^          is it "go back" char?         beq      mod50         cmpa     #'.         is it "go on" char?         bne     mod40         no - exit         puls     a             restore original value         bra     mod20         yes - move to next address*mod40     leas     1,s         clean up stackmod99     rts                 return*modm00     fcc     $d,'  - ',0** J - Jump to user program*jumpprg         jsr     getadr         get routine address         bcs     jump99         exit if error         tfr     d,x         get address         jsr     0,x         call routinejump99     rts         sttl     High-Level Interrupt Handling         pag** Interrupt handling code - Highest level** Should match with inthand code in specific kernel version*          org        hirom* Process firq* either CC,PC or CC....PC (in 6809 or 6309 stack format)**   13 PCL  PCL    PCL*   12 PCH  PCH    PCH*   11 CC   CC     UL    PCL*   10      -1,S   UH    PCH*   9       YL     YL    UL*   8       YH     YH    UH*   7       XL     XL    YL*   6       XH     XH    YH*   5       DP     DP    XL*   4       F      F     XH*   3       E      E     DP*   2       B      B     B*   1       A      A     A*   0       CC     CC    CC** E,F,I are set in new CCufirq     seti                  disable ALL interrupts          leas    -1,s         make room on stack          pshs    dp,x,y       push all regs like irq          tfr     a,dp         create working register*          lda     uisctr        stack depth          cmpa    #STKSIZ-2     63X09 or 68X09 long stack          blo     10f          leas    6,s          clean up stack, already ok          bra     01f* we don't know the USER cpu mode, but we set it for 63X09* if we are wrong, the user process is the victim :-)10        pshsw          tfr     dp,a         restore a          pshs    cc,d         push all regs like irq          lda     11,s         get old cc          stu     10,s         store proper u reg          ora     #$80         set entire bit in cc          sta     0,s          lda     #STKSIZ      we force 63X09 TODO!!*01        sta     ustksz          ldx     #frqvec      point to firq vector          bra     process* Process a USER SWI type interrupt, ints are disableduswi      ldx     #swivec     get vector          bra     process     process the int* Process an USER TRAP interruptutrap    bitmd   %10000000         bne     01f         ldb     #BARGI      illegal instruction         bra     02f01       ldb     #DIVZI      div by 002       ldx     #nmivec     set for nmi vector         bra     process       set int masks** Process USER NMI, this IS a process TRAP*unmi     tfr     cc,dp       masks are set         tfr    s,y         tfr    d,u           save D contents         ldb    uisctr       stack depth         subb   #2         leay   b,y         ldy    0,y          get old PC 63X or 68X*         clr     k_u_map     bring in kernel map* now BXXX is ust area , sp is handled later         stx     userx         stu     userd         sty     userpc*         tfr     dp,a        save user cc         sta     usercc         ldx     #nmivec     set vector         ldb     #FALTI         set fault         bita    #$10        ints masked?         beq     prcs2         ldb     #TIMEI         set timeout         bra     prcs2       kernel already mapped in* swi2 processor  USER SWI2uswi2    ldx     #sw2vec     set vector         bra     process* Process an IRQ type interrupt, ints are disableduirq     ldx     #irqvec     get vector** map in kernel memory* Process the user interrupt* B has FAULT CODE for NMI* X has function address*process  seti         clr     k_u_map     task mapper to kernel** kernel memory map already activated* common part for hardware ints* B has FAULT CODE for NMI* all INTS masked*prcs2    bra     doint       return in common handler*** Handle swi3 - system call interrupt*uswi3    clc                 clear the carry bit         tfr     cc,dp       save cc         seti                mask ints         clr     k_u_map     map in kernel         std     userd       save d register         stx     userx       save x register         ldx     #sw3vec     swi3 handler         tfr     dp,a         sta     usercc         anda    #!$50         tfr     a,dp** common code for interrupt handling*doint    equ     *         sts     usp         save user stack pointer         lds     #sysstk     set system stack         clra                set dp to 0         tfr     a,dp         clr     <kernel     tell kernel code we are here         lda     uisctr      what was cpu mode?         sta     ustksz         ldmd    $03         force 63X09** for NMI, it is essential that the B register has been retained*         jsr     [0,x]        execute handler** common return from interrupt handler*retint   seti                 mask ints         lda     <chpflg       change tasks?         beq     reti35         jsr     [chtask]     change tasks** here prepare to setup user task again*reti35   dec     <kernel* kernel runs as 63X09         lda    ustksz        was it 6909 or 6309         beq    uirt01        not set, assume 63X09         cmpa   #13           63x09?         bhi    uirt01        leave as is* 68X09 emulation with long FIRQ         ldmd    $02          force 68X09 but with long FIRQuirt01   tst     urelod       new task?         beq     usrrti** Load Memory Mapper registers for new task*remap    clra         sta     urelod        erase the flag!         ldb     #segadr       set segment size (16)         trfr    D,W         ldu     #datbox       point to dat ram         lda     umapno        get task number         beq     ufail         mul                   calculate map location         leau    d,u           point to it         ldx     #usrmap       mem table for user process         tfm1    X,U** map in user task memory, but set SP first*usrrti   lds     usp           reset to user stack         lda     umapno        get current task         beq     ufail         blowup if 0 map number         sta     tlatch        set task mapper for return* set user task memory map         lda     #%10000000    select user map / vector set         sta     k_u_map       set user map** release kernel map, but just so that the RTI opcode is read yet*krnrti   sta     cuddwn        adjust int count/fuse         rti*hfail    jsr     panic         hardware rti failure         fcc     'Hardware RTI failure ',0ufail    jsr     panic         blowup on 0 map number         fcc     'Zero map ',0** interrupt in kernel mode, IRQ*kirq     clra         tfr     a,dp         FORCE DP to ZERO         inc     <kernel         jsr     [irqvec]     process interrupt         dec     <kernel         bra     krnrti** interrupt in kernel mode, NMI*knmi     ldx    dbsign        check if kernel debug present         cmpx   #DEBSIG       special pattern         bne    knmix         no, just return         jsr    [debnmi]      enter debuggerknmix    bra    krnrti        return** interrupt in kernel mode, FIRQ** E,F,I are set in new CCkfirq     seti                  disable ALL interrupts          leas    -1,s         make room on stack          pshs    dp,x,y       push all regs like irq          tfr     a,dp          lda     uisctr          cmpa    #STKSIZ-2    63x09 or 68x09          blo     10f          leas    6,s          clean up          bra     01f*10        pshsw          tfr     dp,a         restore old A          pshs    cc,d         push all regs like irq          lda     11,s         get old cc          stu     10,s         store proper u reg          ora     #$80         set entire bit in cc          sta     0,s*01        clrb          tfr     b,dp         FORCE DP to ZERO          inc     <kernel          jsr     [frqvec]     do firqhandler          dec     <kernel          lbra    krnrti** System reset, COLD start*kreset   clra         lds       #inistk       here is RAM for sure         sta       cuddwn        undo reset fetch* only HW level 0 allows for acces DAT         sta       tlatch        select default 0         sta       k_u_map       map in kernel         ldd       #rommap       setup kernel memory map E000-FFFF         std       datbox+ioseg  set E...+F...         ldx       dbsign        check if kernel debug present         cmpx      #DEBSIG       special pattern         bne       kresetx       no, just return         jsr       [debini]kresetx  jmp       rinit         do sys init, find system RAM** System interrupts (unhandled)*kswi      jmp     unswikswi2     jmp     unswi2kswi3     jmp     unswi3ktrap     jmp     cputrp** interrupt vector definitions*         org     usrvec         fdb     utrap         fdb     uswi3         fdb     uswi2         fdb     ufirq         fdb     uirq         fdb     uswi         fdb     unmi         fdb     kreset         org     vector         fdb     ktrap         fdb     kswi3         fdb     kswi2         fdb     kfirq         fdb     kirq         fdb     kswi         fdb     knmi         fdb     kreset        end