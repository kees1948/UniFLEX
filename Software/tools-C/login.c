/* * login [ name ] * UniFLEX login utility * oorspr. unix versie geimplementeerd op UniFLEX, * en uitgebreid met extra functies door /usr/jaron * versie 1.9 * 12-9-'84 */#include <sys/types.h>#include <ctype.h>#include <sgtty.h>#include <utmp.h>#include <signal.h>#include <pwd.h>#include <stdio.h>#include <sys/stat.h>#define SCPYN(a, b) strncpy(a, b, sizeof(a))char maildir[30] = "./mail/";struct passwd nouser = {"", "nope"};struct sgttyb ttyb;struct utmp ut;char plusnam[16] = "+";char pwtemp[16] = "";struct passwd *pwd;struct stat statb;struct passwd *getpwnam();char *strcat();int setpwent();char *ttyname();char *crpass();char *rindex(), *index();char *ctime();char loginarg[10] = "login";char waitarg[10] = "_wait";char stoparg[10] = "_stop";char **mainargv;int stopmotd = 0;int interrupt = 0;int attempts = 0;char attstr[5];main(argc, argv)char **argv;{    register char *namep;    int i, t, f, c;    char *p = "";    char *ttyn;    char *password, testpwd[16];    char *gpw();    int stoplogin();    int go_on();    char *nullchar = "";    signal(SIGQUIT, SIG_IGN);    signal(SIGINT, SIG_IGN);    signal(12,stoplogin);    mainargv = argv;    t = ttynum();   /* schoonvegen van utmp entry */    if ( (f = open("/act/utmp", 1)) >= 0) {       lseek(f, (long)(t*sizeof(ut)), 0);       for(i=0; i < sizeof(ut); ++i)          write(f,nullchar,1);       close(f);    }   /* tasknr. in /act/logintmp entry zetten */    if ( (f = open("/act/logintmp",1)) >= 0) {        lseek(f, (long)(t*sizeof(int)), 0);        i = getpid();        write(f, &i, sizeof(int));        close(f);    }   /* terminal instelling goed zetten */    gtty(0, &ttyb);    ttyb.sg_erase = 0x8;    ttyb.sg_kill = 0x18;    ttyb.sg_flags = ECHO | XTABS | CRMOD | SCOPE ;    ttyb.sg_delay = 0;    ttyb.sg_speed = 0x14;    ttyb.sg_spare = 0;    stty(0, &ttyb);    for (i=3; i<17; i++)        close(i);    ttyn = ttyname(0);    if (ttyn==0)        ttyn = "/dev/tty??";    SCPYN(ut.ut_tty, index(ttyn+1, '/')+4);    if( argc == 3 ) {        attempts = atoi(argv[1]);        strcpy(argv[1]," ");        argc = 1;    }    if( argc > 1 ) goto loop;    /* zet tty_wait text voor ps */    strcpy(argv[0],waitarg);    showmessage();    fflush(stdout);    /* print regel met datum, tijd, en ttynr. */    time(&ut.ut_time);    printf("%.24s %.5s\n",ctime(&ut.ut_time), index(ttyn+1, '/')+1 );    strcpy(argv[0],loginarg); /* wait text weg */    /* vergeet eerder ingetypte characters */    if(ttyname(0) != 0) {        gtty(0, &ttyb);        ttyb.sg_flags = ttyb.sg_flags | CBREAK;        stty(0, &ttyb);        signal(SIGALRM,go_on);        alarm(2);        for(;interrupt == 0;)            getchar();        gtty(0, &ttyb);        ttyb.sg_flags = ttyb.sg_flags & ~CBREAK;        stty(0, &ttyb);    } loop:    if(++attempts > 3) {        alarm(600); /* 10 minuten weg */        stoplogin();    }    sprintf(attstr,"%1d\0",attempts);    SCPYN(ut.ut_name, "");    if (argc>1) {        SCPYN(ut.ut_name, argv[1]);        argc = 0;    }    while (ut.ut_name[0] == '\0') {        namep = ut.ut_name;        printf("\n\nLogin: ");        while ((c = getchar()) != '\n') {           if(c == ' ')               c = '_';           if (c == EOF)               execl("/etc/login","login",attstr," ",0);           if (isupper(c)) {               gtty(0,&ttyb);               ttyb.sg_flags = ttyb.sg_flags | LCASE;               stty(0,&ttyb);               c = c - 'A' +'a';           }           if (namep < ut.ut_name+8)           *namep++ = c;        }    }    setpwent();    if ((pwd = getpwnam(ut.ut_name)) == NULL)        pwd = &nouser;    endpwent();    if (pwd->pw_passwd[0] == '\0')        goto ok;    if( (password = gpw("Password: ")) == 0 )        goto loop;/* fprintf(stderr,"pwd: %s crp: %s\n", pwd->pw_passwd, crpass(password, *testpwd, "ka")); */    if( strncmp(pwd->pw_passwd, crpass(password, *testpwd, "ka"), strlen(pwd->pw_passwd)) != 0 ) {        printf("Login incorrect !\n");        /* loginpoging bij /act/attempts */        if( strlen(ut.ut_name) >1        && (f = open("/act/attempts", 1)) >= 0 ) {            time(&ut.ut_time);            lseek(f, 0L, 2); /* achteraan */            write(f, (char *)&ut, sizeof(ut));            close(f);        }        goto loop;    }ok:    if(chdir(pwd->pw_dir) < 0) {        printf("No directory !\n");        goto loop;    }    time(&ut.ut_time);   /* ingelogde user in utmp zetten */    if ( (f = open("/act/utmp", 1)) >= 0) {        lseek(f, (long)(t*sizeof(ut)), 0);        write(f, (char *)&ut, sizeof(ut));        close(f);    }   /* ingelogde user bij history file zetten */    if ( (f = open("/act/history", 1)) >= 0) {       lseek(f, 0L, 2); /* achteraan */       write(f, (char *)&ut, sizeof(ut));       close(f);    }   /* kijk in /etc/nologin of er ingelogd mag worden */    if( (f = open("/etc/nologin", 0)) >= 0) {       while( read(f, p, 1) == 1)           putchar(*p);       close(f);       fflush(stdout);       if(pwd->pw_uid != 0) exit(0);    }   /* zet uid en tty eigenaar */    chown(ttyn, pwd->pw_uid);    setuid(pwd->pw_uid);    chmod(ttyn,0x01 | 0x02 | 0x10); /* perm. voor tty */   /* .home? file maken voor home directory */    if( (f = creat(".home?",0x03)) >= 0) {        p = pwd->pw_dir;        for(;*p != '\0'; p++)            write(f, p, 1);        write(f, nullchar, 1);        close(f);    }   /* als er een .nomotd file is, dan wordt geen motd afgedrukt */    if( access(".nomotd",0) != 0 )        showmotd();   /* kijk of er mail is */    strcat(maildir, ".mail");    if(access(maildir,4)==0) {        stat(maildir, &statb);        if (statb.st_size)            printf("You have mail.\n");    }   /* signals, dperms std files nice etc. */    signal(SIGQUIT, SIG_DFL);    signal(SIGINT, SIG_DFL);    signal(12, SIG_DFL);   /* umask(0x01 | 0x02 | 0x04 | 0x08 | 0x20); */  /* u+rwx o+rx */    umask(0x10|0x40);  /* disable  o+w s+ */    dup2(1,2); /* open std error output */    for(i=3; i<17; i++)        close(i);    nice(0);   /* Ga shell of ander programma uitvoeren */    if (*pwd->pw_shell == '\0')        pwd->pw_shell = "/bin/shell";    if ((namep = rindex(pwd->pw_shell, '/')) == NULL)        namep = pwd->pw_shell;    else        namep++;    strcat(plusnam, namep);    execl(pwd->pw_shell, plusnam, 0);    if(strcmp(pwd->pw_shell,"/bin/shell") != 0)        execl("/bin/shell","shell","+cx",pwd->pw_shell,0);    printf("No shell !\n");    exit(0);}catch(){ signal(SIGINT, SIG_IGN); stopmotd++;}go_on(){ signal(SIGALRM, SIG_DFL); interrupt++;}stoplogin(){int i; signal(SIGHUP, SIG_IGN); signal(SIGINT, SIG_IGN); signal(SIGQUIT, SIG_IGN); signal(12, SIG_IGN); strcpy(mainargv[0],stoparg); /* zet stop text */ for(i=0; i<17; ++i) close(i); pause(); /* HALT */}showmotd(){ FILE *mf; register c; signal(SIGINT, catch); if((mf = fopen("/etc/log/motd","r")) != NULL) { while((c = getc(mf)) != EOF && stopmotd == 0) { putchar(c); fflush(stdout); } fclose(mf); } signal(SIGINT, SIG_IGN);}showmessage(){ FILE *mf; register c; if((mf = fopen("/etc/log/message","r")) != NULL) { while((c = getc(mf)) != EOF) putchar(c); fclose(mf); }}char *gpw(text)char *text;{char *ptr;register c;gtty(0, &ttyb);ttyb.sg_flags = ttyb.sg_flags & ~ECHO;stty(0, &ttyb);printf("%s",text);ptr = pwtemp;while ((c = getchar()) != '\n') { if(c == ' ') c = '_'; if (c == EOF) execl("/etc/login","login",attstr," ",0); if (ptr < pwtemp+8) *ptr++ = c; }*ptr = '\0';gtty(0, &ttyb);ttyb.sg_flags = ttyb.sg_flags | ECHO;stty(0, &ttyb);printf("\n");if(ptr == pwtemp) return(0);else return(pwtemp);}