#include <stdio.h>#include "boolean.h"#include "termcap.h"extern struct ttycap cap;  /* Terminal capabilities */extern int p_l_row;        /* Physical last row */extern int p_l_column;     /* Physical last column */extern int last_row;         /* Last row number (0 origin) */extern int last_column;      /* Last column number (0 origin) */extern int cu_size;        /* Size of cursor up string */extern int cd_size;        /* Size of cursor down string */extern int cl_size;        /* Size of cursor left string */extern int cr_size;        /* Size of cursor right string */extern int hm_size;        /* Size of home up string */extern int row;           /* Current row number (0 origin) */extern int column;            /* Current column number (0 origin) */extern BOOLEAN margin;        /* True if right margin hit */move_down(n)       /* Move down n rows */int n;{   while (n-- && row < last_row) {       fputs(cap.c_down,stdout);       row++;   }   margin = FALSE;}move_left(n)       /* Move left n columns */int n;{   while (n-- && column != 0) {       fputs(cap.c_left,stdout);       column--;   }   margin = FALSE;}move_to(x,y)       /* Move cursor to specified position */int    x;  /* column */int    y;  /* row */#define ESCAPE 255 /* cursor control escape */#define XY 1       /* bit for row or column, on->column */#define BIAS 2     /* bit for bias */#define SUB 4      /* subtract from maximum */#define BCD 8      /* bit for BCD */#define ASCII 16   /* bit to send position in ASCII */{   int direc;   int from_home;   int from_start;   int v;   char    *c_ptr;   char    ch;   if ((c_ptr=cap.c_pos) != NULL) {/* Process direc cursor addressing */   if (x > last_column) x = last_column;   if (y > last_row) y = last_row;   while ((v=(*c_ptr++)&0xff)!=NULL) {       if (v!=ESCAPE) putchar(v);       else if((v=(*c_ptr++)&0xff)!=NULL) {           ch=((v&XY)==0)?               ((v&SUB)==0? y:p_l_row-y):               ((v&SUB)==0? x:p_l_column-x);           if ((v&BIAS)!=0)               ch += (unsigned)*c_ptr++;           if ((v&BCD)!=0) {               ch=(unsigned)ch/10<<4|(unsigned)ch%10;               putchar(ch);           }           else if ((v&ASCII)!=0) {               putchar((unsigned)ch/10+'0');               putchar((unsigned)ch%10+'0');           }           else putchar(ch);       }   }   column = x;   row = y;   }   else {/* Direct addressing not available, use relative motions. */   direc = (x>column? (x-column)*cr_size: (column-x)*cl_size) +       (y>row? (y-row)*cd_size: (row-y)*cu_size);   from_home = hm_size+x*cr_size+y*cd_size;   from_start = 1 + x*cr_size +       (y>row? (y-row)*cd_size: (row-y)*cu_size);   if (direc <= from_home && direc <= from_start ) {       if (y > row) move_down(y-row);       else move_up(row-y);       if (x > column) move_right(x-column);       else move_left(column-x);   }   else if (from_home < from_start) {       home_up();       move_down(y);       move_right(x);   }   else {       fputs("\r",stdout);       column = 0;       if (y > row) move_down(y-row);       else move_up(row-y);       move_right(x);   }   }   margin = FALSE;}move_right(n)      /* Move right n columns */int n;{   while (n-- && column < last_column) {       fputs(cap.c_right,stdout);       column++;   }}move_up(n)     /* Move up n rows */int n;{   while (n-- && row != 0) {       fputs(cap.c_up,stdout);       row--;   }   margin = FALSE;}