/* display directory tree */#asm info UniFLEX tree info by W. Lekkerkerker info 24-6-1988#endasm#include <stdio.h>#include <dir.h>#include <stat.h>#define DIR_PER_DIR 100int     depth;struct direct dir;                      /* structure of directory entry */struct stat status;typedef struct {        int     stp;        char    *st_array[DIR_PER_DIR];} STACKREF;FILE *fp, *fopen();main(argc, argv)int argc;char *argv[];{        int     arg;        depth = 0;        if (argc == 1)                tree(".");        else                for (arg=1; arg < argc; arg++) {                        depth = 0;                        tree(argv[arg]);                }}tree(s)char *s;{        int     d;        int strc();        char    nextname[DIRSIZ];        STACKREF *st, *open_stack();        if (stat(s, &status) == -1) {                fout("can't get status for %s", s);                return;        }        if ((status.st_mode & S_IFMT) != S_IFDIR)                return;        for (d=0; d < depth; d++)                fputs("+----", stdout);        puts(s);        fflush(stdout);        if (chdir(s) == -1) {                fout("can't change to directory %s", s);                return;        }        depth++;        if (!(fp = fopen(".", "r"))) {                perror("can't open .");                return;        }        st = open_stack();        while (fread(&dir, sizeof(dir), 1, fp)) {                if (dir.d_ino == 0 ||                    strcmp(dir.d_name, ".") == 0 ||                    strcmp(dir.d_name, "..") == 0)                        continue;                if (stat(dir.d_name, &status) == -1) {                        fout("can't get status for %s", dir.d_name);                        continue;                }                if ((status.st_mode & S_IFMT) == S_IFDIR)                        write_stack(st, dir.d_name);        }        fclose(fp);        qsort(st->st_array, st->stp, sizeof(char *), strc);        while (read_stack(st, nextname))                tree(nextname);        close_stack(st);        chdir("..");        depth--;}strc(s1, s2)char **s1, **s2;{        return(strcmp(s2, s1));}fout(s1,s2)char *s1,*s2;{        char out[100];        sprintf(out, s1, s2);        perror(out);}STACKREF *open_stack(){        STACKREF *tp;        if ((tp = malloc(sizeof(STACKREF))) == 0)                badmem();        tp->stp = 0;        return tp;}close_stack(tp)STACKREF *tp;{        free(tp);}badmem(){        fputs("out of memory space\n", stdout);        exit(1);}read_stack(tp, s)STACKREF *tp;char *s;{        char *m;        if (tp->stp == 0)                return 0;        tp->stp--;        strcpy(s, tp->st_array[tp->stp]);        free(tp->st_array[tp->stp]);        return 1;}write_stack(tp, s)STACKREF *tp;char *s;{        char *m;        if ((m = malloc(strlen(s)+1)) == 0)                badmem();        strcpy(m, s);        tp->st_array[tp->stp] = m;        tp->stp++;}