/* dump file */#define SIZE 320                /* number of read bytes */#include <stdio.h>#include <signal.h>#include <sgtty.h>typedef int BOOLEAN;#define TRUE 1#define FALSE 0#define STRSIZE 192     /* Size of string area */struct ttycap {   char    c_rows;     /* Number of rows */   char    c_cols;     /* Number of columns */   char    c_inxy;     /* Invert x and y when positioning */   char    c_wait;     /* Screen settling time */   char    *c_home;    /* Home up */   char    *c_up;      /* Cursor up */   char    *c_down;    /* Cursor down */   char    *c_left;    /* Cursor left */   char    *c_right;   /* Cursor right */   char    *c_clear;   /* Clear screen */   char    *c_pos;     /* Position to x y */   char    *c_init;    /* Initialize terminal */   char    *c_blank;   /* Blank to end of current line */   char    *c_backg;   /* Set background mode */   char    *c_foreg;   /* Set foreground mode */   char    *c_darrow;  /* Down arrow key */   char    *c_uarrow;  /* Up arrow key */   char    *c_larrow;  /* Left arrow key */   char    *c_rarrow;  /* Right arrow key */   char    *c_hmkey;   /* Home key */   char    *c_fn0;     /* Function key 0 */   char    *c_fn1;     /* Function key 1 */   char    *c_fn2;     /* Function key 2 */   char    *c_fn3;     /* Function key 3 */   char    *c_fn4;     /* Function key 4 */   char    *c_fn5;     /* Function key 5 */   char    *c_fn6;     /* Function key 6 */   char    *c_fn7;     /* Function key 7 */   char    *c_fn8;     /* Function key 8 */   char    *c_fn9;     /* Function key 9 */   char    *unused[4]; /* Spares */   char    c_caps[STRSIZE];/* Capability strings */} ;#define HOME_KEY -1#define UP_KEY -2#define DOWN_KEY -3#define LEFT_KEY -4#define RIGHT_KEY -5#define KEY(WHICH) (-10-WHICH)#define NO_DATA -100#define INREADY 0x80#define ESCAPE 255 /* cursor control escape */#define XY 1       /* bit for row or column, on->column */#define BIAS 2     /* bit for bias */#define SUB 4      /* subtract from maximum */#define BCD 8      /* bit for BCD */#define ASCII 16   /* bit to send position in ASCII */#define NIL 0                   /* Null pointer */#define DIRSIZE 32              /* Terminal Directory Size */#define NUMCAP 30               /* Number of capabilities */#define DATABYTES 4             /* Number of bytes before pointers */#asm        info    UniFLEX dm, dump memory        info    (c) 1987 W. Lekkerkerker        info    version 2 with attributes#endasmstruct sgttyb ttybuffer;struct ttycap cap;              /* Terminal capabilities */int nrows;                      /* Number of rows on screen */int ncols;                      /* Number of columns on screen */int p_l_row;                    /* Physical last row */int p_l_column;                 /* Physical last column */int last_row;                   /* Last row number (0 origin) */int last_column;                /* Last column number (0 origin) */int delay;                      /* Screen settle time in seconds */int cu_size;                    /* Size of cursor up string */int cd_size;                    /* Size of cursor down string */int cl_size;                    /* Size of cursor left string */int cr_size;                    /* Size of cursor right string */int hm_size;                    /* Size of home up string */int row;                        /* Current row number (0 origin) */int column;                     /* Current column number (0 origin) */int mode;unsigned char buffer[SIZE];unsigned char *readptr;unsigned char display[SIZE*5];unsigned char *disptr;main(argc, argv)int     argc;char    *argv[];{        int     ifd;            /* input file */        long    address;        /* offset address */        int     i;        int     einde();        if (argc != 3) {                puts("Usage: dm <file> <address>");                exit(1);        }        if ((ifd=open(*++argv, 0))==-1) {                fputs("dm: Can't open ", stdout);                puts(*argv);                exit(1);        }        if (sscanf(*++argv,"%X",&address)!=1) {                fputs("dm: Illegal address ", stdout);                puts(*argv);                exit(1);        };        if (terminit()==FALSE) {                puts("dm: Can't initialize terminal", stdout);                exit(1);        }        signal(SIGINT,einde);        gtty(stdin->_fd, &ttybuffer);        ttybuffer.sg_flag&=~ECHO;         /* no echo */        ttybuffer.sg_flag|=CBREAK;        /* single character */        stty(stdin->_fd, &ttybuffer);        for (disptr = display; disptr<display+SIZE*5; disptr++)                *disptr=0;        move_to(0,0);        for (i=0; i<SIZE; i+=16) {                p5hex(address+i);                putchar('\n');        }        mode = 0;        while (lseek(ifd,address,0) != -1L) {                if (read(ifd, buffer, SIZE)==-1) {                        puts("dm: Read error");                        einde();                }                dump();                testinput(&address);        }}dump(){        int x,y;        if (mode)                foreground();        else                background();        readptr=buffer;        disptr=display;        for (y=0; y<SIZE/16; y++) {                for (x=0; x<16; x++) {                        if (*readptr != *disptr || mode == 0) {                                move_to(6+x*3,y);                                p2hex(*readptr);                                move_to(55+x,y);                                if (*readptr>31 && *readptr<127)                                        putchar(*readptr);                                else                                         putchar('.');                                *disptr++ = *readptr++;                        } else {                                disptr++;                                readptr++;                        }                } /*endfor x*/        } /*endfor y*/        fflush(stdout);        mode = 1;}testinput(addrptr)long *addrptr;{        int i;        gtty(stdin->_fd, &ttybuffer);        if (ttybuffer.sg_speed&INREADY) {                getchar();                move_to(0,21);                fputs("address: ", stdout);                fflush(stdout);                ttybuffer.sg_flag|=ECHO;          /* echo */                ttybuffer.sg_flag&=~CBREAK;       /* no single character */                stty(stdin->_fd, &ttybuffer);                if (scanf("%X",addrptr) != 1) {                        puts("\nbad address");                        sleep(5);                }                ttybuffer.sg_flag&=~ECHO;         /* no echo */                ttybuffer.sg_flag|=CBREAK;        /* single character */                stty(stdin->_fd, &ttybuffer);                background();                mode = 0;                move_to(0,0);                for (i=0; i<SIZE; i+=16) {                        p5hex(*addrptr+i);                        putchar('\n');                }        }}p2hex(h)unsigned int    h;{        int     i;        i=h>>4;        putchar((i > 9) ? i+'7' : i+'0');        i=h&0xf;        putchar((i > 9) ? i+'7' : i+'0');}p5hex(lh)long lh;{        int i;        p2hex((int)(lh>>12));        lh&=0xfffL;        p2hex((int)(lh>>4));        i=(int)lh&0xf;        putchar((i > 9) ? i+'7' : i+'0');}move_to(x,y)       /* Move cursor to specified position */int    x;  /* column */int    y;  /* row */{        int     v;        char    *c_ptr;        char    ch;        if ((c_ptr=cap.c_pos) != NULL) { /* can position cursor */                if (x > last_column)                        x = last_column;        /* truncate x */                if (y > last_row)                        y = last_row;           /* truncate y */                while ((v=(*c_ptr++)&0xff)!=NULL) {                        if (v!=ESCAPE)                                putchar(v);                        else if((v=(*c_ptr++)&0xff)!=NULL) {                                ch=((v&XY)==0)?                                ((v&SUB)==0? y:p_l_row-y):                                ((v&SUB)==0? x:p_l_column-x);                                if ((v&BIAS)!=0)                                        ch += (unsigned)*c_ptr++;                                if ((v&BCD)!=0) {                                        ch=(unsigned)ch/10<<4|(unsigned)ch%10;                                        putchar(ch);                                }                                else if ((v&ASCII)!=0) {                                        putchar((unsigned)ch/10+'0');                                        putchar((unsigned)ch%10+'0');                                }                                else putchar(ch);                        } /* end else if */                } /* end while */                column = x;                row = y;        }}BOOLEAN terminit() /* Initialize terminal */{        if ( !termcap(&cap) )                return FALSE;        nrows = (int)cap.c_rows;        ncols = (int)cap.c_cols;        p_l_row = nrows-1;        last_row = nrows-2;        p_l_column = last_column = ncols-1;        delay = (int)cap.c_wait;        cu_size = strlen(cap.c_up);        cd_size = strlen(cap.c_down);        cl_size = strlen(cap.c_left);        cr_size = strlen(cap.c_right);        hm_size = strlen(cap.c_home);        if (cap.c_init != NIL)                fputs(cap.c_init,stdout);        clear_screen();        return TRUE;}BOOLEAN termcap(cp)    /* Get terminal capabilities */struct ttycap *cp;{        char    **cap_ptr;        int     i;        long    j;        int     fd;        int     direc[DIRSIZE];        long    lseek();        int open(), read();        if ((fd=open("/etc/termcap",0)) == -1)                return FALSE;        if ((i=read(fd,(char *)direc,sizeof(int)*DIRSIZE)) == -1             || i != sizeof(int)*DIRSIZE             || (i=direc[ttyslot()]) == 0             || (j=lseek(fd, (long)i, 0)) == -1L             || (i=read(fd,(char *)cp,sizeof(struct ttycap))) == -1             || i != sizeof(struct ttycap)) {                close(fd);                return FALSE;        }        close(fd);        cap_ptr = (char **)( (char *)cp+DATABYTES );        for (i=NUMCAP; i--; cap_ptr++)                if (*cap_ptr != NIL)                        *cap_ptr += (unsigned)cp;        return TRUE;}background(){        if (*cap.c_backg != NIL)                fputs(cap.c_backg, stdout);}foreground(){        if (*cap.c_foreg != NIL)                fputs(cap.c_foreg, stdout);}clear_screen()     /* Clear screen */{        if (*cap.c_clear != NIL)                fputs(cap.c_clear,stdout);        if (delay != 0)                 sleep(delay);        row = column = 0;}einde(){        background();        move_to(0,23);        ttybuffer.sg_flag|=ECHO;          /* echo */        ttybuffer.sg_flag&=~CBREAK;       /* no single character */        stty(stdin->_fd, &ttybuffer);        exit(0);}