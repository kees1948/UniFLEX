/* Sculptor/Sage compatible scherm opmaak */#include <stdio.h>#include <signal.h>#include <sgtty.h>#include <ctype.h>#include <termcap.h>#include <dir.h>#define BUFFSIZE 100#define LINESIZE 128#define NIL 0           /* Null pointer */#define DIRSIZE 80      /* Terminal Directory Size */#define NUMCAP 60       /* Number of capabilities */#define DATABYTES 4     /* Number of bytes before pointers */#define STDOUT 1        /* Standard output descriptor */#define STDIN 0         /* Standard input descriptor */TTYCAP cap;             /* Terminal capabilities */struct sgttyb ttyorg;   /* original ttyset parameters */int nrows;              /* Number of rows on screen */int ncols;              /* Number of columns on screen */int p_l_column;         /* Physical last column */int last_row;           /* Last row number (0 origin) */int last_column;        /* Last column number (0 origin) */int delay;              /* Screen settle time in seconds */int cu_size;            /* Size of cursor up string */int cd_size;            /* Size of cursor down string */int cl_size;            /* Size of cursor left string */int cr_size;            /* Size of cursor right string */int hm_size;            /* Size of home up string */int row;                /* Current row number (0 origin) */int column;             /* Current column number (0 origin) */BOOLEAN margin;         /* True if right margin hit */char    d_name[DIRSIZ+3];char    f_name[DIRSIZ+3];char    *r_name;char    oneline[LINESIZE];char    in[LINESIZE];char    heading[LINESIZE];FILE    *ffp, *dfp, *wfp, *fopen();int     bp;             /* number of boxes, variables */int     changes = 0;int     i;              /* general use loop counter */int     key;            /* input key flag */int     line;           /* file line number */extern  inthandler();typedef struct {char    *varname;       /* variable name */int     boxlen;         /* box length */int     scroll;         /* nr of array lines */int     xpos;           /* box x coordinate */int     ypos;           /* box y coordinate */char    *varhead;       /* heading text */int     headlen;        /* negative if not known */} VARS;VARS    vardata[BUFFSIZE];VARS    *p;#define CNF 0#define CFN 1#define RPEOF 2#define OMS 3#define BSP 4#define BSV 5#define NYC 6#define NXC 7char *syns[] = {        "Comma not found",        "Can't find numbers",        "Read past end of file",        "Out of memory space",        "Bad scroll parameters",        "Bad size of variable",        "No y coordinate",        "No x coordinate"};main(argc, argv)int     argc;char    *argv[];{        if (argc == 1)                fatal("Sculptor place version 1, no Copyright at all");        if (argc != 2)                fatal("Usage: place name");        argv[1][DIRSIZ-1] = 0;        sprintf(f_name, "%s.f", argv[1]);        if ((ffp = fopen(f_name, "r")) == NULL)                fatal_2("Can't open %s.\n", f_name);        if (terminit() == FALSE)                fatal("Can't initialize terminal (/etc/termcap).");        signal(SIGINT, inthandler);        read_f(f_name);        editor();        fclose(ffp);        termclose();}anykey(){        message("Type any key to resume ");        in1(in);}center(s, space)        /* calculate x offset of string in space */char    *s;int     space;{        return((space - strlen(s))/2);}dec_format(p, s)VARS    *p;char    *s;{        char    *nr1, *nr2;        char    *index(), *rindex();        if ((nr1 = index(s, '#')) == NULL)                return;        if ((nr2 = rindex(s, '#')) == NULL)                return;        p->boxlen = nr2 - nr1 + 1;}descr2(p)VARS    *p;{        char    *comma1, *comma2;        char    *index(), *malloc();        int     type,size;        int     len;        if ((comma1 = index(oneline, ',')) == NULL) {                syntax(CNF);                return;        }        if (sscanf(comma1+1,"%d,%d",&type,&size) != 2) {                syntax(CFN);                return;        }        if (fgets(oneline, LINESIZE, dfp) == NULL) {                syntax(RPEOF);                return;        }        line++;        if (p->headlen == -1) {                 /* heading text */                *index(oneline, '\n') = 0;                if ((len = strlen(oneline)) == 0) {                        p->varhead = p->varname;                        p->headlen = strlen(p->varhead);                } else {                        p->headlen = len;                        if ((p->varhead = malloc(p->headlen+1)) == NULL) {                                syntax(OMS);                                return;                        }                        strncpy(p->varhead, oneline, p->headlen);                }        }        if (fgets(oneline, LINESIZE, dfp) == NULL) {                syntax(RPEOF);                return;        }        line++;        if (p->boxlen == -1 && strlen(oneline) > 0)                dec_format(p, oneline);        if (p->boxlen == -1) {                switch (type) {                case 1:                       /* ascii */                        p->boxlen = size;                        break;                case 2:                       /* integer */                        p->boxlen = (size * 2) + 1;                        break;                case 3:                       /* real */                        if (size == 4)                                p->boxlen = 7;                        else                                p->boxlen = 10;                        break;                case 4:                       /* money */                        p->boxlen = 10;                        break;                case 5:                       /* date */                        p->boxlen = 8;                        break;                }        }        if (fgets(oneline, LINESIZE, dfp) == NULL) {                syntax(RPEOF);                return;        }        line++;}doscroll(){        int     y, number;        VARS    *p;        if (sscanf(oneline+8, "%d,%d", &y, &number) != 2) {                syntax(BSP);                return;        }        y--;        for (i=0; i<bp; i++) {                p = &vardata[i];                if (p->ypos != y)                        continue;                p->scroll = number;        }}dotemp()        /* use temp definitions */{        for (i=0; i<bp; i++) {                p = &vardata[i];                if (strncmp(oneline+6, p->varname, strlen(p->varname)) != 0)                        continue;                if (p->boxlen == -1 || p->headlen == -1)                        getmore(p);        }}getmore(p)VARS    *p;{        char    *comma1, *comma2;        char    *index(), *malloc();        int     size;        if ((comma1 = index(oneline, ',')) == NULL) {                syntax(CNF);                return;        }        if ((comma2 = index(comma1+1, ',')) == NULL) {                syntax(CNF);                return;        }        if (p->headlen == -1 && comma2 > comma1+1) {                p->headlen = comma2 - comma1 - 1;                if ((p->varhead = malloc(p->headlen+1)) == NULL) {                        syntax(OMS);                        return;                }                strncpy(p->varhead, comma1+1, p->headlen);                if (strcmp(p->varhead, " ") == 0) {     /* empty head */                        p->varhead[0] = 0;                        p->headlen = 0;                }        }        if (p->boxlen != -1)                return;        if (sscanf(comma2+2, "%d", &size) != 1) {                syntax(BSV);                return;        }        switch (*(comma2+1)) {        case 'a':                p->boxlen = size;                break;        case 'i':                p->boxlen = (size * 2) + 1;                break;        case 'r':                p->boxlen = 10;                break;        case 'm':                p->boxlen = 10;                break;        case 'd':                p->boxlen = 8;                break;        }}editor(){        int     var;        var = 0;update:        clear_screen();        move_to(center(heading, ncols), 0);        fputs(heading, stdout);        for (i=0; i<bp; i++) {                p = &vardata[i];                printbox();        }loop:        p = &vardata[var];        printbox();        if (key = in1(in)) {                movebox();                switch (key) {                case DOWN_KEY:                        if (p->ypos < nrows) p->ypos++;                        break;                case UP_KEY:                        if (p->ypos > 0) p->ypos--;                        break;                case LEFT_KEY:                        if (p->xpos > 0) p->xpos--;                        break;                case RIGHT_KEY:                        if (p->xpos < ncols) p->xpos++;                        break;                default:                        goto loop;                }                changes = 1;                move_to(0,23);                printf("x=%02d y=%02d ",p->xpos,p->ypos);                goto loop;        }        message("");        switch (*in) {        case '1':                var = 0;                break;        case '+':        case 'n':                if (var < bp-1) var++;                break;        case '-':        case 'p':                if (var > 0) var--;                break;        case '?':                help();                goto update;        case 'r':                report();                goto update;        case 'u':                goto update;        case 'w':                writeback();                changes = 0;                goto update;        case 'x':        case 'e':        case 'q':                if (changes) {                        message("Write changes to form file (y/n)? ");                        in1(in);                        if (*in=='j' || *in=='J' || *in=='y' || *in=='Y')                                writeback();                }                return;        default:                message("Unknown command");        }        goto loop;}fatal(s)char *s;{        puts(s);        exit(1);}fatal_2(s, n)char *s;char *n;{        printf(s, n);        exit(1);}help(){        clear_screen();        move_to(0,0);        puts("                          Sculptor place Help");        puts("");        puts("1       goto first box");        puts("+ n     goto next box");        puts("- p     goto previous box");        puts("?       help");        puts("r       report");        puts("u       update screen");        puts("w       write to screen_form file");        puts("e x q   exit");        puts("");        puts("");        puts("        move cursor using arrow keys");        puts("");        puts("");        puts("");        anykey();}initvar()       /* initialize oneline into a vardata entry */{        char    *comma1, *comma2, *comma3;        char    *index(), *malloc();        int     namlen;        VARS    *p;        p = &vardata[bp];        bp++;        p->headlen = -1;        /* header unknown */        p->boxlen = -1;         /* box size unknown */        p->scroll = 0;        if ((comma1 = index(oneline, ',')) == NULL) {                syntax(CNF);                return;        }        if ((comma2 = index(comma1+1, ',')) == NULL) {                syntax(CNF);                return;        }        if ((comma3 = index(comma2+1, ',')) == NULL) {                syntax(CNF);                return;        }        namlen = comma1 - oneline - 1;        if ((p->varname = malloc(namlen+1)) == NULL) {                syntax(OMS);                return;        }        strncpy(p->varname, oneline+1, namlen);        message(p->varname);        if (comma2 > comma1+1) {                /* heading defined here */                p->headlen = comma2 - comma1 - 1;                if ((p->varhead = malloc(p->headlen+1)) == NULL) {                        syntax(OMS);                        return;                }                strncpy(p->varhead, comma1+1, p->headlen);                if (strcmp(p->varhead, " ") == 0) {     /* empty head */                        p->varhead[0] = 0;                        p->headlen = 0;                }        }        if (sscanf(comma2+1, "%d", &(p->ypos)) != 1) {                syntax(NYC);                return;        }        p->ypos--;        if (sscanf(comma3+1, "%d", &(p->xpos)) != 1) {                syntax(NXC);                return;        }        dec_format(p, comma3+1);}inthandler(){        move_to(0, 24);        termclose();        exit(0);}message(s)char *s;{        move_to(0,23);        fputs(s, stdout);        blank_line();        fflush(stdout);}movebox(){        int     scrline, scrollmax, addy, size;        if (p->scroll) {                addy = 1;                scrollmax = p->scroll;                move_to(center(p->varhead, p->boxlen) + p->xpos-1, p->ypos);        } else {                addy = 0;                scrollmax = 1;                move_to(p->xpos - p->headlen - 3, p->ypos);        }        size = p->headlen;        while(size-- > 0)                putchar(' ');        for (scrline = 1; scrline <= scrollmax; scrline++) {                move_to(p->xpos - 2, p->ypos + addy++);                size = p->boxlen+2;                while(size-- > 0)                        putchar(' ');        }}printbox(){        int     scrline, scrollmax, addy, size;        if (p->scroll) {                addy = 1;                scrollmax = p->scroll;                move_to(center(p->varhead, p->boxlen) + p->xpos-1, p->ypos);        } else {                addy = 0;                scrollmax = 1;                move_to(p->xpos - p->headlen - 3, p->ypos);        }        fputs(p->varhead, stdout);        for (scrline = 1; scrline <= scrollmax; scrline++) {                move_to(p->xpos - 2, p->ypos + addy++);                putchar('[');                size = p->boxlen;                while(size-- > 0)                        putchar('_');                putchar(']');        }        move_to(p->xpos-1, p->ypos);}read_d(s)                /* scan describe file */char *s;{        s[DIRSIZ-1] = 0;        sprintf(d_name, "%s.d", s);        if ((dfp = fopen(d_name, "r")) == NULL)                fatal_2("Can't open %s.\n", d_name);        r_name = d_name;        fgets(oneline, LINESIZE, dfp);        fgets(oneline, LINESIZE, dfp);        line = 2;        while (fgets(oneline, LINESIZE, dfp)) {                line++;                for (i=0; i<bp; i++) {                        p = &vardata[i];                        if (strncmp(oneline,p->varname,strlen(p->varname))!=0)                                continue;                        descr2(p);                        break;                }        }        fclose(dfp);}read_f(s)               /* read form file */char    *s;{        char    *rindex();        r_name = s;        bp = 0;        line = 0;                               /* scan boxes */        while (fgets(oneline, LINESIZE, ffp)) {                line++;                if (line == 1) {                        strncpy(heading, oneline, LINESIZE);                        continue;                }                if (oneline[0] == '+')                        initvar();        }        rewind(ffp);        line = 0;                               /* scan temps & scroll */        while (fgets(oneline, LINESIZE, ffp)) {                line++;                if (strncmp(oneline, "!temp ", 6) == 0) {                        dotemp();                        continue;                }                if (strncmp(oneline, "!scroll ", 8) == 0)                        doscroll();        }        rewind(ffp);        line = 0;                               /* scan temps & scroll */        while (fgets(oneline, LINESIZE, ffp)) {                line++;                if (strncmp(oneline, "!file ", 6) == 0 ||                    strncmp(oneline, "!cfile ", 7) == 0 ||                    strncmp(oneline, "!xfile ", 7) == 0) {                        *(rindex(oneline, '\n')) = 0;                        read_d(rindex(oneline, ' ')+1);                }        }}report(){        clear_screen();        move_to(0,0);        for (i=0; i<bp; i++) {                p = &vardata[i];                printf("%10s \ty=%d \tx=%d \tbox=%d",                        p->varname, p->ypos, p->xpos, p->boxlen);                if (p->headlen > -1)                        printf(" \thead=%s\n", p->varhead);                else                        putchar('\n');        }        anykey();}syntax(i)       /* report a syntax error */int     i;{        printf("File %s line %d %s.\n", r_name, line, syns[i]);}writeback(){        char    command[LINESIZE];        sprintf(command, "rename %s %s.bak", f_name, f_name);        if (system(command)) {                message("Can't write back");                return;        }        if ((wfp = fopen(f_name, "w")) == NULL) {                printf("\nCan't open %s.", f_name);                anykey();                return;        }        rewind(ffp);        while (fgets(oneline, LINESIZE, ffp)) {                if (oneline[0] == '+')                        wr_box();                else if (strncmp(oneline, "!scroll ", 8) == 0)                        wr_scroll();                else                        fputs(oneline, wfp);        }        fclose(wfp);}wr_box(){        char    *comma1, *comma2, *comma3;        char    *ptr;        char    *index();        int     namlen;        if ((comma1 = index(oneline, ',')) == NULL) {                syntax(CNF);                return;        }        if ((comma2 = index(comma1+1, ',')) == NULL) {                syntax(CNF);              return;        }        if ((comma3 = index(comma2+1, ',')) == NULL) {                syntax(CNF);                return;        }        namlen = comma1 - oneline - 1;        for (i=0; i<bp; i++) {                p = &vardata[i];                if (strncmp(p->varname, oneline+1, namlen))                        continue;                message(p->varname);                for (ptr=oneline; ptr<=comma2; ptr++)                        putc(*ptr, wfp);                fprintf(wfp, "%d,%d", p->ypos+1, p->xpos);                comma3++;                while (*comma3 >= '0' && *comma3 <= '9')                        comma3++;                fputs(comma3, wfp);                break;        }}wr_scroll(){        for (i=0; i<bp; i++) {                p = &vardata[i];                if (p->scroll == 0)                        continue;                fprintf(wfp, "!scroll %d,%d\n", p->ypos+1, p->scroll);                break;        }}blank_line()                    /* Blank from current position */{   int i;   if (cap.c_blank != NULL)        fputs(cap.c_blank,stdout);   else {        i = column;        while (column <= last_column && !margin)                c_output(' ');        move_to(i,row);   }}clear_screen()     /* Clear screen */{   fputs(cap.c_clear,stdout);   if (delay != 0) sleep(delay);   row = column = 0;   margin = FALSE;}c_output(c)        /* Output character at current position */char c;{   if (!margin) {       putchar(c);       if (column != last_column) column++;       else margin = TRUE;   }}home_up()      /* Home cursor */{   fputs(cap.c_home,stdout);   row = column = 0;   margin = FALSE;}in1(string)     /* input 1 character */char *string;{        char *str;        int ch;        int x,y;        int lead_in;in2:        lead_in = 0;        str=string;        do {                fflush(stdout);                ch = getchar();                if (errno == 27) {                        x=column;                        y=row;                        move_to(x,y);                        errno=0;                        continue;                }                clearerr(stdout);                if (feof(stdin))                        cleareof(stdin);                if (isprint(ch) && lead_in==0) {                        *str++ = ch;                        c_output(ch);                } else if (str == string &&                                (ch == *cap.c_darrow ||                                ch == *cap.c_uarrow ||                                ch == *cap.c_larrow ||                                ch == *cap.c_rarrow)) {                        lead_in = 1;                }                if (lead_in) {                        *str++ = ch;                        *str = '\0';                        if (strcmp(string, cap.c_darrow) == 0) {                                *string='\0';                                return(DOWN_KEY);                        }                        if (strcmp(string, cap.c_uarrow) == 0) {                                *string='\0';                                return(UP_KEY);                        }                        if (strcmp(string, cap.c_larrow) == 0) {                                *string='\0';                                return(LEFT_KEY);                        }                        if (strcmp(string, cap.c_rarrow) == 0) {                                *string='\0';                                return(RIGHT_KEY);                        }                }        } while (lead_in);        *str = '\0';        if (lead_in) {                          /* arrow key error */                move_left(str-string);                goto in2;        }        fflush(stdout);        return(0);}input(string)       /* Input string */char *string;{        char *str;        int ch;        int x,y;        int lead_in;input2:        lead_in = 0;        str=string;        do {                fflush(stdout);                ch = getchar();                if (errno == 27) {                        x=column;                        y=row;                        move_to(x,y);                        errno=0;                        continue;                }                clearerr(stdout);                if (feof(stdin))                        cleareof(stdin);                if (isprint(ch) && lead_in==0) {                        *str++ = ch;                        c_output(ch);                } else if (str == string &&                                (ch == *cap.c_darrow ||                                ch == *cap.c_uarrow ||                                ch == *cap.c_larrow ||                                ch == *cap.c_rarrow)) {                        lead_in = 1;                }                if (lead_in) {                        *str++ = ch;                        *str = '\0';                        if (strcmp(string, cap.c_darrow) == 0) {                                *string='\0';                                return(DOWN_KEY);                        }                        if (strcmp(string, cap.c_uarrow) == 0) {                                *string='\0';                                return(UP_KEY);                        }                        if (strcmp(string, cap.c_larrow) == 0) {                                *string='\0';                                return(LEFT_KEY);                        }                        if (strcmp(string, cap.c_rarrow) == 0) {                                *string='\0';                                return(RIGHT_KEY);                        }                }                if (lead_in==0 &&                              (ch == ttyorg.sg_erase || ch == 8 || ch == 127)                               && str > string) {                        str--;                        move_left(1);                        c_output(' ');                        move_left(1);                }                if (str == string)                        lead_in = 0;        } while (ch != '\n' && (str - string) < 79);        *str = '\0';        if (lead_in) {                          /* arrow key error */                move_left(str-string);                goto input2;        }        putchar('\n');        fflush(stdout);        return(0);}BOOLEAN termcap(cp)    /* Get terminal capabilities */TTYCAP *cp;{   char    **cap_ptr;   int i;   long    j;   int fd;   int direc[DIRSIZE];   long    lseek();   int open(), read();   if ( (fd=open("/etc/termcap",0)) == -1) return FALSE;   if (    (i=read(fd,(char *)direc,sizeof(int)*DIRSIZE)) == -1 ||    i != sizeof(int)*DIRSIZE ||    (i=direc[ttyslot()]) == 0 ||    (j=lseek(fd, (long)i, 0)) == -1L ||    (i=read(fd,(char *)cp,sizeof(TTYCAP))) == -1 || i != sizeof(TTYCAP)   ) {       close(fd);       return FALSE;   }   close(fd);   cap_ptr = (char **)( (char *)cp+DATABYTES );   for (i=NUMCAP; i--; cap_ptr++)       if (*cap_ptr != NIL) *cap_ptr += (unsigned)cp;   return TRUE;}termclose(){        stty(fileno(stdin),&ttyorg);}BOOLEAN terminit() /* Initialize terminal */{   struct sgttyb ttbuf;   if ( ! termcap(&cap) ) return FALSE;   nrows = (int)cap.c_rows;   ncols = (int)cap.c_cols;   last_row = nrows-1;   p_l_column = last_column = ncols-1;   delay = (int)cap.c_wait;   cu_size = strlen(cap.c_up);   cd_size = strlen(cap.c_down);   cl_size = strlen(cap.c_left);   cr_size = strlen(cap.c_right);   hm_size = strlen(cap.c_home);   gtty(fileno(stdin),&ttyorg);   gtty(fileno(stdin),&ttbuf);   ttbuf.sg_flag &= ~ECHO;   ttbuf.sg_flag |= CBREAK;   ttbuf.sg_spare |= XONXOFF;   ttbuf.sg_spare |= NOESC;   stty(fileno(stdin),&ttbuf);   if (cap.c_init != NIL) fputs(cap.c_init,stdout);   if (cap.c_backg != NULL) fputs(cap.c_backg, stdout);   clear_screen();   return TRUE;}move_down(n)       /* Move down n rows */int n;{   while (n-- && row < last_row) {       fputs(cap.c_down,stdout);       row++;   }   margin = FALSE;}move_left(n)       /* Move left n columns */int n;{   while (n-- && column != 0) {       fputs(cap.c_left,stdout);       column--;   }   margin = FALSE;}move_to(x,y)       /* Move cursor to specified position */int    x;  /* column */int    y;  /* row */#define ESCAPE 255 /* cursor control escape */#define XY 1       /* bit for row or column, on->column */#define BIAS 2     /* bit for bias */#define SUB 4      /* subtract from maximum */#define BCD 8      /* bit for BCD */#define ASCII 16   /* bit to send position in ASCII */{   int direc;   int from_home;   int from_start;   int v;   char    *c_ptr;   char    ch;   if ((c_ptr=cap.c_pos) != NULL) {   if (x > last_column) x = last_column;   if (y > last_row) y = last_row;   while ((v=(*c_ptr++)&0xff)!=NULL) {       if (v!=ESCAPE) putchar(v);       else if((v=(*c_ptr++)&0xff)!=NULL) {           ch=((v&XY)==0)?               ((v&SUB)==0? y:last_row-y):               ((v&SUB)==0? x:p_l_column-x);           if ((v&BIAS)!=0)               ch += (unsigned)*c_ptr++;           if ((v&BCD)!=0) {               ch=(unsigned)ch/10<<4|(unsigned)ch%10;               putchar(ch);           }           else if ((v&ASCII)!=0) {               putchar((unsigned)ch/10+'0');               putchar((unsigned)ch%10+'0');           }           else putchar(ch);       }   }   column = x;   row = y;   } else {   direc = (x>column? (x-column)*cr_size: (column-x)*cl_size) +       (y>row? (y-row)*cd_size: (row-y)*cu_size);   from_home = hm_size+x*cr_size+y*cd_size;   from_start = 1 + x*cr_size +       (y>row? (y-row)*cd_size: (row-y)*cu_size);   if (direc <= from_home && direc <= from_start ) {       if (y > row) move_down(y-row);       else move_up(row-y);       if (x > column) move_right(x-column);       else move_left(column-x);   }   else if (from_home < from_start) {       home_up();       move_down(y);       move_right(x);   }   else {       fputs("\r",stdout);       column = 0;       if (y > row) move_down(y-row);       else move_up(row-y);       move_right(x);   }   }   margin = FALSE;}move_right(n)      /* Move right n columns */int n;{   while (n-- && column < last_column) {       fputs(cap.c_right,stdout);       column++;   }}move_up(n)     /* Move up n rows */int n;{   while (n-- && row != 0) {       fputs(cap.c_up,stdout);       row--;   }   margin = FALSE;}