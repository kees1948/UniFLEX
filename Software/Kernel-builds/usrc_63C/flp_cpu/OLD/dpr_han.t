          lib     ./environment.h          opt     nol          lib     ../include/macdefs.h          lib     ../include/inttab.h          lib     ../include/task.h          lib     ../include/tty.h          lib     ../include/sysdefs.h          opt     lis          lib     ../include/dpr.h          lib     ../include/fio_codes.h          sttl    DPR        Interface          pag          global  NUM_TRM,NUM_TSKDPR_COST  set     2          Activity cost for DPR transaction          data          global  dpr_int          global  dpr_open,dpr_close,dpr_write,dpr_read,dpr_spcl          global  dpr_waitdpr_wait  fcb     0          Count of tasks waiting for this DPR access (global)*         lib     ./dpr.t** dpr_int - Process DPR interrupt*   Y - IOP Control structure*dpr_int   pshs    x,y          ldx     dpr_dba,y  getchip address          ldd     dpr_cpu4,x block #m/#l          pshs    d          ldd     dpr_cpu2,x size/block #h          pshs    d          ldd     dpr_cpu0,x code/transcation          pshs    d          clr     dpr_cpuF,u indicate message received*10        ldy     8,s          leay    dpr_tran,y point to transaction list          ldb     NUM_TRAN   # transactions          pshs    b15        lda     2,s        check transaction #          cmpa    tran_val1,y match?          beq     20f        yes - go*          leay    TRAN_SIZ,y next transaction          dec     0,s        any more?          bne     15b* -- Unsolicited response!          leas    7,s          bra     99f        exit*20        puls    b          clean up stack          ldd     0,s        get response code          std     tran_val0,y save response code          ldd     2,s        get response value          sta     tran_val2,y          ldd     4,s          std     tran_val4,y          leas    6,s          jsr     wakeup     wake up sender99        puls    x,y,pc     return** dpr_msg - Send a value via the DPR Mailbox & wait for response*   X - ptr to bufhdr*   Y - Interlock table*   jsr dpr_msg*   D - Value returned (B = Error response, A = Specific data)*dpr_msg   pshs    cc,d,x,y,u save registers* -- Find an empty transaction box10        seti               turn       off interrupts          ldy     5,s        get DPR control structure address          jsr     MBX_lock   get access to DPR          lbsr    gettslot   go find a slot          beq     15f        jump if one found*          ldy     5,s        restore DPR structure pointer          jsr     MBX_unlock give up DPR until slot available          lbsr    gettslot  make sure no slots available          beq     10b        jump if there is one* sleep until one comes available          ldy     5,s        get DPR pointer          leay    dpr_tflg,y sleep on transaction slots          ldb     #IOPPRI          jsr     Q_sleep    wait for available message slot          bra     10b        try for a transaction slot* found free transaction slot15        ldb     utask+1    set sequence # in slot ???          orb     #1         make unique          stb     tran_val1,y          ldb     0,s        enable (old) interrupts          tfr     b,cc          pshs    y          *** save transaction slot pointer* put data in mailbox*          ldy     7,s        restore IOP structure pointer          lbsr    mbx_put          jsr     MBX_unlock release mailbox*20        puls    y          get transaction slot address          seti    mask       interrupts          tst     tran_val0,y any response yet?          bne     30f        yes - go process* wait for response to arrive          ldx     5,s        get IOP control address          ldd     dpr_fifo,x does this task own the FIFO?          bne     25f        yes - don't allow interrupts!*          pshs    y,u        save registers          ldd     umark1     set up to allow interruptable sleep          pshs    d          ldx     #27f       interrupt handling label          pshs    x          sts     umark1*          ldb     #TTYIPR    set interruptable priority          jsr     A_sleep    wait for IOP response          puls    d,x,y,u    restore registers          stx     umark1     restore interrupt point          bra     30f        continue*27        puls    x,y,u      Interrupt happened! - (D) already popped          stx     umark1     restore stack mark          lda     #E_ABORT   aborted transaction!          sta     tran_resp,y          ldb     #O_INTRPT          pshs    y          save transaction slot pointer          ldy     7,s        restore IOP control pointer          jsr     MBX_lock   get access to mailbox          jsr     mbx_put          jsr     MBX_unlock release mailbox          puls    y          restore transaction slot pointer          bra     30f* sleep until avialable25        ldb     #IOPPRI          pshs    x,y,u      save registers          jsr     A_sleep          puls    x,y,u      restore registers*30        ldx     utask          seti               turn off interrupts while fiddling with transaction slots* -- See if there is a response.  It is possible to* -- get here without one if an interrupt happened which* -- was being ignored.  In this case, the IOP doesn't* -- need to be notified of any interrupt, but we must* -- wait for the IOP response to actually arrive.          ldb     tran_val0,y get response code          bne     35f        jump if response present*          pshs    y          reset stack          bra     20b        wait for response*35        clra               release    transaction slot          sta     tran_val1,y          sta     tran_val2,y          sta     tran_val3,y          lda     tran_val0,y get response value          std     1,s        set return value*          ldy     5,s        wake anybody waiting for this slot          leay    dpr_tflg,y          jsr     wakeup          lda     2,s        interrupted transaction?          cmpa    #E_ABORT          bne     50f        no - continue*          lds     umark1     yes - get out          rts*50        puls    cc,d,x,y,u,pc return** gettslot - find a transaction slot*   Y - DPR control address*   jsr gettslot*   Y - Transaction slot*   <NE> if none available*gettslot pshs    b,x,y save register05        leay    dpr_tran,y point to transactions          ldb     NUM_TRAN          stb     0,s* look first for OUR transaction10        lda     utask+1    check for busy entries          ora     #1          cmpa    tran_seq,y          beq     30f        yes - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     10b* now look for empty slot          ldy     3,s        restore DPR pointer          leay    dpr_tran,y point to transactions          ldb     NUM_TRAN          stb     0,s*20        lda     tran_seq,y entry busy?          beq     30f        no - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     20b*          leay    iop_tflg,y    sleep on transaction slots          ldb     #IOPPRI          jsr     Q_sleep       wait for available message slot          ldy     3,s           restore DPR pointer          bra     05b*30        sty     3,s        return value*99        puls    b,x,y,pc   clean stack & return**  get_F_S - Allocate a transaction slot and the FIFO*    Y - DPR control*get_F_S   pshs    cc,d,x,y,u save registers          seti    mask       interrupts          jsr     gettslot  allocate transaction slot          beq     10f        jump if one found*          ldy     5,s        wait for slot          leay    dpr_tflg,y          ldb     #IOPPRI          jsr     Q_sleep          puls    cc,d,x,y,u restore registers          bra     get_F_S    try again*10        ldb     utask+1    "allocate" slot          orb     #1          stb     tran_seq,y          puls    cc,d,x,y,u restore interrupts/registers          jmp     DPRF_lock  lock DPR access** dpr_open - Open a channel on the IOP*   D = Device #*dpr_open  pshs    d,x,y,u          lbsr    dpr_fdv    compute device #*          pshs    d,u,y      save DPR parameters*05        ldb     #O_OPEN    send "open device" request          jsr     dpr_msg          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     10f*          jsr     p_dpr_bsy  print message          bra     05b*10        cmpb    #E_BADDEV  illegal device?          bne     15f          ldd     #EBDEV     yes - return error          std     uerror*15        puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** dpr_close - Close a terminal at the DPR*dpr_close pshs    d,x,y,u          lbsr    dpr_fdv    compute device #          bcs     99f        jump if error          pshs    d,u,y      save IOP parameters*00        ldb     #O_CLOSE   send "close device" request          jsr     dpr_msg          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     10f*          jsr     p_dpr_bsy  print message          bra     00b*10        puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** Y contains buffhdr* dpr_write - Write data to a channel on the DPR*dpr_write pshs    d,x,y,u          lbsr    dpr_fdv    compute device #* Y = DPR control block          bcs     99f        jump if error*          pshs    d,u,y      save IOP parameters*00        ldd     uicnt      any data left?          beq     90f        no - exit*          ldb     #O_RQWR    send "request write data" request          jsr     dpr_msg          cmpb    #E_IOERR   I/O Error? (possible on printers)          beq     80f*          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     05f*          jsr     p_dpr_bsy  print message          bra     00b*05        jsr     get_F_S    allocate FIFO and a transaction slot* transfer buffer into fifo10        pshs    a,x,y,u    save registers**        lbsr    cpass      get character          puls    a,x,y,u    restore registers          bmi     20f        jump if no more*          jsr     DPRF_put   place character in FIFO          inca               update     count          cmpa    #DPRF_SIZE          bne     10b*20        tsta    anything   in FIFO?          beq     30f        no - exit*25        ldb     #O_WRITE   set Write code          jsr     dpr_msg    signal DPR          cmpb    #E_SYSBSY  if DPR saturated, try again          bne     27f*          jsr     p_dpr_bsy  print message          bra     25b*27        jsr     DPRF_unlock release interlock          bra     00b        continue*30        jsr     DPRF_unlock release FIFO          bra     90f        exit*80        lda     #EIO       some sort of I/O error          sta     uerror*90        puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** dpr_read - Read data from a channel at the DPR*dpr_read  pshs    d,x,y,u          lbsr    dpr_fdv    get DPR params          lbcs    99f        exit if error*          pshs    d,y,u      save DPR params*00        ldd     uicnt      how many more characters needed          beq     90f        exit if none*          ldb     #O_RQRD    inform DPR we need data          jsr     dpr_msg*          jsr     get_F_S    allocate FIFO          ldd     uicnt      how much data to read?          cmpd    #DPRF_SIZE can move no more than FIFO          blo     05f*          ldd     #DPRF_SIZE*05        tfr     b,a        set request max size          ldb     #O_SEND    tell DPR to send data          pshs    a          save size of request          jsr     dpr_msg          cmpa    #0         EOF?          beq     20f        yes - go process it*          pshs    a,b        save input count, response type*10        pshs    a,x,y,u    save registers          jsr     DPRF_get   get character          lbsr    passc send to user          puls    a,x,y,u    restore registers          deca               any        more this load?          bne     10b        yes - go get 'em*          jsr     DPRF_unlock & release it to world          puls    a,b        a=size returned, b=response code          cmpa    ,s+        less than requested amount          bne     90f        exit if not the same (must be less)*          cmpb    #R_SNDMC   Make sure there are more chars available          beq     00b*          bra     90f        exit* -- DPR returned EOF20        jsr     DPRF_unlock          puls    a          clean up stack          bra     90f        exit* -- Try to even loading          ldy     utask          clr     tsact,y* --99        puls    d,x,y,u,pc** dpr_spcl - Perform TTYSET/TTYGET for an DPR channel*  X - =0 if doing ttyset*     <>0 if ttyget*dpr_spcl  pshs    d,x,y,u          lbsr    dpr_fdv    compute device #          bcs     99f        jump if error*00        pshs    d,y,u      save registers          jsr     get_F_S    allocate FIFO and a transaction slot          ldx     6+2,s      get ttyset/get parameter          cmpx    #0         ttyset?          bne     50f        no - do ttyget*          lda     #6         move ttyset data into FIFO          ldx     #usarg0*10        ldb     ,x+        move data          jsr     DPRF_put   into FIFO          deca          bne     10b*          ldb     #O_TTYS    send "ttyset" request          jsr     dpr_msg          bra     90f        exit*50        ldb     #O_TTYG    send "ttyget" request          jsr     dpr_msg          lda     #6         move data from FIFO into buffer*60        jsr     DPRF_get   get data from FIFO          stb     ,x+          deca          bne     60b*90        jsr     DPRF_unlock release FIFO buffer          puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** MBX_lock - Lock the DPR interface*    Y - IOP Control address*MBX_lock  pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     dpr_mbx,y  mailbox already locked?          beq     10f        no - go check FIFO*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     dpr_fifo,y FIFO locked?          beq     50f        no - go lock mailbox*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        inc     dpr_wait          ldb     #IOPPRI          pshs    y          preserve register          jsr     Q_sleep    yes - sleep until available          puls    y          restore register          dec     dpr_wait          puls    cc,d,x,y,u restore environ          bra     MBX_lock   try again*50        ldd     tstid,x    lock mailbox          std     dpr_mbx,y          clr     dpr_int,y  no missed interrupts*99        puls    cc,d,x,y,u,pc return** MBX_unlock - unlock the DPR interface**    Y - IOP Control address*MBX_unlock pshs    cc,d,x,y,u          seti    turn       off interrupts          lda     dpr_int,y  did we miss an interrupt?          beq     05f        no - continue*          jsr     dpr_int    yes - pretend we're seeing it now!*05        clr     dpr_int,y  reset flag          ldd     #0          std     dpr_mbx,y  reset lock          jsr     wakeup     wake up anybody waiting on this IOP          ldy     5,s        restore pointer          lda     dpr_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return** DPRF_lock - Lock the DPR FIFO buffer*    Y - DPR Control address*DPRF_lock pshs    cc,d,x,y,u save registers          seti               mask       interrupts          ldx     utask      get task pointer          ldd     dpr_fifo,y FIFO locked?          beq     10f        no - go check mailbox*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     dpr_mbx,y  mailbox already locked?          beq     50f        no - go lock FIFO*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        ldb     #IOPPRI          inc     dpr_wait   mark somebody waiting          pshs    y          save pointer          jsr     Q_sleep    yes - sleep until available          puls    y          restore pointer          dec     dpr_wait          puls    cc,d,x,y,u restore environ          bra     FIFO_lock  try again*50        ldd     tstid,x    lock FIFO          std     dpr_fifo,y*99        puls    cc,d,x,y,u,pc return** DPRF_unlock - unlock the DPR FIFO buffer**    Y - IOP Control address*DPRF_unlock pshs    cc,d,x,y,u          seti                 turn       off interrupts          ldd     #0          std     dpr_fifo,y reset lock          jsr     wakeup     wake up anybody waiting on this FIFO          ldy     5,s        restore pointer          lda     dpr_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return** Q_sleep - Sleep until event with decreased activity*Q_sleep   jmp     sleep** A_sleep - Sleep until event with no decrease in activity*A_sleep   jsr     sleep      wait for event          pshs    a,x        upgrade activity          ldx     utask          lda     tsact,x          adda    #DPR_COST          bcc     00f*          lda     #$FF*00        sta     tsact,x          puls    a,x,pc** dpr_fdv - Find device info for DPR channel*    D - device #*    jsr dpr_fdv*    B - device # (0..N)*    U - Sequence #/Terminal #*    Y - FIO interlock*    <Carry> if illegal device #*dpr_fdv   pshs    d          save device #          ldu     0,s        get device code          ldy     #DPR0          clc     no         error99        puls    d,pc       return** find_dn - compute device # for a channel on an DPR*   B - relative device #*   Y - IOP control address*   jsr find_dn*   D - absolute device #*find_dn   pshs    d,x,y,u    save registers          clra          std     0,s        set return value          puls    d,x,y,u,pc return*p_dpr_bsy pshs    d,x,y,u          ldx     #00f          jsr     Pdata          ldx     #$FFFF10        leax    -1,x          bne     10b*99        puls    d,x,y,u,pc*00        fcc     $d,'DPR Saturated!',0        defineDPR0    rzb     DPR_SIZENUM_TRAN fcb    0 #transactions allowed        enddef        enddef          end