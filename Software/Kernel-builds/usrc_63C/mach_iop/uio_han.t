          lib     ./environment.h          if      (UIO=1)          opt     nol          lib     ../include/macdefs.h          lib     ../include/task.h          lib     ../include/tty.h          lib     ../include/sysdefs.h          lib     ../include/ust.h          lib     ../include/fio.h          lib     ../include/fio_codes.h          lib     ./uio_han.h        data          opt     lis          sttl    UIO        Interface          paguio_wait  fcb     0          count waitersuio_opct  fcb   0            open flag** UIO, user IO. concept that provides access from a process* to an IO location. These IO locations are in boards* that sit in an external back-plane and are controlled* by a second CPU. This way one can add/remove IO board* in quasi hotplug context. No Interrupts are supported* on the IO bus. The IO map expands from $00  to $FF* access control is done by tables maintained by the IO processor* and these tables can give exclusieve access to locations* based on table and UID. These tables are updated with* ttyget/ttyset calls*          data          global  uio_open,uio_close,uio_write,uio_read,uio_spcl          global  uio_irq*** uio_open - Open a terminal on the UIO*   D = Device #*uio_open  pshs    d,x,y,u          lbsr    uio_fdv    compute device #*99        puls    d,x,y,u,pc** uio_close - Close a terminal at the UIO*uio_close pshs    d,x,y,u          lbsr    uio_fdv    compute device #          inc     uio_opct          dec     uio_opct*99        puls    d,x,y,u,pc** uio_write - Write data to a terminal on the UIO* Y = fdn, D=dev maj/min, X = chrdevtab entry*uio_write pshs    d,x,y,u          lbsr    uio_fdv    compute device #*          bsr     chklim          bne     82f*          jsr     UIO_lock*          std     cpu_fio4,u    offset,cnt          lda     #UIOWR          sta     cpu_fio,u          clr     cpu_fio1,u    status          pshs    b            holds count          leax    fifo,u20        pshs    b,x,y,u          jsr     cpass         get byte          puls    b,x,y,u          sta     0,x+          dec     0,s          bne     20b          puls    a*          jsr     flgslp       sleep and Unlock B holds non-zero*          lda     fio_cpu5,u          sta     uicnt+1      returned count          lda     fio_cpu1,u   error status          bne     81f          bra     99f*82        lda     #EBARG81        sta     uerror*99        puls    d,x,y,u,pc** uio_read - Read data from a terminal at the UIO* Y = fdn, D=dev maj/min, X = chrdevtab entry*uio_read  pshs    d,x,y,u          lbsr    uio_fdv    get UIO params  Y=UIO0, U=devad          lbcs    99f        exit if error*          bsr     chklim          bne     82f*          jsr     UIO_lock*          std     cpu_fio4,u    offset,cnt          lda     #UIORD          sta     cpu_fio,u          clrb          stb     cpu_fio1,u    status*          jsr     flgslp        B = zero*          lda     fio_cpu5,u    returned count          beq     15f          sta     uicnt+1*          leax    fifo,u10        ldb     0,x+          pshs    a,x,y,u          jsr     passc         put character          puls    a,x,y,u          deca                  any more?          bne     10b*15        jsr     UIO_unlock          lda     fio_cpu1,u    status          bne     81f          bra     90f*82        lda     #EBARG81        sta     uerror** -- Try to even loading90        ldy     utask          clr     tsact,y* --99        puls    d,x,y,u,pc** chklim, check address boundaries*chklim  equ     *          ldd     uipos          bne     01f         bad argument          ldd     uicnt          beq     01f         zero data          cmpb    #256-32-16  TODO!          bhs     01f          addb    uipos2+1          bcs     01f          cmpd    #UIMXAD     check max          bhi     01f          lda     uipos2+1    lowest address byte          ldb     uicnt+1     lobyte count          sez          rts                 A = position, B = count01        clz          rts** the transfer 6 bytes are used for ttyset/ttyget* X - =0 if doing ttyset*    <>0 if ttyget*uio_spcl  pshs    d,x,y,u          lbsr    uio_fdv    # on return Y=UIO0, U=devad          bcs     99f        jump if error*          jsr     UIO_lock   allocate FIFO*          ldx     2,s      get ttyset/get parameter          cmpx    #0         ttyset?          bne     50f        no - do ttyget* SET          lda     #UIOTS          sta     cpu_fio,u          clr     cpu_fio1,u*          lda     #6         move ttyset data into FIFO          pshs    a,y          leax    fifo,u          ldy     #usarg0*10        ldb     0,y+        move data          stb     0,x+          deca          bne     10b          puls    b,y*          bsr     flgslp     B = non-zero          bra     99f        exit* GET50        lda     #UIOTG     send "ttyget" request          sta     cpu_fio,u          clrb          stb     cpu_fio1,u          bsr     flgslp     B = zero*          pshs    y          leay    fifo,y          lda     #6         move data from FIFO into buffer60        ldb     0,y+       FIFO_get   get data from FIFO          stb     ,x+          deca          bne     60b          puls    y*          bsr     UIO_unlock release FIFO buffer*99        puls    d,x,y,u,pc** uio_fdv - Find device info for UIO terminal*    D - device #*    jsr uio_fdv*    B - device # (0..N)*    U - Sequence #/Terminal #*    Y - FIO interlock*    <Carry> if illegal device #*uio_fdv   pshs    d          save device #          ldy     #UIO0          ldu     fio_dba,y  hardware address          clc     no         error99        puls    d,pc       return*98        sec                error          puls    d,pc*p_uiobsy pshs    d,x,y,u          ldx     #00f***!!     jsr     Pdata          ldx     #$FFFF10        leax    -1,x          bne     10b99        puls    d,x,y,u,pc*00        fcc     $d,'UIO Saturated!',0** flgslp, B = UNlock flag*flgslp  equ     *          pshs    cc,d,x,y,u          seti                  mask ints          lda     #$ff          sta     cpu_fioF,u*          ldb     #UIOPRI          jsr     sleep         continue when done*          puls    cc,d,x,y,u          tstb          beq     01f          bra     UIO_unlock*01        rts*UIO_lock        equ     *         pshs   cc,d,x,y,u      save regs        seti                    mask        ldx     utask        ldd     fio_mbx,y       mailbox already taken        beq     50f             no,*        cmpd    tstid,x         by me?        beq     50f             no, must wait*10      inc     uio_wait        ldb     #UIOPRI        jsr     sleep        dec     uio_wait        puls    cc,d,x,y,u        bra     UIO_lock*50      ldd     tstid,x        std     fio_mbx,y       set taken        clr     fio_ict,y       no missed ints*99      puls    cc,d,x,y,u,pc   returnUIO_unlock equ     *        pshs    cc,d,x,y,u      save regs        seti                    mask ints        lda     fio_ict,y       did me miss a INT?        beq     05f             no*        ldu     fio_dba,y       restore info        jsr     fio_irq*05      ldy     5,s             restore Y        clr     fio_ict,y       reset flag        clrd        std     fio_mbx,y       release        jsr     wakeup          wake sleepers        ldy     5,s             refresh ptr        lda     uio_wait        was anybody waiting?        beq     10f*        ldx     utask           reset priority        jsr     fixpri        jsr     change          someone else should run*10      puls    cc,d,x,y,u,pc** uio_irq, essentially wakeup those waiting here* Y = UIO0, U= devad*uio_irq equ     *        clr     fio_cpuF,u      reset interrupt        jsr     wakeup        rts        else        data        nop        endif        end