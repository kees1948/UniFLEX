 sttl FIO Simulation Routines pag***+++ if  (IOP=1) define*** TEMPMAP_state equ $F2d0MSG_out   equ $F2e0MSG_in    equ $F2f0 enddef endif***---***+++ ifc &a,'IOPCPU'     - ROM special code --** Wait for IOP to reset interface*fio_reset00      lda     iop_cpuF   irq_gen         wait until magic value appears        cmpa    #$99        bne     00b10      lda     iop_cpuF        wait for Version response and clear INT        beq     10b        lda     iop_cpu1        -- Version #        sta     rom_version        clr     iop_cpuF        let IOP know I'm ready        rts** fio_msg - Send a message via the FIO Mailbox*   B - Message code to send (one byte)*   A - Message specific data*   bsr fio_msg*   B - Error code response*   A - Message specific data*fio_msg pshs    x               save register        stb     cpu_iop         set up mailbox value        sta     cpu_iop2        message specific data        lda     #$FF            sequence #        sta     cpu_iop1        clr     cpu_iop3        terminal 00        lda     #$FF            tell IOP mailbox full        sta     cpu_iopF05      ldx     #$FFFF          time-out counter10      lda     cpu_iopF        wait till value consumed        beq     20f             jump if consumed        leax    -1,x            time-out yet?        bne     10b        bra     05b             try again*-- Wait for response20      ldb     iop_cpuF        wait for data available        beq     20b        lda     iop_cpu2        get message data        ldb     iop_cpu         get primary message response        clr     iop_cpuF        tell IOP we've got it all        puls    x,pc else ***=== KERNEL** fio_send - Send a message via the FIO Mailbox*   Y - IOP control block*   B - Message code to send (one byte)*   A - Message specific data*   U - Sequence #/Terminal #*   bsr fio_send* global fio_sendfio_send pshs   cc,d,x,u        save register        ldu     iop_dba,y        seti                    mask interrupts!        LEDON   LB_FIO0        stb     cpu_iop,u         set up mailbox value        sta     cpu_iop2,u        message specific data        ldd     5,s              (old U) sequence #/terminal #        sta     cpu_iop1,u        stb     cpu_iop3,u*-- TEMP        lda     cpu_iop,u        sta     MSG_out        lda     cpu_iop1,u        sta     MSG_out+1        lda     cpu_iop2,u        sta     MSG_out+2        lda     cpu_iop3,u        sta     MSG_out+3*-- TEMP        lda     #$FF            tell IOP mailbox full*-- TEMP        sta     MSG_out+4*-- TEMP        sta     cpu_iopF,u         let the IOP know it's there* LOOP until IOP consumes malibox05      ldx     #$FFFF          time-out counter10      lda     cpu_iopF,u      wait till value consumed        beq     20f             jump if consumed        leax    -1,x            time-out yet?        bne     10b        bra     05b             try again20        LEDOFF  LB_FIO0*-- TEMP        clr     MSG_out+4*-- TEMP        puls    cc,d,x,u,pc endif  * end of ROM code***---** FIFO_get - Fetch character from FIFO*   Y - IOP control block*   B - Character fetched*FIFOgeta pshs   b        bsr     FIFO_get        puls    a        exg     a,b        rts**   Y - fifo base address*-- Pointers in FIFO are relative to 0*FIFO_get pshs cc,x,y        seti                    -- interrupts must be masked        ldy     iop_dba,y       point to hardware        ldb     fifo_cnt,y      any data?        beq     99f             no - exit*        decb                    yes - adjust count        stb     fifo_cnt,y        ldx     fifo_get,y      get consumer pointer        pshs    x        addr    Y,X             X+Y => X        ldb     fifo,x          fetch byte        puls    x        leax    1,x             bump pointer        cmpx    #FIFO_SIZE      end of fifo?        bne     10f*        ldx     #0              reset pointer*10      stx     fifo_get,y*99      puls    cc,x,y,pc** FIFO_put - Place character into FIFO*   Y - IOP control block*   B - Character fetched*FIFOputa pshs   b        tfr     a,b        bsr     FIFO_put        puls    b,pc**   Y - IOP control block*FIFO_put pshs   cc,x,y        seti                    -- interrups must be masked        ldy     iop_dba,y       point to hardware        ldx     fifo_put,y      get consumer pointer        pshs    x        addr    Y,X             X + Y => X        stb     fifo,x          store byte        puls    x        leax    1,x             bump pointer        cmpx    #FIFO_SIZE      end of fifo?        bne     10f        ldx     #0              reset pointer*10      stx     fifo_put,y        inc     fifo_cnt,y      update count*99      puls    cc,x,y,pc