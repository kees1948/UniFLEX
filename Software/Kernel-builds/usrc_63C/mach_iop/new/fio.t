        if      (FIO=1)        sttl    FIO Routines        global  fio_int,fio_msg** fio_send - Send a message via the FIO Mailbox*   Y - IOP control block*   B - Message code to send (one byte)*   A - Message specific data*   U - Sequence #/Terminal #*   bsr fio_send* global fio_sendfio_send pshs   cc,d,x,u        save register        ldu     iop_dba,y        seti                    mask interrupts!        LEDON   LB_FIO0        stb     cpu_iop,u         set up mailbox value        sta     cpu_iop2,u        message specific data        ldd     5,s              (old U) sequence #/terminal #        sta     cpu_iop1,u        stb     cpu_iop3,u        lda     #$FF            tell IOP mailbox full        sta     cpu_iopF,u         let the IOP know it's there* LOOP until IOP consumes malibox05      ldx     #$FFFF          time-out counter10      lda     cpu_iopF,u      wait till value consumed        beq     20f             jump if consumed        leax    -1,x            time-out yet?        bne     10b        bra     05b             try again20        LEDOFF  LB_FIO0        puls    cc,d,x,u,pc** FIFO_get - Fetch character from FIFO*   Y - IOP control block*   B - Character fetched*FIFOgeta pshs   b        bsr     FIFO_get        puls    a        exg     a,b        rts**   Y - fifo base address*-- Pointers in FIFO are relative to 0*FIFO_get pshs cc,x,y        seti                    -- interrupts must be masked        ldy     iop_dba,y       point to hardware        ldb     fifo_cnt,y      any data?        beq     99f             no - exit*        decb                    yes - adjust count        stb     fifo_cnt,y        ldx     fifo_get,y      get consumer pointer        pshs    x        addr    Y,X             X+Y => X        ldb     fifo,x          fetch byte        puls    x        leax    1,x             bump pointer        cmpx    #FIFO_SIZE      end of fifo?        bne     10f*        ldx     #0              reset pointer*10      stx     fifo_get,y*99      puls    cc,x,y,pc** FIFO_put - Place character into FIFO*   Y - IOP control block*   B - Character fetched*FIFOputa pshs   b        tfr     a,b        bsr     FIFO_put        puls    b,pc**   Y - IOP control block*FIFO_put pshs   cc,x,y        seti                    -- interrups must be masked        ldy     iop_dba,y       point to hardware        ldx     fifo_put,y      get consumer pointer        pshs    x        addr    Y,X             X + Y => X        stb     fifo,x          store byte        puls    x        leax    1,x             bump pointer        cmpx    #FIFO_SIZE      end of fifo?        bne     10f        ldx     #0              reset pointer*10      stx     fifo_put,y        inc     fifo_cnt,y      update count*99      puls    cc,x,y,pc** fio_int - Process IOP interrupt, testing for INT already reset the IRQ*   U - FIO address*   Y - IOP Control structure*fio_int   pshs    x,y          ldx     iop_dba,y  X - dual port RAM address          lda     iop_cpu2,x move transaction data (interrupt#)          pshs    a          -- Transaction specific value          clr     ,-s        ** Filler **          lda     iop_cpu1,x                       (terminal#)          pshs    a          -- Sequence #          lda     iop_cpu,x                        (response)          pshs    a          -- Response code          clr     iop_cpuF,x indicate message received** stack contains resp code, seq#, fil, data, x ,y*          lda     0,s        get response code          cmpa    #R_INTRPT          bne     10f** handle INTERRUPT form tty*05        ldb     1,s        relative terminal #          jsr     find_dn    compute absolute terminal #          ldx     ttytab     compute TTY table address          lda     #TTYSIZ          mul          leax    d,x          clra          ldb     3,s        get interrupt code          jsr     intrpt send interrupt to this terminal          leas    4,s        clean up stack          bra     99f        exit** 0,s - response code* 1,s - sequence #* 3,s - transaction specific returned value*10        leay    iop_tran,y point to transaction list          ldb     #MAX_TRAN   # transactions          pshs    b15        lda     2,s        check transaction #          beq     16f        empty?          cmpa    tran_seq,y match?          beq     20f        yes - go*16        leay    TRAN_SIZ,y next transaction          dec     0,s        any more?          bne     15b* -- Unsolicited response!          leas    5,s        clean up stack          bra     99f        exit*20        puls    b          clean up stack          lda     0,s        get response code          sta     tran_resp,y save response code          lda     3,s        get response value          sta     tran_val,y          leas    4,s        clean up stack          jsr     wakeup     wake up sender99        puls    x,y,pc     return** fio_msg - Send a value via the FIO Mailbox & wait for response*   U - maj/min*   D - Value to send (B = Command, A = Specific data)*   Y - IOP control block*   jsr fio_msg*   D - Value returned (B = Error response, A = Specific data)*fio_msg   pshs    cc,d,x,y,u save registers* -- Find an empty transaction box10        seti               turn off interrupts          ldy     5,s        get IOP control address          jsr     MBX_lock   get access to IOP          lbsr    find_slot  go find a slot          beq     15f        jump if one found*          ldy     5,s        restore IOP structure pointer          jsr     MBX_unlock give up IOP until slot available          lbsr    find_slot  make sure no slots available          beq     10b        jump if there is one*          ldy     5,s        get IOP pointer          leay    iop_tflg,y sleep on transaction slots          ldb     #IOPPRI          jsr     Q_sleep    wait for available message slot          bra     10b        try for a transaction slot*15        ldb     utask+1    set sequence # in slot ???          orb     #1          stb     tran_seq,y          ldb     0,s        enable (old) interrupts          tfr     b,cc          pshs    y          save transaction slot pointer          ldb     4,s        restore message code (B)          lda     3,s        restore specific data (A)          exg     d,u          lda     utask+1          ora     #1         set sequence #          stb     tran_dev,y   minor device          exg     d,u          sta     tran_oval,y                         (A)          stb     tran_msg,y                          (B)          ldy     7,s        restore IOP structure pointer          lbsr    fio_send          jsr     MBX_unlock release mailbox*20        puls    y          get transaction slot address          seti               mask interrupts          tst     tran_resp,y any response yet?          bne     30f        yes - go process*          ldx     5,s        get IOP control address          ldd     iop_fifo,x does this task own the FIFO?          bne     25f        yes - don't allow interrupts!*          pshs    y,u        save registers          ldd     umark1     set up to allow interruptable sleep          pshs    d          ldx     #27f       interrupt handling label          pshs    x          sts     umark1          ldb     #TTYIPR    set interruptable priority          jsr     A_sleep    wait for IOP response          puls    d,x,y,u    restore registers          stx     umark1     restore interrupt point          bra     30f        continue*27        puls    x,y,u      Interrupt happened! - (D) already popped          stx     umark1     restore stack mark          lda     #E_ABORT   aborted transaction!          sta     tran_resp,y          ldb     #O_INTRPT          pshs    y          save transaction slot pointer          ldy     7,s        restore IOP control pointer          jsr     MBX_lock   get access to mailbox          jsr     fio_send          jsr     MBX_unlock release mailbox          puls    y          restore transaction slot pointer          bra     30f*25        ldb     #IOPPRI          pshs    x,y,u      save registers          jsr     A_sleep          puls    x,y,u      restore registers*30        ldx     utask          seti               turn off interrupts while fiddling with transaction slots* -- See if there is a response.  It is possible to* -- get here without one if an interrupt happened which* -- was being ignored.  In this case, the IOP doesn't* -- need to be notified of any interrupt, but we must* -- wait for the IOP response to actually arrive.          ldb     tran_resp,y get response code          bne     35f        jump if response present*          pshs    y          reset stack          bra     20b        wait for response*35        clra               release transaction slot          sta     tran_seq,y          clr     tran_resp,y          lda     tran_val,y get response value          std     1,s        set return value (resp val,resp. code)          ldy     5,s        wake anybody waiting for this slot          leay    iop_tflg,y          jsr     wakeup          lda     2,s        interrupted transaction?          cmpa    #E_ABORT          bne     50f        no - continue*          lds     umark1     yes - get out          rts*50        puls    cc,d,x,y,u,pc return** generic FIO routines*** find_slot - find a transaction slot*   Y - IOP control address*   jsr find_slot*   Y - Transaction slot*   <NE> if none available*find_slot pshs    d,y      save register          leay    iop_tran,y point to transactions          ldb     #MAX_TRAN          pshs    b          beq     40f* look for OUR slot first10        lda     utask+1    check for busy entries          ora     #1          cmpa    tran_seq,y          beq     30f        yes - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     10b*          ldy     3,s        restore IOP pointer          leay    iop_tran,y point to transactions          ldb     #MAX_TRAN          stb     0,s          beq     40f* next search free slot20        lda     tran_seq,y entry busy?          beq     30f        no - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     20b*40        lda     #1         return NE - no slot          bra     99f*30        sty     3,s        return slot          clra               return EQ - slot found*99        leas    1,s        remove counter          puls    d,y,pc     clean stack & return**  get_F_S - Allocate a transaction slot and the FIFO*    Y - IOP control*get_F_S   pshs    cc,d,x,y,u save registers          seti    mask       interrupts          jsr     find_slot  allocate transaction slot          beq     10f        jump if one found*          ldy     5,s        wait for slot          leay    iop_tflg,y          ldb     #IOPPRI          jsr     Q_sleep          puls    cc,d,x,y,u restore registers          bra     get_F_S    try again*10        ldb     utask+1    "allocate" slot          orb     #1          stb     tran_seq,y          puls    cc,d,x,y,u restore interrupts/registers          jmp     FIFO_lock  lock FIO access** MBX_lock - Lock the IOP interface*    Y - IOP Control address*MBX_lock  pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     iop_mbx,y  mailbox already locked?          beq     10f        no - go check FIFO*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     iop_fifo,y FIFO locked?          beq     50f        no - go lock mailbox*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        inc     iop_wait          ldb     #IOPPRI          pshs    y          preserve register          jsr     Q_sleep    yes - sleep until available          puls    y          restore register          dec     iop_wait          puls    cc,d,x,y,u restore environ          bra     MBX_lock   try again*50        ldd     tstid,x    lock mailbox          std     iop_mbx,y          clr     iop_int,y  no missed interrupts*99        puls    cc,d,x,y,u,pc return** MBX_unlock - unlock the IOP interface**    Y - IOP Control address*MBX_unlock pshs    cc,d,x,y,u          seti    turn       off interrupts          lda     iop_int,y  did we miss an interrupt?          beq     05f        no - continue*          jsr     fio_int    yes - pretend we're seeing it now!*05        clr     iop_int,y  reset flag          ldd     #0          std     iop_mbx,y  reset lock          jsr     wakeup     wake up anybody waiting on this IOP          ldy     5,s        restore pointer          lda     iop_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return** FIFO_lock - Lock the IOP FIFO buffer*    Y - IOP Control address*FIFO_lock pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     iop_fifo,y FIFO locked?          beq     10f        no - go check mailbox*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     iop_mbx,y  mailbox already locked?          beq     50f        no - go lock FIFO*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        ldb     #IOPPRI          inc     iop_wait   mark somebody waiting          pshs    y          save pointer          jsr     Q_sleep    yes - sleep until available          puls    y          restore pointer          dec     iop_wait          puls    cc,d,x,y,u restore environ          bra     FIFO_lock  try again*50        ldd     tstid,x    lock FIFO          std     iop_fifo,y*99        puls    cc,d,x,y,u,pc return** FIFO_unlock - unlock the IOP FIFO buffer**    Y - IOP Control address*FIFO_unlock pshs    cc,d,x,y,u          seti    turn       off interrupts          ldd     #0          std     iop_fifo,y reset lock          jsr     wakeup     wake up anybody waiting on this FIFO          ldy     5,s        restore pointer          lda     iop_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return** Q_sleep - Sleep until event with decreased activity*Q_sleep   jmp     sleep** A_sleep - Sleep until event with no decrease in activity*A_sleep   jsr     sleep      wait for event          pshs    a,x        upgrade activity          ldx     utask          lda     tsact,x          adda    #ACT_COST          bcc     00f*          lda     #$FF*00        sta     tsact,x          puls    a,x,pc          endif          end