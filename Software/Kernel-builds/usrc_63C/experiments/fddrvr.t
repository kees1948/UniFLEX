        lib     gendrvr.h        lib     fddrvr.h        sttl     FLOPPY Driver        pag        name    fddrvr        global  flpopen,flpclose,flpio,flpint        global  fplop,flpcl,flpsp,flpcio,flprd,flpwr        global  flpdt,flpchb** Driver local data** Device Tables** dtdfl rmb     2       device buffer fwd link* dtdbl rmb     2       device buffer bwd link* dtqfl rmb     2       device io queue fwd link* dtqbl rmb     2       device io queue bwd link* dtbusy        rmb     1       device busy flag* dtrtry        rmb     1       device error retry count* dtspr rmb     2       device spare byteflpdt   rzb     DVTSIZ          device table* buffer header for character deviceflpchb  rzb     HDRSIZ          buffer header*flpopt  fcb     0,0,0,0         flp open tableBDtable fdb     0               Block Device Table addressFLPDPR  equ     *        rzb     2               dpr_mbx  mailbox lock        rzb     2               dpr_fifo fifo lock        rzb     1               dpr_intc        rzb     1               dpr_tflg semaphore        fdb     FLPDRP          IO address        fdb     FLPDRP+IRQ2DEV  Interrupt in location        rzb     FLP_MXTR*TRAN_SIZE transaction slots** open the flp disk drive - insure the device is online, etc.* D contains device major/minor*flpopflpopen pshs    d,y,u        bsr     flp_dn          set up        sty     2,s             save DPR control address        tst     flpopt,x        already open?        beq     01f        inc     flpopt,x        bra     30f*01      inc     flpopt,x        set open status        jsr     gettslot        pshs    y               transaction slot*05      ldb     #O_OPEN        jsr     dpr_msg        cmpb    #E_SYSBSY       DPR busy?        bne     10f*        jsr     p_dpr_bsy        bra     05b*10      cmpb    #E_BADDEV        bne     15f        ldb     #EBDEV        stb     uerror*15      puls    y               transaction slot        jsr     puttslot*30      puls    d,y,u,pc        clean stackflpspflprts  rts* flp close* D holds device maj/minflpclflpclose  pshs  d,y,u        bsr     flp_dn          set up        sty     2,s             DPR control block        dec     flpopt,x        dec open counter        bpl     20f        clr     flpopt,x        clear open status        jsr     gettslot        pshs    y               transaction slot00      ldb     #O_CLOSE        jsr     dpr_msg        cmpb    #E_SYSBSY        bne     10f        jsr     p_dpr_bsy        bra     00b*10      puls    y        jsr     puttslot20      puls    d,y,u,pc** preset important variables*flp_dn  andb    #%00000011      drive 0...3        stb     flpcur          save select        tfr     d,x        ldy     #FLPDPR        rts** fire up IDE operation to initiate transfer* Y holds buffer header*flpio   stx     BDtable         save Block Device Table address        pshs    y,u        inc     flpdt+dtbusy    mark busy        ldb     bfdvn+1,y       get device #        bsr     flp_dn          set up for drive        tfr     y,u             U=DPR control block*        jsr     gettslot        get slot        tfr     y,x             X=transaction slot        ldy     0,s        ldd     bfxfc,y         get transfer count        cmpd    #512            is it regular block transfer?        bne     20f*        ldb     flpcur        stb     tran_val0,x*        ldb     bfflag,y get buffer flags        bitb    #BFRWF          (read=1)        bne     l003        ldb     #O_RQWR        bra     l004l003        ldb     #O_RQRDl004* disk block #        ldd     bfblck,y        block address 15..0        std     tran_val1,x        exg     y,u        jsr     dpr_msg         send request        cmpb    #E_IOERR        bne     10f*        lda     #EIO        sta     uerror20      lda     #EINV        sta     uerror*        ldab    flpcmdl001    std     flpcmst,u        rts** interrupt process*flpint        ldy     #FLPDPR        jsr     mbx_getflpi01  ldy     flpdt+dtqfl     get last transacion        beq     flpfin        bitb    #IDEERR         error bit?        bne     flprr1        ldd     bfxfc,y         are we swapping        cmpd    #512        bne     nxtswp        bra     flpdonflprr1  lda     bfflag,y        ora     #BFERR        sta     bfflag,y*flpdon  clr     flpdt+dtbusy    set unbusy        ldx     BDtable        jmp     BDioendnxtswp  ldd     bfblck,y        update block address        addd    #8              4K        std     bfblck,y        lda     bfblch,y        adca    #0        sta     bfblch,y        ldd     bfxfc,y         get transfer count        bra     flpswap sttl IDE Winchester Character Drivers pag** open - close - and special**flpop   jmp     flpopen         same as block device*flpcl   jmp     flpclose        same as block*flpsp   rts                     nops here** read*flprd   pshs    d               save device number        jsr     flpgb           get buffer header        puls    d               reset dev number        bsr     flpnf           go configure header        tst     uerror          any errors?        beq     flprd4        jsr     frechbf         release buffer        rts                     error returnflprd4  pshs    a               save task info        orb     #BFRWF          set read mode        andb    #!BFSPC&$ff     clear special mode        stb     bfflag,y        save in buffer        lbra     flpcio           go do it** write*flpwr   pshs    d               save device number        jsr     flpgb           get buffer header        puls    d        bsr     flpnf           configure buffer        tst     uerror          any errors?        beq     flpwr4        jsr     frechbf         release buffer        rts                     error returnflpwr4  pshs    a               save task statusflpcio jmp fchio same as floppies** fchio** Perform the io specified by the buffer header* pointed at by Y.  ** This routine assumes the* floppy disks are major device 0 for the block* type drivers ***fchio   pshs    y               save buffer        ldx     #blktab        jsr     [blkio,x]       call block io routine        ldy     0,s             reset buffer        jsr     fnshio          finish io        jsr     wakbuf          awakeb buffer sleepers        puls    y               reset ptr        lda     bfflag,y        get flags        anda    #!(BFALOC|BFREQ|BFSPC)&$ff clear out busy bits        sta     bfflag,y        save new flags        puls    a               get task modes        ldx     utask           get task entry location        sta     tsmode,x        save task modes        ldd     #0              reset data count to 0        std     uicntfchio6  rts                     return** configure flp character header*flpnf   std     bfdvn,y         set up device number        ldd     uicnt           get transfer count        std     bfxfc,y         set in header        cmpd    #512            is it valid?        bne     flperr          error?        jmp     flpcn2          same as floppiesflperr  lda     #EIO            set error        sta     uerror        rts                     return** flpgb** Get the character buffer header.  If it is busy,* sleep on it.*flpgb   ldy     #flpchb         point to header        pshs    cc              save status        seti        lda     bfflag,y        get buffer flags        bita    #BFALOC         is buffer busy?        beq     flpgb2        ora     #BFREQ          set request buffer bit        sta     bfflag,y        puls    cc              reset status        ldb     #BUFPR          set priority        jsr     sleep           go sleep for buffer        bra     flpgb           repeatflpgb2  lda     #BFALOC         set busy status        sta     bfflag,y        puls    cc,pc           return** flpcn** Configure the buffer header pointed at by Y.* This routine sets up the character device info* from the user block and puts it in the buffer* header such that the device drivers can use* the information for the data transfer.*flpcn   std     bfdvn,y         save device number        ldd     uicnt           get xfr count        std     bfxfc,y         save in header*        cmpd    #128            check for valid number*        beq     fchcn4*        cmpd    #256            is it a sector operation?*        beq     fchcn4        cmpd    #512            is it 512 byte op?*        beq     flpcn4*        cmpd    #5100           is it a write track?*        beq     flpcn2*        cmpd    #10200          is it dd write track?        bne     flpcn8          if not - error         bra    flpcn4flpcn2  lda     bfflag,y        get flags        ora     #BFSPC          set special bit for drivers        sta     bfflag,y        save new flagsflpcn4  ldd     uipos2          get file position        std     bfblck,y        save as block number        lda     uipos+1         store upper part        sta     bfblch,y        ldd     uistrt          get start address of xfr        std     bfadr,y         save in header        jsr     mapupg          find user page        std     bfxadr,y        save in header        ldx     utask           point to task entry        lda     tsmode,x        get mode bits        pshs    a               save        ora     #TLOCK          set lock bit (keep in mem)        sta     tsmode,x        save new mode        ldb     bfflag,y        get flags        puls    a,pc            returnflpcn8  lda     #EBARG          set error        sta     uerror        rts                     return** frechbf - free Character buffer*frechbf pshs    d,x,y,u         save registers        ldy     #flpchb         point to header        lda     bfflag,y        get flags        anda    #!(BFALOC|BFREQ|BFSPC)&$ff clear out busy bits        sta     bfflag,y        save new flags        jsr     wakbuf          awake buffer sleepers        puls    d,x,y,u,pc      return