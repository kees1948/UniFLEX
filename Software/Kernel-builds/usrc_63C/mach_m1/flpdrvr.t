        opt     nol        lib     ../include/flpdrvr.h        lib     ../include/blktab.h        lib     ./gendrvr.h        opt     lis,exp        if      (FLP=1)        sttl     Floppy Drivers        pag        name    flpdrvr        global  flpopen,flpclos,flpio,flpirq        global  flopen,flclos,flread,flwrit,flspcl        global  flpdt* Device Tables** dtdfl rmb     2       device buffer fwd link* dtdbl rmb     2       device buffer bwd link* dtqfl rmb     2       device io queue fwd link* dtqbl rmb     2       device io queue bwd link* dtbusy        rmb     1       device busy flag* dtrtry        rmb     1       device error retry count* dtspr rmb     2       device spare byteflpdt   rzb     DVTSIZ          device table*FDtable fdb     0               Block Device Table addressflpwrk  fdb     0,0,0,0,0,0flpcur  fcb     0flpcot  fcb     0,0            flp char open tableflpopt  fcb     0,0            flp block open tableflpsts  fcb     0,0            side flagsflpstd  fcb     0,0            dens flags** open the flp disk drive - insure the device is online, etc.* B contains device minor*flpopen pshs    d        cmpb    #MAXDRV        lbhi    flpaer          invalid drive*        ldx     #flpopt        tst     b,x        beq     flpop2        inc     b,x        bra     flpop3*flpop2  inc     b,x             set open        ldx     #flpsts        abx        clr     0,x             init the parms, side        clr     2,x             dens        lda     #1        sta     flpdpr+flnwop  new open** try to read disk as 8" SD, 8" DD, 5" SD and 5" DD* As we want to read the SIR, which is block 1 there is no* worry about side select. If SIR is read, the real SIDE/SIZE/DENS* info is taken from the SIR*flpop7  ldd     0,s             get device#        bsr     frdsir          read SIR SD/8"        beq     flpop4        clr     uerror        jsr     freebf          free the buffer*        ldx     #flpstd         density info        ldd     0,s             get device#        lda     b,x        eora    #%00000001        sta     b,x             toggle dens*        ldd     0,s             get device# again        bsr     frdsir          read SIR DD/8"        beq     flpop4          no error        clr     uerror        jsr     freebf*        ldx     #flpstd         density info        ldd     0,s             get device#        lda     b,x        eora    #%00000001        sta     b,x             toggle dens*        ldx     #flpsts         5/8" info        ldd     0,s        lda     b,x        eora    #%01000000      5/8" select        sta     b,x        anda    #%01000000      done already        bne     flpop7*        ldd     0,s        bsr     flpclosflpaer  lda     #EIO            set IO error        sta     uerrorflpop3  puls    d,pc            retunr*flpop4  pshs    y               save buffer        ldx     0,s             buf ptr        ldy     #flpwrk         destination data location        ldu     #sdenf          source data, offset in SIR        ldd     #2              2 bytes(ttyget/set)        jsr     cpybts        ldd     2,s             device#        ldx     #flpsts        abx        lda     flpwrk+1        sta     0,x             side info        lda     flpwrk        sta     2,x             dens info        puls    y        jsr     freebf        puls    d,pc* flp closeflpclos        ldx     #flpopt        dec     b,x             dec open counter        bpl     flpcl1        clr     b,x             clear open statusflpcl1  rts                     return** frdsir, read floppy SIR into a buffer* D is device* Y.X is block number*frdsir  ldx     #1        ldy     #0        jsr     rdbuf        lda     bfflag,y        bita    #BFERR        rts** fire up FLP operation to initiate transfer* Y = buf header*flpio   stx     FDtable         save Block Device Table address        inc     flpdt+dtbusy    mark busy        ldb     bfdvn+1,y       get device #        stb     flpdpr+fldriv        ldu     #flpdpr*        lda     #1              set func        sta     flpdt+dtrtry        ldx     #flpsts         side table        abx        lda     0,x        sta     fltsid,u        lda     2,x             get dens flpstd        sta     fltden,u** 'standard' sizes 128/256/512        ldx     #0              init field        stx     fltxfr,u* set action        lda     bfflag,y        R/W        sta     flrflg,u*        ldx     bfxfc,y         get transfer count        stx     fltsiz,u        TOTAL size        cmpx    #16             swap?        lbls    doswap** single block read/write*        bita    #BFRWF        bne     02f             read=1, go wait** write, transfer data to FIFO**        pshs    b,x,u        tfr     y,x             map buffer        jsr     mapbpt          X points now to SBUFFER  @ OFFSET        pshs    d               make space        ldd     bfxfc,y        cmpd    #BUFSIZ         max data xfer in DPR        bls     01f*splb01  ldd     #BUFSIZ01      std     0,s        trfr    D,W*        lda     bfflag,y        bita    #BFSPC          special function        beq     11f*        ldd     bfxfc,y        subd    0,s             deduct that we do now        std     bfxfc,y        ldd     bfadr,y        addd    0,s             update pointer        std     bfadr,y        bcc     11f        inc     bfxadr,y        hibyte*11      ldd     0,s++        addd    fltxfr,u        actual xfer        std     fltxfr,u        leau    flpfifo,u        tfm1    X,U            transfer data from buffer to system space        puls    b,x,u** read, send command, in interrupt data is there (or not)*02      lda     bfblch,y        BLOCK# H/M/L        sta     flblkh,u        ldd     bfblck,y        std     flblkm,u*        lda     #$ff        sta     flptel,u        rts*01      lda    #EBDEV        sta    uerror        lda    bfflag,y        ora    #BFERR        sta    bfflag,y*flpfin  clr     flpdt+dtrtry    erase function        rtsdoswap  ldx     bfadr,y         get memory page        lda     0,x        cmpa    DSKTRM          end of list        lbeq    flpdon*        ldx     #PAGSIZ         page size        stx     fltsiz,u        TOTAL size        ldb     bfflag,y        read/write?        bitb    #BFRWF        bne     02b* load 1st buffer        jsr     mapsbf          set SBUFFER        ldx     #SBUFFR        pshs    b,x,u        pshs    d               create space        lbra    splb01          write*** IRQ, here something has been done (success or fail)*flpirq  equ     *        ldu     #flpdpr        clr     flpint,u          set we saw it*        ldy     flpdt+dtqfl     get last transaction        beq     flpfin        ldb     flstat,u             result        bne     flprr1*        lda     bfflag,y        bita    #BFSPC          special action        bne     flirrw*        ldx     fltsiz,u        cmpx    #PAGSIZ        lbeq    intswp          do swap** single block transfers, Write= done, Read is get data*        bita    #BFRWF          read=1        beq     03f             for write we're finished** interrupt context, be careful, buffer may be in use*        ldb     DATBOX+SBUF     save DAT setting        pshs    b,x,u        ldd     bfxfc,y        cmpd    #BUFSIZ         max data xfer        bls     10f        ldd     #BUFSIZ10      trfr    D,W        std     fltxfr,u        tfr     y,x             map buffer and        jsr     mapbpt          X points now to SBUFFER @ OFFSET        leau    flpfifo,u        tfm1    U,X            transfer data from system to buffer        puls    b,x,u        stb     DATBOX+SBUF    restore DAT setting** for write, we're done*03      bra     flpdon* handle errorsflprr1  stb     bfstat,y        lda     bfflag,y        ora     #BFERR        sta     bfflag,y        bitb    #%01000000     write protect        beq     01f        lda     #EPRM        bra     02f01      bitb    #%00010000     not found        beq     03f        lda     #EBADF        bra     02f03      lda     #EIO02      sta     uerror*flpdon  clr     flpdt+dtbusy    set unbusy        clr     flpdt+dtrtry    clear funtion        ldx     FDtable        jmp     BDioend** BULK data transfer* for Write, tranfer next data block(s)**flirrw  equ     *        anda    #BFRWF        pshs    a               direction flag        beq     09f* BULK Read        ldd     fltxfr,u        what we got already        cmpd    fltsiz,u        set by read command        bhs     11f* BULK  Read/Write09      ldd     bfxfc,y         any data ?        bne     10f*11      leas    1,s             clean stack        bra     flpdon** common code for Read/Write*10      cmpd    #BUFSIZ        bls     02f        ldd     #BUFSIZ* transfer next block02      trfr    D,W            count        pshs    d              +2*        ldb     DATBOX+SBUF     save old value        pshs    b,x,u          +5        tfr     y,x             map buffer and        jsr     mapbpt          X points now to SBUFFER @ OFFSET*swpinx  leau    flpfifo,u        tst     7,s        beq     14f            read: DPR -> mem        excg    U,X            write: mem -> DPR14      tfm1    X,U            data between buffer and system space        puls    b,x,u          -5, leave old W in stack        stb     DATBOX+SBUF*        lda     bfflag,y        bita    #BFSPC        beq     06f        ldd     bfxfc,y        process data done        subd    0,s            always less then 65K        std     bfxfc,y        ldd     bfadr,y        update buffer pointer        addd    0,s        std     bfadr,y        bcc     06f        inc     bfxadr,y*06      ldd     fltxfr,u        addd    0,s++          -2, correct stack        std     fltxfr,u*        puls    a               cleanup stack        lda     #$ff        sta     flptel,u        rts**  U=fifo address, X=data size, Y=bufhdr*intswp  equ     *               do swap operations        ldx     fltxfr,u        cmpx    fltsiz,u        beq     01f             try next page** swap per block*02      ldd     bfblck,y        select next block        incd        std     bfblck,y        std     flblkm,u        set new block select*        lda     bfflag,y        anda    #BFRWF        pshs    a               +1 build stack        ldd     #BUFSIZ        trfr    D,W        pshs    d               +2*        ldb     DATBOX+SBUF     save old value        pshs    b,x,u           +5        ldx     bfadr,y        lda     0,x             memory page#        jsr     mapsbf        ldx     #SBUFFR         map SBUFFER        ldd     fltxfr,u        offset        leax    d,x        bra     swpinx** one page finished*01      ldx     bfadr,y        now we have completed one page        leax    1,x            check the next        stx     bfadr,y        only now advance        lda     0,x        cmpa    DSKTRM        lbeq    flpdon          all done        ldx     #0              reset transferred        stx     fltxfr,u        bra     02b**  character open*flopen  equ     *        ldx     #flpcot        cmpb    #MAXDRV        bhi     flchop4        tst     b,x        bne     flchop5 don't touch settings        inc     b,x        ldx     #flpopt        tst     b,x     is block driver alrady open?        bne     flchop5 yes, don't do anything        ldx     #flpsts        abx             else        clr     0,x     clear side/size info        clr     2,x     clear dens info        bra     flchop5*flchop4 lda     #EBARG        sta     uerrorflchop5 rts** character close**flclos  jmp     flpclosflclos  ldx     #flpcot don't touch block driver settings        clr     b,x        rts** flchrd*flread  equ     *        pshs    d       save device number        ldy     #fchbuf        jsr     blkgtb  get device buffer        puls    d        jsr     fchcn   configure buffer        tst     uerror  OK?        beq     fchrd4        pshs    y        ldy     #fchbuf        jsr     blkfrb  free the buffer        puls    y,pc    error returnfchrd4  pshs    a       save task mode byte        orb     #BFRWF  set read        stb     bfflag,y save        bra     fchio** flchwr*flwrit  equ     *        pshs    d       save device info        ldy     #fchbuf        jsr     blkgtb  get device buffer        puls    d        jsr     fchcn   configure        tst     uerror  OK        beq     fchwr4        pshs    y        ldy     #fchbuf        jsr     blkfrb  free the buffer        puls    y,pc    error returnfchwr4  pshs    a       save task mode bytefchio   ldb     #FLmajor        jmp     blkcio** fchcn** Configure the buffer header pointed at by Y.* This routine sets up the character device info* from the user block and puts it in the buffer* header such that the device drivers can use* the informationfor the transfer* this routine is specific for the floppy driver*fchcn   std     bfdvn,y save device info        ldd     uicnt   xfr count        std     bfxfc,y        cmpd    #128    check valid numbers        beq     fcnch4        cmpd    #256        beq     fcnch4        cmpd    #512        beq     fcnch4** above are valid sector sizes*        pshs    x        ldx     #tsztabfcnctb  cmpd    0,x++        beq     fcnch2        tst     0,x        bne     fcnctb        puls    x*fcnch8  lda     #EBARG  set error        sta     uerror        rts*fcnch2  puls    x        ldd     uistrt   (big) buffer aligned at 512        bitdi   $01ff    byte boundary?        bne     fcnch8*        lda     bfflag,y        ora     #BFSPC  special bit for drivers        sta     bfflag,y*fcnch4  jmp     blkcnf** valid track sizes* 5" SD, 8" SD, 5" DD, 8" DD, HD, (legay) 5" SD, 8" SD, 5" DD, 8" DD, HD RTRK*tsztab  fdb     3125,5187,6250,10375,12500,3050,5100,6100,10200,12200,12500,0** flspcl*flspcl        tfr     x,y        ldx     #flpsts         side info table        abx                     correct entry        cmpy    #0        bne     01f*        ldd     usarg0        sta     0,x             set side        stb     2,x             set dens        ldd     usarg2          hardware        std     flpdpr+flpstp        rts01      lda     0,x             get side        ldb     2,x             get dens        std     0,y        lda     flpdpr+flstat        sta     2,y        clr     3,y        ldd     flpdpr+flpstp        std     4,y        endif        end