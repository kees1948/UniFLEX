          pag** req_read - CPU has informed us he wants to read* Tell him when some data is available.*req_read  lbsr    ttftab     get TTY table address          lda     [tqproc,x] anything available?          bne     00f        yes - go use it*          lbsr    xtprcq     go process input (wait if none there)*00        lda     [tqproc,x] get input processed count          beq     05f        jump for EOF detected*          cmpa    #1         special case for single character          beq     10f*          ldb     tflags,x   single character & RAW always return 1 char          bitb    #RAW|SCHR          bne     10f*05        ldb     #R_RDOK    inform CPU data now available          rts*10        ldy     tqproc,x   go fetch character          lbsr    getc          lda     #R_RD1C    inform CPU single character returned          exg     a,b          rts** read_data - CPU wants IOP to send data*  Max # chars to move in transaction speicific value*read_data lbsr    ttftab     get TTY table address          ldu     utask      see how many chars to send          ldy     tqproc,x   input queue pointer          clr     ,-s        set FIFO counter10        lda     0,y        any more characters?          beq     20f        no - done*          lbsr    getc       fetch character          lbsr    FIFO_put   put into FIFO          inc     0,s        bump FIFO count          dec     tstval,u   does the guy want more?          bne     10b*20        lda     ,s+        get # chars in FIFO          ldb     #R_SNDNC   data now available in FIFO          tst     0,y        any more data in case guy wants it?          beq     30f*          ldb     #R_SNDMC   yes - special response*30        rts          pag** ttywrt** The main terminal write routine.  Control is passed* to here from the device driver routine which calculates* the ttys structure location and passes it in x.*ttywrt    ldb     fifo_cnt   get FIFO input length          cmpb    #0         anything in FIFO?          beq     90f        no - exit*          pshs    b          save input length*10        lbsr    FIFO_get   fetch character          lbsr    ttyout     output it          dec     0,s        decrement count          bne     10b        repeat*          puls    a          clean up stack*90        pshs    cc         save cc          seti    mask       ints          lbsr    ttyst      give output a kick          puls    cc,pc      return** open_tty - Perform device open*open_tty          jsr     ttopn      perform tty open***+++          if      DBG_IO&DEBUG_CONTROL          jsr     DB_msg          fdb     DBG_IO,10f          lbsr    dmp_TTY          endif***---10        ldb     #R_OPEN          rts** close_tty - Perform device close*close_tty          jsr     ttcls      perform tty close***+++          if      DBG_IO&DEBUG_CONTROL          jsr     DB_msg          fdb     DBG_IO,10f          lbsr    dmp_TTY          endif***---10        ldb     #R_CLOSE          rts** req_write - Request permission to write data*req_write          jsr     ttftab     get TTY table***+++          if      DBG_IO&DEBUG_CONTROL          jsr     DB_msg          fdb     DBG_IO,05f          lbsr    dmp_TTY          endif***---05        pshs    cc         mask interrupts while fiddling*10        seti          ldy     tqout,x    get output queue pointer          ldd     oq_count,y get queue length          addd    tsold,x    include any space already sold          addd    #FIO_FSZ   and assume the CPU will send this many more          cmpd    OQHI       space available?          ble     20f        yes - OK*          lda     tdelay,x   special flush bit?          bita    #$40          beq     15f        no - go to sleep*          jsr     flusho     yes - flush output          bra     10b        try again*15        pshs    d,x,y,u    no - save registers          ldb     #TTYSPR          jsr     sleep          puls    d,x,y,u    restore registers          bra     10b        try again*20        ldd     tsold,x    update amount pre-sold          addd    #FIO_FSZ   -- assume entire FIFO load          std     tsold,x          ldb     #R_REQOK   request granted code          puls    cc,pc      return** write_data - Write data to a terminal*write_data          jsr     ttftab     get tty table pointer          jsr     ttywrt     go consume data          pshs    cc         save interrupt state          seti    mask       interrupts          ldd     tsold,x          subd    #FIO_FSZ          bpl     00f*          ldd     #0         don't screw up!*00        std     tsold,x    update count          ldy     tqout,x    wake up anybody waiting for space***+++          if      DBG_IO&DEBUG_CONTROL          jsr     DB_msg          fdb     DBG_IO,10f          pshs    d,x,y,u          ldx     #00f          jsr     DB_pdata          tfr     y,d          jsr     DB_phex2          puls    d,x,y,u          endif***---10        jsr     wakeup          ldb     #R_WRITE          puls    cc,pc      return*00        fcc     $d,'FIFO consumed, wakeup at $',0** Write single character*  -- Character passed via transaction message*wrt_sc    pshs    cc         save interrupt state          jsr     ttftab     compute tty table address*00        ldy     tqout,x    output Q pointer          ldd     oq_count,y check for overrun          cmpd    OQHI          bls     10f        jump if space*          lda     tdelay,x   special flush bit?          bita    #$40          beq     05f        no - wait for space*          jsr     flusho     yes - make space!          bra     00b*05        ldb     #TTYOPR    wait a while          jsr     sleep          bra     00b        try again*10        ldy     utask      fetch character          ldb     tstval,y          jsr     ttyout     send to output queue          seti    mask       interrupts          jsr     ttyst      kick output - make sure it starts          ldb     #R_WRITE          puls    cc,pc      return** send_int - Interrupt all tasks associated with a terminal*send_int  pshs    d,x,y,u          jsr     ttftab     get TTY table address          jsr     flusht     flush terminal buffers          ldx     tsktab     find all associated tasks          leax    2*TSKSIZ,x          lda     1,s        get terminal #          ldb     NUM_TSK    # tasks in system          subb    #2*10        cmpa    tsdev,x    task associated with this terminal?          bne     20f        no - continue*          jsr     xmtint     yes - interrupt him*20        leax    TSKSIZ,x   next task          decb    any        more tasks?          bne     10b        yes - keep going*          puls    d,x,y,u    clean up stack          leas    2,s        -- pop normal return          rts     abnormal   I/O completion (no response)