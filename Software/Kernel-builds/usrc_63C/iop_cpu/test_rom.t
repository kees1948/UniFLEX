 ttl SWTPc IOP Debug ROM sttl Hardware Definitions abs pag lib constants lib macdefs lib iop_mem lib clist lib outputq lib task lib tty lib vars lib acia sttl System Debug Code pag org ROMorgUSE_8274 set 0TEST_PORT set 1TEST_ONLY set 0 if USE_8274** System port definitions*SYS_8274 equ $8000 else** System ACIA Definitions*SYS_ACIA equ $8080 Debug ACIA Port endif** Vector of entry points* fdb $1234 -- ROM present flag fdb DB_main Interractive debug monitor fdb DB_pdata fdb DB_phex fdb DB_phex2 fdb DB_pcrlf sttl Debug Routines pag** Debug driver*DB_main seti turn off interrupts if TEST_PORT*-- Brute force characters if USE_8274 ldx #SYS_8274 lda #$18 reset channel A sta 2,x mul mul mul ldu #syscnf point to configure string10 lda 0,u+ get byte beq 20f end of list? sta 2,x send to port lda 0,u+ get byte sta 2,x bra 10b repeat20 lda #$10 finish config sta 2,x30 lda #$2040 ldb #$10 do port setup stb 2,x ldb 2,x bitb #$04 xmit busy? beq 40b sta 0,x output char ldb #8045 decb bne 45b inca cmpa #$7E bne 40b if TEST_ONLY bra 30b endif else ldx #SYS_ACIA -- Initialize ACIA lda #$03 sta csr,x mul mul lda #$15 sta csr,x10 ldb #$2020 lda csr,x bita #ACXBSY beq 20b stb dbuf,x incb cmpb #$7E bne 20b if TEST_ONLY bra 10b endif endif endif lds #ROMstack clr DB_iflg pshs cc,d,x,y,u save all registers ldx #00f lbsr DB_pdata10 ldx #01f print prompt lbsr DB_pdata lbsr DB_inch get character pshs a save character lda #'  let the guy know I saw it lbsr DB_putch puls a restore character ldy #DB_cmds process command20 tst 0,y end of table? beq 30f yes - error cmpa 0,y command match? bne 25f no - try next one jsr [1,y] yes - go process it bra 10b next command25 leay 3,y next command entry bra 20b30 ldx #02f illegal command bsr DB_pdata bra 10b*00 fcc $d,'IOP Debug',001 fcc $d,'>>',002 fcc ' ??',0** Debug command table*DB_cmds fcb 'Q Quit - return to normal operation fdb quit fcb 'E Examine system memory fdb examine fcb 'M Modify system memory fdb modify fcb 'T Dump TTY Tables fdb dmp_tty fcb 'S Dump Task tables fdb dmp_task fcb 'R Print registers at time of entry to IOP DEBUG fdb dmp_regs fcb 0 end of table* -- Quit debug modequit puls x return address from command processor puls cc,d,x,y,u,pc return to interrupt context** This file contains routines for debug purposes.*DB_init pshs d,x save registers tst DB_iflg terminal initialized? bne 99f yes - exit lda #1 sta DB_iflg if USE_8274 ldx #SYS_8274 lda #$18 reset channel A sta 2,x pshs d,x,y,u delay some here mul mul mul puls d,x,y,u pshs u save u reg ldu #syscnf point to configure string10 lda 0,u+ get byte beq 20f end of list? sta 2,x send to port lda 0,u+ get byte sta 2,x bra 10b repeat20 lda #$10 finish config sta 2,x puls u reset u reg else ldx #SYS_ACIA lda #$03 reset code sta csr,x lda #$15 config byte sta csr,x endif99 puls d,x,pc if USE_8274syscnf fcb $01,$00,$02,$04,$04,$4c,$03,$c1,$05,$ee,$00 endif* Print character in (A) on debug portDB_putch pshs d,x bsr DB_init initialize terminal if necessary if USE_8274 ldx #SYS_827410 ldb #$10 do port setup stb 2,x ldb 2,x bitb #$04 xmit busy? beq 10b sta 0,x output char else ldx #SYS_ACIA10 ldb csr,x get acia status bitb #ACTBSY xmit busY? beq 10b sta dbuf,x output char endif puls d,x,pc* Print string (pointed to by X) on debug portDB_pdata pshs d,x10 lda ,x+ get next character beq 99f exit at end of string cmpa #CR map carriage returns to CR/LF bne 15f bsr DB_putch lda #NL send LF15 bsr DB_putch bra 10b99 puls d,x,pc return* Print character in (A) in HexDB_phex pshs d,x ldx #00f string of nibbles lsra lsra lsra lsra lda a,x bsr DB_putch print character lda 0,s anda #$0F lda a,x bsr DB_putch print character puls d,x,pc*00 fcc '0123456789ABCDEF'* Print the value in (D) in HexDB_phex2 pshs d bsr DB_phex print (A) lda 1,s bsr DB_phex print (B) puls d,pc return* Print a spaceDB_outsp lda #' bra DB_putch** Read & Echo one character*   DB_inch - Character in A*DB_inch pshs x save registers if USE_8274 ldx #SYS_827410 lda 2,x data available? bita #1 beq 10b lda 0,x fetch character else ldx #SYS_ACIA get port address10 lda csr,x wait for character present bita #ACRBSY beq 10b lda dbuf,x get character endif anda #$7F strip parity cmpa #'a map lower case -> upper case blo 20f anda #!$2020 puls x restore register bra DB_putch print character** Dump a range of memory (X..Y)*DB_dump pshs d,x,y,u** Print one line (16 bytes) of data*10 lbsr DB_pcrlf start a new print line ldd 2,s print address lbsr DB_phex2 lbsr DB_outsp lbsr DB_outsp ldx 2,s ldb #16 print 16 bytes pshs b20 lda ,x+ get next byte to print lbsr DB_phex lbsr DB_outsp dec 0,s done? bne 20b no - go back ldx 1+2,s now print characters lbsr DB_outsp lbsr DB_outsp ldb #16 stb 0,s30 lda ,x+ get next byte cmpa #$20 printable? blo 35f no cmpa #$7F blo 40f go print character35 lda #'. print period for unprintable40 lbsr DB_putch print character dec 0,s done? bne 30b leas 1,s clean up stack stx 2,s update address cmpx 4,s any more? bls 10b yes - go to it99 lbsr DB_pcrlf puls d,x,y,u,pc return** DB_pcrlf - print carriage return/line feed*DB_pcrlf pshs d,x save registers ldx #CRLF lbsr DB_pdata puls d,x,pc returnCRLF fcc $d,0 sttl DEBUG - Memory Modify Command pag** Modify system memory*modify leas -2,s reserve temp space lbsr DB_getadr get starting address bcs mod99 exit if error std 0,s save address*mod10 ldx #modm00 lbsr DB_pdata ldd 0,s print address lbsr DB_phex2 lbsr DB_outsp ldx 0,s get byte address lda 0,x get value pshs a save current value lbsr DB_phex output it lbsr DB_outsp print a space lbsr DB_gethex get a hex digit bcs mod30 jump if error asla asla asla asla sta 0,s update value lbsr DB_gethex get second hex digit bcs mod40 exit if error ora ,s+ compute total valuemod20 ldx 0,s get memory address sta ,x+ update memory stx 0,s update address bra mod10 continue with next byte*mod30 cmpa #'. is it "go on" char? bne mod40 no - exit puls a restore original value bra mod20 yes - move to next address*mod40 leas 1,s clean up stackmod99 puls x,pc return*modm00 fcc $d,'  - ',0 sttl Memory Examine Command pag** Examine memory (system)*examine leas -4,s reserve temp space lbsr DB_getadr get low address bcs 99f std 0,s save low limit lda #'- lbsr DB_putch lbsr DB_getadr get high address bcs 99f std 2,s save high limit puls x,y get limit registers lbsr DB_dump go dump memory rts exit99 puls x,y,pc return - error** get 4 hex digit address*   return value in D*DB_getadr ldb #4 number of digits pshs b ldd #0 starting value pshs d10 lbsr DB_gethex get a hex digit (in B) bcs 90f jump if error pshs a ldd 1,s fix up value aslb rola aslb rola aslb rola aslb rola orb ,s+ std ,s dec 2,s done? bne 10b clc90 puls d get value leas 1,s clean up stack rts return** DB_gethex - get one hex digit*DB_gethex lbsr DB_inch read character cmpa #'0 check for legal digit blo 90f cmpa #'9 bls 10f cmpa #'A legal digit? blo 90f no - error cmpa #'F bhi 90f adda #9 add bias10 anda #$0F strip ASCII stuff clc rts all done - no error90 sec illegal rts exit sttl Dump TTY Tables pag** dmp_tty - dump TTY table*dmp_tty pshs d,x,y,u ldy #TTYTABS TTY table base address lda #MAX_TRM # TTYs in system pshs a ldx #00f lbsr DB_pdata10 lbsr DB_pcrlf tfr y,d table address lbsr DB_phex2 lbsr spc_2 ldd tqin,y lbsr DB_phex2 ldx #04f lbsr DB_pdata lda [tqin,y] lbsr DB_phex lbsr spc_2 ldd tqout,y lbsr DB_phex2 ldx #04f lbsr DB_pdata ldd [tqout,y] lbsr DB_phex2 lbsr spc_2 lda tflags,y lbsr DB_phex lbsr spc_2 ldd tstate,y lbsr DB_phex2 lbsr spc_2 ldd tsold,y lbsr DB_phex2 leay TTYSIZ,y next entry dec 0,s any more tables? bne 10b puls a clean stack99 puls d,x,y,u,pc*00 fcc $d,'TTY   In Q    Out Q    Flag  State Sold',004 fcc '/',0 sttl Dump Task Tables pag** dmp_tasks - Print task tables*dmp_tasks pshs d,x,y,u ldx #00f lbsr DB_pdata lbsr DB_pcrlf lda #1 1=Busy, 0=Free pshs a05 ldy #tsktab10 lda tsstat,y get task state tst 0,s free or busy tasks? beq 11f jump for free cmpa #TFREE skip free tasks this time beq 20f bra 12f go print info11 cmpa #TFREE skip non-free tasks this time bne 20f12 tfr y,d lbsr DB_phex2 bsr spc_2 ldd tsstat,y lbsr DB_phex2 bsr spc_2 ldu umark0,y lda tsstat,y task sleeping? cmpa #TSLEEP bne 13f no ldd 0+7,u PC - in sleep bra 15f13 ldd 0,u PC - from interrupt15 lbsr DB_phex2 bsr spc_2 ldd tsevnt,y lbsr DB_phex2 event bsr spc_2 lda tsdev,y lbsr DB_phex bsr spc_2 lda tscmd,y lbsr DB_phex bsr spc_2 ldd tsseq,y lbsr DB_phex2 bsr spc_2 lda tstval,y lbsr DB_phex lbsr DB_pcrlf20 leay TSKSIZ,y cmpy #end_vars bne 10b dec 0,s next pass bpl 05b puls a clean stack99 puls d,x,y,u,pc00 fcc $d,'Task  State  PC   Event TTY CMD SEQ#  VAL',001 fcc '  ',0spc_2 ldx #01b lbra DB_pdata sttl Dump IOP Registers pagdmp_regs ldx #00f jsr DB_pdata leay 2,s point to stacked regs lda ,y+ CC jsr DB_phex ldx #01f jsr DB_pdata ldd ,y++ D jsr DB_phex2 ldx #02f jsr DB_pdata ldd ,y++ X jsr DB_phex2 ldx #03f jsr DB_pdata ldd ,y++ Y jsr DB_phex2 ldx #04f jsr DB_pdata ldd ,y++ U jsr DB_phex2 ldx #05f jsr DB_pdata tfr y,d jsr DB_phex2 ldx #06f jsr DB_pdata ldd ,y++ D jsr DB_phex2 rts*00 fcc $d,'CC = ',001 fcc   ', D = ',002 fcc   ', X = ',003 fcc   ', Y = ',004 fcc   ', U = ',005 fcc   ', S = ',006 fcc   ', PC = ',0 org $FFF0 fdb DB_main fdb DB_main fdb DB_main fdb DB_main fdb DB_main fdb DB_main fdb DB_main fdb DB_main