          sttl    Table      Initialization          pag          if      DBG_INIT&DEBUG_CONTROL00        fcc     $d,'Init CLISTs',001        fcc     $d,'Init TTYs',002        fcc     $d,'Init Tasks',003        fcc     $d,'STBinit done',0          endif** stbinit - Initialize System Memory Tables*stbinit   ldx     #sys_vars  clear all variables          ldd     #010        std     ,x++          cmpx    #end_vars  done yet?          blo     10b          ldd     #DEBUG          std     DB_cntrl          lbsr    set_tables go figure out configuration, tables, etc* Initialize Terminal Interrupt Queue15        ldx     #TI_Q      set queue empty          stx     TI_Q_ptr          ldx     #int_buf   reset message in pointer          stx     int_ptr          lbsr    clinit     initialize Clists16        lbsr    ttyinit    initialize TTY tables17        lbsr    tskinit    initialize tasks18        lbsr    DB_config  display configuration          rts          if      DBG_INIT&DEBUG_CONTROL00        fcc     $d,'Compute configuration',001        fcc     $d,'Size memory',002        fcc     $d,'Initialize devices',0          endif** Set up system tables*set_tables* -- Force in the on-board PIA*09        ldd     #PIA_SLOT*          jsr     [D_test+DEV_L2]* -- Force in the TOD interface*          ldy     #dev_tab+((MAX_DEV-1)*DEV_SIZE)*          ldx     #DEV_TOD*          stx     dev_type,y* Compute configuration          lda     #SR4_SLOTS          pshs    a          ldd     #BASE_SLOT set port address          ldx     #slot_tbl          pshs    x10        ldu     #no_dev          stu     0,x          ldu     #mod_tbl      tables with module refs12        ldx     mod_type,u          beq     20f        jump if end of module table          jsr     [D_test,x] check for device          bcs     15f        jump if found          leau    MOD_SIZE,u          bra     12b15        ldx     mod_name,u          stx     [0,s]20        addd    #NEXT_SLOT advance address          ldx     0,s        update slot table pointer          leax    2,x          stx     0,s          dec     2,s        any more slots          bne     10b          puls    a,x* -- All done setting up configuration* Set up constants based on configuration22        lda     #MAX_CL          sta     NUM_CL**         lda     #MAX_TSK          lda     #MAX_TRAN           reserve for system tasks          adda    #4          sta     NUM_TSK*          ldd     #MAX_OB          std     OBUF_SIZE* Now figure out where system tables go, based on configuration30        ldd     OBUF_SIZE          subd    #10          std     OQHI          subd    #(FIFO_SIZE+5)          std     OQLO          ldd     #SYS_TABS  start of system tables* -- Round up to CBSIZE boundary          addd    #CBSIZE-1          andb    #!(CBSIZE-1)          tfr     d,u* -- CLISTS          lda     #CBSIZE          ldb     NUM_CL          mul          stu     CLISTS          lbsr    sto_chk    check for system table space overflow          lbcs    40f        jump if it happens* -- TTY Control tables          lda     #TTYSIZ          ldb     NUM_TRM          mul          stu     TTYTABS    point to tty table          lbsr    sto_chk    check for system table space overflow          bcs     40f        jump if it happens* -- TTY Queue headers          lda     #2*QH_SIZE          ldb     NUM_TRM          mul          stu     TTYQS          lbsr    sto_chk    check for system table space overflow          bcs     40f        jump if it happens          lda     #OQH_SIZE          ldb     NUM_TRM          mul          lbsr    sto_chk    check for system table space overflow          bcs     40f        jump if it happens* -- TTY Output Queues          clra          ldb     NUM_TRM          tfr     d,x          ldd     #010        addd    OBUF_SIZE          leax    -1,x          bne     10b          stu     OBUFRS          lbsr    sto_chk    check for system table space overflow          bcs     40f        jump if it happens* -- Task table          lda     #TSKSIZ          ldb     NUM_TSK          mul          stu     tsktab          lbsr    sto_chk    check for system table space overflow          bcs     40f        jump if it happens          stu     tskend*          bra     60f* -- System table space has overflowed!* -- Try adjusting some parameters to get it under control40        ldd     OBUF_SIZE  first step, reduce output buffer size          subd    #32          std     OBUF_SIZE          cmpd    #MIN_OB          bge     50f        jump if still something left          ldd     #MAX_OB    start over & try something else          std     OBUF_SIZE          lda     NUM_TSK    try reducing # tasks          suba    #1          sta     NUM_TSK          ldb     NUM_TRM          addb    NUM_PPR          addb    NUM_NEC          addb    #3          pshs    b          cmpa    ,s+          bge     50f          lda     #MAX_TSK          sta     NUM_TSK          lda     NUM_CL     crank back on # clists          suba    #1          sta     NUM_CL          cmpa    NUM_TRM          bge     50f          ldb     #MAX_CL          stb     NUM_CL          ldx     #00f          jsr     DB_pdata          jsr     DB_config          jsr     DB_main          jmp     rom_init   ... what else can I do???50        lbra    30b        go try it all again*-- Initialize devices60        ldu     #dev_tab          if      DBG_INIT&DEBUG_CONTROL          jsr     DB_msg          fdb     DBG_INIT,62f          ldx     #02b          jsr     DB_pdata          endif62        clrb70        pshs    b          ldx     dev_addr,u get device address          beq     75f        jump if none there          ldy     dev_type,u get device kind          if      DBG_INIT&DEBUG_CONTROL          bsr     init_msg          endif          jsr     [D_init,y] go initialize device75        leau    DEV_SIZE,u          puls    b          incb          cmpb    #MAX_DEV-1          bne     70b* -- All done90        rts*00        fcc     $d,"...Can't size tables!",0*no_dev    fcc     '..None',0          if      DBG_INIT&DEBUG_CONTROL** init_msg - Print message about to initialize device*   B - Device #*   X - Device address*   Y - Device handler table*init_msg  pshs    d,x,y,u          jsr     DB_msg          fdb     DBG_INIT,99f          ldx     #00f          jsr     DB_pdata          lda     1,s          jsr     DB_phex          ldx     #01f          jsr     DB_pdata          ldd     2,s          jsr     DB_phex2          ldx     #02f          jsr     DB_pdata          ldd     D_init,y          jsr     DB_phex299        puls    d,x,y,u,pc*00        fcc     $d,'...Initialize device $',001        fcc     ', Addr $',002        fcc     ', At $',0          endif** Allocate some system table space*   D - Space being consumed*   U - Current end of table space*   jsr sto_chk (System Table Overflow check)*   <CS> if overflow*sto_chk   leau    d,u        compute new end pointer          cmpu    #end_vars  overflow?          bhi     10f        yes - return error          clc     no         - return OK          rts10        sec     ..         bad owies          rts** clinit** Initialize character buffer lists.  This routine* is only called once at startup time.*clinit    ldx     CLISTS     point to clist          ldb     NUM_CL     set count          stx     cfreel     set head pointerclini2    leay    CBSIZE,x          sty     0,x        set fwd link          tfr     y,x        advance to next          decb          bne     clini2          lda     NUM_CL     get buffer count          suba    #2          sta     lcbuf      set max count          clra    make       d=0          std     -CBSIZE,x  clear last link          clr     cbufct          rts     all        done!** ttyinit** Init the tty tables and queues.*ttyinit   ldy     TTYQS      point to q tables          clr     ,-s        terminal # counter          ldb     NUM_TRM    get terminal count          pshs    b          ldu     OBUFRS     output buffer          ldx     TTYTABS    point to TTY Tables10        sty     tqin,x     set input q          leay    QH_SIZE,y  get next q          sty     tqproc,x   set pr q          leay    QH_SIZE,y  set next q          sty     tqout,x    set output q          stu     oq_buf,y   ** Init output Q **          stu     oq_get,y          stu     oq_put,y          ldd     OBUF_SIZE          leau    d,u          stu     oq_end,y          leay    OQH_SIZE,y get next q          lda     #AC_SET    #%101<<2   8 bits, no parity, 1 stop bit          sta     tbaud,x    set conf word          lda     1,s        get terminal #          sta     tdevic,x   set in table          pshs    d,u          ldb     #DEV_SIZE          mul          ldu     #dev_tab          leau    d,u          ldd     dev_addr,u -- device address          std     taddr,x          puls    d,u          inc     1,s        bump terminal #          leax    TTYSIZ,x   next tty entry          dec     0,s        dec the count          bne     10b        repeat?          puls    d,pc       clean up stack & return** tskinit - Initialize all tasks*tskinit   ldx     tsktab          stx     utask          ldb     NUM_TSK    # tasks in system          pshs    b          ldy     tsktab     task 1          leay    TSKSIZ,y10          if      DBG_INIT&DEBUG_CONTROL          jsr     DB_msg          fdb     DBG_INIT,11f          pshs    d,x,y          ldx     #90f          lbsr    DB_pdata          ldd     2,s          lbsr    DB_phex2          puls    d,x,y          endif11        lda     #TFREE     mark all tasks free          cmpx    tsktab     is this the system task?          bne     15f          lda     #TSYS       the system task is never free15        sta     tsstat,x          lda     #$FF       not associated with a terminal          sta     tsdev,x          leau    TSKSIZ,x   initialize stack          ldd     #IO_han          pshs    y          cmpx    ,s++       task 1?          bne     20f        no - normal I/O handling task          ldd     #TI_HAN    yes - special terminal interrupt handling task20        pshu    d          stu     usp,x          stu     umark0,x          leax    TSKSIZ,x          dec     0,s        done?          bne     10b          leas    1,s        clean up stack          ldd     #0         nothing running or sleeping          std     runlst          std     slplst          std     slplst+tsslnk          leax    0,y        start interrupt handling task          jsr     makrdy          rts          if      DBG_INIT&DEBUG_CONTROL90        fcc     $d,'... Init task $',0          endif