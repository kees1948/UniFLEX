CPU09IOP   Intelligent I/O Proce     14:10:45  Jan 12, 2026   Page    1Hardware   Definitions                                                                                                       opt    lisCPU09IOP   Intelligent I/O Proce     14:10:46  Jan 12, 2026   Page    2IOP        Memory Layout                                                 *                     * Basic Memory Layout                     *               0100  RAMorg    equ    $0100     28K of RAM - Thru $6FFF               6FFF  RAMend    equ    $6FFF               7000  RAMscratch equ   $7000     4K of scratchpad RAM               7F00  RAMscrend equ    $7F00               7FFF  ROMstack  equ    $7FFF     High end of ROM Stack               E000  ROMLOorg  equ    $E000     8K of ROM - $E000-$FFFF               C000  DEBUGROM  equ    $C000     8K of Debug ROM $C000-$DFFF               FFF0  CPUtraps  equ    $FFF0     CPU Trap Vectors                                          *                     * layout of hardware, up to 6 IO boards                     *               8000  SYS_ACIA  equ    $8000     first ACIA in first slot               0003  SR4_SLOTS equ    3         Number of Physical CPU09SR4 I/O slots               8000  BASE_SLOT equ    $8000     Base address for I/O slots               0010  NEXT_SLOT equ    $0010     Offest between slots                                          * clock hardware               8070  CLOCK     equ    $8070     hardware clock, status and control               8071  CLOCKI    equ    $8071     interrupt resetCPU09IOP   Intelligent I/O Proce     14:10:46  Jan 12, 2026   Page    3IOP        Memory Layout                                                                      *                     * Clist Structure                     *                     * The clist structure is the head of a linked list of                     * characters used for i/o.  A head and tail pointer                     * are kept, as well as a character count of active                     * characters on the queue.                     *                                          * struct clist                       0000                         org    0                       0000               clcnt     rmb    1         character count  0001               clfst     rmb    2         head character pointer  0003               cllst     rmb    2         tail character pointer                     *               0005  QH_SIZE   equ    *         Size of Queue Header                                                               *                     * Clist Buffer                     *                     * The characters for i/o are placed in buffers as                     * needed.  Each buffer contains 32 bytes, the first                     * two contain a chain pointer, the next 30 hold                     * the actual characters.                     *                       0000                         org    0                                    0020  CBSIZE    equ    32  0000               cbstrt    rmb    2  0002               cbchrs    rmb    CBSIZE-2CPU09IOP   Intelligent I/O Proce     14:10:46  Jan 12, 2026   Page    4Output     Queue Structure                                                                    *                     * This is the definition of the output queue used                     * to buffer characters going to a terminal.  It is                     * different from the "clist" mechanism for efficiency                     * concerns.                     *                       0000                         org    0  0000               oq_count  rmb    2         Number of characters in Q  0002               oq_buf    rmb    2         Start of Q buffer  0004               oq_put    rmb    2         Address of next character to insert  0006               oq_get    rmb    2         Address of next character to consume  0008               oq_end    rmb    2         Limiting address of Q                     *  000A               OQH_SIZE  rmb    0         Size of output Queue headerCPU09IOP   Intelligent I/O Proce     14:10:46  Jan 12, 2026   Page    5Task       Structure                                                     *                     * Task Table                     *                       0000                         org    0                                          * struct task                                    008A  USTSIZ    equ    138       User Stack Size (big enough??)                     *  0000               tslink    rmb    2         list link of running tasks  0002               tsslnk    rmb    2         list link of sleeping tasks  0004               tsstat    rmb    1         * see below *  0005               tsprir    rmb    1         priority - negative is low  0006               tsevnt    rmb    2         event task is waiting on  0008               tssgnl    rmb    1         Signal waiting for task                     *  0009               tscmd     rmb    1         Saved mailbox command  000A               tsseq     rmb    2         Saved message sequence #  000C               tstval    rmb    1         Saved transaction value  000D               tsdev     rmb    2         Terminal task is servicing  000F               tsdtix    rmb    1         device table entry index  0010               tsagin    rmb    2         Task re-entry pointer                     *  0012               usp       rmb    2         Saved User Stack Pointer  0014               umark0    rmb    2         Stack Frame Markers  0016               umark1    rmb    2  0018                         rmb    USTSIZ    space for per/process stack                                    00A2  TSKSIZ    equ    *         task structure size                     * stat codes                                    0001  TRUN      equ    1         running               0002  TSLEEP    equ    2         sleep with high priority               0003  TWAIT     equ    3         sleep with low priority               0004  TFREE     equ    4         task is free (uncommitted)               0005  TSYS      equ    5         system taskCPU09IOP   Intelligent I/O Proce     14:10:46  Jan 12, 2026   Page    6TTY        Structure                                                                          *                     * TTY Structure                     *                     * A tty structure is required for each character type                     * i/o device used for standard terminal i/o.                     *                                          * struct tty                       0000                         org    0                       0000               tqin      rmb    2         pointer to in q clist str  0002               tqproc    rmb    2         pointer to proccessed q clist str  0004               tqout     rmb    2         pointer to out q clist str  0006               taddr     rmb    2         device address  0008               tflags    rmb    1         mode flags  0009               tdelay    rmb    1         time out definitions  000A               tdevic    rmb    2         device name  000C               ttask     rmb    2         task ID  000E               tdel      rmb    1         raw delimiter count  000F               tcolm     rmb    1         printing column  0010               tbksp     rmb    1         back space character  0011               tcncl     rmb    1         line cancel character  0012               tbaud     rmb    1         device baud rates  0013               tbaud2    rmb    1         actual baud rate (for baud rate generator)  0014               tstate    rmb    1         internal state  0015               tstate2   rmb    1         additional states  0016               tstate3   rmb    1         states of CTS,DCD  0017               tlock     rmb    1         structure lock  0018               tsold     rmb    2         amount of output queue already "sold"  001A               tregs     rmb    8         copy of device registers (for 8274)                                    0022  TTYSIZ    equ    *                                                               * modes                                    0001  RAW       equ    %00000001 raw or cooked mode               0002  ECHO      equ    %00000010 echo characters               0004  XTABS     equ    %00000100 expand tabs               0008  LCASE     equ    %00001000 map to lower case               0010  CRMOD     equ    %00010000 map NL to CR & LF               0020  BSECH     equ    %00100000 backspace echo flag               0040  SCHR      equ    %01000000 single character input               0080  CNTRL     equ    %10000000 ignore control characters                                          * internal states                                    0001  TIMOUT    equ    %00000001 timeout in progress               0002  HOLD      equ    %00000010 output suspended               0004  TOPEN     equ    %00000100 terminal has been openedCPU09IOP   Intelligent I/O Proce     14:10:47  Jan 12, 2026   Page    7TTY        Structure                                               0008  TRANSPNT  equ    %00001000 Transparent mode               0010  IXONXOF   equ    %00010000 Use XON/XOFF to control input               0010  TOPWOC    equ    %00010000 Device opened without carrier present               0020  XANY      equ    %00100000 Allow any character to break HOLD               0040  XONXOF    equ    %01000000 XON/XOFF protocol               0080  ESCOFF    equ    %10000000 Disable ESC as HOLD character                     *               00F8  PROTOCOL  equ    ESCOFF|XANY|XONXOF|IXONXOF|TRANSPNT                                    0001  DSR_OK    equ    %00000001 OK to send               0002  SEND_XON  equ    %00000010 Send XON next               0004  SEND_XOF  equ    %00000100 Send XOFF next               0008  SEND_DLE  equ    %00001000 Send DLE next               0010  XOF_SENT  equ    %00010000 We shut the other guy down               0020  DLE_SENT  equ    %00100000 DLE sequence started               0040  DLE_GOT   equ    %01000000 DLE sequence receivedCPU09IOP   Intelligent I/O Proce     14:10:47  Jan 12, 2026   Page    8Variable   Space                                                           0100                         org    RAMorg                       0100               sys_vars  rmb    0         -- start of system variables                                          * Configuration "constants"  0100               OBUF_SIZE rmb    2         Size of TTY Output Queues  0102               OQHI      rmb    2         Output Queue High-water mark  0104               OQLO      rmb    2         Output Queue Low-water mark  0106               slot_tbl  rmb    2*SR4_SLOTS slot configuration                       010C               DB_iflg   rmb    1         Debug terminal initialized  010D               DB_cntrl  rmb    2         Debug control flags                     *  010F               runlst    rmb    2         Pointer to active tasks  0111               slplst    rmb    4         Pointer to waiting tasks  0115               utask     rmb    2         Currently executing task  0117               jobpri    rmb    1         Current job priority (for scheduling)  0118               chproc    rmb    1         Set if must switch users of CPU (reschedule)  0119               cfreel    rmb    2         Pointer to first free Clist buffer  011B               cbufct    rmb    1         Count of Clist buffers in use  011C               lcbuf     rmb    1         Limit on Clist buffers  011D               idle      rmb    1         idle loop flag for scheduler  011E               SI_Q      rmb    6*MAX_TI  Max Terminal Interrupts  015A               SI_Q_ptr  rmb    2         current Q pointer  015C               FIO_lock  rmb    1         FIO in use lock                     *  015D               int_buf   rmb    2*7       Current Message in (1+2+1+2+1)  016B               int_ptr   rmb    2         Message in pointer  016D               clock_tick rmb   1         Clock tick counter  016E               prcbuf    rmb    PRCSIZ    buffer for erase and kill                                                               * Pointers to system tables - configuration dependent  026E               CLISTS    rmb    2         Space for Clists  0270               TTYTABS   rmb    2         Terminal tables  0272               TTYQS     rmb    2         TTY Input Queue Headers  0274               OBUFRS    rmb    2         TTY Output Queues  0276               tsktab    rmb    2         Task Control Tables  0278               tskend    rmb    2         End of task table  027A               PPstr     rmb    2         Pointer to parallel device tables  027C               NECstr    rmb    2         Pointer to NEC device tables  027E               dev_tab   rmb    DEV_SIZE*MAX_DEV system configuration table  02CC               NEC_IQ    rmb    2         Pointer to NEC input queue  02CE               NECADR    rmb    2         Address of NEC printer                     *  02D0               brbutb    rmb    MAX_TTY/2 baudrate latch backup table                     *  02D6               SYS_TABS  rmb    0         Start of dynamic system tables                                    6FFF  end_vars  equ    RAMend    End of System VariablesCPU09IOP   Intelligent I/O Proce     14:10:47  Jan 12, 2026   Page    9Variable   Space                                                         *                     * ACIA Structure                     *                                          * struct acia                       0000                         org    0                                            0000               csr       rmb    1         control - status  0001               dbuf      rmb    1         data buffer  0002               brr       rmb    1         baudrate latch                                          *                     * status codes                     *               0001  AS_RDRF   equ    %00000001 receive data register full               0002  AS_TDRE   equ    %00000010 transmit data register empty               0004  AS_NDCD   equ    %00000100 DCD status bit, 1 is inactive               0008  AS_NCTS   equ    %00001000 CTS bit, 1 is inactive TX IRQ off               0010  AS_FRME   equ    %00010000 receive framing error               0020  AS_OVRN   equ    %00100000 receive overrun               0040  AS_PERR   equ    %01000000 receive parity error               0080  AS_IRQ    equ    %10000000 INT flag, 1 is active                     *                     * control codes                     *               0001  AC_DIV0   equ    %00000001 counter divide bit 0 :1/:16/:64/reset               0002  AC_DIV1   equ    %00000010 counter divide bit 1               0004  AC_WS0    equ    %00000100 word select 0 7E2/7O2/7E1/7O1               0008  AC_WS1    equ    %00001000 word select 1 8N2/8N1/8E1/8O1               0010  AC_WS2    equ    %00010000 word select 2               0020  AC_TEIN   equ    %00100000 transmit control 0  NRTS/NINT,NRTS/INTE               0040  AC_DRTS   equ    %01000000 transmit control 1  RTS/NINT,NRTS/SBRK/NINT               0080  AC_REIN   equ    %10000000 receive enable IRQ                     *               0001  AC_DV16   equ    %00000001 setting for clk/16               0003  AC_MRES   equ    AC_DIV1+AC_DIV0 master reset               0014  AC_8N1    equ    AC_WS2+AC_WS0 select for 8N1               0015  AC_SET    equ    AC_8N1+AC_DV16 ACIA default setupCPU09IOP   Intelligent I/O Proce     14:10:48  Jan 12, 2026   Page   10FIO in Dual Port RAM                                                                          *                     * is now performed by CY7C130 dual port RAM where (1024 * 8)                     * the RAM size is limited to the (upper) 256 bytes, which                     * contains the Interrupt handshake locations                     *                     *                       0000                         org    $0000     absolute addressed                                          ************************************************************                     * the first 32 bytes of a fifo/DPR area are the same                     * for ALL applications                     ************************************************************  0000               cpu_fio   rmb    1         Command code  0001               cpu_fio1  rmb    2         Task ID/sequence  0003               cpu_fio2  rmb    1         Message specific data  0004               cpu_fio3  rmb    2         Device designator  0006               cpu_fio4  rmb    2         UIO  0008               cpu_fio5  rmb    1         Device table index                     ************************************************************  0009               fio_cpu   rmb    1         Response code  000A               fio_cpu1  rmb    2         Task ID /sequence  000C               fio_cpu2  rmb    1         Transaction specific value  000D               fio_cpu3  rmb    2         --  000F               fio_cpu4  rmb    2         UIO  0011               fio_cpu5  rmb    1         --                     ************************************************************                     *  0012               fifo_cnt  rmb    2         Count of data in FIFO  0014               fifo_get  rmb    2         retrieval ponter  0016               fifo_put  rmb    2         storage pointer                     *                     * these values are initialized by the IO CPU                     *  0018               fifo_us0  rmb    2         FIFO offset to application data                     *  001A               fifo_us1  rmb    2         FIFO offset to user specific area2  001C               fifo_us2  rmb    2         FIFO offset to user specific area2  001E               fifo_us3  rmb    2         FIFO offset to user specific area3                     *  0020                         rmb    32-(*-cpu_fio) ** Filler **                     * end of defined area                                          ************************************************************  0020               fifo      rmb    1                     * the size of the fifo is defined in the parameter block                     ************************************************************                                          ************************************************************                     * the top 4 locations are also fixed and shared on all applications                     ************************************************************CPU09IOP   Intelligent I/O Proce     14:10:48  Jan 12, 2026   Page   11FIO in Dual Port RAM                                  0021               DEV2CPU   rmb    1         debug data from IOP/GPP  0022               CPU2DEV   rmb    1         debug data to IOP/GPP                     * should end up at the two top locations in the DUALPORT RAM  0023               fio_cpuF  rmb    1         INT + non-zero   contains info AND set CPU IRQ when written  0024               cpu_fioF  rmb    1         INT + non-zero   contains info AND set FIO IRQ when written                     **************************************************************                                          *                     * FIO Task Priority                     *   -- Set to make task uninterruptable while                     *   -- actually using the FIO                     *               000F  FIOPRI    set    15                                          *                     * FIO Control structures                     *                                          * Transaction slots                                                               *                     * IOP ROM Version #                     *               0020  ROM_VERSION equ  $20       Major/Minor Version of IOP ROM                                          *                     * generic and specific transaction codes for use with fio_han                     * these are for IOP                     *                                          *                     * Error codes                     *               0080  REJECT    equ    %10000000 Error/Reject bit in command response               0081  E_BADCMD  equ    REJECT+$01 Illegal command               0082  E_SYSBSY  equ    REJECT+$02 IOP saturated               0083  E_NTOPEN  equ    REJECT+$03 Selected device not open               0084  E_BADDEV  equ    REJECT+$04 Illegal device # (=3)               0085  E_DEVBSY  equ    REJECT+$05 Device is already open (exclusieve)               0086  E_IOERR   equ    REJECT+$06 Some sort of IO error               00BE  E_INTRPT  equ    REJECT+$3E Terminal interrupt (send by IOP to UniFLEX)               00BF  E_ABORT   set    REJECT+$3F Transaction aborted by UniFLEX (not sent by IOP)               00C0  E_SOCKET  equ    REJECT+$40 Socket error,                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     *               0008  O_OPEN    equ    $08       Open device               0010  O_CLOSE   equ    $10       Close device               0018  O_RQWR    equ    $18       Request write               0020  O_WRITE   equ    $20       Write data via fifo to IOPCPU09IOP   Intelligent I/O Proce     14:10:48  Jan 12, 2026   Page   12FIO in Dual Port RAM                                               0028  O_RQRD    equ    $28       Request read data               0030  O_READ    equ    $30       Read data for via fifo from IOP               0038  O_INTRPT  set    $38       Interrupt all tasks on a terminal               0040  O_WR1C    equ    $40       Write single character               0048  O_TTYS    equ    $48       TTY Set               0050  O_TTYG    equ    $50       TTY Get                                    0058  O_PGETD   equ    $58       Read baudrate settings               0060  O_PSETD   equ    $60       Write baudrate settings                                          *                     * Normal responses                     * error is with bit 7 set, A contains error code                     *               000F  R_RESET   equ    $0F       System reset & functioning               0001  R_OPEN    equ    $01       Device open successful               0002  R_CLOSE   equ    $02       Device close successful               0003  R_REQOK   equ    $03       Write request now granted               0004  R_WRITE   equ    $04       Write data complete               0005  R_RDOK    equ    $05       Read data now available               0006  R_READ    equ    $06       Read data in FIFO & no more data is available               0007  R_INTRPT  set    $07       Interrupt complete               0008  R_WR1C    equ    $08       Write single character               0009  R_RD1C    equ    $09       Single character available               000B  R_PDATA   equ    $0B       port data transaction succes               000C  R_READM   equ    $0C       Read data in fifo, more data waiting               000D  R_TTY     equ    $0D       TTYSET/GET complete               000E  R_CLOCK   equ    $0E       Interval Timer Tick                                          CPU09IOP   Intelligent I/O Proce     14:10:49  Jan 12, 2026   Page   13CPU        Vectors                                                         0025                         abs                       FFF0                         org    CPUtraps                       FFF0 E0BB                    fdb    rom_trap  Unused  FFF2 E0B4                    fdb    rom_swi3  SWI3  FFF4 E0AD                    fdb    rom_swi2  SWI2  FFF6 E0A0                    fdb    rom_firq  FIRQ  FFF8 E069                    fdb    irq_han   IRQ  FFFA E0A7                    fdb    rom_swi   SWI  FFFC E09A                    fdb    rom_nmi   NMI  FFFE E075                    fdb    rom_init  Reset                     CPU09IOP   Intelligent I/O Proce     14:10:49  Jan 12, 2026   Page   14System     RESET Code                                                                         *                     * this declaration makes it possible to address                     * NUM_TSK, NUM_TRM etc directly                     *                     *                     * starting device minor for IOP serial devices                     *                     * on the CPU side, serial devices may take up                     * from tty00 up to tty08                     *               0009  IOPTDMIN  equ    9         IOP tty lowest minor               00E0  CFGDAT    equ    $00E0     place in DPR where info is passed                       00E0                         org    CFGDAT  00E0               NUM_TSK   rmb    1  00E1               NUM_CL    rmb    1  00E2               NUM_TRM   rmb    1  00E3               NUM_PPR   rmb    1  00E4               NUM_NEC   rmb    1                                          *                     * the normal declaraction for this device                     *  E000                         org    ROMLOorg                       E000 0D 49 4F 50   DBmsg00   fcc    $d,'IOP ROM :260112',0  E011 0D 53 79 73   DBmsg01   fcc    $d,'System Initialization Complete',0  E031 0D 43 50 55   DBmsg02   fcc    $d,'CPU RESET Complete',0  E045 0D 0D 53 79   CPU_down  fcc    $d,$d,'System CPU not functioning',0                                                         E062  fio_fsz   equ    *               E064  fio_dsz   equ    *+2               E066  max_trn   equ    *+4                     *                     * share specific DUAL PORT RAM device initialization                     * between UniFLEX kernel and IOP CPU                     *  E062 0080                    fdb    128       fio_fsz FIFO SIZE  E064 0100                    fdb    256       fio_dsz DEVICE SIZE  E066 18                      fcb    24        fio_mxtrn MAX_TRANSACTIONS  E067 0000                    fdb    0                                          *                     * IRQ handler                     *               E069  irq_han   equ    *  E069 BD   E502               jsr    IRQ_han   do actual handler                     *                     * common return for all interrupts                     *CPU09IOP   Intelligent I/O Proce     14:10:49  Jan 12, 2026   Page   15System     RESET Code                                 E06C 7D   0118     intret    tst    chproc    change process?  E06F 27   03                 beq    01f  E071 BD   E5C3               jsr    change    change process  E074 3B            01        rti                                                               *                     * System RESET code, interrupts disabled                     *  E075 10CE 7FFF     rom_init  lds    #ROMstack initialize stack pointer  E079                         ldmd   3                       E07C 8E   0000               ldx    #0        clear all of RAM, including FIFO  E07F CC   0000               ldd    #0  E082 ED   81       10        std    ,x++  E084 8C   6FFF               cmpx   #end_vars  E087 25   F9                 blo    10b                                           >E089 17   0050     20        lbsr   stbinit   go initialize system memory                                            E08C 10FE 0276     30        lds    tsktab  E090 32   E9 00A2            leas   TSKSIZ,s  Task 0 Stack  E094 17   02AB               lbsr   fio_reset                                          *                     * Initialization complete - Start executing commands                     *  E097               fio_start                     *         ldb     #ROM_VERSION                     *         stb     fio_cpu1                     *         ldb     #R_RESET   send "system reset & running" message                     *         lbsr    fio_msg                                            E097 7E   E5C9     10        jmp    rsched                     CPU09IOP   Intelligent I/O Proce     14:10:49  Jan 12, 2026   Page   16ROM        Interrupt Fielders                                              E09A 8D   26       rom_nmi   bsr    rom_int  E09C 4E 4D 49 00             fcc    'NMI',0  E0A0 8D   20       rom_firq  bsr    rom_int  E0A2 46 49 52 51             fcc    'FIRQ',0  E0A7 8D   19       rom_swi   bsr    rom_int  E0A9 53 57 49 00             fcc    'SWI',0  E0AD 8D   13       rom_swi2  bsr    rom_int  E0AF 53 57 49 32             fcc    'SWI2',0  E0B4 8D   0C       rom_swi3  bsr    rom_int  E0B6 53 57 49 33             fcc    'SWI3',0  E0BB 8D   05       rom_trap  bsr    rom_int  E0BD 54 52 41 50             fcc    'TRAP',0                       E0C2 8E   E0CF     rom_int   ldx    #ROM_ERR  E0C5 BD   F074               jsr    DB_pdata  E0C8 35   10                 puls   x  E0CA BD   F074               jsr    DB_pdata  E0CD 20   FE       rom_bad   bra    *                     *  E0CF 0D 52 4F 4D   ROM_ERR   fcc    $d,'ROM Error: ',0CPU09IOP   Intelligent I/O Proce     14:10:49  Jan 12, 2026   Page   17Table      Initialization                                                                                                               *                     * stbinit - Initialize System Memory Tables                     *  E0DC 8E   0100     stbinit   ldx    #sys_vars clear all variables  E0DF CC   0000               ldd    #0  E0E2 ED   81       10        std    ,x++  E0E4 8C   6FFF               cmpx   #end_vars done yet?  E0E7 25   F9                 blo    10b  E0E9 CC   0D04               ldd    #DEBUG  E0EC FD   010D               std    DB_cntrl                     * >E0EF 17   0019               lbsr   set_tables go figure out configuration, tables, etc                     * Initialize Terminal Interrupt Queue  E0F2 8E   011E     15        ldx    #SI_Q     set queue empty  E0F5 BF   015A               stx    SI_Q_ptr  E0F8 8E   015D               ldx    #int_buf  reset message in pointer  E0FB BF   016B               stx    int_ptr  E0FE 17   0169               lbsr   clinit    initialize Clists  E101 17   0188     16        lbsr   ttyinit   initialize TTY tables  E104 17   01D5     17        lbsr   tskinit   initialize tasks  E107 17   0F88     18        lbsr   DB_config display configuration  E10A 39                      rts                                                               *                     * Set up system tables                     *  E10B               set_tables                     * -- Force in the on-board PIA                     *09        ldd     #PIA_SLOT                     *          jsr     [D_test+DEV_L2]                     * -- Force in the TOD interface                     *          ldy     #dev_tab+((MAX_DEV-1)*DEV_SIZE)                     *          ldx     #DEV_TOD                     *          stx     dev_type,y                                                               * Compute configuration  E10B 86   03                 lda    #SR4_SLOTS  E10D 34   02                 pshs   a  E10F CC   8000               ldd    #BASE_SLOT set port address  E112 8E   0106               ldx    #slot_tbl  E115 34   10                 pshs   x  E117 CE   E255     10        ldu    #no_dev  E11A EF   84                 stu    0,x  E11C CE   E333               ldu    #mod_tbl  tables with module refs  E11F AE   C4       12        ldx    mod_type,u  E121 27   0D                 beq    20f       jump if end of module table  E123 AD   98 24              jsr    [D_test,x] check for deviceCPU09IOP   Intelligent I/O Proce     14:10:50  Jan 12, 2026   Page   18Table      Initialization                             E126 25   04                 bcs    15f       jump if found  E128 33   44                 leau   MOD_SIZE,u  E12A 20   F3                 bra    12b  E12C AE   42       15        ldx    mod_name,u  E12E AF   F4                 stx    [0,s]  E130 C3   0010     20        addd   #NEXT_SLOT advance address  E133 AE   E4                 ldx    0,s       update slot table pointer  E135 30   02                 leax   2,x  E137 AF   E4                 stx    0,s  E139 6A   62                 dec    2,s       any more slots  E13B 26   DA                 bne    10b  E13D 35   12                 puls   a,x                     * -- All done setting up configuration                     * Set up constants based on configuration  E13F 86   7C       22        lda    #MAX_CL  E141 34   10                 pshs   x  E143 8E   00E0               ldx    #CFGDAT  E146 9F   18                 stx    fifo_us0  initialize config data pointer  E148 35   10                 puls   x  E14A 97   E1                 sta    NUM_CL                     *  E14C B6   E066               lda    max_trn   reserve for system tasks  E14F 8B   04                 adda   #4  E151 97   E0                 sta    NUM_TSK                     *  E153 CC   0400               ldd    #MAX_OB  E156 FD   0100               std    OBUF_SIZE                     * Now figure out where system tables go, based on configuration  E159 FC   0100     30        ldd    OBUF_SIZE  E15C 83   000A               subd   #10  E15F FD   0102               std    OQHI  E162 B3   E062               subd   fio_fsz  E165 83   0005               subd   #5  E168 FD   0104               std    OQLO  E16B CC   02D6               ldd    #SYS_TABS start of system tables                     * -- Round up to CBSIZE boundary  E16E C3   001F               addd   #CBSIZE-1  E171 C4   E0                 andb   #!(CBSIZE-1)  E173 1F   03                 tfr    d,u                     * -- CLISTS  E175 86   20                 lda    #CBSIZE  E177 D6   E1                 ldb    NUM_CL  E179 3D                      mul  E17A FF   026E               stu    CLISTS  E17D 17   00DC               lbsr   sto_chk   check for system table space overflow >E180 1025 004D               lbcs   40f       jump if it happens                     * -- TTY Control tables  E184 86   22                 lda    #TTYSIZ  E186 D6   E2                 ldb    NUM_TRM  E188 3D                      mul  E189 FF   0270               stu    TTYTABS   point to tty table  E18C 17   00CD               lbsr   sto_chk   check for system table space overflowCPU09IOP   Intelligent I/O Proce     14:10:50  Jan 12, 2026   Page   19Table      Initialization                             E18F 25   40                 bcs    40f       jump if it happens                     * -- TTY Queue headers  E191 86   0A                 lda    #2*QH_SIZE  E193 D6   E2                 ldb    NUM_TRM  E195 3D                      mul  E196 FF   0272               stu    TTYQS  E199 17   00C0               lbsr   sto_chk   check for system table space overflow  E19C 25   33                 bcs    40f       jump if it happens  E19E 86   0A                 lda    #OQH_SIZE  E1A0 D6   E2                 ldb    NUM_TRM  E1A2 3D                      mul  E1A3 17   00B6               lbsr   sto_chk   check for system table space overflow  E1A6 25   29                 bcs    40f       jump if it happens                     * -- TTY Output Queues  E1A8 4F                      clra  E1A9 D6   E2                 ldb    NUM_TRM  E1AB 1F   01                 tfr    d,x  E1AD CC   0000               ldd    #0  E1B0 F3   0100     10        addd   OBUF_SIZE  E1B3 30   1F                 leax   -1,x  E1B5 26   F9                 bne    10b  E1B7 FF   0274               stu    OBUFRS  E1BA 17   009F               lbsr   sto_chk   check for system table space overflow  E1BD 25   12                 bcs    40f       jump if it happens                     * -- Task table  E1BF 86   A2                 lda    #TSKSIZ  E1C1 D6   E0                 ldb    NUM_TSK  E1C3 3D                      mul  E1C4 FF   0276               stu    tsktab  E1C7 17   0092               lbsr   sto_chk   check for system table space overflow  E1CA 25   05                 bcs    40f       jump if it happens  E1CC FF   0278               stu    tskend                     *  E1CF 20   53                 bra    60f                     * -- System table space has overflowed!                     * -- Try adjusting some parameters to get it under control  E1D1 FC   0100     40        ldd    OBUF_SIZE first step, reduce output buffer size  E1D4 83   0020               subd   #32  E1D7 FD   0100               std    OBUF_SIZE  E1DA 1083 0120               cmpd   #MIN_OB  E1DE 2C   41                 bge    50f       jump if still something left  E1E0 CC   0400               ldd    #MAX_OB   start over & try something else  E1E3 FD   0100               std    OBUF_SIZE  E1E6 34   10                 pshs   x  E1E8 9E   18                 ldx    fifo_us0  pointer  E1EA 96   E0                 lda    NUM_TSK   try reducing # tasks  E1EC 80   01                 suba   #1  E1EE 97   E0                 sta    NUM_TSK  E1F0 D6   E2                 ldb    NUM_TRM  E1F2 DB   E3                 addb   NUM_PPR  E1F4 DB   E4                 addb   NUM_NEC  E1F6 35   10                 puls   xCPU09IOP   Intelligent I/O Proce     14:10:50  Jan 12, 2026   Page   20Table      Initialization                             E1F8 CB   03                 addb   #3  E1FA 34   04                 pshs   b  E1FC A1   E0                 cmpa   ,s+  E1FE 2C   21                 bge    50f  E200 86   28                 lda    #MAX_TSK  E202 97   E0                 sta    NUM_TSK  E204 96   E1                 lda    NUM_CL    crank back on # clists  E206 80   01                 suba   #1  E208 97   E1                 sta    NUM_CL  E20A 91   E2                 cmpa   NUM_TRM  E20C 2C   13                 bge    50f  E20E C6   7C                 ldb    #MAX_CL  E210 D7   E1                 stb    NUM_CL  E212 8E   E23E               ldx    #00f  E215 BD   F074               jsr    DB_pdata  E218 BD   F092               jsr    DB_config  E21B BD   F06E               jsr    DB_main  E21E 7E   E075               jmp    rom_init  ... what else can I do???  E221 16   FF35     50        lbra   30b       go try it all again                     *-- Initialize devices  E224 CE   027E     60        ldu    #dev_tab  E227 5F            62        clrb  E228 34   04       70        pshs   b  E22A AE   C4                 ldx    dev_addr,u get device address  E22C 27   06                 beq    75f       jump if none there  E22E 10AE 42                 ldy    dev_type,u get device kind  E231 AD   B8 22              jsr    [D_init,y] go initialize device  E234 33   46       75        leau   DEV_SIZE,u  E236 35   04                 puls   b  E238 5C                      incb  E239 C1   0C                 cmpb   #MAX_DEV-1  E23B 26   EB                 bne    70b                     * -- All done  E23D 39            90        rts                     *  E23E 0D 2E 2E 2E   00        fcc    $d,"...Can't size tables!",0                     *  E255 2E 2E 4E 6F   no_dev    fcc    '..None',0                                          *                     * Allocate some system table space                     *   D - Space being consumed                     *   U - Current end of table space                     *   jsr sto_chk (System Table Overflow check)                     *   <CS> if overflow                     *  E25C 33   CB       sto_chk   leau   d,u       compute new end pointer  E25E 1183 6FFF               cmpu   #end_vars overflow?  E262 22   03                 bhi    10f       yes - return error  E264 1C   FE                 clc              no         - return OK  E266 39                      rts  E267 1A   01       10        sec              ..         bad owiesCPU09IOP   Intelligent I/O Proce     14:10:51  Jan 12, 2026   Page   21Table      Initialization                             E269 39                      rts                                          *                     * clinit                     *                     * Initialize character buffer lists.  This routine                     * is only called once at startup time.                     *                       E26A BE   026E     clinit    ldx    CLISTS    point to clist  E26D D6   E1                 ldb    NUM_CL    set count  E26F BF   0119               stx    cfreel    set head pointer  E272 31   88 20    clini2    leay   CBSIZE,x  E275 10AF 84                 sty    0,x       set fwd link  E278 1F   21                 tfr    y,x       advance to next  E27A 5A                      decb  E27B 26   F5                 bne    clini2  E27D 96   E1                 lda    NUM_CL    get buffer count  E27F 80   02                 suba   #2  E281 B7   011C               sta    lcbuf     set max count  E284 4F                      clra             make       d=0  E285 ED   88 E0              std    -CBSIZE,x clear last link  E288 7F   011B               clr    cbufct  E28B 39                      rts              all        done!                                          *                     * ttyinit                     *                     * Init the tty tables and queues.                     *                       E28C 10BE 0272     ttyinit   ldy    TTYQS     point to q tables  E290 6F   E2                 clr    ,-s       terminal # counter  E292 D6   E2                 ldb    NUM_TRM   get terminal count  E294 34   04                 pshs   b  E296 FE   0274               ldu    OBUFRS    output buffer  E299 BE   0270               ldx    TTYTABS   point to TTY Tables  E29C 10AF 84       10        sty    tqin,x    set input q  E29F 31   25                 leay   QH_SIZE,y get next q  E2A1 10AF 02                 sty    tqproc,x  set pr q  E2A4 31   25                 leay   QH_SIZE,y set next q  E2A6 10AF 04                 sty    tqout,x   set output q  E2A9 EF   22                 stu    oq_buf,y  ** Init output Q **  E2AB EF   26                 stu    oq_get,y  E2AD EF   24                 stu    oq_put,y  E2AF FC   0100               ldd    OBUF_SIZE  E2B2 33   CB                 leau   d,u  E2B4 EF   28                 stu    oq_end,y  E2B6 31   2A                 leay   OQH_SIZE,y get next q  E2B8 86   15                 lda    #AC_SET   #%101<<2   8 bits, no parity, 1 stop bit  E2BA A7   88 12              sta    tbaud,x   set conf word  E2BD A6   61                 lda    1,s       get terminal #CPU09IOP   Intelligent I/O Proce     14:10:51  Jan 12, 2026   Page   22Table      Initialization                             E2BF A7   0B                 sta    tdevic+1,x set in table  E2C1 34   46                 pshs   d,u  E2C3 C6   06                 ldb    #DEV_SIZE  E2C5 3D                      mul  E2C6 CE   027E               ldu    #dev_tab  E2C9 33   CB                 leau   d,u  E2CB EC   C4                 ldd    dev_addr,u -- device address  E2CD ED   06                 std    taddr,x  E2CF 35   46                 puls   d,u  E2D1 6C   61                 inc    1,s       bump terminal #  E2D3 30   88 22              leax   TTYSIZ,x  next tty entry  E2D6 6A   E4                 dec    0,s       dec the count  E2D8 26   C2                 bne    10b       repeat?  E2DA 35   86                 puls   d,pc      clean up stack & return                                          *                     * tskinit - Initialize all tasks                     *  E2DC 8E   0276     tskinit   ldx    #tsktab  E2DF BF   0115               stx    utask  E2E2 D6   E0                 ldb    NUM_TSK   # tasks in system  E2E4 34   04                 pshs   b  E2E6 10BE 0276               ldy    tsktab    task 1  E2EA 31   A9 00A2            leay   TSKSIZ,y  E2EE               10  E2EE 86   04       11        lda    #TFREE    mark all tasks free  E2F0 BC   0276               cmpx   tsktab    is this the system task?  E2F3 26   02                 bne    15f  E2F5 86   05                 lda    #TSYS     the system task is never free  E2F7 A7   04       15        sta    tsstat,x  E2F9 86   FF                 lda    #$FF      not associated with a terminal  E2FB A7   0D                 sta    tsdev,x  E2FD A7   0E                 sta    tsdev+1,x  E2FF 33   89 00A2            leau   TSKSIZ,x  initialize stack  E303 CC   E47E               ldd    #IO_han  E306 34   20                 pshs   y  E308 AC   E1                 cmpx   ,s++      task 1?  E30A 26   03                 bne    20f       no - normal I/O handling task  E30C CC   E55E               ldd    #SI_HAN   yes - special signal interrupt handling task  E30F 36   06       20        pshu   d  E311 EF   88 12              stu    usp,x  E314 EF   88 14              stu    umark0,x  E317 30   89 00A2            leax   TSKSIZ,x  E31B 6A   E4                 dec    0,s       done?  E31D 26   CF                 bne    10b  E31F 32   61                 leas   1,s       clean up stack  E321 CC   0000               ldd    #0        nothing running or sleeping  E324 FD   010F               std    runlst  E327 FD   0111               std    slplst  E32A FD   0113               std    slplst+tsslnk  E32D 30   A4                 leax   0,y       start interrupt handling task  E32F BD   E66F               jsr    makrdyCPU09IOP   Intelligent I/O Proce     14:10:51  Jan 12, 2026   Page   23Table      Initialization                             E332 39                      rtsCPU09IOP   Intelligent I/O Proce     14:10:51  Jan 12, 2026   Page   24IOP        Configuration                                                                      *                     * define which type of boards are present                     *               E333  mod_tbl   equ    *  E333 EEC5 E339               fdb    DEV_6850,SR4_name  E337 0000                    fdb    0                     *  E339 43 50 55 30   SR4_name  fcc    'CPU09SR4',0CPU09IOP   Intelligent I/O Proce     14:10:51  Jan 12, 2026   Page   25FIO        Simulation Routines                                                                *                     * Reset CPU-IOP Interface                     * it is assumed that the FIO (DPR) sits at $0000                     *  E342               fio_reset                     * when here, all storage locations have been erased already                     *  E342 8E   0000               ldx    #0  E345 9F   14                 stx    fifo_get  set Q pointers  E347 9F   16                 stx    fifo_put  E349 8E   00E0               ldx    #CFGDAT  E34C 9F   18                 stx    fifo_us0  so that kernel CPU can see it  E34E BE   E064               ldx    fio_dsz  E351 30   1E                 leax   -2,x      one from top  E353 CE   0400               ldu    #1024     -- Reset Time-Out value                     *  E356 C6   FF       fio_wait  ldb    #255      Spin counter                     *  E358               00  E358 6D   84                 tst    0,x       fio_cpuF  E35A 27   0D                 beq    10f                     *  E35C 5A                      decb  E35D 26   F9                 bne    00b       jump back if not ready  E35F 33   5F                 leau   -1,u  E361 1183 0000               cmpu   #0  E365 26   EF                 bne    fio_wait  E367 20   D9                 bra    fio_reset wait 'forever'                     * reset OK  E369 39            10        rtsCPU09IOP   Intelligent I/O Proce     14:10:52  Jan 12, 2026   Page   26FIO        Simulation Routines                                                                *                     * fio_msg - Send a message via the FIO Mailbox                     * it is assumed that the FIO (DPR) sits at $0000                     *   B - Message code to send (one byte)                     *   fio_cpu1..3 already set up                     *  E36A 34   54       fio_msg   pshs   b,x,u     save register  E36C FE   E064               ldu    fio_dsz  E36F 33   5E                 leau   -2,u      one off top  E371 D7   09                 stb    fio_cpu   set up mailbox value                       E373 86   FF       5         lda    #$FF      tell CPU mailbox full  E375 A7   C4                 sta    0,u       fio_cpuF  E377 8E   FFFF     05        ldx    #$FFFF    time-out counter                     *  E37A A6   C4       10        lda    0,u       fio_cpuF   wait till value consumed  E37C 27   06                 beq    20f       jump if consumed                     *  E37E 30   1F                 leax   -1,x      time-out yet?  E380 26   F8                 bne    10b                     *  E382 20   F3                 bra    05b       try again                     *  E384 35   D4       20        puls   b,x,u,pc                     *                                          *                     * fio_response - Return a response code/sequence #                     * it is assumed that the FIO (DPR) sits at $0000                     *    X = utask,                     *    B - Response code                     *    A - Transaction specific value                     *  E386 34   16       fio_response pshs d,x  E388 8D   18                 bsr    FIO_get   access FIO  E38A BE   0115               ldx    utask     task ID  E38D EC   0A                 ldd    tsseq,x  E38F DD   0A                 std    fio_cpu1  E391 EC   0D                 ldd    tsdev,x   device info  E393 DD   0D                 std    fio_cpu3  E395 A6   E4                 lda    0,s       get transaction specific value  E397 97   0C                 sta    fio_cpu2  E399 E6   61                 ldb    1,s       is RESPONSE code >E39B BD   E36A               jsr    fio_msg  E39E 8D   17                 bsr    FIO_rel   release FIO  E3A0 35   96                 puls   d,x,pc    return                                          *                     * FIO_get - Get access to FIO device                     * -- Sleep till available                     *CPU09IOP   Intelligent I/O Proce     14:10:52  Jan 12, 2026   Page   27FIO        Simulation Routines                        E3A2 34   76       FIO_get   pshs   d,x,y,u   save registers  E3A4 108E 015C     10        ldy    #FIO_lock is the device locked  E3A8 6D   A4                 tst    0,y  E3AA 27   07                 beq    20f       no - go get it                     *  E3AC C6   0F                 ldb    #FIOPRI   waiting for the FIO  E3AE BD   E6A9               jsr    sleep  E3B1 20   F1                 bra    10b       try again                     *  E3B3 6C   A4       20        inc    0,y       mark in use  E3B5 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIO_rel - Release access to FIO                     *  E3B7 34   76       FIO_rel   pshs   d,x,y,u  E3B9 108E 015C               ldy    #FIO_lock  E3BD 6F   A4                 clr    0,y  E3BF BD   E685               jsr    wakeup  E3C2 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIFO_get - Fetch character from FIFO                     *   B - Character fetched                     *  E3C4 34   04       FIFOgeta  pshs   b  E3C6 8D   05                 bsr    FIFO_get  E3C8 35   02                 puls   a  E3CA 1E   89                 exg    a,b  E3CC 39                      rts                     *  E3CD 34   12       FIFO_get  pshs   a,x  E3CF DC   12                 ldd    fifo_cnt  any data?  E3D1 27   15                 beq    99f       no - exit                     *  E3D3                         decd   yes       - adjust count  E3D5 DD   12                 std    fifo_cnt  E3D7 9E   14                 ldx    fifo_get  get consumer pointer  E3D9 E6   88 20              ldb    fifo,x    fetch byte  E3DC 30   01                 leax   1,x       bump pointer  E3DE BC   E062               cmpx   fio_fsz   end of fifo?  E3E1 26   03                 bne    10f                     *  E3E3 8E   0000               ldx    #0        reset pointer                     *  E3E6 9F   14       10        stx    fifo_get                     *  E3E8 35   92       99        puls   a,x,pc                                          *                     * FIFO_put - Place character into FIFO                     *   B - Character fetchedCPU09IOP   Intelligent I/O Proce     14:10:52  Jan 12, 2026   Page   28FIO        Simulation Routines                                           *  E3EA 34   04       FIFOputa  pshs   b  E3EC 1F   89                 tfr    a,b  E3EE 8D   02                 bsr    FIFO_put  E3F0 35   84                 puls   b,pc                     *  E3F2 34   16       FIFO_put  pshs   d,x  E3F4 9E   16                 ldx    fifo_put  get consumer pointer  E3F6 E7   88 20              stb    fifo,x    store byte  E3F9 30   01                 leax   1,x       bump pointer  E3FB BC   E062               cmpx   fio_fsz   end of FIFO?  E3FE 26   03                 bne    10f                     *  E400 8E   0000               ldx    #0        reset pointer  E403 9F   16       10        stx    fifo_put                     *  E405 DC   12                 ldd    fifo_cnt  E407                         incd  E409 DD   12                 std    fifo_cnt  E40B 35   96       99        puls   d,x,pcCPU09IOP   Intelligent I/O Proce     14:10:52  Jan 12, 2026   Page   29FIO        FIO IRQ code                                                                       *                     * FIO interrupt handler, called when IRQ was set (interrupt context)                     * for regular NWP and IOP purpose                     *  E40D BE   016B     fio_irq   ldx    int_ptr   input message pointer  E410 96   00                 lda    cpu_fio   move REQUEST  E412 A7   80                 sta    ,x+  E414 DC   01                 ldd    cpu_fio1  sequence # TASK ID  E416 ED   81                 std    ,x++  E418 96   03                 lda    cpu_fio2  specific DATA  E41A A7   80                 sta    ,x+  E41C DC   04                 ldd    cpu_fio3  device major/minor  E41E ED   81                 std    ,x++  E420 96   08                 lda    cpu_fio5  E422 A7   80                 sta    0,x+                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device, X[6]=devtab                     *  E424 FE   E064               ldu    fio_dsz  E427 33   5F                 leau   -1,u  E429 6F   C4                 clr    0,u       cpu_fioF indicate message consumed                     *  E42B BF   016B               stx    int_ptr   update pointer  E42E 108E 015D               ldy    #int_buf  get message from buffer  E432 A6   A4                 lda    0,y       -- Send interrupt command?  E434 81   38                 cmpa   #O_INTRPT  E436 26   0D                 bne    30f                     *                     * special case OOB signal                     *  E438 10BF 016B               sty    int_ptr   reset pointer  E43C E6   23                 ldb    3,y       signal  E43E AE   24                 ldx    4,y       DEVICE/SOCK reference                     *  E440 BD   EEA2               jsr    sdev_sig  send device signal  E443 20   38                 bra    fiointe   exit                     *                     * normal command                     * acquire free task slot                     *  E445 8E   0276     30        ldx    #tsktab   search for an available task  E448 D6   E0                 ldb    NUM_TSK   Number of tasks in system                     *  E44A A6   04       32        lda    tsstat,x  E44C 81   04                 cmpa   #TFREE    looking for a "free" task  E44E 27   0E                 beq    40f                     *  E450 30   89 00A2            leax   TSKSIZ,x  E454 5A                      decb  E455 26   F3                 bne    32b                     *CPU09IOP   Intelligent I/O Proce     14:10:53  Jan 12, 2026   Page   30FIO        FIO IRQ code                               E457 C6   82                 ldb    #E_SYSBSY can't process - IOP saturated!  E459 BD   E36A               jsr    fio_msg  E45C 20   1F                 bra    fiointe   exit                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device, X[6]=device table                     * move data over into task struct                     *  E45E 108E 015D     40        ldy    #int_buf  get message from buffer  E462 10BF 016B               sty    int_ptr   reset pointer  E466 E6   A0                 ldb    ,y+       command byte  REQUEST  E468 E7   09                 stb    tscmd,x   save for task  E46A EC   A1                 ldd    ,y++      sequence #    task ID  E46C ED   0A                 std    tsseq,x  E46E E6   A0                 ldb    ,y+       command specific DATA  E470 E7   0C                 stb    tstval,x  E472 EC   A1                 ldd    ,y++      associate with terminal major/minor  E474 ED   0D                 std    tsdev,x  E476 A6   A0                 lda    ,y+  E478 A7   0F                 sta    tsdtix,x  device table index  E47A BD   E66F               jsr    makrdy    make task ready to run                     *  E47D 39            fiointe   rts              exitCPU09IOP   Intelligent I/O Proce     14:10:53  Jan 12, 2026   Page   31IO         Command Handler                                               *                     *                     * IO_han - I/O Command Handler                     *                     *   This routine comprises the main processing loop                     * for each task in the system.  Whenever an I/O command                     * is detected (via the message interrupt), a task will                     * be scheduled to process it.  This is that task.                     *   The command is saved in the "tscmd" field of the                     * task control block.                     *  E47E               IO_han                     *                     * we execute the task belonging to the transaction                     *  E47E                         clri  E480 BE   0115               ldx    utask     get task control block address  E483 A6   09                 lda    tscmd,x   get I/O command  E485 E6   0F                 ldb    tsdtix,x  get device table selector                     *                     * The command byte is shifted and used as an index                     * in a DEV_XXXX tab, max 32 commands allowed                     *  E487 44                      lsra             isolate    command  E488 44                      lsra  E489 44                      lsra                     *  E48A C1   0D                 cmpb   #MAX_DEV  invalid device?  E48C 25   04                 blo    00f  E48E C6   84                 ldb    #E_BADDEV  E490 20   4F                 bra    20f                     *  E492 81   10       00        cmpa   #MAX_FCMD max. fifo commands  E494 25   04                 blo    01f  E496 C6   81                 ldb    #E_BADCMD  E498 20   47                 bra    20f                     *                     * build 16 bit index in table                     *  E49A 48            01        lsla             --   word index on command  E49B 34   02                 pshs   a  E49D 8E   027E               ldx    #dev_tab  E4A0 86   06                 lda    #DEV_SIZE  E4A2 3D                      mul  E4A3 30   8B                 leax   d,x       right table selected  E4A5 AE   02                 ldx    dev_type,x get handler table address  E4A7 35   02                 puls   a  E4A9 10AE 86                 ldy    a,x       get processor address  E4AC 34   20                 pshs   y         can be changed on stack..                     * Y=function code address  E4AE 10AE 88 10              ldy    tsagin,x  if 0, d nothing  E4B2 27   0B                 beq    05f       else it is target ponterCPU09IOP   Intelligent I/O Proce     14:10:53  Jan 12, 2026   Page   32IO         Command Handler                            E4B4 10AF E4                 sty    0,s       code asks for rerun, overwrite  E4B7 108E 0000               ldy    #0  E4BB 10AF 88 10              sty    tsagin,x  reset pointer                     *  E4BF 35   20       05        puls   y         change address  E4C1 4F                      clra                     *  E4C2 8E   E4E4               ldx    #IO_end   interrupt handler address  E4C5 34   10                 pshs   x  E4C7 BE   0115               ldx    utask     task pointer  E4CA 10EF 88 16              sts    umark1,x  E4CE EE   0D                 ldu    tsdev,x   get sock reference                     *                     * CALL HANDLER: X=utask, Y=handler address, U=device reference                     * can be maj/min or wzsock address                     *  E4D0 AD   A4                 jsr    0,y       perform operation & return status  E4D2 32   62                 leas   2,s       clean up stack                     *                     * on return, Y= flag. -1 is resched, else end task                     * B = status , A = danta, X,U are lost                     *  E4D4 BE   0115               ldx    utask     restore task pointer  E4D7 108C FFFF               cmpy   #$ffff  E4DB 26   04                 bne    20f                     * task is NOT done yet, don't stop it! re-schedule  E4DD                         seti   set       interrupt mask  E4DF 20   18                 bra    91f       just escape (and come back)                     *                     * A=transaction value, B=response code, U=device reference                     * X = task pointer                     * in fio_response the task ID is added as sequence reference                     * SEND the response to the host CPU                     *                     *  E4E1 BD   E386     20        jsr    fio_response                     *                     * task is done                     *  E4E4               IO_end    seti   mask      interrupts  E4E6 BE   0115               ldx    utask     restore task control block address  E4E9 A7   0C                 sta    tstval,x  remember transaction value sent  E4EB E7   09                 stb    tscmd,x   and command response  E4ED 86   04                 lda    #TFREE    mark task "terminated & free"  E4EF A7   04                 sta    tsstat,x  E4F1 86   FF                 lda    #$FF      disassociate from any terminal  E4F3 A7   0D                 sta    tsdev,x  E4F5 A7   0E                 sta    tsdev+1,x  E4F7 6F   08                 clr    tssgnl,x  no waiting signals                     *                     * exit here to rescheduling                     *CPU09IOP   Intelligent I/O Proce     14:10:54  Jan 12, 2026   Page   33IO         Command Handler                            E4F9 BD   E5C9     91        jsr    rsched    run other tasks  E4FC 16   FF7F               lbra   IO_han                                          *                     * not implemented                     *  E4FF C6   81       bad_cmd   ldb    #E_BADCMD error code  E501 39                      rtsCPU09IOP   Intelligent I/O Proce     14:10:54  Jan 12, 2026   Page   34Interrupt  Processing                                                                         *                     * This routine handles all IRQ interrupts                     *                     *  E502               IRQ_han                     *  E502 CE   027E     00        ldu    #dev_tab  scan devices  E505 CC   0000               ldd    #0        start with device 0                     *  E508 AE   C4       10        ldx    dev_addr,u get device address  E50A 27   0A                 beq    20f       jump if none there                     *  E50C 10AE 42                 ldy    dev_type,u get device type  E50F AD   B8 20    15        jsr    [D_inthan,y] call interrupt poller/handler >E512 1025 0017               lbcs   99f       exit if interrupt serviced                     *  E516 C3   0001     20        addd   #1        next device  E519 33   46                 leau   DEV_SIZE,u  E51B 1083 000D               cmpd   #MAX_DEV  any more devices?  E51F 25   E7                 blo    10b                                          *                     * Check for FIO Mailbox interrupt                     *  E521 FE   E064               ldu    fio_dsz  E524 33   5F                 leau   -1,u      top location  E526 A6   C4                 lda    0,u       cpu_fioF   see if mailbox interrupt  E528 27   03                 beq    99f       no - move on  E52A BD   E40D               jsr    fio_irq                                          *         lbsr    DB_main                     *  E52D 39            99        rts              return from interrupt                     *CPU09IOP   Intelligent I/O Proce     14:10:54  Jan 12, 2026   Page   35Interrupt  All Tasks                                                                          *                     * Interrupt all tasks associated with a given device                     *   D - Device #, XL = SIG                     *   jsr int_all                     * Note: The current task is skipped, along with                     * the system and the interrupt handler task (1).                     *  E52E 34   36       int_all   pshs   d,x,y  E530 D6   E0                 ldb    NUM_TSK  E532 C0   02                 subb   #2  E534 34   04                 pshs   b  E536 BE   0276               ldx    tsktab  E539 30   89 0144            leax   2*TSKSIZ,x                     *  E53D EC   61       10        ldd    1,s  E53F 10A3 0D                 cmpd   tsdev,x   is this guy associated with the device?  E542 26   0E                 bne    20f                     *  E544 BC   0115               cmpx   utask     make sure I don't get blown away  E547 27   09                 beq    20f                     *  E549 34   16                 pshs   d,x                     * B = signal #  E54B E6   64                 ldb    4,s       XL  E54D BD   E6DE               jsr    xmtint    interrupt task  E550 35   16                 puls   d,x                     *  E552 30   89 00A2  20        leax   TSKSIZ,x  next task  E556 6A   E4                 dec    0,s       more tasks?  E558 26   E3                 bne    10b  E55A 32   61                 leas   1,s                     *  E55C 35   B6                 puls   d,x,y,pc  returnCPU09IOP   Intelligent I/O Proce     14:10:54  Jan 12, 2026   Page   36Generic Signal Handling Task                                                                  *                     * SI_HAN Signal interrupt handler                     *  E55E 108E 011E     SI_HAN    ldy    #SI_Q     Terminal Interrupt Queue  E562                         seti  E564 FE   015A               ldu    SI_Q_ptr  get current Q ptr  E567 1183 011E               cmpu   #SI_Q     anything in Q?  E56B 26   07                 bne    20f       yes - go process it                     *  E56D C6   D8                 ldb    #SIQPRI   wait for something to do  E56F BD   E6A9               jsr    sleep  E572 20   EA                 bra    SI_HAN                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *  E574 E6   C2       20        ldb    0,-u      B = Interrupt #  E576 34   04                 pshs   b  E578 EC   C3                 ldd    0,--u     A = Device #  E57A 34   06                 pshs   d  E57C EC   C3                 ldd    0,--u     task ID  E57E 34   06                 pshs   d         save registers  E580 FF   015A               stu    SI_Q_ptr  update pointer                     *                     * S[0][1]=task,U[2][3]=dev,U[4]=response                     *  E583 E6   63                 ldb    3,s       set up to flush all input for this terminal  E585                         clri   allow     interrupts                     *  E587 BD   E3A2               jsr    FIO_get   get access to FIO  E58A EC   E1                 ldd    0,s++     task ID  E58C DD   0A                 std    fio_cpu1  E58E EC   E1                 ldd    ,s++      terminal #  E590 DD   0D                 std    fio_cpu3  terminal  E592 E6   E0                 ldb    ,s+       interrupt #  E594 D7   0C                 stb    fio_cpu2  signal  E596 C6   07                 ldb    #R_INTRPT  E598 BD   E36A               jsr    fio_msg   send interrupt message  E59B BD   E3B7               jsr    FIO_rel   release access to FIO  E59E 20   BE                 bra    SI_HAN    process more if needed                                          *                     * Send_SI - Send a Signal interrupt                     *   B = Interrupt #                     *   X = task struct                     *   jsr send_SI                     *  E5A0 34   76       send_SI   pshs   d,x,y,u   save registers  E5A2 FE   015A               ldu    SI_Q_ptr  get Q head  E5A5 1183 015A               cmpu   #SI_Q_ptr check for overflow  E5A9 24   0F                 bhs    90f       exit if so - sorry                     *CPU09IOP   Intelligent I/O Proce     14:10:54  Jan 12, 2026   Page   37Generic Signal Handling Task                          E5AB EC   0A                 ldd    tsseq,x   task ID @ master side  E5AD ED   C1                 std    0,u++  E5AF EC   0D                 ldd    tsdev,x   device #  E5B1 ED   C1                 std    0,u++     place value in Queue  E5B3 E6   61                 ldb    1,s       old B  E5B5 E7   C0                 stb    0,u+  E5B7 FF   015A               stu    SI_Q_ptr  update pointer                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *                     *  E5BA 108E 011E     90        ldy    #SI_Q     wake up Queue server  E5BE BD   E685               jsr    wakeup  E5C1 35   F6       99        puls   d,x,y,u,pc returnCPU09IOP   Intelligent I/O Proce     14:10:54  Jan 12, 2026   Page   38Scheduler  routines                                                                           *                     * All routines in this file pertain to scheduling                     * operations.                     *                                          *                     * change & rsched                     *                     * Change will change tasks.  The current task is put                     * back on the linked list of running tasks.                     * Rsched will reschedule the cpu giving control to                     * another ready task.  If no tasks are ready, idle                     * looping is done until one becomes ready.  Rsched                     * does not put the current task back on the ready list!                     * This routine returns one to the caller.  All registers                     * are destroyed.                     *                       E5C3 BE   0115     change    ldx    utask     point to task table entry >E5C6 17   006D               lbsr   putrun    put on ready list                     *  E5C9               rsched    seti   mask      interrupts  E5CB BE   0115               ldx    utask     point to current task  E5CE 10EF 88 14              sts    umark0,x  save stack pointers  E5D2 BE   0276               ldx    tsktab    point to task table  E5D5 8D   23                 bsr    swtchu    switch users  E5D7 7F   011D               clr    idle      reset idle/running flag                     *  E5DA 7F   0118     rsche2    clr    chproc    reset change flag >E5DD 17   0025               lbsr   getjob    get a new task  E5E0 26   0C                 bne    rsche3    find one?                       E5E2 86   7F       05        lda    #127      set higheset priority  E5E4 B7   0117               sta    jobpri    set as current  E5E7                         clri   clear     interrupts                     * idle work could go on here  E5E9 12                      nop  E5EA                         seti  E5EC 20   EC                 bra    rsche2    loop til find a ready one                     *  E5EE F7   0117     rsche3    stb    jobpri    set new priority  E5F1 8D   07                 bsr    swtchu    switch users top page  E5F3 BE   0115               ldx    utask     point to task                     ** -- I don't think this will ever happen                     ** tst tssgnl,x any waiting signals?                     ** lbne sleep yes - this will blow task away...  E5F6 CC   0001               ldd    #1        return 1 to new task  E5F9 39                      rts              return                                          *                     * Switch usersCPU09IOP   Intelligent I/O Proce     14:10:55  Jan 12, 2026   Page   39Scheduler  routines                                                      *   X - Task entry for new task                     *  E5FA 35   20       swtchu    puls   y         get return address  E5FC BF   0115               stx    utask     set up new running task  E5FF 10EE 88 14              lds    umark0,x  reset stack  E603 6E   A4                 jmp    0,y       return to caller                     CPU09IOP   Intelligent I/O Proce     14:10:55  Jan 12, 2026   Page   40Scheduler  routines                                                                           *                     * getjob                     *                     * Search ready list for ready task.  If none found,                     * return 'EQ' status.  Otherwise return task table                     * entry address in x.                     *                       E605 5F            getjob    clrb             clear      flag  E606 BE   010F               ldx    runlst    point to head of list  E609 27   1F                 beq    getjo6    empty list?                     *  E60B A6   04       getjo1    lda    tsstat,x  get status byte  E60D 81   01                 cmpa   #TRUN     is it in run state?  E60F 26   1B                 bne    getjo8                     *  E611 5D                      tstb             first      in list?  E612 27   06                 beq    getjo2                     *  E614 EC   84                 ldd    tslink,x  remove from list  E616 ED   A4                 std    tslink,y  E618 20   07                 bra    getjo4                     *  E61A 10AE 84       getjo2    ldy    tslink,x  remove from list head  E61D 10BF 010F               sty    runlst    set new head                     *  E621 E6   05       getjo4    ldb    tsprir,x  get priority  E623 6F   84                 clr    tslink,x  zero out link  E625 6F   01                 clr    tslink+1,x so not run list  E627 86   FF                 lda    #$ff      set ne status  E629 39                      rts              return                     *  E62A 4F            getjo6    clra             set        eq status  E62B 39                      rts                     *  E62C 1F   12       getjo8    tfr    x,y       save old pos  E62E AE   84                 ldx    tslink,x  follow link  E630 27   F8                 beq    getjo6                     *  E632 C6   01                 ldb    #1        set flag  E634 20   D5                 bra    getjo1    repeat loop                     CPU09IOP   Intelligent I/O Proce     14:10:55  Jan 12, 2026   Page   41Scheduler  routines                                                                           *                     * putrun                     *                     * Put current task on ready list.  The list is                     * arranged with higher priority tasks at the top.                     * If equal priorities are found, the new one is                     * put at the end of the block.  On entry, x points                     * to the task table entry.  All registers are                     * destroyed except x.                     *                       E636 34   01       putrun    pshs   cc        save status  E638                         seti   mask      interrupts  E63A 10BE 010F               ldy    runlst    point to head  E63E 26   0A                 bne    putru2  E640 BF   010F               stx    runlst    set new head                     *  E643 CC   0000     putru1    ldd    #0        set last link  E646 ED   84                 std    tslink,x  E648 35   81                 puls   cc,pc     return                     *  E64A E6   05       putru2    ldb    tsprir,x  get priority  E64C E1   25                 cmpb   tsprir,y  look for correct prior slot  E64E 2F   08                 ble    putru4                     *  E650 FC   010F               ldd    runlst  E653 BF   010F               stx    runlst    set new head  E656 20   0F                 bra    putru5    link in rest                     *  E658 1F   23       putru4    tfr    y,u       save last look  E65A 10AE A4                 ldy    tslink,y  follow link  E65D 27   0C                 beq    putru6                     *  E65F E1   25                 cmpb   tsprir,y  check priority  E661 2F   F5                 ble    putru4                     *  E663 EC   C4                 ldd    tslink,u  link into list here  E665 AF   C4                 stx    tslink,u                     *  E667 ED   84       putru5    std    tslink,x  E669 35   81                 puls   cc,pc     return                     *  E66B AF   C4       putru6    stx    tslink,u  E66D 20   D4                 bra    putru1    go zero last link                     CPU09IOP   Intelligent I/O Proce     14:10:55  Jan 12, 2026   Page   42Scheduler  routines                                                                           *                     * makrdy                     *                     * Make a task ready to run.  Enter with x                     * pointing to task table entry.  If new tasks                     * priority is higher than current, set the                     * 'chproc' flag so the system can change tasks.                     *                       E66F 86   01       makrdy    lda    #TRUN     set status  E671 A7   04                 sta    tsstat,x  E673 CC   0000               ldd    #0        clear events flag  E676 ED   06                 std    tsevnt,x  E678 8D   BC                 bsr    putrun    put on ready list  E67A E6   05                 ldb    tsprir,x  get priority  E67C F1   0117               cmpb   jobpri    higher than current?  E67F 2F   03                 ble    makrd6                     *  E681 7C   0118               inc    chproc    set change flag                     *  E684 39            makrd6    rts              returnCPU09IOP   Intelligent I/O Proce     14:10:56  Jan 12, 2026   Page   43Sleep      and Wakeup routines                                                                *                     * wakeup                     *                     * Wakeup all tasks waiting the event designated                     * in the y register.  The x reg is preserved.                     *                       E685 34   57       wakeup    pshs   cc,d,x,u  save registers  E687                         seti   mask      interupts  E689 CE   0111               ldu    #slplst  E68C AE   42                 ldx    tsslnk,u  point to sleep list  E68E 27   0B                 beq    wakeu4                     *  E690 10AC 06       wakeu2    cmpy   tsevnt,x  check event  E693 27   08                 beq    wakeu5  E695 33   84                 leau   0,x       mark this entry                     *  E697 AE   02       wakeu3    ldx    tsslnk,x  follow chain  E699 26   F5                 bne    wakeu2    end of list?                     *  E69B 35   D7       wakeu4    puls   cc,d,x,u,pc return                     *  E69D 34   70       wakeu5    pshs   x,y,u     save registers  E69F EC   02                 ldd    tsslnk,x  remove from list  E6A1 ED   42                 std    tsslnk,u  E6A3 8D   CA                 bsr    makrdy    put on ready list  E6A5 35   70                 puls   u,x,y  E6A7 20   EE                 bra    wakeu3    repeat                     CPU09IOP   Intelligent I/O Proce     14:10:56  Jan 12, 2026   Page   44Sleep      and Wakeup routines                                                                *                     * sleep                     *                     * Sleep will put this task to sleep with priority                     * specified in the b register.  On entry, y is pointing                     * to the event which will be awakened.                     *  E6A9 34   51       sleep     pshs   cc,x,u    save registers  E6AB BE   0115               ldx    utask     point to task  E6AE 6D   08                 tst    tssgnl,x  any signals waiting?  E6B0 26   1F                 bne    sleep7                     *  E6B2                         seti   mask      ints  E6B4 E7   05                 stb    tsprir,x  set priority  E6B6 10AF 06                 sty    tsevnt,x  set event  E6B9 86   02                 lda    #TSLEEP   set status  E6BB A7   04                 sta    tsstat,x  E6BD FC   0113               ldd    slplst+tsslnk get head of list  E6C0 ED   02                 std    tsslnk,x  set new link  E6C2 BF   0113               stx    slplst+tsslnk set new head  E6C5 17   FF01               lbsr   rsched    reschedule cpu                       E6C8 BE   0115     20        ldx    utask     get task entry  E6CB 6D   08                 tst    tssgnl,x  any signals waiting?  E6CD 26   02                 bne    sleep7                     *  E6CF 35   D1                 puls   cc,x,u,pc return                     *  E6D1 BE   0115     sleep7    ldx    utask     reset signal  E6D4 6F   08                 clr    tssgnl,x  E6D6 EC   88 16              ldd    umark1,x  stack reset point  E6D9 35   51                 puls   cc,x,u    reset cc and registers  E6DB 1F   04                 tfr    d,s       change stacks  E6DD 39                      rts              returnCPU09IOP   Intelligent I/O Proce     14:10:56  Jan 12, 2026   Page   45Sleep      and Wakeup routines                                                                *                     * xmtint - Send an interrupt to a task                     *  X - Task entry                     *  B - signal#                     *  jsr xmtint                     *  E6DE 34   76       xmtint    pshs   d,x,y,u   save registers  E6E0 A6   04                 lda    tsstat,x  get task state  E6E2 81   01                 cmpa   #TRUN     running?  E6E4 26   04                 bne    10f       no - try something else                     *  E6E6 E7   08                 stb    tssgnl,x  set signal  E6E8 20   0C                 bra    99f       exit                     *  E6EA 81   02       10        cmpa   #TSLEEP   task sleeping?  E6EC 26   08                 bne    99f       no - can't send interrupt                     *  E6EE E7   08                 stb    tssgnl,x  set signal  E6F0 10AE 06                 ldy    tsevnt,x  wake task up >E6F3 17   FF8F               lbsr   wakeup                     *  E6F6 35   F6       99        puls   d,x,y,u,pc returnCPU09IOP   Intelligent I/O Proce     14:10:56  Jan 12, 2026   Page   46Clist      - Get & Put Char Code                                                              *                     * getc                     *                     * Get a character from a specified character q.                     * The q is pointed to by y upon entry.  The char                     * is returned in b.                     *                       E6F8 34   15       getc      pshs   x,b,cc    save x  E6FA                         seti  E6FC AE   21                 ldx    clfst,y   get first pointer  E6FE 27   3A                 beq    getc4  E700 E6   80                 ldb    0,x+      get character  E702 E7   61                 stb    1,s  E704 AF   21                 stx    clfst,y   save new ptr  E706 6A   A4                 dec    clcnt,y   dec the count  E708 26   09                 bne    getc1  E70A CC   0000               ldd    #0        zero pointers  E70D ED   21                 std    clfst,y  E70F ED   23                 std    cllst,y  E711 20   0E                 bra    getc2  E713 1F   10       getc1     tfr    x,d  E715 C5   1F                 bitb   #CBSIZE-1 check pointer  E717 26   1C                 bne    getc3  E719 EC   88 E0              ldd    -CBSIZE,x  E71C C3   0002               addd   #2  E71F ED   21                 std    clfst,y   set new first  E721 1F   10       getc2     tfr    x,d  E723 83   0001               subd   #1  E726 C4   E0                 andb   #!(CBSIZE-1) check pointer  E728 1F   01                 tfr    d,x       reset  E72A FC   0119               ldd    cfreel    get free block  E72D ED   84                 std    0,x       set link  E72F BF   0119               stx    cfreel  E732 7A   011B               dec    cbufct    dec the buffer count  E735 35   01       getc3     puls   cc  E737 4F                      clra  E738 35   94                 puls   b,x,pc  E73A 35   01       getc4     puls   cc  E73C 86   FF                 lda    #$ff      set -1  E73E 35   94                 puls   b,x,pc                     CPU09IOP   Intelligent I/O Proce     14:10:57  Jan 12, 2026   Page   47Clist      - Get & Put Char Code                                                              *                     * putc                     *                     * Put a character on the specified q.  The q is                     * pointed to by y upon entry and the character                     * should be in b.                     *                       E740 34   15       putc      pshs   x,b,cc  E742                         seti  E744 AE   23                 ldx    cllst,y   get tail pointer  E746 26   16                 bne    putc1  E748 BE   0119               ldx    cfreel    get free list  E74B 27   43                 beq    putc4  E74D EC   84                 ldd    0,x       pickup pointer  E74F FD   0119               std    cfreel  E752 7C   011B               inc    cbufct    update buffer count  E755 CC   0000               ldd    #0        zero fwd link  E758 ED   81                 std    0,x++  E75A AF   21                 stx    clfst,y   set first  E75C 20   23                 bra    putc2  E75E 1F   10       putc1     tfr    x,d       mask pointer  E760 C5   1F                 bitb   #CBSIZE-1  E762 26   1D                 bne    putc2  E764 34   20                 pshs   y  E766 10BE 0119               ldy    cfreel    get free list  E76A 27   22                 beq    putc3  E76C EC   A4                 ldd    0,y       get pointer  E76E FD   0119               std    cfreel    save new head  E771 7C   011B               inc    cbufct    update buffer count  E774 10AF 88 E0              sty    -CBSIZE,x  E778 1F   21                 tfr    y,x  E77A 35   20                 puls   y  E77C CC   0000               ldd    #0        clear fwd link  E77F ED   81                 std    0,x++  E781 E6   61       putc2     ldb    1,s       get character  E783 E7   80                 stb    0,x+      put in q  E785 AF   23                 stx    cllst,y   save last ptr  E787 6C   A4                 inc    clcnt,y   update character count  E789 35   01                 puls   cc  E78B 4F                      clra  E78C 35   94                 puls   b,x,pc    return  E78E 35   20       putc3     puls   y  E790 35   01       putc4     puls   cc  E792 86   FF                 lda    #$ff      set error  E794 35   94                 puls   b,x,pc                     CPU09IOP   Intelligent I/O Proce     14:10:57  Jan 12, 2026   Page   48Output     Q Handling                                                                         *                     * get_oq                     *                     * Fetch the next character from the output Q                     *   Y - Output Queue Header                     *   jsr get_oq                     *   B - Character                     *   <EQ> if Queue was not empty                     *  E796 34   13       get_oq    pshs   cc,a,x    save registers  E798                         seti   no        interrupts allowed!  E79A EC   A4                 ldd    oq_count,y  E79C 27   16                 beq    20f       Queue empty  E79E 83   0001               subd   #1  E7A1 ED   A4                 std    oq_count,y update counter  E7A3 AE   26                 ldx    oq_get,y  source pointer  E7A5 E6   80                 ldb    ,x+       get data  E7A7 AC   28                 cmpx   oq_end,y  buffer overflow?  E7A9 25   02                 blo    10f       no - continue  E7AB AE   22                 ldx    oq_buf,y  yes - reset pointer  E7AD AF   26       10        stx    oq_get,y  update pointer  E7AF 35   01                 puls   cc  E7B1 4F                      clra             Queue not empty  E7B2 35   92                 puls   a,x,pc    return  E7B4 35   01       20        puls   cc  E7B6 86   FF                 lda    #$FF      Queue empty  E7B8 35   92                 puls   a,x,pc                     CPU09IOP   Intelligent I/O Proce     14:10:57  Jan 12, 2026   Page   49Output     Q Handling                                                                         *                     * put_oq                     *                     * Put a character into an output Q                     *    Y - Output Q header                     *    B - Character to insert                     *    jsr put_oq                     *  E7BA 34   17       put_oq    pshs   cc,d,x    save registers  E7BC                         seti   no        interrupts  E7BE AE   24                 ldx    oq_put,y  get pointer  E7C0 E7   80                 stb    ,x+       put data into Q  E7C2 AC   28                 cmpx   oq_end,y  buffer overflow?  E7C4 25   02                 blo    10f       no - continue  E7C6 AE   22                 ldx    oq_buf,y  yes - reset pointer  E7C8 AF   24       10        stx    oq_put,y  save new pointer  E7CA EC   A4                 ldd    oq_count,y update count  E7CC C3   0001               addd   #1  E7CF ED   A4                 std    oq_count,y  E7D1 35   97                 puls   cc,d,x,pc returnCPU09IOP   Intelligent I/O Proce     14:10:57  Jan 12, 2026   Page   50Terminal   Drivers                                                                            *                     * The routines in this file make up the main system                     * terminal drivers.  Most of the work is actually                     * performed by other internal routines.                     *                                          *                     * ttopn                     *                     * Open a terminal for use.  On entry, U has                     * the device number.                     *                       E7D3 34   06       ttopn     pshs   d         save device number  E7D5 BD   E864               jsr    ttftab    get table address  E7D8 25   11                 bes    30f  E7DA A6   88 14              lda    tstate,x  get states  E7DD 85   04                 bita   #TOPEN    is it already open?  E7DF 26   02                 bne    ttopn8  E7E1 8D   0D                 bsr    ttdopn    do actual open  E7E3 10AE 06       ttopn8    ldy    taddr,x   point to device  E7E6 AD   D8 30              jsr    [D_ttenr,u] enable rcv interrupts  E7E9 35   86                 puls   d,pc      return  E7EB 32   62       30        leas   2,s       drop D  E7ED 16   05EA               lbra   tterxt                                          *                     * ttdopn                     *                     * Do actual terminal open.  X points to tty entry.                     *                       E7F0 10AE 06       ttdopn    ldy    taddr,x   get device address  E7F3 6F   88 16              clr    tstate3,x  E7F6 34   10                 pshs   x  E7F8 BE   0115               ldx    utask  E7FB EC   0A                 ldd    tsseq,x  E7FD 35   10                 puls   x  E7FF ED   0C                 std    ttask,x  E801 AD   D8 26    10        jsr    [D_ttconf,u] configure the port                     * response of NE implies open OK                                          * if EQ then blocked by CTS if Carry is 0  E804 26   18                 bne    ttdop6    is it ready?  E806 25   0B                 bcs    ttdop5    branch if blocked by DCD  E808 34   31                 pshs   cc,x,y    save regs  E80A                         seti   mask      ints  E80C AD   D8 4A              jsr    [D_ttwcts,u] wait for CTS  E80F 35   31                 puls   cc,x,y    reset regs  E811 20   DD                 bra    ttdopn    repeat open  E813 34   31       ttdop5    pshs   cc,x,y    save regsCPU09IOP   Intelligent I/O Proce     14:10:58  Jan 12, 2026   Page   51Terminal   Drivers                                    E815                         seti   mask      ints  E817 AD   D8 4C              jsr    [D_ttwdcd,u] wait for DCD  E81A 35   31                 puls   cc,x,y    reset regs  E81C 20   D2                 bra    ttdopn    repeat open  E81E 86   36       ttdop6    lda    #ECHO|XTABS|CRMOD|BSECH  E820 A7   08                 sta    tflags,x  setup initial mode  E822 86   7F                 lda    #BSPCH    get backspace char  E824 A7   88 10              sta    tbksp,x   save in table  E827 86   18                 lda    #CNCLC    get cancel character  E829 A7   88 11              sta    tcncl,x   save in table  E82C A6   88 14              lda    tstate,x  set OPEN flag  E82F 8A   04                 ora    #TOPEN    set open status  E831 A7   88 14              sta    tstate,x  save in table  E834 86   01                 lda    #DSR_OK   allow transmitting  E836 A7   88 15              sta    tstate2,x  E839 39                      rts              return                     CPU09IOP   Intelligent I/O Proce     14:10:58  Jan 12, 2026   Page   52Terminal   Drivers                                                                            *                     * ttcls                     *                     * Close the terminal whode device number is in U.                     *                       E83A 8D   28       ttcls     bsr    ttftab    find table entry  E83C 1025 059A               lbes   tterxt    invalid  E840 A6   88 14              lda    tstate,x  was the port actually open?  E843 85   04                 bita   #TOPEN  E845 27   0E                 beq    10f       no - skip flush  E847 84   FB                 anda   #!TOPEN   yes - clear bit  E849 A7   88 14              sta    tstate,x  ... so we don't get hung up ...  E84C 17   03F3               lbsr   flusho    flush out buffers  E84F 10AE 06                 ldy    taddr,x   get device address  E852 AD   D8 34              jsr    [D_ttenno,u] close down the port  E855 A6   88 14    10        lda    tstate,x  clear state bits  E858 84   F8                 anda   #PROTOCOL preserve protocol flags  E85A A7   88 14              sta    tstate,x  E85D 6F   88 15              clr    tstate2,x  E860 6F   88 16              clr    tstate3,x  E863 39                      rts                                          *                     * ttftab                     *                     * Find tty table entry associated with device in U.                     * Exit with entry pointed at by X.                     * exit with Y point to devtab entry                     * Also compute device handler table in U.                     *                       E864 1F   30       ttftab    tfr    u,d  E866 D1   E2                 cmpb   NUM_TRM   valid tty?  E868 24   1A                 bhs    30f                     *                     * device reference now in D                     *  E86A 34   06       ttftb2    pshs   d  E86C BE   0270               ldx    TTYTABS   point to table  E86F 86   22                 lda    #TTYSIZ   set size up  E871 3D                      mul              calculate  offset  E872 30   8B                 leax   d,x       point to entry  E874 35   06                 puls   d                     * TODO , use tsdvti  correctly  E876 108E 027E               ldy    #dev_tab  E87A 86   06                 lda    #DEV_SIZE  E87C 3D                      mul  E87D 31   AB                 leay   d,y  E87F EE   22                 ldu    dev_type,y get handler table address                     *CPU09IOP   Intelligent I/O Proce     14:10:58  Jan 12, 2026   Page   53Terminal   Drivers                                    E881 1C   FE                 clc              clear error  E883 39                      rts              return                     *  E884 C6   84       30        ldb    #E_BADDEV  E886 4F                      clra  E887 1A   01                 sec              set error  E889 39                      rts              return                     CPU09IOP   Intelligent I/O Proce     14:10:58  Jan 12, 2026   Page   54Terminal   Drivers                                                                            *                     * tintr                     *                     * TTY interrupt handler.  Determine if the interrupt                     * is a receive or transmit one and take appropriate                     * actions.                     *                       E88A 8D   DE       tintr     bsr    ttftb2    calculate table addresses  E88C 10AE 06                 ldy    taddr,x   get device address  E88F 34   20       01        pshs   y         save port address  E891 EC   64                 ldd    4,s       fetch device status (if present)                       E893 AD   D8 3C              jsr    [D_tttstr,u] test for rcv int  E896 26   20                 bne    tintr2                       E898 AD   D8 3E              jsr    [D_tttstb,u] test for break interrupt  E89B 26   39                 bne    tintr5                       E89D AD   D8 42              jsr    [D_tttstc,u] test drop carrier int  E8A0 26   3C                 bne    tintr6                       E8A2 AD   D8 40              jsr    [D_tttsts,u] test CTS change interrupt  E8A5 26   5F                 bne    tintr9                       E8A7 AD   D8 44              jsr    [D_tttstd,u] test dsr change  E8AA 26   41                 bne    tintr8                       E8AC AD   D8 38              jsr    [D_tttstx,u] test for xmit int  E8AF 26   0F                 bne    tintr3                       E8B1 AD   D8 46              jsr    [D_tttste,u] test error int  E8B4 26   30                 bne    tintr7    ** should be 7? **                       E8B6 20   4E                 bra    tintr9  E8B8 AD   D8 2A    tintr2    jsr    [D_ttgetc,u] get character from port  E8BB BD   EB1E               jsr    ttyin     go buffer char  E8BE 20   46                 bra    tintr9  E8C0 BD   EA1A     tintr3    jsr    ttyst     go output another char  E8C3 EC   98 04              ldd    [tqout,x] check queue count  E8C6 27   06                 beq    tintr4  E8C8 10B3 0104               cmpd   OQLO      low water mark?  E8CC 26   38                 bne    tintr9  E8CE 10AE 04       tintr4    ldy    tqout,x   get output queue  E8D1 BD   E685               jsr    wakeup  E8D4 20   30                 bra    tintr9  E8D6 CC   0002     tintr5    ldd    #INTS     set INT interrupt  E8D9 BD   E5A0               jsr    send_SI   send interrupt  E8DC 20   28                 bra    tintr9  E8DE CC   0001     tintr6    ldd    #HANGS    set hangup unt  E8E1 BD   E5A0               jsr    send_SI   send interruptCPU09IOP   Intelligent I/O Proce     14:10:58  Jan 12, 2026   Page   55Terminal   Drivers                                    E8E4 20   20                 bra    tintr9  E8E6 C6   07       tintr7    ldb    #$07      set bell char  E8E8 BD   EB1E               jsr    ttyin     go buffer it  E8EB 20   19                 bra    tintr9    exit  E8ED A6   88 15    tintr8    lda    tstate2,x get state  E8F0 85   01                 bita   #DSR_OK   was it OK to send before?  E8F2 27   0A                 beq    85f       no - must be now  E8F4 84   FE                 anda   #!DSR_OK  don't allow any sending  E8F6 A7   88 15              sta    tstate2,x  E8F9 AD   D8 2E              jsr    [D_ttdisx,u] disable transmitter  E8FC 20   08                 bra    tintr9    exit  E8FE 8A   01       85        ora    #DSR_OK   allow transmitting  E900 A7   88 15              sta    tstate2,x  E903 BD   EA02               jsr    ttyren    restart transmission  E906 35   20       tintr9    puls   y         restore port address  E908 6E   D8 48              jmp    [D_ttend,u] clean up the port & return                     CPU09IOP   Intelligent I/O Proce     14:10:59  Jan 12, 2026   Page   56Terminal   Drivers                                                                            *                     * ttyset/ttyget                     *                     * Handle the actual get or put of data for ttyset                     * and ttyget.                     *                       E90B 17   FF56     ttyset    lbsr   ttftab    get tty table address  E90E 1025 04C8               lbes   tterxt  E912 17   FAAF               lbsr   FIFOgeta  move data from FIFO  E915 E6   08                 ldb    tflags,x  save current flags  E917 A7   08                 sta    tflags,x  set flags  E919 C5   41                 bitb   #RAW|SCHR currently in RAW or Single Character mode?  E91B 26   21                 bne    10f       yes - no change  E91D 85   41                 bita   #RAW|SCHR going to one of those modes?  E91F 27   1D                 beq    10f       no - continue  E921 6D   94                 tst    [tqin,x]  any unsolicited input?  E923 27   06                 beq    00f       no - continue  E925 6D   0E                 tst    tdel,x    any delimiters?  E927 27   02                 beq    00f  E929 6C   0E                 inc    tdel,x    force a delimiter  E92B 85   01       00        bita   #RAW      going into RAW mode?  E92D 27   0F                 beq    10f       no  E92F A6   88 14              lda    tstate,x  yes - no HOLD processing in RAW mode  E932 85   02                 bita   #HOLD     currently holding?  E934 27   08                 beq    10f       no - continue  E936 84   FD                 anda   #!HOLD  E938 A7   88 14              sta    tstate,x  E93B 17   00C4               lbsr   ttyren    kick output  E93E 17   FA83     10        lbsr   FIFOgeta  move data from FIFO  E941 A7   09                 sta    tdelay,x  set delays  E943 17   FA7E               lbsr   FIFOgeta  move data from FIFO  E946 A7   88 11              sta    tcncl,x   set cancel char  E949 17   FA78               lbsr   FIFOgeta  move data from FIFO  E94C A7   88 10              sta    tbksp,x   set back space char  E94F 17   FA72               lbsr   FIFOgeta  move data from FIFO  E952 84   7F                 anda   #$7F  E954 A7   88 12              sta    tbaud,x   set bauds  E957 17   FA6A               lbsr   FIFOgeta  move data from FIFO  E95A 34   02                 pshs   a  E95C 84   F8                 anda   #PROTOCOL save protocol bits  E95E 34   02                 pshs   a  E960 A6   88 14              lda    tstate,x  update state  E963 84   07                 anda   #(!PROTOCOL)&$FF clear current bits  E965 AA   E0                 ora    ,s+       set new bits  E967 A7   88 14              sta    tstate,x  E96A 35   02                 puls   a  E96C 84   0F                 anda   #$0F      get baud rate  E96E 34   02                 pshs   a  E970 A6   88 13              lda    tbaud2,x  update baud rate  E973 84   F0                 anda   #$F0CPU09IOP   Intelligent I/O Proce     14:10:59  Jan 12, 2026   Page   57Terminal   Drivers                                    E975 AA   E0                 ora    ,s+  E977 A7   88 13              sta    tbaud2,x                     *  E97A C6   0D                 ldb    #R_TTY    return TTYSET OK  E97C 39                      rts              return                       E97D 17   FEE4     ttyget    lbsr   ttftab    get table address  E980 1025 0456               lbes   tterxt  E984 A6   08                 lda    tflags,x  get flags byte  E986 17   FA61               lbsr   FIFOputa  put data into FIFO  E989 A6   09                 lda    tdelay,x  get delays  E98B 17   FA5C               lbsr   FIFOputa  put data into FIFO  E98E A6   88 11              lda    tcncl,x   get cancel char  E991 17   FA56               lbsr   FIFOputa  put data into FIFO  E994 A6   88 10              lda    tbksp,x   get b.s. char  E997 17   FA50               lbsr   FIFOputa  put data into FIFO  E99A A6   88 12              lda    tbaud,x   get bauds  E99D 84   7F                 anda   #$7F  E99F 6D   0E                 tst    tdel,x    check delimiter count  E9A1 26   05                 bne    ttys45  E9A3 6D   98 02              tst    [tqproc,x] any chars in processed queue?  E9A6 27   02                 beq    ttysg5  E9A8 8A   80       ttys45    ora    #%10000000 set del bit  E9AA 17   FA3D     ttysg5    lbsr   FIFOputa  put data into FIFO  E9AD A6   88 14              lda    tstate,x  return protocol bits  E9B0 84   F8                 anda   #PROTOCOL  E9B2 34   02                 pshs   a  E9B4 A6   88 13              lda    tbaud2,x  get baud rate  E9B7 84   0F                 anda   #$0F  E9B9 AA   E0                 ora    ,s+  E9BB 17   FA2C               lbsr   FIFOputa  put data into FIFO                     *  E9BE C6   0D                 ldb    #R_TTY    response = TTYGET = OK  E9C0 39                      rts              return                                          *                     * get_pdat, get special port data                     *                     * X=utask, Y=handler address, U=device reference               E9C1  get_pdat  equ    *  E9C1 17   FEA0               lbsr   ttftab    get terminal base info  E9C4 1025 0412               lbes   tterxt                     * X=processing code, Y=devtab entry  E9C8 34   36                 pshs   d,x,y                     * extra device table entry....  E9CA AE   24                 ldx    dev_brbu,y baudrate backup  E9CC A6   84                 lda    0,x       get baud info  E9CE BD   E3EA               jsr    FIFOputa  E9D1 4F                      clra  E9D2 BD   E3EA               jsr    FIFOputa  E9D5 BD   E3EA               jsr    FIFOputa  E9D8 BD   E3EA               jsr    FIFOputaCPU09IOP   Intelligent I/O Proce     14:10:59  Jan 12, 2026   Page   58Terminal   Drivers                                    E9DB 35   36                 puls   d,x,y                     *  E9DD C6   0B                 ldb    #R_PDATA  E9DF 39                      rts                                          * X=utask, Y=handler address, U=device reference               E9E0  set_pdat  equ    *  E9E0 17   FE81               lbsr   ttftab    get terminal base info  E9E3 1025 03F3               lbes   tterxt  E9E7 34   36                 pshs   d,x,y  E9E9 BD   E3C4               jsr    FIFOgeta                     * extra device table entry  E9EC AE   24                 ldx    dev_brbu,y  E9EE A7   84                 sta    0,x                     * write baudrate latch !!  E9F0 AE   A4                 ldx    dev_addr,y  E9F2 A7   02                 sta    brr,x     baudrate register  E9F4 BD   E3C4               jsr    FIFOgeta  E9F7 BD   E3C4               jsr    FIFOgeta  E9FA BD   E3C4               jsr    FIFOgeta  E9FD 35   36                 puls   d,x,y                     *  E9FF C6   0B                 ldb    #R_PDATA  EA01 39                      rtsCPU09IOP   Intelligent I/O Proce     14:11:00  Jan 12, 2026   Page   59TTY        Handlers                                                                           *                     * All code in this section is the common tty handler                     * code.  The device dependent code resides with the                     * drivers.  This handler package requires an ACIA be used                     * for all character type devices.                     *                                                               *                     * ttyren                     *                     * Re-enable the tty output after a timeout operation.                     * Upon entry, x should point to the tty structure.                     *                       EA02               ttyren  EA02 A6   88 14              lda    tstate,x  check state  EA05 85   02                 bita   #HOLD >EA07 1026 0056               lbne   ttyst9                     *  EA0B 84   FE                 anda   #!TIMOUT  clear time out  EA0D A7   88 14              sta    tstate,x  reset state  EA10 10AE 06                 ldy    taddr,x >EA13 1027 0036               lbeq   ttys55                     *  EA17 AD   D8 2C              jsr    [D_ttenxr,u] enable xmit interrupts                                          CPU09IOP   Intelligent I/O Proce     14:11:00  Jan 12, 2026   Page   60TTY        Handlers                                                                           *                     * ttyst                     *                     * TTY start will output a character to the terminal.                     * Upon entry, x should point to the tty structure in                     * use.  Getc is called for the character.                     *                       EA1A A6   88 15    ttyst     lda    tstate2,x is it ok to transmit?  EA1D 85   01                 bita   #DSR_OK >EA1F 1027 003E               lbeq   ttyst9    no - wait until it is                     *  EA23 10AE 06                 ldy    taddr,x   get device address  EA26 27   25                 beq    ttys55                     *  EA28 AD   D8 36              jsr    [D_ttxbsy,u] test xmit busy?  EA2B 27   20                 beq    ttys55                     *  EA2D A6   88 14    ttyst1    lda    tstate,x  EA30 85   01                 bita   #TIMOUT >EA32 1026 002B               lbne   ttyst9                                          ***+++                     ***---                       EA36               ttyst15  EA36 10AE 04                 ldy    tqout,x   get out q  EA39 17   FD5A               lbsr   get_oq    get character  EA3C 26   23                 bne    ttyst9    exit if queue empty                                          ***+++                     ***---                       EA3E A6   08                 lda    tflags,x  EA40 85   01                 bita   #RAW      test raw mode  EA42 26   03                 bne    ttyst2                     *  EA44 5D                      tstb             char       negative?  EA45 2B   07                 bmi    ttyst6                     *  EA47 10AE 06       ttyst2    ldy    taddr,x   get device address  EA4A 6E   D8 28              jmp    [D_ttputc,u] write characetr                     *  EA4D 39            ttys55    rts                     *  EA4E A6   88 14    ttyst6    lda    tstate,x  EA51 85   60                 bita   #XANY|XONXOF HOLD processing enabled?  EA53 26   04                 bne    ttyst65   yes                     *  EA55 85   80                 bita   #ESCOFF   ESCape HOLD disabled?  EA57 26   F4                 bne    ttys55    yes - ignore HOLD characterCPU09IOP   Intelligent I/O Proce     14:11:00  Jan 12, 2026   Page   61TTY        Handlers                                                      *  EA59 A6   88 14    ttyst65   lda    tstate,x  get states  EA5C 8A   03                 ora    #TIMOUT|HOLD set hold mode  EA5E A7   88 14              sta    tstate,x  reset states                     *  EA61 10AE 06       ttyst9    ldy    taddr,x   get port  EA64 6E   D8 2E              jmp    [D_ttdisx,u] disable xmit interrupts                     CPU09IOP   Intelligent I/O Proce     14:11:00  Jan 12, 2026   Page   62TTY        Handlers                                                                           *                     * ttyout                     *                     * Put the character in b into the output q.  Upon                     * entry, x should point to the tty structure.  Tab                     * expansions, upper case mapping, and special character                     * handling are all done here.                     *                       EA67 A6   08       ttyout    lda    tflags,x  get flags  EA69 85   01                 bita   #RAW      raw mode?  EA6B 27   11                 beq    ttyo12                     *  EA6D A6   88 14              lda    tstate,x  no hold in RAW mode  EA70 84   FD                 anda   #!HOLD  EA72 A7   88 14              sta    tstate,x  EA75 10AE 04                 ldy    tqout,x   point to out q  EA78 17   FD3F               lbsr   put_oq    put char in q  EA7B 16   0087               lbra   ttyoue    go finish                     *  EA7E C1   FF       ttyo12    cmpb   #$ff      special hold char?  EA80 27   53                 beq    ttyou6                     *  EA82 C4   7F                 andb   #$7f      mask parity bit  EA84 C1   09                 cmpb   #TABCH  EA86 26   11                 bne    ttyou2                     *  EA88 A6   08                 lda    tflags,x  check mode  EA8A 85   04                 bita   #XTABS    expand tabs?  EA8C 27   0B                 beq    ttyou2                     *  EA8E C6   20       ttyo14    ldb    #SPACE  EA90 8D   D5                 bsr    ttyout    output it  EA92 A6   0F                 lda    tcolm,x   check column  EA94 85   07                 bita   #7  EA96 26   F6                 bne    ttyo14                     *  EA98 39                      rts                     *  EA99 A6   08       ttyou2    lda    tflags,x  check mode  EA9B 85   08                 bita   #LCASE    lower case mode?  EA9D 27   25                 beq    ttyou4                     *  EA9F C1   61                 cmpb   #'a       lower case letter?  EAA1 25   08                 blo    ttyo22                     *  EAA3 C1   7A                 cmpb   #'z  EAA5 22   04                 bhi    ttyo22                     *  EAA7 C0   20                 subb   #$20      make upper  EAA9 20   19                 bra    ttyou4CPU09IOP   Intelligent I/O Proce     14:11:00  Jan 12, 2026   Page   63TTY        Handlers                                                      *  EAAB 108E EB13     ttyo22    ldy    #lcht     point to map                     *  EAAF E1   A1       ttyo23    cmpb   0,y++  EAB1 26   0D                 bne    ttyo24                     *  EAB3 E6   3F                 ldb    -1,y      get mapped char  EAB5 34   04                 pshs   b  EAB7 C6   5C                 ldb    #'\       output escape >EAB9 17   FFAB               lbsr   ttyout  EABC 35   04                 puls   b  EABE 20   15                 bra    ttyou6                     *  EAC0 6D   A4       ttyo24    tst    0,y       end of list?  EAC2 26   EB                 bne    ttyo23                     *  EAC4 C1   0D       ttyou4    cmpb   #CR  EAC6 26   0D                 bne    ttyou6                     *  EAC8 A6   08                 lda    tflags,x  check mode  EACA 85   10                 bita   #CRMOD  EACC 27   07                 beq    ttyou6                     *  EACE C6   0A                 ldb    #NL       convert to NL >EAD0 17   FF94               lbsr   ttyout    output it  EAD3 C6   0D                 ldb    #CR       reset CR                     *  EAD5 10AE 04       ttyou6    ldy    tqout,x   point to out q  EAD8 17   FCDF               lbsr   put_oq  EADB C1   0D                 cmpb   #CR  EADD 22   20                 bhi    ttyou8                     *  EADF 26   02                 bne    ttyo75    is it cr?                     *  EAE1 6F   0F                 clr    tcolm,x   clear out column count!                     *  EAE3 C1   09       ttyo75    cmpb   #9        is it tab character?  EAE5 26   0A                 bne    ttyo77                     *  EAE7 A6   0F                 lda    tcolm,x   get column count  EAE9 84   F8                 anda   #!7       mask low 3 bits  EAEB 8B   08                 adda   #8        add in tab  EAED A7   0F                 sta    tcolm,x   save new column  EAEF 20   14                 bra    ttyoue                     *  EAF1 C1   08       ttyo77    cmpb   #$08      hardware backspace?  EAF3 25   10                 blo    ttyoue  EAF5 26   08                 bne    ttyou8  EAF7 6D   0F                 tst    tcolm,x   column zero?  EAF9 27   0A                 beq    ttyoue  EAFB 6A   0F                 dec    tcolm,x  EAFD 20   06                 bra    ttyoueCPU09IOP   Intelligent I/O Proce     14:11:01  Jan 12, 2026   Page   64TTY        Handlers                                                      *  EAFF C1   20       ttyou8    cmpb   #SPACE    is it control char?  EB01 25   02                 blo    ttyoue                     *  EB03 6C   0F                 inc    tcolm,x   bump column count                     *  EB05 A6   88 14    ttyoue    lda    tstate,x  ** kludge for ACIA **  EB08 85   02                 bita   #HOLD  EB0A 26   06                 bne    ttyoe1                     *  EB0C 10AE 06                 ldy    taddr,x   get device address  EB0F 6E   D8 2C              jmp    [D_ttenxr,u] enable xmit interrupts                     *  EB12 39            ttyoe1    rts              return                       EB13 7E 5E 7C 21   lcht      fcc    "~^|!{(})`'"  EB1D 00                      fcb    0CPU09IOP   Intelligent I/O Proce     14:11:01  Jan 12, 2026   Page   65TTY        Handlers                                                                           *                     * ttyin                     *                     * Place the character in b on the input q.                     * Upon entry, x should point to the tty structure.                     * Signal processing and character mapping are                     * performed in this roiutine.                     *                       EB1E               ttyin                                          ***+++                     ***---                       EB1E A6   08                 lda    tflags,x  raw mode?  EB20 85   01                 bita   #RAW  EB22 26   51                 bne    ttyi44                     *  EB24 C4   7F                 andb   #$7f      mask par bit                     *  EB26 C1   20       ttyin0    cmpb   #SPACE    control char?  EB28 24   4B                 bhs    ttyi44    skip junk if so                     *  EB2A C1   1C       ttyin2    cmpb   #QUITC  EB2C 27   09                 beq    ttyi25                     *  EB2E C1   03                 cmpb   #INTRC  EB30 26   0B                 bne    ttyin3                     *  EB32 CC   0002               ldd    #INTS     set signal  EB35 20   03                 bra    ttyi27                     *  EB37 CC   0003     ttyi25    ldd    #QUITS    set signal                     *  EB3A 7E   E5A0     ttyi27    jmp    send_SI   send interrupt & get out                     *  EB3D A6   88 14    ttyin3    lda    tstate,x  get state  EB40 C1   1B                 cmpb   #HOLDC    Escape?  EB42 26   10                 bne    ttyi34                     *  EB44 85   80                 bita   #ESCOFF   escape processing disabled?  EB46 26   27                 bne    ttyin4    yes - ignore ESC as special character                     *  EB48 85   02                 bita   #HOLD     holding??  EB4A 26   1B                 bne    ttyi36                     *  EB4C 8A   03       ttyi33    ora    #TIMOUT|HOLD set HOLDing  EB4E A7   88 14              sta    tstate,x  EB51 7E   EA02               jmp    ttyren                     *  EB54 85   40       ttyi34    bita   #XONXOF   doing XON/XOFF processing?CPU09IOP   Intelligent I/O Proce     14:11:01  Jan 12, 2026   Page   66TTY        Handlers                                   EB56 27   17                 beq    ttyin4    no - don't bother                     *  EB58 C1   13                 cmpb   #XOFFC    XOFF character?  EB5A 26   07                 bne    ttyi35    no                     *  EB5C 85   02                 bita   #HOLD     already stopped?  EB5E 27   EC                 beq    ttyi33    no - stop output                     *  EB60 16   00B6               lbra   ttyin9    ignore XOFF if already stopped!                     *  EB63 C1   11       ttyi35    cmpb   #XONC     XON character  EB65 26   08                 bne    ttyin4    no - continue                     * -- HOLD off  EB67 84   FD       ttyi36    anda   #!HOLD    clear hold mode  EB69 A7   88 14              sta    tstate,x  EB6C 7E   EA02               jmp    ttyren                     *  EB6F C1   0D       ttyin4    cmpb   #CR       new line?  EB71 26   02                 bne    ttyi44                     *  EB73 6F   0F                 clr    tcolm,x   clear out column                     *  EB75 A6   88 14    ttyi44    lda    tstate,x  get current state  EB78 85   20                 bita   #XANY     allow any character to restart?  EB7A 27   04                 beq    ttyi46    no - continue on                     *  EB7C 85   02                 bita   #HOLD     currently stopped?  EB7E 26   E7                 bne    ttyi36    yes - go restart it                     *  EB80 10AE 84       ttyi46    ldy    tqin,x    input Q pointer  EB83 A6   A4                 lda    0,y       check q count                                          ***+++                     ***---                       EB85 81   FE                 cmpa   #CHRLIM   hit limit?  EB87 1024 008F               lbhs   flusht    flush this guy!                     *  EB8B B6   011B               lda    cbufct    check buffer count  EB8E B1   011C               cmpa   lcbuf  EB91 1022 0085               lbhi   flusht    if overflow, flush!                     *  EB95 A6   08       49        lda    tflags,x  check mode  EB97 85   01                 bita   #RAW      raw mode?  EB99 27   10                 beq    ttyin5                     *  EB9B 17   FBA2               lbsr   putc      put char in q  EB9E 10AE 84                 ldy    tqin,x    get in q  EBA1 34   04                 pshs   b         save char  EBA3 17   FADF               lbsr   wakeup    awaken those waiting  EBA6 35   04                 puls   b         get character  EBA8 6C   0E                 inc    tdel,x    bump delimiter countCPU09IOP   Intelligent I/O Proce     14:11:02  Jan 12, 2026   Page   67TTY        Handlers                                   EBAA 39                      rts              return                     *  EBAB 85   08       ttyin5    bita   #LCASE  EBAD 27   0A                 beq    ttyin6                     *  EBAF C1   41                 cmpb   #'A       capital letter?  EBB1 25   06                 blo    ttyin6                     *  EBB3 C1   5A                 cmpb   #'Z  EBB5 22   02                 bhi    ttyin6                     *  EBB7 CB   20                 addb   #$20      make lower case                     *  EBB9 10AE 84       ttyin6    ldy    tqin,x    point to input q  EBBC 17   FB81               lbsr   putc  EBBF A6   08                 lda    tflags,x  check mode  EBC1 85   40                 bita   #SCHR     single char mode?  EBC3 26   0A                 bne    ttyi65                     *  EBC5 C1   0D                 cmpb   #CR  EBC7 22   12                 bhi    ttyin7                     *  EBC9 27   04                 beq    ttyi65                     *  EBCB C1   04                 cmpb   #EOTCH  EBCD 26   0C                 bne    ttyin7                     *  EBCF 10AE 84       ttyi65    ldy    tqin,x    point to input q  EBD2 34   04                 pshs   b  EBD4 17   FAAE               lbsr   wakeup    wake up waiting  EBD7 6C   0E                 inc    tdel,x    bump count                     *  EBD9 35   04       ttyi67    puls   b         reset char                     *  EBDB E1   88 11    ttyin7    cmpb   tcncl,x   kill character?  EBDE 26   18                 bne    ttyin8                     *  EBE0 A6   08                 lda    tflags,x  check mode  EBE2 85   40                 bita   #SCHR     single character?  EBE4 26   12                 bne    ttyin8                     *  EBE6 C6   5E                 ldb    #'^       output '^x\n'  EBE8 17   FE7C               lbsr   ttyout  EBEB C6   78                 ldb    #'x  EBED 17   FE77               lbsr   ttyout  EBF0 C6   0D                 ldb    #CR  EBF2 17   FE72               lbsr   ttyout  EBF5 7E   EA1A               jmp    ttyst                     *  EBF8 A6   08       ttyin8    lda    tflags,x  check mode  EBFA 85   02                 bita   #ECHO  EBFC 27   1B                 beq    ttyin9CPU09IOP   Intelligent I/O Proce     14:11:02  Jan 12, 2026   Page   68TTY        Handlers                                                      *  EBFE E1   88 10              cmpb   tbksp,x   back space?  EC01 26   10                 bne    ttyi85                     *  EC03 85   20                 bita   #BSECH    echo bs?  EC05 27   0C                 beq    ttyi85                     *  EC07 C6   08                 ldb    #$08      set bs  EC09 17   FE5B               lbsr   ttyout  EC0C C6   20                 ldb    #SPACE    set space  EC0E 17   FE56               lbsr   ttyout  EC11 C6   08                 ldb    #$08      reset char                     *  EC13 17   FE51     ttyi85    lbsr   ttyout    echo character  EC16 7E   EA1A               jmp    ttyst     start output                     *  EC19 39            ttyin9    rts              return                     CPU09IOP   Intelligent I/O Proce     14:11:02  Jan 12, 2026   Page   69TTY        Handlers                                                                           *                     * flusht                     *                     * Flush all queues belonging to this terminal.                     *                       EC1A               flusht >EC1A 17   0050               lbsr   flushi    flush Input queues  EC1D 10AE 04                 ldy    tqout,x   point to out q                     *  EC20 17   FB73     10        lbsr   get_oq    flush out q  EC23 2A   FB                 bpl    10b                     *  EC25 10AE 84                 ldy    tqin,x    get input q  EC28 17   FA5A               lbsr   wakeup    wakeup input q waiters  EC2B 10AE 04                 ldy    tqout,x   wake up out q waiters  EC2E 17   FA54               lbsr   wakeup  EC31 A6   88 14              lda    tstate,x  get states  EC34 84   FC                 anda   #!(HOLD|TIMOUT) clear hold mode  EC36 A7   88 14              sta    tstate,x  EC39 CC   0000               ldd    #0        no pre-sold output  EC3C ED   88 18              std    tsold,x  EC3F 7E   EA1A               jmp    ttyst                                          *                     * flusho                     *                     * Flush all this guys queues after waiting for the                     * output q to empty.                     *                       EC42 A6   88 14    flusho    lda    tstate,x  check state  EC45 85   02                 bita   #HOLD     holding?  EC47 27   08                 beq    fluso1                     *  EC49 84   FC       fluso0    anda   #!(HOLD|TIMOUT)  EC4B A7   88 14              sta    tstate,x  clear hold  EC4E 17   FDB1               lbsr   ttyren    kick output                     *  EC51 EC   98 04    fluso1    ldd    [tqout,x] check char count >EC54 1027 FFC2               lbeq   flusht  EC58 A6   88 14              lda    tstate,x  check for hold  EC5B 85   02                 bita   #HOLD  EC5D 26   EA                 bne    fluso0                                          ***+++                     ***---                       EC5F 10AE 04                 ldy    tqout,x   point to out q  EC62 C6   EC                 ldb    #TTYOPR   set priority  EC64 34   10                 pshs   x         save xCPU09IOP   Intelligent I/O Proce     14:11:03  Jan 12, 2026   Page   70TTY        Handlers                                   EC66 17   FA40               lbsr   sleep  EC69 35   10                 puls   x  EC6B 20   E4                 bra    fluso1                                          *                     * flushi - Flush input Queues only                     *  EC6D               flushi  EC6D 10AE 02                 ldy    tqproc,x  get procd q                     *  EC70 17   FA85     10        lbsr   getc      get character  EC73 2A   FB                 bpl    10b                     *  EC75 10AE 84                 ldy    tqin,x    flush input q                     *  EC78 17   FA7D     20        lbsr   getc  EC7B 2A   FB                 bpl    20b                     *  EC7D 6F   0E                 clr    tdel,x    clear delim count                                          ***+++                     ***---                       EC7F 39                      rts                                                                                    *                     * xtprcq                     *                     * Transfer characters from input q to procd q.  If not                     * in raw mode, do escape, backspace, and cancel                     * processing.  Enter with x pointing to tty structure.                     *                       EC80 34   01       xtprcq    pshs   cc        save cc  EC82                         seti   mask      ints  EC84 6D   0E                 tst    tdel,x    delimiters yet?  EC86 26   10                 bne    xtprc0                                          ***+++                     ***---                       EC88 10AE 84                 ldy    tqin,x    sleep on input q  EC8B C6   F6                 ldb    #TTYIPR  EC8D 34   10                 pshs   x         save x  EC8F 17   FA17               lbsr   sleep  EC92 35   10                 puls   x  EC94 35   01                 puls   cc        reset cc  EC96 20   E8                 bra    xtprcq                     *  EC98 35   01       xtprc0    puls   cc        reset ccCPU09IOP   Intelligent I/O Proce     14:11:03  Jan 12, 2026   Page   71TTY        Handlers                                   EC9A 6D   94                 tst    [tqin,x]  input q empty?  EC9C 26   04                 bne    xtprc1                     *  EC9E 6A   0E                 dec    tdel,x    dec the del count  ECA0 20   DE                 bra    xtprcq    repeat test                     *  ECA2 108E 0170     xtprc1    ldy    #prcbuf+2 point to buffer  ECA6 5F                      clrb  ECA7 34   24                 pshs   b,y       delimiter flag                     *  ECA9 6D   E4       xtprc2    tst    0,s       delimiter?  ECAB 27   10                 beq    xtpr22                     *  ECAD 6F   E4                 clr    0,s       clear del flag  ECAF 6D   0E                 tst    tdel,x    check del count  ECB1 27   02                 beq    xtpr21    if 0 - skip                     *  ECB3 6A   0E                 dec    tdel,x    dec the del count                     *  ECB5 A6   08       xtpr21    lda    tflags,x  get flags  ECB7 85   41                 bita   #RAW|SCHR in raw mode?  ECB9 1027 0085               lbeq   xtprc5                     *  ECBD 10AE 84       xtpr22    ldy    tqin,x    point to in q  ECC0 17   FA35               lbsr   getc      get a character  ECC3 2B   7D                 bmi    xtprc5    none left?                     *  ECC5 C1   0D                 cmpb   #CR       check for delim  ECC7 27   0C                 beq    xtpr25                     *  ECC9 C1   04                 cmpb   #EOTCH  ECCB 26   0A                 bne    xtprc3                     *  ECCD 6C   E4                 inc    0,s       set del flag  ECCF A6   08                 lda    tflags,x  get flags  ECD1 85   40                 bita   #SCHR     single char mode?  ECD3 26   D4                 bne    xtprc2                     *  ECD5 6C   E4       xtpr25    inc    0,s       set del flag                     *  ECD7 A6   08       xtprc3    lda    tflags,x  check mode  ECD9 85   41                 bita   #RAW|SCHR  ECDB 27   04                 beq    xtpr31                     *  ECDD 6C   E4                 inc    0,s       set del flag for each raw char  ECDF 20   51                 bra    xtpr45                     *  ECE1 10AE 61       xtpr31    ldy    1,s       point to buffer  ECE4 A6   3F                 lda    -1,y      check previous  ECE6 81   5C                 cmpa   #'\       escape?  ECE8 26   15                 bne    xtca32                     *CPU09IOP   Intelligent I/O Proce     14:11:03  Jan 12, 2026   Page   72TTY        Handlers                                   ECEA C1   04                 cmpb   #EOTCH    is it eot?  ECEC 27   0A                 beq    xtp315                     *  ECEE E1   88 10              cmpb   tbksp,x   backspace char?  ECF1 27   05                 beq    xtp315                     *  ECF3 E1   88 11              cmpb   tcncl,x   cancel char?  ECF6 26   07                 bne    xtca32                     *  ECF8 31   3F       xtp315    leay   -1,y      backup over slash  ECFA 10AF 61                 sty    1,s       save new ptr  ECFD 20   33                 bra    xtpr45                     *  ECFF E1   88 10    xtca32    cmpb   tbksp,x   backspace char?  ED02 26   0D                 bne    xtca33                     *  ED04 108C 0170               cmpy   #prcbuf+2 buffer begin?  ED08 27   9F                 beq    xtprc2                     *  ED0A 31   3F                 leay   -1,y      backup pointer  ED0C 10AF 61                 sty    1,s  ED0F 20   98                 bra    xtprc2                     *  ED11 C1   04       xtca33    cmpb   #EOTCH    eot char?  ED13 27   94                 beq    xtprc2                     *  ED15 E1   88 11              cmpb   tcncl,x   cancel char?  ED18 26   04                 bne    xtprc4                     *  ED1A 35   24                 puls   b,y       -- caution (order)  ED1C 20   84                 bra    xtprc1    repeat all                     *  ED1E C1   20       xtprc4    cmpb   #$20      check for control char  ED20 24   10                 bhs    xtpr45                     *  ED22 C1   0D                 cmpb   #CR       is it cr?  ED24 27   0C                 beq    xtpr45                     *  ED26 C1   09                 cmpb   #9        is it tab char?  ED28 27   08                 beq    xtpr45                     *  ED2A A6   08                 lda    tflags,x  get flags  ED2C 85   80                 bita   #CNTRL    control char ignore?  ED2E 1026 FF77               lbne   xtprc2                     *  ED32 10AE 61       xtpr45    ldy    1,s       get pointer  ED35 E7   A0                 stb    0,y+      transfer char  ED37 10AF 61                 sty    1,s       save pointer  ED3A 108C 026E               cmpy   #prcbuf+PRCSIZ overflow??  ED3E 1025 FF67               lblo   xtprc2                     *  ED42 35   04       xtprc5    puls   b         remove del flag from stackCPU09IOP   Intelligent I/O Proce     14:11:03  Jan 12, 2026   Page   73TTY        Handlers                                   ED44 10AE 02                 ldy    tqproc,x  get procd q  ED47 34   10                 pshs   x  ED49 8E   0170               ldx    #prcbuf+2 point to processed buf                     *  ED4C AC   62       xtprc6    cmpx   2,s       end of buffer?  ED4E 24   07                 bhs    xtprc7                     *  ED50 E6   80                 ldb    0,x+      get character  ED52 17   F9EB               lbsr   putc  ED55 20   F5                 bra    xtprc6                     *  ED57               xtprc7                                          ***+++                     ***---                       ED57 CC   FFFF               ldd    #-1       set good  ED5A 35   B0                 puls   x,y,pc    return                                          ***+++                     ***---                     *                     * most routines below are called from fio_mesg handler                     * A = specific data, B = command, U = device reference                     *CPU09IOP   Intelligent I/O Proce     14:11:04  Jan 12, 2026   Page   74TTY        Handlers                                                                           *                     * req_read - CPU has informed us he wants to read                     * Tell him when some data is available.                     * U = device reference                     *  ED5C 17   FB05     req_read  lbsr   ttftab    get TTY table address  ED5F 25   24                 bes    30f  ED61 A6   98 02              lda    [tqproc,x] anything available?  ED64 26   03                 bne    00f       yes - go use it                     *  ED66 17   FF17               lbsr   xtprcq    go process input (wait if none there)                     *  ED69 A6   98 02    00        lda    [tqproc,x] get input processed count  ED6C 27   0A                 beq    05f       jump for EOF detected                     *  ED6E 81   01                 cmpa   #1        special case for single character  ED70 27   09                 beq    10f                     *  ED72 E6   08                 ldb    tflags,x  single character & RAW always return 1 char  ED74 C5   41                 bitb   #RAW|SCHR  ED76 26   03                 bne    10f                     *  ED78 C6   05       05        ldb    #R_RDOK   inform CPU data now available  ED7A 39                      rts                     *  ED7B 10AE 02       10        ldy    tqproc,x  go fetch character  ED7E 17   F977               lbsr   getc  ED81 86   09                 lda    #R_RD1C   inform CPU single character returned  ED83 1E   89                 exg    a,b  ED85 39            30        rts                                          *                     * read_data - CPU wants IOP to send data                     *  Max # chars to move in transaction speicific value                     *  ED86 17   FADB     read_data lbsr   ttftab    get TTY table address  ED89 25   22                 bes    30f  ED8B FE   0115               ldu    utask     see how many chars to send  ED8E 10AE 02                 ldy    tqproc,x  input queue pointer  ED91 6F   E2                 clr    ,-s       set FIFO counter                     *  ED93 A6   A4       10        lda    0,y       any more characters?  ED95 27   0C                 beq    20f       no - done                     *  ED97 17   F95E               lbsr   getc      fetch character  ED9A 17   F655               lbsr   FIFO_put  put into FIFO  ED9D 6C   E4                 inc    0,s       bump FIFO count  ED9F 6A   4C                 dec    tstval,u  does the guy want more?  EDA1 26   F0                 bne    10b                     *  EDA3 A6   E0       20        lda    ,s+       get # chars in FIFOCPU09IOP   Intelligent I/O Proce     14:11:04  Jan 12, 2026   Page   75TTY        Handlers                                   EDA5 C6   06                 ldb    #R_READ   data now available in FIFO  EDA7 6D   A4                 tst    0,y       any more data in case guy wants it?  EDA9 27   02                 beq    30f                     *  EDAB C6   0C                 ldb    #R_READM  yes - special response                     *  EDAD 39            30        rtsCPU09IOP   Intelligent I/O Proce     14:11:04  Jan 12, 2026   Page   76TTY        Handlers                                                                           *                     * ttywrt                     *                     * The main terminal write routine.  Control is passed                     * to here from the device driver routine which calculates                     * the ttys structure location and passes it in x.                     *                       EDAE D6   13       ttywrt    ldb    fifo_cnt+1 get FIFO input length  EDB0 C1   00                 cmpb   #0        anything in FIFO?  EDB2 27   0E                 beq    90f       no - exit                     *  EDB4 34   04                 pshs   b         save input length                     *  EDB6 17   F614     10        lbsr   FIFO_get  fetch character  EDB9 17   FCAB               lbsr   ttyout    output it  EDBC 6A   E4                 dec    0,s       decrement count  EDBE 26   F6                 bne    10b       repeat                     *  EDC0 35   02                 puls   a         clean up stack                     *  EDC2 34   01       90        pshs   cc        save cc  EDC4                         seti   mask      ints  EDC6 17   FC51               lbsr   ttyst     give output a kick  EDC9 35   81                 puls   cc,pc     return                                          *                     * open_tty - Perform device open                     *  EDCB               open_tty  EDCB BD   E7D3               jsr    ttopn     perform tty open  EDCE 25   0A                 bes    tterxt                                          ***+++                     ***---                       EDD0 C6   01       10        ldb    #R_OPEN  EDD2 39                      rts                                          *                     * close_tty - Perform device close                     *  EDD3               close_tty  EDD3 BD   E83A               jsr    ttcls     perform tty close  EDD6 27   02                 beq    tterxt                                          ***+++                     ***---                       EDD8 C6   02       10        ldb    #R_CLOSE  EDDA 39            tterxt    rtsCPU09IOP   Intelligent I/O Proce     14:11:04  Jan 12, 2026   Page   77TTY        Handlers                                                                           *                     * req_write - Request permission to write data                     *  EDDB               req_write  EDDB BD   E864               jsr    ttftab    get TTY table  EDDE 25   FA                 bes    tterxt                                          ***+++                     ***---                       EDE0 34   01       05        pshs   cc        mask interrupts while fiddling                     *  EDE2               10        seti  EDE4 10AE 04                 ldy    tqout,x   get output queue pointer  EDE7 EC   A4                 ldd    oq_count,y get queue length  EDE9 E3   88 18              addd   tsold,x   include any space already sold  EDEC F3   E062               addd   fio_fsz   and assume the CPU will send this many more  EDEF 10B3 0102               cmpd   OQHI      space available?  EDF3 2F   16                 ble    20f       yes - OK                     *  EDF5 A6   09                 lda    tdelay,x  special flush bit?  EDF7 85   40                 bita   #$40  EDF9 27   05                 beq    15f       no - go to sleep                     *  EDFB BD   EC42               jsr    flusho    yes - flush output  EDFE 20   E2                 bra    10b       try again                     *  EE00 34   76       15        pshs   d,x,y,u   no - save registers  EE02 C6   E2                 ldb    #TTYSPR  EE04 BD   E6A9               jsr    sleep  EE07 35   76                 puls   d,x,y,u   restore registers  EE09 20   D7                 bra    10b       try again                     *  EE0B 10BE 0115     20        ldy    utask     am I supposed to be dead?  EE0F 6D   28                 tst    tssgnl,y  EE11 26   0D                 bne    30f       yes - abort                     *  EE13 EC   88 18              ldd    tsold,x   update amount pre-sold  EE16 F3   E062               addd   fio_fsz   -- assume entire FIFO load  EE19 ED   88 18              std    tsold,x  EE1C C6   03                 ldb    #R_REQOK  request granted code  EE1E 35   81                 puls   cc,pc     return                     *  EE20 35   01       30        puls   cc        clean up stack  EE22 32   62                 leas   2,s       -- pop normal return  EE24 39                      rts              abnormal   I/O completion (no response)                                          *                     * write_data - Write data to a terminal                     *  EE25               write_dataCPU09IOP   Intelligent I/O Proce     14:11:05  Jan 12, 2026   Page   78TTY        Handlers                                   EE25 BD   E864               jsr    ttftab    get tty table pointer >EE28 1025 FFAE               lbes   tterxt  EE2C BD   EDAE               jsr    ttywrt    go consume data  EE2F 34   01                 pshs   cc        save interrupt state  EE31                         seti   mask      interrupts  EE33 EC   88 18              ldd    tsold,x  EE36 B3   E062               subd   fio_fsz  EE39 2A   03                 bpl    00f                     *  EE3B CC   0000               ldd    #0        don't screw up!                     *  EE3E ED   88 18    00        std    tsold,x   update count  EE41 10AE 04                 ldy    tqout,x   wake up anybody waiting for space                                          ***+++                     ***---                       EE44 BD   E685     10        jsr    wakeup  EE47 C6   04                 ldb    #R_WRITE  EE49 35   81                 puls   cc,pc     return                     *  EE4B 0D 46 49 46   00        fcc    $d,'FIFO consumed, wakeup at $',0                                          *                     * Write single character                     *  -- Character passed via transaction message                     *  EE67 34   01       wrt_sc    pshs   cc        save interrupt state  EE69 BD   E864               jsr    ttftab    compute tty table address  EE6C 24   05                 bec    00f  EE6E 32   61                 leas   1,s       drop old cc  EE70 16   FF67               lbra   tterxt                     *  EE73 10AE 04       00        ldy    tqout,x   output Q pointer  EE76 EC   A4                 ldd    oq_count,y check for overrun  EE78 10B3 0102               cmpd   OQHI  EE7C 23   12                 bls    10f       jump if space                     *  EE7E A6   09                 lda    tdelay,x  special flush bit?  EE80 85   40                 bita   #$40  EE82 27   05                 beq    05f       no - wait for space                     *  EE84 BD   EC42               jsr    flusho    yes - make space!  EE87 20   EA                 bra    00b                     *  EE89 C6   EC       05        ldb    #TTYOPR   wait a while  EE8B BD   E6A9               jsr    sleep  EE8E 20   E3                 bra    00b       try again                     *  EE90 10BE 0115     10        ldy    utask     fetch character  EE94 E6   2C                 ldb    tstval,y  EE96 BD   EA67               jsr    ttyout    send to output queueCPU09IOP   Intelligent I/O Proce     14:11:05  Jan 12, 2026   Page   79TTY        Handlers                                   EE99                         seti   mask      interrupts  EE9B BD   EA1A               jsr    ttyst     kick output - make sure it starts  EE9E C6   04                 ldb    #R_WRITE  EEA0 35   81                 puls   cc,pc     return                     *                     * sdev_sig, generic function to deliver interrupts                     * from main CPU to slave CPU processes                     *                     * B = signal# , A = O_INTRPT/S_INTRPT                     * X = device reference                     * called from Interrupt context                     *  EEA2 1E   01       sdev_sig  exg    d,x                                          *                     * send_int - Interrupt all tasks associated with a terminal                     * D = device #  XL = signal#                     *  EEA4 34   76       send_int  pshs   d,x,y,u  EEA6 D1   E2                 cmpb   NUM_TRM  EEA8 24   19                 bhs    10f       skip if invalid                     *  EEAA BD   E864               jsr    ttftab    get TTY table address  EEAD BD   EC1A               jsr    flusht    flush terminal buffers  EEB0 EC   E4                 ldd    0,s       get terminal #  EEB2 AE   62                 ldx    2,s       XL = signal#                     * D = device , XL = signal#  EEB4 BD   E52E               jsr    int_all   interrupt all associated tasks  EEB7 BE   0115               ldx    utask     also interrupt current task if appropriate  EEBA A6   61                 lda    1,s  EEBC A1   0E                 cmpa   tsdev+1,x  EEBE 26   03                 bne    10f                     *  EEC0 BD   E6DE               jsr    xmtint                     *  EEC3 35   F6       10        puls   d,x,y,u,pc clean up stack & return                                          ***+++                     ***----CPU09IOP   Intelligent I/O Proce     14:11:05  Jan 12, 2026   Page   80ACIA       interface routines                                                                                      *                     * 6850 Device table                     *  EEC5               DEV_6850  EEC5 E4FF                    fdb    bad_cmd   0 -  EEC7 EDCB                    fdb    open_tty  1 -  EEC9 EDD3                    fdb    close_tty 2 -  EECB EDDB                    fdb    req_write 3 -  EECD EE25                    fdb    write_data 4 -  EECF ED5C                    fdb    req_read  5 -  EED1 ED86                    fdb    read_data 6 -  EED3 EE67                    fdb    wrt_sc    7 -  EED5 E90B                    fdb    ttyset    8 -  EED7 E97D                    fdb    ttyget    9 -  EED9 E4FF                    fdb    bad_cmd   A -  EEDB E4FF                    fdb    bad_cmd   B -  EEDD E4FF                    fdb    bad_cmd   C -  EEDF E9C1                    fdb    get_pdat  D -  EEE1 E9E0                    fdb    set_pdat  E -  EEE3 E4FF                    fdb    bad_cmd   F -                     *                     * end of FIO command list                     *               0010  MAX_FCMD  equ    (*-DEV_6850)/2                       EEE5 EF19                    fdb    SR4_IRQ  EEE7 EF33                    fdb    SR4_init  EEE9 EF41                    fdb    SR4_test                     *  EEEB EFBA                    fdb    SR4ttconf  EEED EFF3                    fdb    SR4ttputc  EEEF EFF6                    fdb    SR4ttgetc  EEF1 EFF9                    fdb    SR4ttnxr  EEF3 F001                    fdb    SR4ttdisx  EEF5 F009                    fdb    SR4ttnr  EEF7 F011                    fdb    SR4ttnx  EEF9 F019                    fdb    SR4ttnno  EEFB F021                    fdb    SR4ttxbsy  EEFD F026                    fdb    SR4ttstx  EEFF F02E                    fdb    SR4ttiscts  EF01 F038                    fdb    SR4ttstr  EF03 F040                    fdb    SR4ttstb  EF05 F04F                    fdb    SR4ttsts  EF07 F051                    fdb    SR4ttstc  EF09 F05F                    fdb    SR4ttstd  EF0B F05A                    fdb    SR4ttste  EF0D F062                    fdb    SR4ttnd  EF0F F063                    fdb    SR4ttwcts  EF11 F06D                    fdb    SR4ttwdcd                     *CPU09IOP   Intelligent I/O Proce     14:11:06  Jan 12, 2026   Page   81ACIA       interface routines                                                                 * The routines in this file are specific to an ACIA (6850).                     * They are called from the "ttyhan" and "ttydrv" files.                     * preset table for baudrates at each port                     *                     * baudrate latch backup bytes, for 2 acia's each                     *                     * CB B2 B1 B0 CA A2 A1 A0       C=/CTS override, 0 = active                     * X2 X1 X0 are baudrate select bits 38K4/19K2/9K6/4K8/2K4/1K2/0K6/0K3                     * 111 is highest baudrate, 000 is lowest.                     *  EF13 77            brbupr    fcb    $77       acia 0 and 1 board 1  EF14 77                      fcb    $77       acia 2 and 3 ,, ,,  EF15 77                      fcb    $77       acia 4 and 5 board 2  EF16 77                      fcb    $77       acia 6 and 7 ,, ,,  EF17 77                      fcb    $77       acia 8 and 9 board3  EF18 77                      fcb    $77       acia 10 and 11 ,, ,,               0006  BRTBSIZ   equ    *-brbupr                                          *                     * Check for and process an ACIA interrupt                     *  D - Device #                     *  X - Device address                     *  EF19 34   76       SR4_IRQ   pshs   d,x,y,u   save registers just in case  EF1B A6   84                 lda    csr,x     check for interrupt  EF1D 85   80                 bita   #AS_IRQ  EF1F 27   0E                 beq    10f       jump if no interrupt                     *  EF21 5F                      clrb  EF22 34   06                 pshs   d                     *  EF24 EC   62                 ldd    2,s       restore device #  EF26 BD   E88A               jsr    tintr     go process interrupt  EF29 32   62                 leas   2,s       remove device status  EF2B 1A   01                 sec              --         interrupt processed  EF2D 20   02                 bra    99f                     *  EF2F 1C   FE       10        clc              --         no interrupt processed                     *  EF31 35   F6       99        puls   d,x,y,u,pc                                          *                     * Initialize ACIA port                     *   B - Device #                     *   X - Device address                     *  EF33 34   76       SR4_init  pshs   d,x,y,u  EF35 6F   02                 clr    2,x       init baudrate latch  EF37 86   43                 lda    #AC_DRTS+AC_MRES set up reset code  EF39 A7   84                 sta    0,x       reset acia  EF3B 34   06                 pshs   d         delayCPU09IOP   Intelligent I/O Proce     14:11:06  Jan 12, 2026   Page   82ACIA       interface routines                         EF3D 35   06                 puls   d  EF3F 35   F6                 puls   d,x,y,u,pc                                          *                     * Determine if CPU09SR4 ACIA board is present                     *  D - ACIA port address                     *  Y - Device table address                     *  <CS> if present & ACIA                     *  EF41 34   56       SR4_test  pshs   d,x,u  EF43 1F   03                 tfr    d,u  EF45 86   43                 lda    #AC_DRTS+AC_MRES set up reset code  EF47 A7   C4                 sta    0,u       reset acia  EF49 34   06                 pshs   d         delay  EF4B 35   06                 puls   d  EF4D A6   C4                 lda    0,u       check response  EF4F 27   08                 beq    00f                     *  EF51 84   F3                 anda   #%11110011 todo: bit names  EF53 27   04                 beq    00f                     *  EF55 1C   FE                 clc              --         not an 6350  EF57 20   5F                 bra    99f                     *                     * found an ACIA, fill in the port info                     *  EF59               00  EF59 96   E2                 lda    NUM_TRM   Compute device table address  EF5B C6   06                 ldb    #DEV_SIZE  EF5D 3D                      mul  EF5E 108E 027E               ldy    #dev_tab  EF62 31   AB                 leay   d,y  EF64 96   E2                 lda    NUM_TRM  EF66 46                      rora             2 ports for each baudrate backup  EF67 CE   02D0               ldu    #brbutb   address of table  EF6A 33   C6                 leau   a,u                     * account for 4 ports CPU09SR4  EF6C D6   E2                 ldb    NUM_TRM  EF6E CB   04                 addb   #4  EF70 D7   E2                 stb    NUM_TRM                     *  EF72 EC   E4                 ldd    0,s       port address  EF74 8E   EEC5               ldx    #DEV_6850  EF77 ED   A4                 std    dev_addr,y device address  EF79 AF   22                 stx    dev_type,y handler dispatch table  EF7B EF   24                 stu    dev_brbu,y baudrate latch backup  EF7D 34   02                 pshs   a  EF7F A6   C9 EC43            lda    (brbupr-brbutb),u get rom preset  EF83 A7   C4                 sta    0,u  EF85 35   02                 puls   a  EF87 31   26                 leay   DEV_SIZE,y  EF89 C3   0004               addd   #4        offset to next ACIACPU09IOP   Intelligent I/O Proce     14:11:06  Jan 12, 2026   Page   83ACIA       interface routines                         EF8C ED   A4                 std    dev_addr,y  EF8E AF   22                 stx    dev_type,y  EF90 EF   24                 stu    dev_brbu,y  EF92 31   26                 leay   DEV_SIZE,y  EF94 C3   0004               addd   #4  EF97 33   41                 leau   1,u       next backup location  EF99 ED   A4                 std    dev_addr,y  EF9B AF   22                 stx    dev_type,y  EF9D EF   24                 stu    dev_brbu,y  EF9F 34   02                 pshs   a  EFA1 A6   C9 EC43            lda    (brbupr-brbutb),u get rom preset  EFA5 A7   C4                 sta    0,u  EFA7 35   02                 puls   a  EFA9 31   26                 leay   DEV_SIZE,y  EFAB C3   0004               addd   #4  EFAE ED   A4                 std    dev_addr,y  EFB0 AF   22                 stx    dev_type,y  EFB2 EF   24                 stu    dev_brbu,y  EFB4 31   26                 leay   DEV_SIZE,y  EFB6 1A   01                 sec  EFB8 35   D6       99        puls   d,x,u,pc                                                               *                     * ttconf                     *                     * Configure the port pointed at by the Y register.  The X                     * register is pointing to the terminal table.  All registers                     * except D should be preserved.                     *                       EFBA 86   03       SR4ttconf lda    #AC_MRES  reset the acia  EFBC A7   A4                 sta    csr,y  EFBE 34   06                 pshs   d         delay some here  EFC0 35   06                 puls   d  EFC2 A6   A4                 lda    csr,y     get status - see if acia is really here  EFC4 27   04                 beq    2f        if 0 status - then ok                     *  EFC6 85   F3                 bita   #$f3      see if funny status is ok  todo: bit names  EFC8 26   21                 bne    4f                     *  EFCA A6   88 12    2         lda    tbaud,x   get configuration word from table                       EFCD 8A   01                 ora    #AC_DV16  set up full configuration  EFCF A7   A4                 sta    csr,y     (no ints enabled & RTS brought high)                     *  EFD1 34   16                 pshs   d,x  EFD3 A6   0B                 lda    tdevic+1,x get terminal id  EFD5 C6   06                 ldb    #DEV_SIZE  EFD7 3D                      mul  EFD8 8E   027E               ldx    #dev_tab  EFDB 30   8B                 leax   d,xCPU09IOP   Intelligent I/O Proce     14:11:07  Jan 12, 2026   Page   84ACIA       interface routines                         EFDD AE   04                 ldx    dev_brbu,x set baudrate latch  EFDF A6   84                 lda    0,x  EFE1 A7   22                 sta    brr,y  EFE3 35   16                 puls   d,x                       EFE5 A6   A4                 lda    csr,y     get new status  EFE7 85   08                 bita   #AS_NCTS  is CTS ok?  EFE9 27   05                 beq    6f                     *  EFEB 1A   04       4         sez              set        false status  EFED 1C   FE                 clc              show       wait for CTS  EFEF 39                      rts              return                     *  EFF0 1C   FB       6         clz              set        true status  EFF2 39                      rts              return                                          *                     * ttputc                     *                     * Send the character in the B register to the ACIA.  All                     * registers should be preserved.  Y points to the device.                     *                       EFF3 E7   21       SR4ttputc stb    dbuf,y    send character  EFF5 39                      rts              return                                                               *                     * ttgetc                     *                     * Get the character from the device and return in the B                     * register.  Y points to the device and all registers                     * should be preserved.                     *                       EFF6 E6   21       SR4ttgetc ldb    dbuf,y    get the character  EFF8 39                      rts              return                                                               *                     * ttenxr                     *                     * Enable the transmit interrupts and leave the receive                     * interrupt enabled (it is enabled upon routine entry).                     * Y points to the device and X points to to the terminal                     * table entry.  Preserve all registers but D.                     *                     *                       EFF9 A6   88 12    SR4ttnxr  lda    tbaud,x   get configuration  EFFC 8A   A1                 ora    #AC_TEIN+AC_REIN+AC_DV16 enable int bits  EFFE A7   A4                 sta    csr,y     send to aciaCPU09IOP   Intelligent I/O Proce     14:11:07  Jan 12, 2026   Page   85ACIA       interface routines                         F000 39                      rts              return                                                               *                     * ttdisx                     *                     * Disable the transmit interrupt and leave the receive                     * interrupt enabled.  Y points to the device and X points                     * to the terminal table entry.  Preserve all but D.                     *                       F001 A6   88 12    SR4ttdisx lda    tbaud,x   get configuration word  F004 8A   81                 ora    #AC_REIN+AC_DV16 set bits  F006 A7   A4                 sta    csr,y     send to acia  F008 39                      rts              return                                                               *                     * ttenr                     *                     * Enable the receive interrupts only.  The transmit                     * interrupts should be turned off.  Y points to the device                     * and X point to the terminal table entry.  Preserve all                     * but the D register.                     *                       F009 A6   88 12    SR4ttnr   lda    tbaud,x   get configuration word  F00C 8A   81                 ora    #AC_REIN+AC_DV16 set bits  F00E A7   A4                 sta    csr,y     send to acia  F010 39                      rts              return                                                               *                     * ttenx                     *                     * Enable the transmit interrupts only.  The receive                     * interrupts should be left disabled.  Y points to the                     * device and X points to the terminal table entry.                     * All registers but D shoud be preserved.                     *                       F011 A6   88 12    SR4ttnx   lda    tbaud,x   get configuration word  F014 8A   21                 ora    #AC_TEIN+AC_DV16 set bits  F016 A7   A4                 sta    csr,y     send to acia  F018 39                      rts              return                                                               *                     * ttenno                     *                     * Disable all interrupts from device and drop the RTS                     * line.  Y points to the device and X points to theCPU09IOP   Intelligent I/O Proce     14:11:07  Jan 12, 2026   Page   86ACIA       interface routines                                            * terminal table entry.  Preserve all but D register.                     *                       F019 A6   88 12    SR4ttnno  lda    tbaud,x   get configuration word  F01C 8A   41                 ora    #AC_DRTS+AC_DV16 set bits  F01E A7   A4                 sta    csr,y     send to acia  F020 39                      rts              return                                                               *                     * ttxbsy                     *                     * Test if the transmit buffer is empty.  Return TRUE if                     * it is empty (N.E. status). Y points to the device and                     * all but A needs preserved.                     *                       F021 A6   A4       SR4ttxbsy lda    csr,y     get status  F023 85   02                 bita   #AS_TDRE  is it busy?  F025 39                      rts              return                                                               *                     * tttstx                     *                     * Test device pointed at by Y for a transmit interrupt.                     * Return TRUE if interrupt present.  Preserve all but                     * the A register.                     *                       F026 A6   A4       SR4ttstx  lda    csr,y     get status  F028 85   02                 bita   #AS_TDRE  F02A 26   06                 bne    SR4true  F02C 20   07                 bra    SR4false                                                               *                     * ttiscts                     *                     * Test device pointed at by X for "Clear to Send"                     * -- Return TRUE (not equal) if yes                     *  F02E               SR4ttiscts  F02E 85   08                 bita   #AS_NCTS  is CTS down?  F030 26   03                 bne    SR4false  F032 1C   FB       SR4true   clz              no         - return TRUE  F034 39                      rts  F035 1A   04       SR4false  sez              yes        - return FALSE  F037 39                      rts                                                               *CPU09IOP   Intelligent I/O Proce     14:11:08  Jan 12, 2026   Page   87ACIA       interface routines                                            * tttstr                     *                     * Test device pointed at by Y for a receive interrupt.                     * Return TRUE if interrupt present.  Preserve all but                     * the A register.                     *                       F038 A6   A4       SR4ttstr  lda    csr,y  F03A 85   01                 bita   #AS_RDRF  F03C 26   F4                 bne    SR4true  F03E 20   F5                 bra    SR4false                                                               *                     * tttstb                     *                     * Test device pointed at by Y for a "break" condition.                     * Return TRUE if found.  Preserve all registers but A                     * and return NULL in B (for break character).                     *                       F040 85   30       SR4ttstb  bita   #AS_OVRN+AS_FRME check for break condition  F042 27   0A                 beq    2f        ZERO = false                     *  F044 E6   21                 ldb    dbuf,y    get character from acia  F046 34   76                 pshs   d,x,y,u   delay some here  F048 35   76                 puls   d,x,y,u  F04A A6   21                 lda    dbuf,y    get next garbage char if any  F04C 1C   FB                 clz              set        TRUE                     *  F04E 39            2         rts              return                                                               *                     * tttsts                     *                     * Test device for "CTS" interrupt.                     *                       F04F 20   E4       SR4ttsts  bra    SR4false  not currently implemented                                                               *                     * tttstc                     *                     * Test device pointed at by Y for drop "Carrier Detect"                     * type interrupt.  Return TRUE if so.  Preserve all registers                     * but A.                     *                       F051 85   04       SR4ttstc  bita   #AS_NDCD  check for carrier drop  F053 27   04                 beq    1f        jump if no errorCPU09IOP   Intelligent I/O Proce     14:11:08  Jan 12, 2026   Page   88ACIA       interface routines                                            *  F055 E6   21                 ldb    dbuf,y    read reg to reset status  F057 1C   FB                 clz              return     true                     *  F059 39            1         rts              return                                                               *                     * tttste                     *                     * Test device pointed at by Y for error conditions.                     * Handle all errors local to this routine - no status                     * returned.  Preserve all but A.                     *                       F05A A6   21       SR4ttste  lda    dbuf,y    read data register to clear any interrupt conditions  F05C 1A   04                 sez              return false clz     return     true  F05E 39                      rts              return                                          *                     * tttstd - Test for drop in DTR                     *  F05F 1A   04       SR4ttstd  sez              --         not supported by hardware  F061 39                      rts                                                               *                     * ttend                     *                     * Terminate i/o operation for device pointed at by Y.                     * Preserve all but D.                     *                       F062 39            SR4ttnd   rts              return     (nothing for acia)                                                               *                     * ttwcts                     *                     * Wait for CTS to go high (sleep on it).                     *                       F063 8D   AC       SR4ttwcts bsr    SR4ttnx   enable xmit ints only  F065 C6   EC                 ldb    #TTYOPR   set priority  F067 10AE 04                 ldy    tqout,x   point to output q  F06A 7E   E6A9               jmp    sleep     sleep on CTS                                                               *                     * ttwdcd                     *                     * Wait for DCD to go high (sleep on it).CPU09IOP   Intelligent I/O Proce     14:11:08  Jan 12, 2026   Page   89ACIA       interface routines                                            *                       F06D 39            SR4ttwdcd rts              currently  not implementedCPU09IOP   Intelligent I/O Proce     14:11:08  Jan 12, 2026   Page   90Debug Interface Routines                                                   F06E               DB_main  F06E 8D   4F                 bsr    DB_test   see if debug routines present  F070 6E   9F C002            jmp    [DEBUGROM+2]  F074               DB_pdata  F074 8D   49                 bsr    DB_test   see if debug routines present  F076 6E   9F C004            jmp    [DEBUGROM+4]  F07A               DB_phex  F07A 8D   43                 bsr    DB_test   see if debug routines present  F07C 6E   9F C006            jmp    [DEBUGROM+6]  F080               DB_phex2  F080 8D   3D                 bsr    DB_test   see if debug routines present  F082 6E   9F C008            jmp    [DEBUGROM+8]  F086               DB_pcrlf  F086 8D   37                 bsr    DB_test   see if debug routines present  F088 6E   9F C00A            jmp    [DEBUGROM+10]  F08C               DB_check  F08C 8D   31                 bsr    DB_test   see if debug routines present  F08E 6E   9F C00C            jmp    [DEBUGROM+12]  F092               DB_config  F092 8D   2B                 bsr    DB_test   see if debug routines present  F094 6E   9F C00E            jmp    [DEBUGROM+14]  F098 34   17       DB_msg    pshs   cc,d,x  F09A AE   65                 ldx    1+2+2,s   get return address  F09C EC   81                 ldd    ,x++      get mask word  F09E B4   010D               anda   DB_cntrl  F0A1 F4   010E               andb   DB_cntrl+1  F0A4 34   04                 pshs   b  F0A6 AA   E0                 ora    ,s+  F0A8 27   04                 beq    10f       jump if flag not set  F0AA 30   02                 leax   2,x       skip over false address & fall through  F0AC 20   02                 bra    20f  F0AE AE   84       10        ldx    ,x        get false branch label  F0B0 AF   65       20        stx    1+2+2,s   fix up return address  F0B2 35   97                 puls   cc,d,x,pc return                     *  F0B4               DB_pspace  F0B4               DB_outsp  F0B4 34   16                 pshs   d,x  F0B6 8E   F0BD               ldx    #00f  F0B9 8D   B9                 bsr    DB_pdata  F0BB 35   96                 puls   d,x,pc  F0BD 20 00         00        fcc    ' ',0                       F0BF 34   07       DB_test   pshs   cc,d  F0C1 FC   C000               ldd    DEBUGROM  Debug rom present?  F0C4 1083 1234               cmpd   #$1234    special marker  F0C8 27   05                 beq    99f       yes - exit  F0CA 35   07                 puls   cc,d      no - abort DB_xx function  F0CC 32   62                 leas   2,s  F0CE 39                      rts  F0CF 35   87       99        puls   cc,d,pc   returnCPU09IOP   Intelligent I/O Proce     14:11:08  Jan 12, 2026   Page   91Debug Interface Routines                                                                                                     end    rom_initCPU09IOP   Intelligent I/O Proce     14:11:09  Jan 12, 2026   Page   92Debug Interface Routines                            Symbol Table:Absolute Symbols:A        0008   AC_8N1   0014   AC_DIV0  0001   AC_DIV1  0002   AC_DRTS  0040   AC_DV16  0001   AC_MRES  0003   AC_REIN  0080   AC_SET   0015   AC_TEIN  0020   AC_WS0   0004   AC_WS1   0008   AC_WS2   0010   AS_FRME  0010   AS_IRQ   0080   AS_NCTS  0008   AS_NDCD  0004   AS_OVRN  0020   AS_PERR  0040   AS_RDRF  0001   AS_TDRE  0002   B        0009   BASE_SLO 8000   BRTBSIZ  0006   BSECH    0020   BSPCH    007F   CBSIZE   0020   CC       000A   CFGDAT   00E0   CHRLIM   00FE   CLISTS   026E   CLOCK    8070   CLOCKI   8071   CLOCKPR  FFC4   CNCLC    0018   CNTRL    0080   CPU2DEV  0022   CPU_down E045   CPUtraps FFF0   CR       000D   CRMOD    0010   D        0000   DBG_8274 0002   DBG_CMD  0100   DBG_HAN  0020   DBG_INIT 0400   DBG_INT  0004   DBG_IO   0010   DBG_MSG  0200   DBG_OPEN 0800   DBG_SLP  0040   DBG_SYS  0001   DBG_TASK 0080   DBG_TRMI 0008   DB_check F08C   DB_cntrl 010D   DB_confi F092   DB_iflg  010C   DB_main  F06E   DB_msg   F098   DB_outsp F0B4   DB_pcrlf F086   DB_pdata F074   DB_phex  F07A   DB_phex2 F080   DB_pspac F0B4   DB_test  F0BF   DBmsg00  E000   DBmsg01  E011   DBmsg02  E031   DEBUG    0D04   DEBUGROM C000   DEBUG_CO 0000   DEV2CPU  0021   DEV_6850 EEC5   DEV_SIZE 0006   DLE      0010   DLE_GOT  0040   DLE_SENT 0020   DO_HISTO 0000   DO_IXON  0000   DP       000B   DSR_OK   0001   D_CLOSE  0004   D_END    0026   D_GETD   0014   D_INTRPT 000E   D_OPEN   0002   D_RQRD   000A   D_RQWR   0006   D_SEND   000C   D_SETD   0016   D_TTYG   001C   D_TTYS   001A   D_WRC    001E   D_WRITE  0008   D_init   0022   D_inthan 0020   D_test   0024   D_ttconf 0026   D_ttdisx 002E   D_ttend  0048   D_ttenno 0034   D_ttenr  0030   D_ttenx  0032   D_ttenxr 002C   D_ttgetc 002A   D_ttisct 003A   D_ttputc 0028   D_tttstb 003E   D_tttstc 0042   D_tttstd 0044   D_tttste 0046   D_tttstr 003C   D_tttsts 0040   D_tttstx 0038   D_ttwcts 004A   D_ttwdcd 004C   D_ttxbsy 0036   E        000E   ECHO     0002   EOTCH    0004   ESCOFF   0080   E_ABORT  00BF   E_BADCMD 0081   E_BADDEV 0084   E_DEVBSY 0085   E_INTRPT 00BE   E_IOERR  0086   E_NTOPEN 0083   E_SOCKET 00C0   E_SYSBSY 0082   F        000F   FF       0040   FIFO_get E3CD   FIFO_put E3F2   FIFOgeta E3C4   FIFOputa E3EA   FIOPRI   000F   FIO_get  E3A2   FIO_lock 015C   FIO_rel  E3B7   HANGS    0001   HOLD     0002   HOLDC    001B   IF       0010   INTRC    0003   INTS     0002   IOPTDMIN 0009   IO_end   E4E4   IO_han   E47E   IRQ_han  E502   IS       0003   IU       0002   IX       0000   IXONXOF  0010   IY       0001   LCASE    0008   MAX_CL   007C   MAX_DEV  000D   MAX_FCMD 0010   MAX_NEC  0000   MAX_OB   0400   MAX_PPR  0000   MAX_TI   000A   MAX_TSK  0028   MAX_TTY  000C   MIN_OB   0120   MIN_TSK  0020   MOD_SIZE 0004   NECADR   02CE   NEC_IQ   02CC   NECstr   027C   NEXT_SLO 0010   NL       000A   NUM_CL   00E1   NUM_NEC  00E4   NUM_PPR  00E3   NUM_TRM  00E2   NUM_TSK  00E0   OBUFRS   0274   OBUF_SIZ 0100   OQHI     0102   OQH_SIZE 000A   OQLO     0104   O_CLOSE  0010   O_INTRPT 0038   O_OPEN   0008   O_PGETD  0058   O_PSETD  0060   O_READ   0030   O_RQRD   0028   O_RQWR   0018   O_TTYG   0050   O_TTYS   0048   O_WR1C   0040   O_WRITE  0020   PC       0005   PPstr    027A   PRCSIZ   0100   PROTOCOL 00F8   QH_SIZE  0005   QUITC    001C   QUITS    0003   RAMend   6FFF   RAMorg   0100   RAMscrat 7000   RAMscren 7F00   RAW      0001   REJECT   0080   ROMLOorg E000   ROM_ERR  E0CF   ROM_VERS 0020   ROMstack 7FFF   RUNPRI   0046   R_CLOCK  000E   R_CLOSE  0002   R_INTRPT 0007   R_OPEN   0001   R_PDATA  000B   R_RD1C   0009   R_RDOK   0005   R_READ   0006   R_READM  000C   R_REQOK  0003   CPU09IOP   Intelligent I/O Proce     14:11:09  Jan 12, 2026   Page   93Debug Interface Routines                            R_RESET  000F   R_TTY    000D   R_WR1C   0008   R_WRITE  0004   S        0004   SCHR     0040   SEND_DLE 0008   SEND_XOF 0004   SEND_XON 0002   SIQPRI   FFD8   SI_HAN   E55E   SI_Q     011E   SI_Q_ptr 015A   SPACE    0020   SR4_IRQ  EF19   SR4_SLOT 0003   SR4_init EF33   SR4_name E339   SR4_test EF41   SR4false F035   SR4true  F032   SR4ttcon EFBA   SR4ttdis F001   SR4ttget EFF6   SR4ttisc F02E   SR4ttnd  F062   SR4ttnno F019   SR4ttnr  F009   SR4ttnx  F011   SR4ttnxr EFF9   SR4ttput EFF3   SR4ttstb F040   SR4ttstc F051   SR4ttstd F05F   SR4ttste F05A   SR4ttstr F038   SR4ttsts F04F   SR4ttstx F026   SR4ttwct F063   SR4ttwdc F06D   SR4ttxbs F021   SYS_ACIA 8000   SYS_TABS 02D6   TABCH    0009   TFREE    0004   TIMOUT   0001   TOPEN    0004   TOPWOC   0010   TRANSPNT 0008   TRUN     0001   TSKSIZ   00A2   TSLEEP   0002   TSYS     0005   TTYIPR   FFF6   TTYLOCK  FFDD   TTYOPR   FFEC   TTYQS    0272   TTYSIZ   0022   TTYSPR   FFE2   TTYTABS  0270   TWAIT    0003   U        0003   USTSIZ   008A   V        0007   W        0006   X        0001   XANY     0020   XOFFC    0013   XOF_SENT 0010   XONC     0011   XONXOF   0040   XTABS    0004   Y        0002   Z0       000C   Z1       000D   bad_cmd  E4FF   brbupr   EF13   brbutb   02D0   brr      0002   cbchrs   0002   cbstrt   0000   cbufct   011B   cfreel   0119   change   E5C3   chproc   0118   clcnt    0000   clfst    0001   clini2   E272   clinit   E26A   cllst    0003   clock_ti 016D   close_tt EDD3   cpu_fio  0000   cpu_fio1 0001   cpu_fio2 0003   cpu_fio3 0004   cpu_fio4 0006   cpu_fio5 0008   cpu_fioF 0024   csr      0000   dbuf     0001   dev_addr 0000   dev_brbu 0004   dev_tab  027E   dev_type 0002   end_vars 6FFF   fifo     0020   fifo_cnt 0012   fifo_get 0014   fifo_put 0016   fifo_us0 0018   fifo_us1 001A   fifo_us2 001C   fifo_us3 001E   fio_cpu  0009   fio_cpu1 000A   fio_cpu2 000C   fio_cpu3 000D   fio_cpu4 000F   fio_cpu5 0011   fio_cpuF 0023   fio_dsz  E064   fio_fsz  E062   fio_irq  E40D   fio_msg  E36A   fio_rese E342   fio_resp E386   fio_star E097   fio_wait E356   fiointe  E47D   flushi   EC6D   flusho   EC42   flusht   EC1A   fluso0   EC49   fluso1   EC51   get_oq   E796   get_pdat E9C1   getc     E6F8   getc1    E713   getc2    E721   getc3    E735   getc4    E73A   getjo1   E60B   getjo2   E61A   getjo4   E621   getjo6   E62A   getjo8   E62C   getjob   E605   idle     011D   int_all  E52E   int_buf  015D   int_ptr  016B   intret   E06C   irq_han  E069   jobpri   0117   lcbuf    011C   lcht     EB13   makrd6   E684   makrdy   E66F   max_trn  E066   mod_name 0002   mod_tbl  E333   mod_type 0000   no_dev   E255   open_tty EDCB   oq_buf   0002   oq_count 0000   oq_end   0008   oq_get   0006   oq_put   0004   prcbuf   016E   put_oq   E7BA   putc     E740   putc1    E75E   putc2    E781   putc3    E78E   putc4    E790   putru1   E643   putru2   E64A   putru4   E658   putru5   E667   putru6   E66B   putrun   E636   read_dat ED86   req_read ED5C   req_writ EDDB   rom_bad  E0CD   rom_firq E0A0   rom_init E075   rom_int  E0C2   rom_nmi  E09A   rom_swi  E0A7   rom_swi2 E0AD   rom_swi3 E0B4   rom_trap E0BB   rsche2   E5DA   rsche3   E5EE   rsched   E5C9   runlst   010F   sdev_sig EEA2   send_SI  E5A0   send_int EEA4   set_pdat E9E0   set_tabl E10B   sleep    E6A9   sleep7   E6D1   slot_tbl 0106   slplst   0111   stbinit  E0DC   sto_chk  E25C   swtchu   E5FA   sys_vars 0100   taddr    0006   tbaud    0012   tbaud2   0013   tbksp    0010   tcncl    0011   tcolm    000F   tdel     000E   tdelay   0009   tdevic   000A   tflags   0008   tintr    E88A   tintr2   E8B8   tintr3   E8C0   tintr4   E8CE   tintr5   E8D6   tintr6   E8DE   tintr7   E8E6   tintr8   E8ED   tintr9   E906   tlock    0017   tqin     0000   tqout    0004   tqproc   0002   tregs    001A   tsagin   0010   tscmd    0009   tsdev    000D   tsdtix   000F   tsevnt   0006   tskend   0278   tskinit  E2DC   tsktab   0276   tslink   0000   tsold    0018   tsprir   0005   tsseq    000A   tssgnl   0008   tsslnk   0002   tsstat   0004   tstate   0014   tstate2  0015   tstate3  0016   tstval   000C   ttask    000C   ttcls    E83A   ttdop5   E813   ttdop6   E81E   ttdopn   E7F0   CPU09IOP   Intelligent I/O Proce     14:11:09  Jan 12, 2026   Page   94Debug Interface Routines                            tterxt   EDDA   ttftab   E864   ttftb2   E86A   ttopn    E7D3   ttopn8   E7E3   ttyget   E97D   ttyi25   EB37   ttyi27   EB3A   ttyi33   EB4C   ttyi34   EB54   ttyi35   EB63   ttyi36   EB67   ttyi44   EB75   ttyi46   EB80   ttyi65   EBCF   ttyi67   EBD9   ttyi85   EC13   ttyin    EB1E   ttyin0   EB26   ttyin2   EB2A   ttyin3   EB3D   ttyin4   EB6F   ttyin5   EBAB   ttyin6   EBB9   ttyin7   EBDB   ttyin8   EBF8   ttyin9   EC19   ttyinit  E28C   ttyo12   EA7E   ttyo14   EA8E   ttyo22   EAAB   ttyo23   EAAF   ttyo24   EAC0   ttyo75   EAE3   ttyo77   EAF1   ttyoe1   EB12   ttyou2   EA99   ttyou4   EAC4   ttyou6   EAD5   ttyou8   EAFF   ttyoue   EB05   ttyout   EA67   ttyren   EA02   ttys45   E9A8   ttys55   EA4D   ttyset   E90B   ttysg5   E9AA   ttyst    EA1A   ttyst1   EA2D   ttyst15  EA36   ttyst2   EA47   ttyst6   EA4E   ttyst65  EA59   ttyst9   EA61   ttywrt   EDAE   umark0   0014   umark1   0016   usp      0012   utask    0115   wakeu2   E690   wakeu3   E697   wakeu4   E69B   wakeu5   E69D   wakeup   E685   write_da EE25   wrt_sc   EE67   xmtint   E6DE   xtca32   ECFF   xtca33   ED11   xtp315   ECF8   xtpr21   ECB5   xtpr22   ECBD   xtpr25   ECD5   xtpr31   ECE1   xtpr45   ED32   xtprc0   EC98   xtprc1   ECA2   xtprc2   ECA9   xtprc3   ECD7   xtprc4   ED1E   xtprc5   ED42   xtprc6   ED4C   xtprc7   ED57   xtprcq   EC80   