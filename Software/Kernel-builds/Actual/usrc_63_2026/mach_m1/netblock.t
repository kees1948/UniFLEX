        opt     nol        lib     ../mach_m1/sysconfig.h        lib     ./gendrvr.h        lib     ../include/blktab.h        lib     ../include/wzsock.h        lib     ../include/fio.h        lib     ../include/fio_ctrl.h        lib     ../include/fio_codes.h        lib     ../include/nwp_codes.h        lib     ../include/socket.h        lib     ../include/ust.h        lib     ./netblock.h        opt     lis,exp        if       (NETBLCK=1)        if       (NET<>1)        err     "netdrivers not present!!!        endif        sttl     netblock Driver        pag        data        name    netblockdrvr        global  nbopn,nbcls,nbio,nbdata        global  nbcopen,nbcclos,nbcspcl,nbcrd,nbcwrREPORT  set     0**************************************************************** netblock driver, allow a remote block device or diksimage file* to be accessed as a local filesystem** uses a socket connection with the remote part***************************************************************NBtbl  fdb     0               Block Device Table addressblktbp  rzb     2               swap memory block table pointernbdata  rzb     NBPSIZ*2       all details are kept here* Block driver part, no equivalent device driver**************************************************************** open the netblock disk drive* B contains device minor* here the devices run from 0 up to max***************************************************************nbopn   pshs    d,x        ldx     #nbdata         all there is to know        cmpb    #MXNBDV        bhs     nbop12        lda     #NBPSIZ        mul        leax    d,x             point to right data set* set in use        ldy     #NWP0        lda     nbopct,x        is it open?        inca        sta     nbopct,x        cmpa    #1              first open?        bne     nbop3           if open do not initialize** fresh open*nbop61  jsr     wzsock          init socket, set nbsock        bne     01f        stu     nbsock,x* U=wzsock        jsr     nbskop          open socket        bne     nbop21        lda     nbflgs,x        ora     #NB_OPEN        open done        sta     nbflgs,x*        jsr     nbskcn          try connect        bne     nbop21          server should be there first* connection made        ldb     #NB_ESTB        established        orb     nbflgs,x        stb     nbflgs,x        bra     nbop3** Y=NWP0, X=nbdata, failure during open or connect*nbop21  bsr     nbskcl        bra     02f** device minor in error, not much to do*nbop12  lda     #EBDEV        sta     uerror        bra     nbop3** set error and close*nbop2   lda      #EBARG          no image file set01      sta      uerror** error code alreay set, undo open count*02        dec     nbopct,x*nbcl3   lda     nbflgs,x        anda    #255-(NB_OPEN+NB_ESTB)        sta     nbflgs,x** open exit, generic*nbop3   puls     d,x,pc          return**************************************************************** nb close D=device***************************************************************nbcls   pshs    d,x        ldx     #nbdata         all items        cmpb    #MXNBDV        bhs     nbop12        lda     #NBPSIZ        mul        leax    d,x             point to right data set*        lda     nbopct,x        beq     nbcl3        deca        sta     nbopct,x        bne     nbop3* disconnect        bsr     nbskcl        bra     nbcl3nbskcl  ldu     nbsock,x        release socket info        jsr     wskcl        ldd     #0        std     nbsock,x        rts*************************************************************** X=nbdata, Y=NWP0, U=xxxx* init socket data, check local device active**************************************************************nbskin  pshs    x,y,u        jsr     wzsock          allocate a wzsock        bne     02f* U=wzsock        ldx     0,s             nbdata        stu     nbsock,x        set wzsock        clra*02      puls    x,y,u,pc**************************************************************** X=nbdata, Y=NWP0, U=wzsock* open socket**************************************************************nbskop  pshs    x,y,u        ldu     nbsock,x        ldd     #AF_INET        std     wzfaml,u        ldd     #SK_STRM|SK_SPONCL      signal @ disconnect        std     wztype,u        ldd     #0        std     wzprot,u        jsr     wskop           open the socket        puls    x,y,u,pc        pass error in D*************************************************************** X=nbdata, Y=NWP0, U=wzsock* open socket**************************************************************nbskcn  pshs    x,y,u        ldu     nbsock,x        ldd     nbipad,x        transfer network settings        std     wzipad,u        ldd     nbipad+2,x        std     wzipad+2,u        ldd     nbport,x        std     wzdprt,u        ordx    nbipad+2,IX      X via macro!        ordx    nbipad,IX       check        beq     nbcne1           not set* try connect, bail out when peer is absent        jsr     wskcn           peer should be there01      puls    x,y,u,pc        pass error via Dnbcne1  ldd     #-1        bra     01b**************************************************************** X = ptr to block device struct* Y = buf header* devices run from 0 up to max***************************************************************nbio    stx     NBtbl         save Block Device Table address        inc     nblkdt+dtbusy    mark busy*        ldx     #nbdata        ldb     bfdvn+1,y       device minor        cmpb    #MXNBDV        bhs     02f        lda     #NBPSIZ        mul        leax    d,x             point to right data set*        ldu     nbsock,x        get wzsock        bne     01f** error return*02      ldb     #EBARG          wzsock missing!!        bra     07f* closed connection16      ldb     #ENOFL        bra     06f** clean up stack first*32      puls    x,y,u*06      pshs    b        ldy     #NWP0        jsr     FIFO_unlock        puls    b07      lbra    nbdone          return** tests passed*01      ldb     wzfsta,u        bpl     16b        ldb     wzstat,u        cmpb    #WSESTB         established        bne     16b** X=nbdata, Y=bufhdr, U=wzsock* nbdata holds a number of items*04      pshs    x,y,u           X=nbdata,Y=bufhdr,U=wzsock*        clr     wzflg,u         no swap initially        ldd     bfxfc,y         safety check        cmpd    #MAXPAGES        bhi     24f* swap        ldd     bfadr,y         copy table pointer        std     blktbp          keep it        inc     wzflg,u         set swap action** main swap loop,*swplop  jsr     nbsetba         set real buff address        bne     29f        puls    x,y,u        lbra    nbdone*29      ldd     #0        std     wzswap,u        init start valu        bra     swpbfl*24      cmpd    #BUFSIZ        beq     26f        cmpd    #256            FLEX BUF        beq     26f        puls    x,y,u           correct stack        bra     02b             illegal size** do 8 times per page*swpbfl  ldd     #BUFSIZ* we can skip a couple of tests as it is al system26      std     wzrqln,u*        ldu     #NWP0        ldu     fio_dba,u       fifo base address        ldd     bfblck,y        std     fifo_us3,u        lda     bfflag,y        write command        ldb     bfblch,y        std     fifo_us2,u      and 'disk' address        ldu     4,s             restore wzsock* X=nbdata, U=wzsock, Y=NWP0, A=bfflag*        ldy     #NWP0           for fifo access        bita    #BFRWF          1 = read        beq     nbwrt** X=nbdata Y=NWP0, U=wzsock, READ function*        ldb     #S_RQRBLK       tell GPP I want to data        jsr     fio_msg         then it should tell the peer        cmpb    #R_RQRBLK        lbne      32b             to arrive, on return it has arrived*        jsr     get_F_S         allocate fifo        ldb     #S_RDRBLK       tell we are ready for it        jsr     fio_msg        cmpb    #R_RDRBLK        lbne    32b** X=nbdata,Y=NWP0, W=count, U=wzsock*        ldx     2,s             X=bufhdr        ldd     wzxfer,u        ldu     #0        ldy     fio_dba,y        leay    fifo,y        jsr     cpystb          sytem to buffer        ldy     #NWP0        jsr     FIFO_unlock        puls    x,y,u        ldb     wzflg,u        beq     nbdone** swap update*nbupdlp equ     *        pshs    x,y,u           save again        ldd     bfblck,y        incd        std     bfblck,y        bcc     01f        inc     bfblch,y01      ldx     #BUFSIZ        ldd     wzswap,u        addr    X,D             X + D > D        std     wzswap,u        cmpd    #PAGSIZ         did 8 buffers        beq     02f        ldd     bfadr,y        addr    X,D             X + D > D        std     bfadr,y        ldx     0,s             old X        lbra    swpbfl* next page?02      lbra    swplop** X=nbdata Y=NWP0, U=wzsock, WRITE function*nbwrt   ldb     #S_RQSBLK       tell GPP I want to send data        jsr     fio_msg         on return it ready to get it        cmpb    #R_RQSBLK       response        lbne    32b        jsr     get_F_S         allocate fifo** X=nbdata, Y=NWP0, W=count, U=wzsock, D=count*        ldx     2,s             X=bufhdr        ldd     wzrqln,u        ldu     #0        ldy     fio_dba,y       Y= fifo (memory address)        leay    fifo,y        jsr     cpybts        ldy     #NWP0*        ldu     4,s             restore wzsock        ldb     #S_SNDBLK       tell GPP data is in fifo        jsr     fio_msg        cmpb    #R_SNDBLK        lbne    32b        jsr     FIFO_unlock        puls    x,y,u        ldb     wzflg,u        bne     nbupdlp** done, update the caller bufhdr for error return* no interrupts are to be handled in this code*nbdone  ldy     nblkdt+dtqfl    nbbufh,x        get last transaction        stb     uerror        beq     01f        lda     bfflag,y        ora     #BFERR        sta     bfflag,y*01      clr     nblkdt+dtbusy    set unbusy        clr     nblkdt+dtrtry    clear funtion        ldx     NBtbl        jmp     BDioend** nb get new swap page*nbsetba pshs    x        ldx     blktbp        ldb     0,x+        stx     blktbp        cmpb    DSKTRM          end        bne     81f        clrb                    sez        puls    x,pc81      lda     #16        mul        std     bfxadr,y        clr     bfadr+1,y        ldd     #0        std     wzswap,u        clz        puls    x,pc        pag* nb-control,  a character interface driver**  character open*  open the /dev/nbctl with minor 0*  A/B = device , Y = FND ptr, single (exclusive) open*nbcopen  equ     *        ldx     #nbdata        cmpb    #MXNBDV        bhs     21f        lda     #NBPSIZ        mul        leax    d,x             point to right data set*        lda     nbflgs,x         and nb-control is to be        bita    #NC_OPEN        exclusively open for each        bne     02f             /dev/nbx instance*nbcop10 ora     #NC_OPEN        mark open state        sta     nbflgs,x        bra     05f*21      lda     #EBDEV        bra     03f*02      lda     #EBSY           tel caller to wait03      sta     uerror05      rts** character close**nbcclos  ldx    #nbdata        cmpb    #MXNBDV        bhs     21b        lda     #NBPSIZ        mul        leax    d,x             point to right data set*        lda     nbflgs,x          the right details        anda    #255-NC_OPEN     erase open state        sta     nbflgs,x        rts** nbcrd, character read*nbcrd   equ     *        pshs    d       save device info        ldy     #nbchbf private buffer        jsr     blkgtb  get device buffer        puls    d        jsr     nbchcn  configure buffer        tst     uerror  OK?        beq     nbchr4*nbche1  pshs    y        ldy     #nbchbf        jsr     blkfrb  release buffer        puls    y,pc*nbchr4  pshs    a        orb     #BFRWF  set read        stb     bfflag,y        bra     nbchio** nbcwr, character write*nbcwr   equ     *        pshs    d       save device info        ldy     #nbchbf        jsr     blkgtb        puls    d        jsr     nbchcn  configure        tst     uerror  OK        bne     nbche1*        pshs    anbchio  ldb     #NBmajor        jmp     blkcio*nbchcn  std     bfdvn,y        ldd     uicnt        std     bfxfc,y        cmpd    #BUFSIZ        beq     nbch5*        lda     #EBARG        sta     uerror        rts*nbch5   jmp     blkcnf** D=major minor, X=data area*nbcspcl pshs    d,x,y,u* is sock allocated?        tfr     x,y             Y := data area        cmpb    #MXNBDV        bhs     21f        ldx     #nbdata        lda     #NBPSIZ        mul        leax    d,x             point to right data set* X=nbdata, don't change when in use*        cmpy    #0              get/set indicator        bne     01f* Y is free now        tfr     x,y             Y = nbdata******************************************************* set (usarg0,usarg1,usarg2)* read user space via pointer* usarg0 =* usarg1 = pointer to sock_addr* usarg2 =* Y=nbdata* U=wzsock********************************************************        ldx     usarg1          memory pointer        cmpx    #MXUMEM         check bounds        bhs     11f** ONLY when AF_INET is set properly* and the block device is NOT open* and NO socket is allocated*        jsr     gtuwrd          get data from [X] !!        cmpd    #AF_INET        bne     51f        lda     nbflgs,y        bita    #NB_OPEN        don't change        bne     12f        ldu     nbsock,y        stu     -2,s            test zero        bne     12f** it is safe to set the parameters*        leax    2,x             same sockaddr_in struct*40      jsr     gtuwrd        std     nbipad,y        as in other code        leax    2,x        jsr     gtuwrd        std     nbipad+2,y        leax    2,x        jsr     gtuwrd        std     nbport,y*        bra     10f51      cmpd    #$ffff        bne     11f*        ldx     #nbdata        ldb     1,s             old B        lda     #NBPSIZ        mul        leax    d,x        lda     nbflgs,x        anda    #255-(NB_OPEN+NB_ESTB)        sta     nbflgs,x        ldu     1,x        beq     52f        jsr     wskcl52      bra     40b******************************************************* get (0,y 1,y 2,y 3,y 4,y 5,y)* write data via pointer into user space* 0,x =* 2,x =* 4,x =* X = nbdata*******************************************************01      ldd     nbipad,x        std     0,y             put data to user        ldd     nbipad+2,x        std     2,y        ldd     nbport,x        std     4,y*        bra     10f*12      lda     #EBSY        bra     14f*21      lda     #EBDEV        bra     14f*11      lda     #EBARG         error return14      sta     uerror*10      puls    d,x,y,u,pc        endif        end