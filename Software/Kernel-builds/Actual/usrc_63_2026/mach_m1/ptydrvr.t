** slave driver for PTY's pseudo tty*        lib     ../mach_m1/sysconfig.h        if      (PTTY=1)        opt nol        lib     ./gendrvr.h        lib     ../include/tty.h        lib     ../include/ust.h        lib     ../include/sysdefs.h        lib     ../include/inttab.h        opt lis        data        global  ptysop,ptyscl,ptysrd,ptyswr,ptysspptyopen rzb     MAXPTY          open flags** open slave device, shoudl be exclusively* on error, the open failed*ptysop  equ     *        bsr     ptgxtb          get table        bne     02f             no error return* table failed, was it control device?ptyer2  tstb                    for control info only        beq     01fptyer1  lda     #EBDEV          error selecting device04      sta     uerror01      rts03      lda     #EBSY          error return        bra     04b02      subb    minpty          first pty        ldx     #ptyopen        open flags        abx        tst     0,x*        bne     03b             already open, error        inc     0,x             set new open        rts** close slave device*ptyscl  equ     *        bsr     ptgxtb        beq     ptyer1        tstb                    pty control?        beq     01f             just return* only for normal ptys        pshs    b               save port info        jsr     flusht          empty device queues        ldd     #HANGS          signal all connected processes        jsr     intrpt          send hangup        puls    b               restore        subb    minpty          first pty        ldx     #ptyopen        open flags        abx        clr     0,x             set closed01      rts** slave read, get master write data*ptysrd  equ     *        bsr     ptgxtb          get table info        beq     ptyer1        lda     #1              set user IO space        sta     uiosp*02      ldy     tqout,x        jsr     getc            get char from queue        bmi     01f             no data        jsr     passc           to user        bra     02b* wakeup senders01      ldy     tqout,x        jsr     wakeup          wake sleepers        rts** slave write, is master read data*ptyswr  equ     *        bsr     ptgxtb          get table info        beq     ptyer1        lda     #1              set user IO space        sta     uiosp*02      jsr     cpass           byte from user        bmi     01f        jsr     ttyin           to input queue        bra     02b*01      ldy     tqproc,x        wake readers        jsr     wakeup        rts** return the right tty structure* return: Z=set, table invalid, Z=clr, table valid*ptgxtb  pshs    d        subb    minpty        bmi     ptxer1          too low        cmpb    #MAXPTY        bhs     ptxer1          too high*        ldb     1,s             restore B        ldx     ttytab        lda     #TTYSIZ        mul        leax    d,x             pick right table        ldd     taddr,x         address MUST be zero        bne     ptxer1        lda     #1              CLZ01      puls    d,pcptxer1  clra                    SEZ        bra     01b** special, return control info* on ENTRY:D = maj/min* X: if 0, set from user args* X: if #0 get from tty struct*ptyssp  equ     *        tfr     x,y             move X to Y        tstb                    ptys0?        beq     01f             allow        bsr     ptgxtb          X = tty struct        lbne    ptyer1          illegal*        sty     -2,s            test Y        beq     ptyset** pty get*        lda     tflags,x        ldb     tdelay,x        std     0,y++        lda     tcncl,x        ldb     tbksp,x        std     0,y++        lda     tbaud,x        anda    #$1c            baud bits        tst     tdel,x          delimiter count        bne     10f        tst     [tqproc,x]      processed que        beq     11f10      ora     #%10000000      set new input11      tst     [tqout,x]        beq     12f        ora     #%01000000      set output present12      ldb     tstate,x                        a        andb    #HLDBTS        std     0,y        rts** pty set*ptyset  ldd     usarg1        sta     tcncl,x        stb     tbksp,x        ldd     usarg2        anda    #$1c        sta     tbaud,x        andb    #HLDBTS        pshs    b        ldb     tstate,x        andb    #(!HLDBTS)&$ff        orb     0,s+        stb     tstate,x        ldd     usarg0        stb     tdelay,x        ldb     tflags,x        sta     tflags,x        rts** for ptys00, control info*01      sty     -2,s            tst Y        beq     ptyse1* data to userptyge1  lda     minpty        ldb     #MAXPTY        std     0,y        ldd     #0        std     2,y        std     4,y        rts* data from userptyse1  nop                        nothing        rts        else        data        endif        end