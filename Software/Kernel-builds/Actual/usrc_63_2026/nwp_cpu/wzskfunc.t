** this file contains all socket handlers** when a wzsocket is opened, all locations are effectively* cleared to zero, with exception of the enumeration byte*BUFSIZ  equ     512             fifo and system buffer size** do everything to init the system*skinit  equ     *        jsr     spinit          set SPI        ldb     #%10000010      software reset + force ARP        jsr     PCRMR01      jsr     GCRMR        tstb        bmi     01b*        ldb     #%01111000      power up        jsr     PCRPHY          set the PHY part        ldd     #32768        std     wzanyp          set value for Source port        rts** sknone, return error, not implemented*sknone  ldb     #E_BADCMD        rts** check if ROM locations are preset, if not skip this here* else setup device with provided values*skdvini ldy     #wzifma         where mac address is to be found03      ldd     0,y++        cmpd    #$ffff          not set        bne     02f        cmpy    #wzifga+4       past area        blo     03b* ROM not initialized, do nothing        rts** values present, setup device*02      pshs    d,y,u        ldu     fifo_us1        ldy     #wzifip         source IP        ldd     0,y++        std     0,u++        ldd     0,y++        std     0,u++        ldy     #wzifnm         netmask        ldd     0,y++        std     0,u++        ldd     0,y++        std     0,u++        ldy     #wzifga         gateway ip        ldd     0,y++        std     0,u++        ldd     0,y++        std     0,u++        ldy     #wzifma         mac address        ldd     0,y++        std     0,u++        ldd     0,y++        std     0,u++        ldd     0,y++        std     0,u++*        ldb     #$ff            set active        stb     0,u        jsr     wzwdev           init device with settings        puls    d,y,u,pc** test if device is present*sktest  sec                     yes        rts** skinthan, fromddevice table*skinthan equ    *        rts** device signal handle, from master*sdev_sig equ    *        ldb     #R_INTRPT       we saw it        rts** get a new source port*sknewp  ldd     wzanyp          else create one        incd        cmpd    #$FFF0        blo     03f        ldd     #$800003      std     wzanyp        rts** check if W5500 is active* wzdevt, device test, return Z if running, NZ if not*wzdevt  pshs    a,y        ldy     fifo_us1        device info        lda     wzdsta,y        cmpa    #$ff            open        puls    a,y,pc** U=wzsock, originally in OS address range* convert it to Network CPU range* skfres, socket restore info, set E register*skfres  exg     u,d        anda    #%00000011      i.e EA20 -> 0220        exg     d,u        lda     wzenum,u        socket #, is remembered        trfr    A,E        clr     wzerr,u         init result        rts** skctcp, check if in TCP mode* return zero if in TCP mode, non-zero if not* U = wzsock*skctcp  pshs    d        ldd     wztype,u        SOCK_STREAM        cmpb    #SK_STRM        is TCP        puls    d,pc** skcudp, check if in UDP  mode* return zero if in UDP mode, non-zero if not* U = wzsock*skcudp  pshs    d        ldd     wztype,u        SOCK_DGRAM        cmpb    #SK_DGRM        is UDP        beq     01f        cmpb    #SK_IRAW        also allowed01      puls    d,pc** skraw, check if in RAW mode* return zero if in RAW mode, non-zero if not* U = wzsock*skcraw  pshs    d        ldd     wztype,u        SOCK_DGRAM        cmpb    #SK_MRAW        is RAW socket        puls    d,pc****************************************************************** here the socket is opened* X hold the TASK table* U holds the sock address*skopen  equ     *        jsr     skfres** check if DEVICE is active*        jsr     wzdevt        beq     11f        jsr     skclin          NO, close internal and don't start04      lbra    skoper1** retry, we do all things*11      lda     wzfsta,u        check if allocated by OS        bpl     04b             error, do nothing** check socket() call arguments*        clr     wzflg,u         erase flags        clr     wzdctr,u        init counter        ldd     wzfaml,u        cmpb    #AF_INET        bne     04b             not supported* wztype holds socket type AND socket flags (hibyte)        ldd     wztype,u        cmpb    #SK_STRM        SOCK_STREAM        beq     01f        cmpb    #SK_DGRM        SOCK_DGRAM        beq     21f*        cmpb    #SK_MRAW        SOCK_RAW*        beq     41f        cmpb    #SK_IRAW        IP_RAW        bne     skoper2** raw IP socket, set protocol register first* UDP and TCP are handled in a different way*        ldd     wzprot,u        what is the protocol option?        cmpb    #SP_TCP         not allowed        beq     skoper2        cmpb    #SP_UDP         not allowed        beq     skoper2        jsr     PSRPROT         set protocol register*        ldb     #%00000011      IPRAW        bra     07f* nacraw41      ldb     #%00000100      MACRAW        bra     07f* dgram21      ldb     #%00000010      UDP        bra     07f* TCP socket01      ldb     #%00000001       TCP set source port in connect** set socket mode register*07      jsr     PSRMR           set socket mode register** here do the real OPEN,*        ldb     #WCOPEN         open the device        stb     wzcmnd,u        copy command        jsr     PSRCR        ldy     #0              nopoll** interrupts not expected*skowfo  equ     *        jsr     skfres          reset important info21      jsr     GSRSR           get status        stb     wzstat,u        cmpb    #WSCLSD         not closed?        bne     22f*        dec     wzdctr,u        delay counter        beq     skoper2        ldy     #skowfo        jmp     polext          switch tasks*22      lda     wzfsta,u        mark bind is needed        ora     #WZWBND        sta     wzfsta,u        clra        ldb     #R_OPEN         response99      rts*skoper1 lda     #1               device not initialized        bra     12fskoper2 lda     #2              type error12      ldb     #E_SOCKET        bra     99b** convert number in bit position* B = enum, B=bit*num2bt  pshs    x        ldx     #bittab        abx        ldb     0,x        puls    x,pc** bit to nummer, offset byt one, entry should NOT be 0*bt2num  pshs    x        ldx     #bittab        clr     0,-s02      cmpb    0,x+        beq     01f        inc     0,s        bra     02b01      puls    b,x,pc* tablebittab  fcb     0        fcb     %00000001,%00000010,%00000100,%00001000        fcb     %00010000,%00100000,%01000000,%10000000***************************************************************** close the socket and clean up* X hold the task table* U holds the sock address*skclos  equ     *skintrp equ     *               interrupt!        jsr     skfres        ldb     #WCDISC        stb     wzcmnd,u        jsr     PSRCR           send disconnect*        bsr     skclin          internal close        clrd        std     wzfaml,u        std     wztype,u        std     wzprot,u*        clra        ldb     #R_CLOSE        response        rts** wzclin, close interal*skclin  pshs    d        ldb     #WCCLOS         do close        stb     wzcmnd,u        jsr     PSRCR** erase registers in device*        ldd     #0        jsr     PSRPORT         source port*        lda     wzfsta,u        anda    #0              mask (?)        sta     wzfsta,u        ldd     #0        std     wzxfer,u        clear remaining size*91      jsr     GSRSR        stb     wzstat,u        stat = 0 (closed)*        ldd     #0        std     wzsprt,u        erase old info        std     wzipad,u        std     wzipad+2,u        std     wzdprt,u        stb     wzflg,u         clear flags*        puls    d,pc***************************************************************** connect socket* X hold the task table* U holds the sock address* connect() call fills in info in the sock structure*skconn  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt        beq     01f        jsr     skclos          NO, don't start02      lbra    skcner401      jsr     skctcp          not in tcp, illegal        bne     02b** check if socket has been set up*11      jsr     GSRSR           status        stb     wzstat,u        check if properly setup        cmpb    #WSINIT         SHOULD BE        lbne    skcner6** check the info from the connect call*        ldd     wzipad,u        check if dest IP == null        ordx    wzipad+2,IU        beq     skcner1         IP address == NULL* IP address = 0000        ldd     wzipad,u        or FFFFFFFF        incd        bne     01f        ldd     wzipad+2,u        incd        beq     skcner1         IP address = FFFFFFFF** valid IP*01      ldd     wzdprt,u        check destination port        beq     skcner5         is not set, error*        jsr     PSRDPOR         set destination port        leay    wzipad,u        load socket        jsr     PSRDIP          set destination IP** source port, create one, always unique*        jsr     sknewp          get new        std     wzsprt,u        tell us what you took        jsr     PSRPORT         source port** do the CONNECT here*        ldb     #WCCONN        stb     wzcmnd,u        jsr     PSRCR           do connect***conlb1  jsr     skfres        jsr     GSRSR           update status        stb     wzstat,u        cmpb    #WSESTB        beq     90f        cmpb    #WSCLSD         is closed?        beq     skcner2        cmpb    #WSCLWT         close wait?        beq     skcner2        ldy     #conlb1        bra     polext*90      clra        ldb     #R_CONNECT99      rts** polexit, Y=where to return*polext  sty     tsagin,x        here to restart        ldy     #$ffFF        rtsskcner2 ldb     #R_DISCON        bra     99bskcner6        lda     #15             not properly setup        bra     09fskcner5 lda     #14             destination port not set        bra     09fskcner1 lda     #11             IP address invalid        bra     09fskcner4 lda     #1              device not initialized09      ldb     #E_SOCKET        bra     99b***************************************************************** bind request* X hold the task table* U holds the sock address* bindt() call fills in info in the sock structure*skbind  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt        lbne    rdrqer1        jsr     skctcp          check TCP        beq     01f        jsr     skcudp          check UDP        lbne    skcner601** go on , the bind() call sets wzipad and wzsprt, this is for* a server, for a client it needs to set wzdprt* for as server IP is local, for a client IP is remote**        jsr     GSRSR           status        stb     wzstat,u        cmpb    #WSUDP          check        beq     03f        cmpb    #WSINIT         should be04      lbne    skcner6** set the network connection data*        jsr     sknewp        std     wzdprt,u        jsr     PSRDPOR         destination port        ldd     wzsprt,u04      jsr     PSRPORT         source port*        leay    wzipad,u        jsr     PSRDIP          source IP*        lda     wzfsta,u        we did BIND        anda    #255-WZWBND        sta     wzfsta,u        clra        ldb     #R_BIND        rts*03      ldd     wzsprt,u        if set, keep it        bne     04b        jsr     sknewp          make new        std     wzsprt,u        bra     04b***************************************************************** listen request* X hold the task table* U holds the sock address* listen() call waits for peer to connect*sklist  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b** go on**        jsr     GSRSR           status        stb     wzstat,u*        cmpb    #WSCLSD         closed?        beq     80f        cmpb    #WSCLWT         close wait?        beq     80f        cmpb    #WSINIT         opened        bne     90f*        lda     wzfsta,u        did we BIND        bita    #WZWBND        bne     80f             no, error*        ldb     #WCLIST        stb     wzcmnd,u        jsr     PSRCR*        clra        ldb     #R_LISTEN        rts* Go close and tidy up80      jmp     skclos*90      ldy     #sklist        jmp     polext***************************************************************** accept request* X hold the task table* U holds the sock address* listen() call waits for peer to connect*skacpt  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b             wrong mode** go on*        jsr     GSRSR           status        stb     wzstat,u        cmpb    #WSESTB         connected        bne     01f*        lda     wzfsta,u        did we BIND        bita    #WZWBND        bne     03f             no, error*        jsr     GSRDPOR         fill in peer port        std     wzdprt,u        leay    wzipad,u        jsr     GSRDIP*        clra        ldb     #R_ACCEPT        rts*01      cmpb    #WSCLSD        beq     03f        cmpb    #WSCLWT        bne     02f03      clra* go close and tidy up        jmp     skclos*02      ldy     #skacpt        jmp     polext***************************************************************** read request  TCP only !!* X hold the task table* U holds the sock address* connect() call fills in info in the sock structure*skreqrd equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp          check TCP        bne     02b** go on*        jsr     GSRSR        stb     wzstat,u        update status        cmpb    #WSESTB         connection active?        bne     82f* check data available        jsr     GSRRXRS         data available?        std     wzxfer,u        beq     85f* data present87      clra        ldb     #R_RQRD        rts* not established82      ldb     wzstat,u        cmpb    #WSCLSD         closed?        bne     84f             (85f)241128* close socket and return81      ldd     wztype,u        bita    #WFSHNGC        beq     71f        ldb     #HANGS        bra     72f71      bita    #WFSPOC        beq     70f             no signal        ldb     #PIPES72      jsr     send_SI         send to main CPU* close and tidy up70      jmp     skclos  !!##* established but no data yet || not established and not closed85      ldd     wztype,u        check flags        bita    #WFNBLK         non block        beq     84f* non block ************************        clra        ldb     #R_RQRDNB       tell no data        rts*84      ldb     wzstat,u        cmpb    #WSCLWT         last attempt        bne     86f             go poll* close wait active        jsr     GSRRXRS        std     wzxfer,u        bne     87b             last data        bra     81b             close*86      ldy     #skreqrd        jmp     polext** error in socket statusrdrqer1 lda     #130        ldb     #E_SOCKET        rts***************************************************************** get the data  U=wzsock, X=task struct*skrecv  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt        lbne    rdrqer102      jsr     skctcp        bne     02b** we got info that data is present, get it* if here the main CPU already locked the fifo for us* on return D= xfreed count*        jsr     GSRRXRS         received size* D total aviable data        ldy     #fifo           target        jsr     RDSK2FB         transfer datat to fifo        std     wzxfer,u        save it** here check if PROT_XLTEOF is set*        tst     wzprot,u        PROT_XLTEOL is $8000        bpl     01f** do EOL conversion in fifo buffer*        pshs    d,x,y        tfr     d,x             count        ldy     #fifo03      lda     0,y        cmpa    #LF             is line feed        bne     02f        lda     #CR             make it Return02      sta     0,y+        leax    -1,x            count        bne     03b        puls    d,x,y***01      ldb     #WCRECV        stb     wzcmnd,u        jsr     PSRCR           tell sender we took it        ldb     #R_READ         tell data in fifo        clra        rts***************************************************************** write request* X hold the task table* U holds the sock address* connect() call fills in info in the sock structure*skreqwr equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b** go on*        jsr     GSRSR        stb     wzstat,u        update status        cmpb    #WSESTB        bne     82f* connection active83      jsr     GSRTXFR         free size (remaining)        cmpd    wzrqln,u        would it fit        blo     85f* data space is enough88      clra        ldb     #R_RQWR        rts* not established82      ldb     wzstat,u        cmpb    #WSCLSD        bne     85f* close socket and return89      ldd     wztype,u        bita    #WFSHNGC        beq     71f        ldb     #HANGS        bra     72f71      bita    #WFSPOC        beq     70f             no signal        ldb     #PIPES72      jsr     send_SI         send to main CPU* close and tidy up70      jmp     skclos          !!##*85      ldd     wztype,u        bita    #WFNBLK        beq     86f* data space exhausted, would block        clra        ldb     #R_RQWRNB        rts* not closed86      ldb     wzstat,u        cmpb    #WSCLWT         try data        bne     87f*        jsr     GSRTXFR         free size (remaining)        cmpd    wzrqln,u        would it fit        bhs     88b        bra     89b*87      ldy     #skreqwr        jmp     polext***************************************************************** write request* X hold the task table* U holds the sock address* connect() call fills in info in the sock structure*sksend  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b** we got info that data is present, get it* if here the main CPU already locked the fifo for us* on return D= xfreed count*        ldd     wzrqln,u        data to xfer* D = total available space        tst     wzprot,u        check if PROT_XLTEOL is set        bpl     01f**  do EOL conversion in fifo buffer*        pshs    d,x,y        tfr     d,x             count        ldy     #fifo03      lda     0,y        cmpa    #CR             Return?        bne     02f        lda     #LF             make it Line feed02      sta     0,y+        leax    -1,x            count        bne     03b        puls    d,x,y***01      ldy     #fifo           target        jsr     WRFB2SK         transfer from fifo to socket        std     wzxfer,u        save it        ldb     #WCSEND        stb     wzcmnd,u        jsr     PSRCR           tell sender it is coming        ldb     #R_WRITE        tell data in fifo        clra        rts**************************************************************** skurrdf, request readfrom*** X hold the task table* U holds the sock address** UDP type transfers have diffent W5500 buffer layouts for receive** pure UDP  (WSUDP) returns**  [sender-IP][sender-Port][data-len][data.............]** IPRAW (WSIRAW) returns**  [senser-IP][data-len][data.................]**skurrdf equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skcudp        bne     02b** no  packet data present, wait for it*        jsr     GSRSR        stb     wzstat,u        update status        cmpb    #WSUDP        beq     81f*        cmpb    #WSIRAW         W55 state        bne     82f* IPRAW handling        ldd     wzurms,u        new data        bne     83f             no* yes, read data details        jsr     GSRRXRS         now full UDP size        std     -2,s            test D        beq     82f* read [sender-IP][data-len]        leay    wzuipa,u        ldd     #6        jsr     bmread* read data size        ldd     wzuprt,u        here lands size        std     wzurms,u        bra     87f* pure UDP handling, check if BIND has been called before81      lda     wzfsta,u        bita    #WZWBND         did we? BIND erases flag        lbne    skuer1          we need for datagram server*        ldd     wzurms,u        new data?        bne     83f             no* check data available        jsr     GSRRXRS         data available?        std     -2,s            test D        beq     82f             keep waiting** first data present, set [wzuipa(4), wzuprt(2), wzurms(2)]** get header info from data        ldd     #8              size of header        leay    wzuipa,u        read 8 bytes from socketbuffer        jsr     bmread          copy data and update PSRRXRP!        ldd     wzuprt,u        who sent it        std     wzdprt,u87      ldb     #WCRECV        stb     wzcmnd,u        process move pointer        jsr     PSRCR** wzurms is fetched from socket buffer with bmread*84      ldd     wzurms,u83      cmpd    #MAX_UDP        max size        bhi     89f*        clra        ldb     #R_RDFRM        tell caller        rts* no data yet82      ldd     wztype,u        check non-block        bita    #WFNBLK        bne     90f*        ldy     #skurrdf        jmp     polext*90      clra        ldb     #R_RQRDNB        rts*89        ldb     #E_SOCKET        rts**************************************************************** skurrd,  data readfrom*** X hold the task table* U holds the sock address*skurrd  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skcudp        bne     02b** go on*** transfer at most fio_fsz bytes        ldd     wzurms,u        this is leading count* D = total available data        ldy     #fifo           target        jsr     RDSK2FB         transfer data, update wzxfer        pshs    d               xferred count        ldd     wzurms,u        update        subd    0,s++        std     wzurms,u        new remaining*01      ldb     #WCRECV        stb     wzcmnd,u        set processed pointer        jsr     PSRCR*        clra        ldb     #R_RRDFD        rts**************************************************************** skurwt,  request sendto*** X hold the task table* U holds the sock address*skurwt  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skcudp        bne     02b** go on*        ldd     wzipad,u        ordx    wzipad+2,IU        lbeq    skuer1* set network registers        leay    wzipad,u        jsr     PSRDIP*        ldd     wzdprt,u        check illegal port        lbeq    skuer1*        ldd     wzdprt,u        jsr     PSRDPOR* for IPRAW set only destination IP and port        ldb     wzstat,u        cmpb    #WSIRAW        beq     skusnm          special** regulare UDP, set source port if not yet assigned        ldd     wzsprt,u        already set?        bne     16f        jsr     sknewp          get new source port        std     wzsprt,u        std     wzuprt,u        set also return port16      jsr     PSRPORT** wait for data to go out loop*skusnm  equ     *skuwr2  jsr     skfres          set socket base        jsr     wzdevt          devie active        lbne    02b             no        jsr     skcudp          check open method        bne     02b*        jsr     GSRSR        stb     wzstat,u        update status        cmpb    #WSUDP        beq     20f        cmpb    #WSIRAW         IPRAW        bne     skuer120      jsr     GSRTXFR         free size        cmpd    wzurms,u        set by driver        bhs     10f* no space yet        ldd     wztype,u        bita    #WFNBLK        bne     21f*        ldy     #skuwr2        jmp     polext          keep polling*21      clra        ldb     #R_RQWRNB       non block write        rts*10      ldd     wzurms,u        cmpd    #MAX_UDP        too big        bhi     skuer1*        clra        ldb     #R_RSNDTO        rtsskuer1        ldb     #E_SOCKET        rts**************************************************************** skusnt,  data sendto*** X hold the task table* U holds the sock address*skusnt  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skcudp        bne     02b** go on** transfer fifo to socket data register        ldd     wzurms,u        total data*        ldy     #fifo           target        jsr     WRFB2SK         fifo to socket        pshs    d        ldd     wzurms,u        all loaded        subd    0,s++        std     wzurms,u        bne     01f        ldd     wzuwrp,u        is it used        jsr     PSRTXWP         set write pointer        ldb     #WCSEND        stb     wzcmnd,u        jsr     PSRCR        clra        ldb     #R_WSNDTO       data taken        rts01      clra        ldb     #R_SNDTOM       ask for more        rts***************************************************************** netblock, read block* the method is special, we need to send a request* over the net first (send) before new data can be returned* request sits at fido_us2/fifo_us3* X=task struct, U=wzsock** requires exclusive and permanent access to fifo and* therefore a CPU09GPP/09NET combo where for this device* the socket drivers are not active****************************************************************sknbrr  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b***        jsr     GSRSR           get status        stb     wzstat,u        update sock        cmpb    #WSESTB         established        bne     sknbe1          error*        jsr     GSRTXFR         get free space        cmpd    #NBRQLN        blo     sknbrp1         go poll** read, send command info to server*        ldd     #NBRQLN         actual size of request        ldy     #fifo_us2       where request is present        jsr     WRFB2SK        ldb     #WCSEND         tell socket we put it        stb     wzcmnd,u        jsr     PSRCR** read is 2 phase, receive response from server*sknbrp2 jsr     skfres          reset important info        jsr     GSRRXRS         check response        pshs    d        ldd     wzrqln,u        requested data        addd    #NBRQLN        cmpd    0,s++           allows for other data packet sizes        bls     01f        jsr     GSRSR        stb     wzstat,u        cmpb    #WSESTB         check socket state        bne     sknbe1        cmpb    #WSCLWT        beq     sknbe1          bail out        ldy     #sknbrp2        wait until** poll loop*02      jmp     polext*sknbrp1 ldy     #sknbrr        bra     02b*sknbe1  ldb     #E_SOCKET        rts* we have data in socket01      ldb     #R_RQRBLK        clra        rts**************************************************************** here data is moved from the socket to the fifo* write 4 bytes back to fifo_us2/fifo_us3***************************************************************sknbrd  equ     *        jsr     skfres        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b** when we arrive here, the data has arrived*01      ldd     wzrqln,u        request sets the buffer size        pshs    d        addd    #NBRQLN        std     wzrqln,u        fool RDSK2FB        ldy     #fifo_us2       data contains cmd info        jsr     RDSK2FB        ldb     #WCRECV         tell socket we took it        stb     wzcmnd,u        jsr     PSRCR* transfer only data part        puls    d        std     wzxfer,u        std     wzrqln,u*        ldb     #R_RDRBLK       tell caller, data in fifo_us2 and fifo        rts***************************************************************** netblock, write block****************************************************************sknbsr  equ     *        jsr     skfres** is the DEVICE (still) active*        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b*        jsr     GSRSR           status        stb     wzstat,u        cmpb    #WSESTB         still there?        bne     sknbe10*        jsr     GSRTXFR         get free space        pshs    d        ldd     #NBRQLN        addd    wzrqln,u        cmpd    0,s++        bls     70f*        ldy     #sknbsr        jmp     polext*sknbe10 ldd     #0        std     wzxfer,u        ldb     #E_SOCKET        rts70      clra        ldb     #R_RQSBLK        rts********************************************************************************************************************************sknbsd  equ     *        jsr     skfres        jsr     wzdevt02      lbne    rdrqer1        jsr     skctcp        bne     02b** data to write, cnd +data*70      ldd     wzrqln,u        pshs    d        addd    #NBRQLN        std     wzrqln,u        fool WFB2SK        ldy     #fifo_us2       where cmd sits        jsr     WRFB2SK        ldb     #WCSEND         send it now        stb     wzcmnd,u        jsr     PSRCR        puls    d        std     wzxfer,u        make it correct        std     wzrqln,u        clra        ldb     #R_SNDBLK       tell host we did        rts***************************************************************** special function, tstval,x is indicator* X holds the task table* U holds the  sock address (wz....  access!)*skspcl  equ     **        jsr     skfres          set U to internal address        pshs    x        ldb     tstval,x        get index        cmpb    #MAXTBL        bhi     01f             illegal*        aslb        ldx     #functb        ldy     b,x             get special function        beq     01f             not valid        puls    x*        jsr     0,y             do function        bne     90f* done, tell OS        clra        ldb     #R_SPCL        bra     99f*90      lda     #162        bra     02f*01      puls    x        lda     #16102        ldb     #E_SOCKET       set socket error*99      rts* dispatch tablefunctb  fdb     wzwdev           write device settings        fdb     wzwdev        fdb     wzrdev           read device settings        fdb     showrgMAXTBL  equ     ((*-functb)/2)-1** write W5500 device settings!** X hold the task table* U holds the special sock address*wzwdev        ldb     #8        trfr    B,E        ldu     fifo_us1        device info area        leay    0,u             myip        jsr     PCRSIP          source IP        leay    4,u        jsr     PCRSNM          subnet mask        leay    8,u        jsr     PCRGA           gateway IP        leay    12,u        jsr     PCRSHA          hardware address*        lda     18,u            ON/OFF        beq     01f        ldb     #%11111000     all on        bra     02f01      ldb     #%01111000     all off02      jsr     PCRPHY        clra                   no error return status        rts** read W5500 device settings*wzrdev        ldb     #8        trfr    B,E             select first socket        ldu     fifo_us1        leay    0,u             overwrite what was set        jsr     GCRSIP          source IP        leay    4,u        jsr     GCRSNM          network mask        leay    8,u        jsr     GCRGA           gateway address        leay    12,u        jsr     GCRSHA          hardware address        clra                    no error return status        rts** DEBUG service, read selected registers*showrg        ldb     #8        trfr    B,E             select first socket        ldu     fifo_us1        leau    32,u            skip network data area*        jsr     GSRMR           socket mask        stb     0,u+        jsr     GSRSR           socket status        stb     0,u+        jsr     GSRRBFS         socket        stb     0,u+        ldb     #'=        stb     0,u+        leay    0,u        jsr     GCRSIP          control source IP        leau    4,u        leay    0,u        jsr     GCRGA           control gateway address        leau    4,u        ldb     #'#        stb     0,u+        leay    0,u        jsr     GCRSHA          control hardware address        leau    6,u        ldb     #'#        stb     0,u+        leay    0,u        jsr     GCRSNM          control net mask        leau    4,u        ldb     #'=        stb     0,u+        jsr     GCRVERS         control version        std     0,u++        ldb     #'#        stb     0,u        clra        rts* not implemented functions** X hold the task table* U holds the wzsock address*   skintrpskdiscsksmacskskep        lda     #255        sta     wzerr,u        ldb     #E_SOCKET        rts