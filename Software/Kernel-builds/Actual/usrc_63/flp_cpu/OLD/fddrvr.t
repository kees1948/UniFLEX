*       lib     gendrvr.h*       lib     fddrvr.h        lib     gppflp.h        lib     ../include/dtab.h        lib     ../include/bfhdr.h        lib     ../include/dpr.h        lib     ../include/dprcode.h        lib     ./environment.h        sttl     FLOPPY Driver        pag        name    fddrvr        global  flpopen,flpclose,flpio,flpint*       global  fplop,flpcl,flpsp,flpcio,flprd,flpwr        global  flpdt,flpchb,FLPDPR        global  dpr_irqa,dpr_ihanFLPDPA  equ     $e000** Driver local data** Device Tables** dtdfl rmb     2       device buffer fwd link* dtdbl rmb     2       device buffer bwd link* dtqfl rmb     2       device io queue fwd link* dtqbl rmb     2       device io queue bwd link* dtbusy        rmb     1       device busy flag* dtrtry        rmb     1       device error retry count* dtspr rmb     2       device spare byteflpdt   rzb     DVTSIZ          device table* buffer header for character deviceflpchb  rzb     HDRSIZ          buffer header*flpopt  fcb     0,0,0,0         flp open tableflttyp  fdb     0,0,0,0         flp ttyset/get valuesflpcur  rzb     1               current  driveBDtable fdb     0               Block Device Table addressFLPDPR  equ     *        rzb     2               dpr_mbx  mailbox lock        rzb     2               dpr_fifo fifo lock        rzb     1               dpr_intc        rzb     1               dpr_tflg semaphore        fdb     FLPDPA          dpr_dba IO address        fdb     FLPDPA+dpr_cpuF dpr_irqa Interrupt in location <>0 is INT        fdb     flpint          dpr_ihan interrupt service        rzb     2      ** FLPMXTR*TRANSIZE transaction slots** open the flp disk drive - insure the device is online, etc.* D contains device major/minor*flpopflpopen pshs    d,y,u        lbsr    flp_dn          set up        sty     2,s             save DPR control address        tst     flpopt,x        already open?        beq     01f        inc     flpopt,x        bra     30f*01      inc     flpopt,x        set open status*       jsr     gettslot        pshs    y               transaction slot*        lda     2,s             device        sta     fl_dr_sz,y      set drive info        clrd        std     fl_ttys,y       erase side/dens info*05      ldb     #O_OPEN***     jsr     dpr_msg        cmpb    #E_SYSBSY       DPR busy?        bne     10f****     jsr     p_dprbsy        bra     05b*10      cmpb    #E_BADDEV        bne     15f        ldb     #EBDEV        stb     uerror        leas    2,s        bra     16f*15      puls    y               transaction  slot*       ldb     flpcur          device info*       clra*       tfr     d,x             save new device settings*       ldu     fl_ttys,y*       stu     flttyp,x        save data16***     jsr     puttslot*30      puls    d,y,u,pc        clean stackflpspflprts  rts* flp close* D holds device maj/minflpclflpclose  pshs  d,y,u        bsr     flp_dn          set up        sty     2,s             DPR control block        dec     flpopt,x        dec open counter        bpl     20f        clr     flpopt,x        clear open status*       jsr     gettslot        pshs    y               transaction slot00      ldb     #O_CLOSE***     jsr     dpr_msg        cmpb    #E_SYSBSY        bne     10f***     jsr     p_dprbsy        bra     00b*10      puls    y***     jsr     puttslot20      puls    d,y,u,pc** preset important variables*flp_dn  andb    #%00000011      drive 0...3        stb     flpcur          save select        tfr     d,x        ldy     #FLPDPR        rts** fire up IDE operation to initiate transfer* X block device table address* Y holds buffer header*flpio   stx     BDtable         save Block Device Table address        pshs    y,u        inc     flpdt+dtbusy    mark busy        ldb     bfdvn+1,y       get device #*        bsr     flp_dn          set up for drive        pshs    y               save it        ldx     dpr_dba,y        get DPR address        ldy     2,s             buff hdr        sty     fl_bfhh,x        ldd     bfxfc,y         get transfer count        cmpd    #512            is it regular block transfer?        bne     20f        asld                    1=128,2=256,4=512,8=1024        ldb     flpcur        aslb        aslb        aslb        aslb        pshs    b        ora     0,s+        sta     fl_dr_sz,x*        ldb     bfflag,y get buffer flags        bitb    #BFRWF          (read=1)        bne     l003        ldb     #O_RQWR        bra     l004l003        ldb     #O_RQRDl004    sta     fl_func,x* disk block #        ldu     bfblck,y        block address 15..0        stu     fl_blkmi,x*       ldy     0,s*       jsr     dpr_msg         send request        lda     #$ff        sta     cpu_dprF,x      INT GPP*       cmpb    #E_IOERR*       bne     10f        clra        bra     21f*        lda     #EIO        bra     21f*20      lda     #EBARG21      sta     uerror        leas    2,s             remove        puls    y,u,pc**** interrupt process* Y = CONTROL block* X = device address*flpint        ldb     fl_func,x      what did we doflpi01  ldy     flpdt+dtqfl     get last transacion        beq     flpfin        tstb        bmi     flprr1        pshs    x,y        leay    dprf,x          get fifo address        ldx     fl_bfhh,x       buf header        ldd     bfxfc,y        count        ldu     #0        stx     $e380        sty     $e382        stu     $e384        std     $e386*       jsr     cpystb        puls    x,y        bra     flpdonflprr1  lda     bfflag,y        ora     #BFERR        sta     bfflag,y        andb    #$7f        stb     uerror*flpdon  clr     flpdt+dtbusy    set unbusy        clr     dpr_cpuF,x      reset postbox        ldx     BDtable        jmp     BDioendflpfin  clr     dpr_cpuF,x      reset postbox        rts** open - close - and special**flpop   jmp     flpopen         same as block device*flpcl   jmp     flpclose        same as block*flpsp   rts                     nops here** read*flprd   pshs    d               save device number        jsr     flpgb           get buffer header        puls    d               reset dev number        bsr     flpnf           go configure header        tst     uerror          any errors?        beq     flprd4        jsr     frechbf         release buffer        rts                     error returnflprd4  pshs    a               save task info        orb     #BFRWF          set read mode        andb    #!BFSPC&$ff     clear special mode        stb     bfflag,y        save in buffer        lbra     flpcio           go do it** write*flpwr   pshs    d               save device number        jsr     flpgb           get buffer header        puls    d        bsr     flpnf           configure buffer        tst     uerror          any errors?        beq     flpwr4        jsr     frechbf         release buffer        rts                     error returnflpwr4  pshs    a               save task statusflpcio jmp fchio same as floppies** fchio** Perform the io specified by the buffer header* pointed at by Y.  ** This routine assumes the* floppy disks are major device 0 for the block* type drivers ***fchio   pshs    y               save buffer        ldx     #blktab        jsr     [blkio,x]       call block io routine        ldy     0,s             reset buffer        jsr     fnshio          finish io        jsr     wakbuf          awakeb buffer sleepers        puls    y               reset ptr        lda     bfflag,y        get flags        anda    #!(BFALOC|BFREQ|BFSPC)&$ff clear out busy bits        sta     bfflag,y        save new flags        puls    a               get task modes        ldx     utask           get task entry location        sta     tsmode,x        save task modes        ldd     #0              reset data count to 0        std     uicntfchio6  rts                     return** configure flp character header*flpnf   std     bfdvn,y         set up device number        ldd     uicnt           get transfer count        std     bfxfc,y         set in header        cmpd    #512            is it valid?        bne     flperr          error?        jmp     flpcn2          same as floppiesflperr  lda     #EIO            set error        sta     uerror        rts                     return** flpgb** Get the character buffer header.  If it is busy,* sleep on it.*flpgb   ldy     #flpchb         point to header        pshs    cc              save status        seti        lda     bfflag,y        get buffer flags        bita    #BFALOC         is buffer busy?        beq     flpgb2        ora     #BFREQ          set request buffer bit        sta     bfflag,y        puls    cc              reset status        ldb     #BUFPR          set priority        jsr     sleep           go sleep for buffer        bra     flpgb           repeatflpgb2  lda     #BFALOC         set busy status        sta     bfflag,y        puls    cc,pc           return** flpcn** Configure the buffer header pointed at by Y.* This routine sets up the character device info* from the user block and puts it in the buffer* header such that the device drivers can use* the information for the data transfer.*flpcn   std     bfdvn,y         save device number        ldd     uicnt           get xfr count        std     bfxfc,y         save in header*        cmpd    #128            check for valid number*        beq     fchcn4*        cmpd    #256            is it a sector operation?*        beq     fchcn4        cmpd    #512            is it 512 byte op?*        beq     flpcn4*        cmpd    #5100           is it a write track?*        beq     flpcn2*        cmpd    #10200          is it dd write track?        bne     flpcn8          if not - error         bra    flpcn4flpcn2  lda     bfflag,y        get flags        ora     #BFSPC          set special bit for drivers        sta     bfflag,y        save new flagsflpcn4  ldd     uipos2          get file position        std     bfblck,y        save as block number        lda     uipos+1         store upper part        sta     bfblch,y        ldd     uistrt          get start address of xfr        std     bfadr,y         save in header        jsr     mapupg          find user page        std     bfxadr,y        save in header        ldx     utask           point to task entry        lda     tsmode,x        get mode bits        pshs    a               save        ora     #TLOCK          set lock bit (keep in mem)        sta     tsmode,x        save new mode        ldb     bfflag,y        get flags        puls    a,pc            returnflpcn8  lda     #EBARG          set error        sta     uerror        rts                     return** frechbf - free Character buffer*frechbf pshs    d,x,y,u         save registers        ldy     #flpchb         point to header        lda     bfflag,y        get flags        anda    #!(BFALOC|BFREQ|BFSPC)&$ff clear out busy bits        sta     bfflag,y        save new flags        jsr     wakbuf          awake buffer sleepers        puls    d,x,y,u,pc      return