                     *                     * GPPFLPDRV, ROM code for CPU09GPP with 09FLP add-on                     *                     * 2021-03-05: write track, no retry. return error if drive/diskette absent                     *                     * 2021-04-30: minor bug fixes, different approach for WD2791                     *                     * 2021-08-31: correction in fseek, ready test now OK                     *                     * 2021-11-12: added double step, 40 track disk in 80 track drive                     *                     * 2021-12-04: implemented read track, flpdrvr.t is already done                     *                     * 2021-12-07: buffer clear read-track, ttyset to disable error check                     *                     * 2024-07-25: corrected drive table for 4 drives, added individual                     *             steprate settings per drive via DPR location                     *                     *                     * supports:  read block 128,256,512 byte size                     *            write block 128,256,512 byte size                     *            read track 125kBit, 250kBit, 500 kBit rate                     *            write track 125kBit, 250 kBit, 500 kBit rate                     *                     *            supports 8", 5.25" and 3.5" in single /                     *            double side and single / double / high density                     *                     *            runs with Interrupts disabled                     *            almost no 63X09 code                     *                     *                     * compatibility with FLEX improved                     *                     *                     *                     *                     *                     *                     *                     *                     *                               opt    lis,exp                               opt    nop                                          *                     *  for DEBUG program is RAM based                     *               E000  ROMBASE   equ    $E000                                    FFF0  VECTORS   equ    $FFF0                                                         0400  RAMBASE   equ    $0400     just above Dual Port Ram               0800  BUFFER    equ    $0800     track buffer                                    0040  STACKSZ   equ    64        enough?                                    9C40  RDYWAIT   equ    40000     delay count                                          * hardware dependent values               0005  LA_DS0    equ    LA_SEL0   drive select 0               000A  LA_DS1    equ    LA_SEL1   drive select 1                                          *                     * DPR, command exchange withe kernel                     *               0091  CMDMSK    equ    %10010001 command mask               0011  CMDRSC    equ    %00010001 read sector               0001  CMDWSC    equ    %00000001 write sector               0091  CMDRTK    equ    %10010001 read track               0081  CMDWTK    equ    %10000001 write track                     *                     *                                                               * for a WD2793 (default) leave this at 0                     * for a WD2791 set it to 1               0000  WD2791    set    0                                    0007  MXDMSK    equ    %00000111 max drive mask 0,1,2,3               0003  MXSTPM    equ    %00000011 max step rate mask                     *               0080  SBDCRC    equ    %10000000 side info, disable CRC               0001  SBDSID    equ    %00000001 side info, double (other) side               0010  DBDSTP    equ    %00010000 dens info, double step               0001  DBDDEN    equ    %00000001 dens info, doubel dens                     *               0015  FDSTP1    equ    %00010101 FDC TYPE 1 status mask               0004  FDSTZR    equ    %00000100 FDC TYPE 1, track zero                                            0000                         org    $0  0000               dtrack    rmb    MAXDEV    track#  0005               ddens     rmb    MAXDEV    latch  000A               dstep     rmb    MAXDEV    step rate               000F  FTABSZ    equ    *                     *  0400                         org    RAMBASE                       0400               lside     rmb    1         actual latch side  0401               track     rmb    1  0402               sector    rmb    1  0403               latch     rmb    1         latch backup  0404               curdrv    rmb    1         last selected drive  0405               diserr    rmb    1         disable (read) error check                     *  0406               pstep     rmb    1         debug for progress  0407               wrkprm    rmb    2         pointer to drive info table entry  0409               retry     rmb    1         retry count  040A               steprt    rmb    1         step rate modifier                     *  040B               drvtab    rmb    FTABSZ    drive param table                       041A                         rmb    STACKSZ               045A  romstck   equ    *                                    045A  RAMEND    equ    *                       0800                         org    BUFFER  0800               trkbuf    rmb    12500     track buffer                       E000                         org    ROMBASE                       E000 47 50 50 20   revision  fcc    "GPP 09FLP ROM 2025-06-12"                                          *                     * configuration constants                     *  E018 02            rretry    fcb    2                                    0000  DRVOFS    equ    0                     *                     * drive 0 and 1 obey the IBM PC selects                     *  E019 05 0A         drvsel    fcb    LA_DS0,LA_DS1 drive select bytes                     *                     * drive 2 and 3 have no specific setup                     *  E01B 04 08                   fcb    %00000100,%00001000 drive select bytes  E01D 00                      fcb    %00000000 extra 8", DD. side 0               0005  DRVTSZ    equ    (*-drvsel)                                                               *                     * command table                     *  E01E 11 00         parstab   fcb    CMDRSC,0  E020 E1B3 E1B3               fdb    do_rdsc,do_rdsc,do_rdsc,do_rdsc,do_rtpb               000C  PARTSZ    equ    *-parstab  E02A 01 00                   fcb    CMDWSC,0  E02C E1D8 E1D8               fdb    do_wrsc,do_wrsc,do_wrsc,do_wrsc,do_wtpb  E036 91 00                   fcb    CMDRTK,0  E038 E1FD E1FD               fdb    do_rdtk,do_rdtk,do_rdtk,do_rdtk,do_rttk  E042 81 00                   fcb    CMDWTK,0  E044 E280 E280               fdb    do_wrtk,do_wrtk,do_wrtk,do_wrtk,do_wttk  E04E 0000 0000               fdb    0,0       end of table                                                                                    * GPP references               0000  func      equ    flpdpr+flrflg               0001  addrh     equ    flpdpr+flblkh               0002  addrm     equ    flpdpr+flblkm               0003  addrl     equ    flpdpr+flblkl               0004  size      equ    flpdpr+fltsiz               0006  xfer      equ    flpdpr+fltxfr               0008  stat      equ    flpdpr+flstat               0009  driv      equ    flpdpr+fldriv               000A  open      equ    flpdpr+flnwop               000B  side      equ    flpdpr+fltsid               000C  dens      equ    flpdpr+fltden               000D  major     equ    flpdpr+fltdev                     * step table 0,1,2,3               03F0  step      equ    flpdpr+flpstp                                    03FE  fiop      equ    flpdpr+flpint               03FF  tiop      equ    flpdpr+flptel                     *                                          *                     * cold start                     *               E052  reset     equ    *  E052 1A   50                 orcc   #$50  E054 10CE 045A               lds    #romstck  E058 86   80                 lda    #fdbasp  E05A 1F   8B                 tfr    a,dp               0080            setdp  fdbasp                     * NATIVE 63X09 !!  E05C 11 3D 03                fcb    $11,$3d,$03 6309                     *  E05F 8E   0000               ldx    #flpdpr   go clear the Dual Port Ram  E062 4F                      clra  E063 5F                      clrb  E064 ED   81       01        std    0,x++  E066 8C   03FF               cmpx   #flpdpr+flptel  E069 25   F9                 blo    01b                     *  E06B 8E   0400               ldx    #RAMBASE  E06E ED   81       02        std    0,x++  E070 8C   045A               cmpx   #RAMEND  E073 25   F9                 blo    02b                     * set default disk type  E075 8E   E491               ldx    #flpdfl  E078 BF   0407               stx    wrkprm    set pointer                     ****************************************************************                     *                     * normally the driver loops here                     *                     ****************************************************************               E07B  warm      equ    *  E07B 1A   50                 orcc   #$50  E07D 10CE 045A               lds    #romstck                     *  E081 BD   E18B     01        jsr    flpcmd    new message from main CPU  E084 27   FB                 beq    01b       wait                     * save previous settings for track register and latch  E086 BD   E171               jsr    seldrv    save old setttings for curdrv  E089 D6   01                 ldb    <fo2trk  E08B E7   84                 stb    dtrack,x  E08D F6   0403               ldb    latch  E090 E7   05                 stb    ddens,x                     * restore the correct setting for the current drive  E092 F6   0009               ldb    driv      get drive  0,1  E095 C1   05                 cmpb   #MAXDEV  E097 1024 00B2               lbhs   ilgdev    not allowed  E09B F7   0404               stb    curdrv    update current drive                     * put new settings  E09E BD   E171               jsr    seldrv  E0A1 E6   84                 ldb    dtrack,x  E0A3 D7   01                 stb    <fo2trk  E0A5 E6   05                 ldb    ddens,x   density/size  E0A7 F7   0403               stb    latch                     *  E0AA E6   0A                 ldb    dstep,x  E0AC C4   03                 andb   #MXSTPM   correct  E0AE F7   040A               stb    steprt                     * set drive select bits  E0B1 F6   0404               ldb    curdrv  E0B4 8E   E019               ldx    #drvsel   different table  E0B7 3A                      abx  E0B8 B6   0403               lda    latch  E0BB 84   F0                 anda   #%11110000 leave these intact  E0BD 34   02                 pshs   a  E0BF E6   84                 ldb    0,x  E0C1 C4   0F                 andb   #%00001111 select bits only  E0C3 EA   E0                 orb    0,s+  E0C5 F7   0403               stb    latch     clean higher bits                     *                     * update other settings                     *  E0C8 B6   E018               lda    rretry    rom setting  E0CB B7   0409               sta    retry                     * test 5"/8"  E0CE F6   0403               ldb    latch  E0D1 B6   000B               lda    side  E0D4 85   40                 bita   #LA_8_5   5/8" select  E0D6 27   04                 beq    setd2  E0D8 CA   40                 orb    #LA_8_5  E0DA 20   02                 bra    setd3                     *  E0DC C4   BF       setd2     andb   #255-LA_8_5  E0DE CA   80       setd3     orb    #$80  E0E0 F7   0403               stb    latch  E0E3 D7   04                 stb    <fo4lat   set latch                     *  E0E5 7F   0405               clr    diserr    initialize  E0E8 F6   E019               ldb    drvsel                     *                     * everything is set                     *  E0EB BD   E406               jsr    chkrdy    see if drive is on-line  E0EE B7   0008               sta    stat  E0F1 27   02                 beq    03f  E0F3 20   76                 bra    fend1                     * if new open force restore  E0F5 B6   000A     03        lda    open      new open?  E0F8 27   21                 beq    04f       yes, skip forced restore                     *  E0FA 34   16                 pshs   d,x  E0FC 8E   03F0               ldx    #step     step infor / drive  E0FF F6   0404               ldb    curdrv  E102 3A                      abx  E103 A6   84                 lda    0,x  E105 8E   040B               ldx    #drvtab  E108 3A                      abx  E109 A7   0A                 sta    dstep,x  E10B 84   03                 anda   #MXSTPM   correct  E10D B7   040A               sta    steprt  E110 35   16                 puls   d,x                     *                     * retry loops here                     *  E112 BD   E447     skretry   jsr    restore   restore drive  E115 84   15                 anda   #FDSTP1  E117 81   04                 cmpa   #FDSTZR   should be there  E119 26   3E                 bne    flerr                     *  E11B 7F   000A     04        clr    open      remove flag                     *  E11E C6   01                 ldb    #1        set progress  E120 F7   0406               stb    pstep                     *  E123 7F   0008               clr    stat      initialize return status                     *  E126 BD   E406               jsr    chkrdy    drive still ready?  E129 4D                      tsta  E12A 26   2D                 bne    flerr                     *  E12C BD   E472     06        jsr    srchpm    scan drive table                     *  E12F C6   02                 ldb    #2  E131 F7   0406               stb    pstep  E134 B6   0000               lda    func      check command for valid  E137 84   91                 anda   #CMDMSK                     *  E139 8E   E01E               ldx    #parstab  search function  E13C A1   84       21        cmpa   0,x  E13E 27   11                 beq    20f  E140 30   0C                 leax   PARTSZ,x  next entry  E142 6D   84                 tst    0,x  E144 26   F6                 bne    21b                     *  E146 86   BF                 lda    #FD_ERR+63  E148 B7   0008               sta    stat  E14B 20   1E                 bra    fend1                     * illegal device  E14D 86   12       ilgdev    lda    #EBDEV  E14F 20   08                 bra    flerr                                          *                     * take entry from table, device dependent                     *  E151 F6   0404     20        ldb    curdrv    which entry to take  E154 58                      aslb             size of word  E155 CB   02                 addb   #2        size of cmd (offset)  E157 AD   95                 jsr    [b,x]                     *                     * generic error exit                     *  E159 B7   0008     flerr     sta    stat                     *  E15C C6   07       fend      ldb    #7  E15E F7   0406               stb    pstep  E161 4D                      tsta             error  E162 27   07                 beq    fend1  E164 7A   0409               dec    retry >E167 1026 FFA7               lbne   skretry  E16B 12            fend1     nop  E16C 8D   0E                 bsr    flpack    tell main CPU about it                     *  E16E 7E   E07B               jmp    warm                                          *                     * seldrv                     *  E171 34   04       seldrv    pshs   b  E173 8E   040B               ldx    #drvtab  E176 F6   0404               ldb    curdrv  E179 3A                      abx  E17A 35   84                 puls   b,pc                                          *                     *  write MAILBOX to other CPU I'm done                     *  E17C C6   08       flpack    ldb    #8  E17E F7   0406               stb    pstep  E181 7F   03FF               clr    tiop      acknowledge main CPU  E184 86   FF                 lda    #$ff  E186 B7   03FE               sta    fiop      tell him I'am done  E189 12                      nop  E18A 39                      rts                                          *                     * flpcmd, test MAILBOX for new data from main CPU                     *  E18B B6   03FF     flpcmd    lda    tiop      command present?  E18E 12                      nop  E18F 39                      rts                                                         E190  do_rtpb   equ    *         read tape block  E190 34   14                 pshs   b,x  E192 F6   03F5               ldb    $03f5     latch preset  E195 D7   04                 stb    <fo4lat   clear latch  E197 BE   000B               ldx    side  E19A 27   07                 beq    01f  E19C 86   40       03        lda    #FD_STI  E19E BA   03F4               ora    $03f4     step bits preset  E1A1 97   00                 sta    <fo2cmd  E1A3 96   08       01        lda    <fo4sta  E1A5 85   40                 bita   #ST_INT  E1A7 27   FA                 beq    01b  E1A9 30   1F                 leax   -1,x  E1AB 26   EF                 bne    03b  E1AD 4F            01        clra  E1AE 35   94                 puls   b,x,pc                                                         E1B0  do_wtpb   equ    *         write tape block                                    E1B0  do_rttk   equ    *         read tape track                                    E1B0  do_wttk   equ    *         write tape track                       E1B0 86   12                 lda    #EBDEV  E1B2 39                      rts                                                               *                     * Y = fdcbase                     *               E1B3  do_rdsc   equ    *  E1B3 C6   03                 ldb    #3  E1B5 F7   0406               stb    pstep                     *  E1B8 BD   E338               jsr    clcpos    block# -> trk/sec/sid  E1BB 4D                      tsta  E1BC 26   18                 bne    frder     error                     *  E1BE C6   04                 ldb    #4  E1C0 F7   0406               stb    pstep  E1C3 BD   E39A               jsr    fseek  E1C6 4D                      tsta  E1C7 26   0D                 bne    frder                     *  E1C9 C6   05                 ldb    #5  E1CB F7   0406               stb    pstep  E1CE CE   0020               ldu    #flpdpr+flpfifo where data is to land  E1D1 86   80                 lda    #FD_SRD  E1D3 BD   E2E4               jsr    frdblk                     *  E1D6 12            frder     nop  E1D7 39                      rts                                          *                     * Y = fdcbase                     *               E1D8  do_wrsc   equ    *  E1D8 C6   03                 ldb    #3  E1DA F7   0406               stb    pstep                     *  E1DD BD   E338               jsr    clcpos    block# -> trk/sec/sid  E1E0 4D                      tsta  E1E1 26   18                 bne    fwder     error                     *  E1E3 C6   04                 ldb    #4  E1E5 F7   0406               stb    pstep  E1E8 BD   E39A               jsr    fseek  E1EB 4D                      tsta  E1EC 26   0D                 bne    fwder                     *  E1EE C6   05                 ldb    #5  E1F0 F7   0406               stb    pstep  E1F3 CE   0020               ldu    #flpdpr+flpfifo where data is present  E1F6 86   A0                 lda    #FD_SWR  E1F8 BD   E320               jsr    fwrblk                     *  E1FB 12            fwder     nop  E1FC 39                      rts                                          *                     * We read the designated track into buffer and transfer                     * that back to the System                     *               E1FD  do_rdtk   equ    *  E1FD 34   70                 pshs   x,y,u                     *  clear track buffer  E1FF FC   0004               ldd    size  E202                         trfr   D,W  E202 1F                      fcb    $1f  E203 06                      fcb    D<<4|W                               endm  E204 8E   0800               ldx    #trkbuf  E207 6F   E2                 clr    0,-s  E209                         tfm4   S,X  E209 113B                    fdb    $113b  E20B 41                      fcb    S<<4|X                               endm  E20C 32   61                 leas   1,s                     *  E20E 86   01                 lda    #1        no retry!  E210 B7   0409               sta    retry  E213 C6   03                 ldb    #3  E215 F7   0406               stb    pstep                     *  E218 B6   0003               lda    addrl     track address << 1 + side bit  E21B 5F                      clrb  E21C 44                      lsra             strip side bit  E21D 24   01                 bcc    08f  E21F 5C                      incb             set side select  E220 F7   0400     08        stb    lside     read  track on other side                     *  E223 B7   0401               sta    track  E226 26   03                 bne    18f       make sure we  start at track 00  E228 BD   E447               jsr    restore   restore if target is 0                     *  E22B 86   01       18        lda    #1        set sector register  E22D B7   0402               sta    sector                     *  E230 BD   E39A               jsr    fseek     should set latch  E233 4D                      tsta  E234 26   47                 bne    10f                     *                     * do actual Read Track here                     *  E236 C6   04                 ldb    #4  E238 F7   0406               stb    pstep  E23B CE   0800               ldu    #trkbuf   do read into large buffer  E23E 86   E0                 lda    #FD_RTR  E240 BD   E2E4               jsr    frdblk  E243 12                      nop  E244 4D                      tsta  E245 27   05                 beq    20f  E247 7D   0405               tst    diserr    if error and not set, abort  E24A 27   31                 beq    10f                     *                     * copy trkbuf data to DPR, first direct, next on INT's                     *  E24C BC   0004     20        cmpx   size      set size of result is smaller  E24F 24   03                 bhs    21f  E251 BF   0004               stx    size  E254 C6   05       21        ldb    #5  E256 F7   0406               stb    pstep  E259 8E   0800               ldx    #trkbuf   data source  E25C FC   0006     03        ldd    xfer      is updated by kernel driver  E25F 10B3 0004               cmpd   size      did we enough?  E263 24   17                 bhs    02f                     *  E265 CE   0020               ldu    #flpdpr+flpfifo  E268                         ldwi   BUFSIZ    immediate load  E268 1086                    fdb    $1086  E26A 0200                    fdb    BUFSIZ                               endm  E26C                         tfm1   X,U       data to main side  E26C 1138                    fdb    $1138  E26E 13                      fcb    X<<4|U                               endm  E26F 4F                      clra  E270 BD   E17C               jsr    flpack    tell him  I have it                     *  E273 0D   08       01        tst    <fo4sta   keep motor running  E275 BD   E18B               jsr    flpcmd    wait for him to grab it  E278 27   F9                 beq    01b       postbox empty  E27A 20   E0                 bra    03b       loop until all                     *  E27C 4F            02        clra             set no error                     *  E27D 12            10        nop              debug  E27E 35   F0                 puls   x,y,u,pc                                          *                     * We arrive here when the DPR contains the first BUFSIZ                     * bytes of the track image                     *               E280  do_wrtk   equ    *  E280 34   70                 pshs   x,y,u  E282 8E   0800               ldx    #trkbuf                     *                     * copy DPR data to trkbuf                     *  E285 12            03        nop  E286 CE   0020               ldu    #flpdpr+flpfifo  E289                         ldwi   BUFSIZ    immediate load  E289 1086                    fdb    $1086  E28B 0200                    fdb    BUFSIZ                               endm  E28D                         tfm1   U,X  E28D 1138                    fdb    $1138  E28F 31                      fcb    U<<4|X                               endm  E290 FC   0006               ldd    xfer      is updated by kernel driver  E293 10B3 0004               cmpd   size      we have all  E297 24   0D                 bhs    02f  E299 4F                      clra  E29A BD   E17C               jsr    flpack    tell hime I took it                     *  E29D 0D   08       01        tst    <fo4sta   keep motor running  E29F BD   E18B               jsr    flpcmd    wait for next data  E2A2 27   F9                 beq    01b       postbox empty  E2A4 20   DF                 bra    03b       loop until all                     *                     * all data present                     *  E2A6 12            02        nop              TRAP  E2A7 86   01                 lda    #1        no retry!  E2A9 B7   0409               sta    retry  E2AC C6   03                 ldb    #3  E2AE F7   0406               stb    pstep                     *  E2B1 B6   0003               lda    addrl     track address << 1 + side bit  E2B4 5F                      clrb  E2B5 44                      lsra             strip side bit  E2B6 24   01                 bcc    08f  E2B8 5C                      incb  E2B9 F7   0400     08        stb    lside     format track on other side                     *  E2BC B7   0401               sta    track  E2BF 26   03                 bne    18f       make sure we  start at track 00  E2C1 BD   E447               jsr    restore   restore if target is 0                     *  E2C4 86   01       18        lda    #1  E2C6 B7   0402               sta    sector                     *  E2C9 C6   04                 ldb    #4  E2CB F7   0406               stb    pstep  E2CE BD   E39A               jsr    fseek  E2D1 4D                      tsta  E2D2 26   0D                 bne    10f                     *                     * restore the registers for the write                     *  E2D4 C6   05                 ldb    #5  E2D6 F7   0406               stb    pstep  E2D9 CE   0800               ldu    #trkbuf  E2DC 86   F0                 lda    #FD_WTR >E2DE BD   E320               jsr    fwrblk                     *  E2E1 12            10        nop  E2E2 35   F0                 puls   x,y,u,pc                                          *                     * code routine, to read one dataset from FDC                     * U = buffer address,                     * Y = base address hardware                     * A = command                     *                     * can read sector or track                     * drive select, density and such alreay set up                     * time out from INT fdc                     *               E2E4  frdblk    equ    *  E2E4 34   70                 pshs   x,y,u  E2E6 C6   1F                 ldb    #31       very long              create timeout  E2E8 8E   0000               ldx    #0        65536*2*25/4 cycles                     *  E2EB 97   00                 sta    <fo2cmd                     *  E2ED 1A   50       01        orcc   #$50      disable ints  E2EF 20   04                 bra    03f                     * loop here  E2F1 96   03       02        lda    <fo2dat   get data  E2F3 A7   C0                 sta    0,u+      transfer                     * poll fdc for DRQ  E2F5 96   08       03        lda    <fo4sta  E2F7 48                      asla  E2F8 25   F7                 bcs    02b       DRQ  E2FA 2B   07                 bmi    90f  E2FC 30   01                 leax   1,x       count up  E2FE 26   F5                 bne    03b  E300 5A                      decb             at zero dec B  E301 26   F2                 bne    03b       if zero abort                     * end of command  E303 11A3 64       90        cmpu   4,s       nothing got?  E306 27   0D                 beq    98f       unexpected                     * normal end of read  E308 96   00       97        lda    <fo2cmd   read status  E30A EF   E4                 stu    0,s       preset X                     *  E30C 7D   0405     95        tst    diserr  E30F 27   02                 beq    99f  E311 84   E7                 anda   #%11100111 remove CRC/RNF error (if any)                     *  E313 35   F0       99        puls   x,y,u,pc  A = result status                                          * timeout occurred  E315 86   D0       98        lda    #FD_FI0   force interrupt  E317 97   00                 sta    <fo2cmd  E319 BD   E46A               jsr    delay  E31C 86   10                 lda    #$10      not found  E31E 20   EC                 bra    95b                                          *                     * code routine, to write one dataset to the FDC                     * U = buffer address                     * Y = hardware base                     * A = command                     *                     * drive select, density and such alreay set up                     * time out from INT fdc                     *               E320  fwrblk    equ    *  E320 34   70                 pshs   x,y,u                     *  E322 97   00                 sta    <fo2cmd                     *  E324 1A   50       01        orcc   #$50      disable ints  E326 20   02                 bra    04f                       E328 97   03                 sta    <fo2dat   put data                     *  E32A A6   C0       04        lda    0,u+                     *  E32C D6   08       03        ldb    <fo4sta  E32E 2B   F8                 bmi    02b  E330 C5   40                 bitb   #ST_INT   INT  E332 27   F8                 beq    03b                     *  E334 96   00                 lda    <fo2cmd   read status                     *  E336 35   F0       99        puls   x,y,u,pc                                          *                     * clcpos, transfer block# into track/sector/side                     *                     * Y = fdcbase                     *               E338  clcpos    equ    *  E338 34   70                 pshs   x,y,u  E33A 7F   0400               clr    lside     result side of calc  E33D FC   0002               ldd    addrm     block# M/L                     *  E340 BE   0004               ldx    size      check special addressing  E343 8C   0100               cmpx   #256  E346 27   05                 beq    21f  E348 8C   0080               cmpx   #128  E34B 26   12                 bne    20f       otherwise                     *                     *  absolute addressing                     *  E34D B7   0401     21        sta    track  E350 F7   0402               stb    sector  E353 B6   000B               lda    side      from ttyset  E356 84   03                 anda   #%00000011 DS or Biased  E358 27   39                 beq    88f  E35A 7C   0400               inc    lside     set side 1  E35D 20   34                 bra    88f                     *                     * regular 512 byte block to track/sector                     *  E35F BE   0407     20        ldx    wrkprm    fresh copy of drive params                     *  E362 7F   0401               clr    track     track = 0                     *  E365 A3   03       02        subd   3,x       sec/trk  E367 2B   05                 bmi    01f                     *  E369 7C   0401               inc    track     up track #  E36C 20   F7                 bra    02b                     *  E36E E3   03       01        addd   3,x       adjust                     * sector in B, track# on stack  E370 B6   000B               lda    side      is double sided?  E373 85   03                 bita   #%00000011 DS or biased  E375 27   11                 beq    05f       no                     *  E377 74   0401               lsr    track     track# / 2  E37A 24   0C                 bcc    05f       even track                     * odd track, add bias  E37C 7C   0400               inc    lside                     * TEST Biased here!  E37F B6   000B               lda    side  E382 85   02                 bita   #%00000010  E384 26   02                 bne    05f       no  E386 EB   04                 addb   4,x       biased sector#                     *  E388 5C            05        incb             1 relative  E389 F7   0402               stb    sector    set sector#                     *  E38C B6   0401     08        lda    track  E38F A1   02                 cmpa   2,x       test against max  E391 22   03                 bhi    91f                     * normal return  E393 4F            88        clra             set OK  E394 35   F0                 puls   x,y,u,pc                     * errors  E396 86   10       91        lda    #FS_SKER  track > max  E398 35   F0                 puls   x,y,u,pc                                          *                     * fseek, move head to track#, set registers                     * Y = hardware base                     *               E39A  fseek     equ    *  E39A 34   70                 pshs   x,y,u  E39C B6   0400               lda    lside  E39F 85   01                 bita   #SBDSID  E3A1 27   06                 beq    lsk1  E3A3                         oime   LA_SID,latch 1 = side 1  E3A3 71                      fcb    $71  E3A4 10                      fcb    LA_SID  E3A5 0403                    fdb    latch                               endm  E3A7 20   04                 bra    lsk2  E3A9               lsk1      aime   !LA_SID,latch 0 = side 0  E3A9 72                      fcb    $72  E3AA EF                      fcb    !LA_SID  E3AB 0403                    fdb    latch                               endm                     *  E3AD B6   000C     lsk2      lda    dens  E3B0 85   01                 bita   #DBDDEN  E3B2 26   06                 bne    lsk3  E3B4                         oime   LA_SDN,latch  E3B4 71                      fcb    $71  E3B5 20                      fcb    LA_SDN  E3B6 0403                    fdb    latch                               endm  E3B8 20   04                 bra    lsk4  E3BA               lsk3      aime   !LA_SDN,latch  E3BA 72                      fcb    $72  E3BB DF                      fcb    !LA_SDN  E3BC 0403                    fdb    latch                               endm                     *  E3BE B6   0403     lsk4      lda    latch  E3C1 97   04                 sta    <fo4lat                     *  E3C3 B6   0402               lda    sector  E3C6 97   02                 sta    <fo2sec   set sector register                     *  E3C8 B6   0401               lda    track  E3CB 91   01                 cmpa   <fo2trk  E3CD 27   28                 beq    04f                     *                     * test double step function,                     *  E3CF F6   000C               ldb    dens  E3D2 C5   10                 bitb   #DBDSTP   double step  E3D4 27   06                 beq    lsk10                     * it is double step  E3D6 D6   01                 ldb    <fo2trk   logical track#  E3D8 58                      aslb             *2  E3D9 D7   01                 stb    <fo2trk   physical track#  E3DB 48                      asla                     *                     * track is no the same, do SEEK                     *  E3DC 97   03       lsk10     sta    <fo2dat  E3DE 86   18                 lda    #FD_SEK  E3E0 BA   040A               ora    steprt    update steprate  E3E3 97   00                 sta    <fo2cmd                     *  E3E5 96   08       01        lda    <fo4sta  E3E7 85   40                 bita   #ST_INT  E3E9 27   FA                 beq    01b                     *                     *                     *  E3EB F6   000C               ldb    dens  E3EE C5   10                 bitb   #%00010000 double step  E3F0 27   05                 beq    04f                     *  E3F2 D6   01                 ldb    <fo2trk   physical track#  E3F4 57                      asrb             /2  E3F5 D7   01                 stb    <fo2trk   logical track#                     *                     *                     *  E3F7 96   00       04        lda    <fo2cmd                       E3F9 84   D9                 anda   #!(FS_TRK0|FS_IDX|FS_HLD) remove these from status                     * check if we need to pass write protect  E3FB F6   0000               ldb    func  E3FE C5   10                 bitb   #%00010000 command is read  E400 27   02                 beq    02f  E402 84   BF                 anda   #!FS_WRP                     *  E404 35   F0       02        puls   x,y,u,pc                                          *                     * chkrdy, check if drive is ready                     * Y = fdcbase                     *  E406 34   14       chkrdy    pshs   b,x  E408 F6   0404               ldb    curdrv  E40B C1   04                 cmpb   #MAXFLP  E40D 24   24                 bhs    12f  E40F C6   07                 ldb    #7        multiply  E411 B6   0403               lda    latch  E414 85   0F                 bita   #%00001111 drive select bits  E416 27   1B                 beq    12f       none, declare ready                     *  E418 97   04                 sta    <fo4lat >E41A BD   E46A               jsr    delay                     *  E41D 8E   7FFF     10        ldx    #$7fff    long delay                     *  E420 B6   0403     11        lda    latch  E423 97   04                 sta    <fo4lat  E425 96   00                 lda    <fo2cmd  E427 2A   0A                 bpl    12f                     *  E429 30   1F                 leax   -1,x      decrement counter  E42B 26   F3                 bne    11b                     *  E42D 5A                      decb             multiply  E42E 26   ED                 bne    10b                     *  E430 86   80                 lda    #FS_NRDY  E432 39                      rts                     *  E433 4F            12        clra  E434 35   94                 puls   b,x,pc                                          *                     * trigger headload delay from outside FDC                     * like when drive select is changed                     *  E436 34   02       trghlt    pshs   a  E438 B6   0403               lda    latch  E43B 84   7F                 anda   #$7f      trigger headsettling delay  E43D 97   04                 sta    <fo4lat  E43F 1E   11                 exg    x,x  E441 8A   80                 ora    #$80  E443 97   04                 sta    <fo4lat  E445 35   82                 puls   a,pc                                          *                     * restore, set drive at track 0                     * Y = fdcbase                     *  E447 34   04       restore   pshs   b  E449 F6   0404               ldb    curdrv  E44C C1   04                 cmpb   #MAXFLP  E44E 24   18                 bhs    21f  E450 86   08                 lda    #FD_RST  E452 BA   040A               ora    steprt    adjust  E455 97   00                 sta    <fo2cmd  E457 96   08       20        lda    <fo4sta  E459 0D   04                 tst    <fo4lat   ??  E45B 85   40                 bita   #ST_INT  E45D 27   F8                 beq    20b  E45F 96   00                 lda    <fo2cmd  E461 85   64                 bita   #00000100  E463 26   03                 bne    21f  E465 7F   0401               clr    track     update info  E468 35   84       21        puls   b,pc                                          *                     * delay, spend some time , no registers affected                     *  E46A 8D   00       delay     bsr    del1  E46C 8D   00       del1      bsr    del2  E46E 34   76       del2      pshs   d,x,y,u  E470 35   F6                 puls   d,x,y,u,pc                                          *                     * srchpm, search drive param table, used for track/sector calculations                     * Y = fdcbase                     *  E472 34   70       srchpm    pshs   x,y,u  E474 8E   E491               ldx    #fltabl   start table  E477 FC   000B               ldd    side      get ttyset/ttyget bytes  E47A 84   40                 anda   #%01000000 side bits 5/8" flag  E47C C4   C1                 andb   #%11000001 dens bits HD,10s,DD  E47E 10A3 84       31        cmpd   0,x  E481 27   09                 beq    30f  E483 30   06                 leax   6,x       size of entry  E485 6D   02                 tst    2,x  E487 26   F5                 bne    31b  E489 8E   E491               ldx    #flpdfl                     *  E48C BF   0407     30        stx    wrkprm  E48F 35   F0                 puls   x,y,u,pc                                    E491  fltabl    equ    *  E491 00 00 4C 00   flpdfl    fcb    $00,$00,76,0,8,0 FD-XS  E497 00 01 4C 00             fcb    $00,$01,76,0,16,0 FD-DX  E49D 40 00 4F 00             fcb    $40,$00,79,0,5,0 F5-SX  E4A3 40 01 4F 00             fcb    $40,$01,79,0,9,0 F5-XD  E4A9 40 41 4F 00             fcb    $40,$41,79,0,10,0 F5-XDE  E4AF 00 81 4F 00             fcb    $00,$81,79,0,18,0 F3-XD  E4B5 00 C1 4F 00             fcb    $00,$c1,79,0,20,0 F3-XH  E4BB 00 00 00 00             fcb    0,0,0,0,0,0                                                               * all process registers stacked               E4C1  nmihnd    equ    *                                          *                     * signal any interrupt at location in DPR                     *  E4C1 86   55       rtiend    lda    #$55  E4C3 B7   03F8               sta    flpdpr+$03f8 give warning in DPR  E4C6 3B                      rti                       FFF0                         org    VECTORS                       FFF0 E4C1                    fdb    rtiend  FFF2 E4C1                    fdb    rtiend  FFF4 E4C1                    fdb    rtiend  FFF6 E4C1                    fdb    rtiend  FFF8 E4C1                    fdb    rtiend  FFFA E4C1                    fdb    rtiend  FFFC E4C1                    fdb    nmihnd  FFFE E052                    fdb    reset                                                    end0 Error(s) detected     3 Excessive BRANCH/JUMP(S) detectedSymbol Table:Absolute Symbols:A        0008   ALARMS   000A   B        0009   BADBFD   0002   BARGS    0007   BSPCH    007F   BUFFER   0800   BUFPR    0032   BUFSIZ   0200   CBIT     0001   CC       000A   CDBLKS   0064   CFDN     0032   CMDMSK   0091   CMDRSC   0011   CMDRTK   0091   CMDWSC   0001   CMDWTK   0081   CNCLC    0018   CR       000D   D        0000   DBDDEN   0001   DBDSTP   0010   DBG      0000   DBGA     0000   DIRSIZ   000E   DP       000B   DPLCNT   000A   DPLSIZ   0009   DRVOFS   0000   DRVPAG   0009   DRVTSZ   0005   DSKADS   0003   E        000E   EARGC    0013   EBADF    0007   EBARG    000C   EBBIG    0016   EBDCL    001A   EBDEV    0012   EBIT     0080   EBSY     0010   ECN      0000   EDFUL    0005   EDTOF    0003   EFAULT   0002   EFLX     000B   EINTR    001B   EIO      0001   EISDR    0014   ELOCK    001F   EMSDR    0009   EMT2S    0008   EMTS     0004   ENBLK    000F   ENCHD    0018   ENDR     0004   ENMNT    0011   ENOFL    0008   ENOTB    0015   ENTSK    001C   ENTTY    001D   EOTCH    0004   EPIPE    001E   EPRM     000A   ESEEK    000D   ESOCK    0020   ESTOF    0017   ETMFL    0006   ETMTS    0019   EXCSIZ   0008   EXDEV    000E   F        000F   FALTS    0007   FDC      0AE9   FDNPR    0064   FDSTP1   0015   FDSTZR   0004   FD_ERR   0080   FD_FI0   00D0   FD_MRD   0090   FD_MWR   00B0   FD_RST   0008   FD_RTR   00E0   FD_SEK   0018   FD_SRD   0080   FD_STI   0040   FD_STO   0060   FD_STP   0020   FD_SWR   00A0   FD_WTR   00F0   FF       0040   FLP      0001   FS_BUSY  0001   FS_CRC   0008   FS_DRQ   0002   FS_HLD   0020   FS_IDX   0002   FS_LOST  0004   FS_NRDY  0080   FS_RNF   0010   FS_RWOK  00D8   FS_SKER  0010   FS_TRK0  0004   FS_WRP   0040   FTABSZ   000F   GPPDBG   0001   HANGS    0001   HOLDC    001B   IDE      0001   IF       0010   INTRC    0003   INTS     0002   IOP      0000   IS       0003   IU       0002   IX       0000   IY       0001   KBOLT    000A   KILLS    0005   LA_8_5   0040   LA_DS0   0005   LA_DS1   000A   LA_HLT   0080   LA_MOT   0008   LA_SDN   0020   LA_SEL0  0005   LA_SEL1  000A   LA_SID   0010   LOOP     0001   MAPSIZ   000D   MAXDEV   0005   MAXFLP   0004   MAXPAG   0100   MAXPAGES 0010   MAXPIP   1000   MXDMSK   0007   MXSTPM   0003   MXUMEM   FE00   NET      0001   NETBLCK  0000   NFDNPR   0050   NL       000A   NOACIA   0000   NODEV    FFFF   NONRAM   00F0   PAGSIZ   1000   PARTSZ   000C   PC       0005   PIPEPR   FFFB   PRCSIZ   0100   PTTY     0001   QUITC    001C   QUITS    0003   RAMBASE  0400   RAMDSK   0000   RAMEND   045A   RDYWAIT  9C40   REGSIZ   0008   RESTM    0009   ROMBASE  E000   ROMDBG   0000   S        0004   SBDCRC   0080   SBDSID   0001   SBUF     000C   SBUFFR   C000   SHMEM    0000   SIGCNT   000C   SLEPPR   FFB0   SMAPSZ   0100   SPACE    0020   SPI      0000   STABPG   0001   STACKSZ  0040   STKOFS   0F38   ST_DRQ   0080   ST_INT   0040   SWAPPR   0078   SYSBLK   000F   SYSLOC   0000   SYSPAG   0000   SYSSTK   BF38   SYSTXT   0005   TABCH    0009   TERMS    000B   TIMES    0009   TRACS    0008   TTYIPR   FFF6   TTYOPR   FFEC   U        0003   UA       0001   UB       0002   UCC      0000   UD       0001   UIO      0000   UNFILS   0010   UPB      0007   UPC      0005   USERBL   BF38   USERPR   FFA6   USERS    000C   USRLOC   000B   USTKO    0E00   UX       0003   V        0007   VECTORS  FFF0   VID      0000   W        0006   WAITPR   FFD8   WBUFPR   001E   WD2791   0000   WMEMPR   FFFB   WPIPES   0006   X        0001   XBUF     000D   XBUFFR   D000   XOFFC    0013   XONC     0011   Y        0002   Z0       000C   Z1       000D   addrh    0001   addrl    0003   addrm    0002   chkrdy   E406   clcpos   E338   curdrv   0404   ddens    0005   del1     E46C   del2     E46E   delay    E46A   dens     000C   diserr   0405   do_rdsc  E1B3   do_rdtk  E1FD   do_rtpb  E190   do_rttk  E1B0   do_wrsc  E1D8   do_wrtk  E280   do_wtpb  E1B0   do_wttk  E1B0   driv     0009   drvsel   E019   drvtab   040B   dstep    000A   dtrack   0000   fcp2io   03FD   fdbasp   0080   fdcbas   8000   fend     E15C   fend1    E16B   fio2cp   03FC   fiop     03FE   flblkh   0001   flblkl   0003   flblkm   0002   fldriv   0009   flerr    E159   flnwop   000A   flpack   E17C   flpcmd   E18B   flpdfl   E491   flpdpr   0000   flpfifo  0020   flpint   03FE   flpstp   03F0   flptel   03FF   flrflg   0000   flstat   0008   fltabl   E491   fltden   000C   fltdev   000D   fltsid   000B   fltsiz   0004   fltxfr   0006   fo2cmd   8000   fo2dat   8003   fo2sec   8002   fo2trg   800C   fo2trk   8001   fo4lat   8004   fo4sta   8008   frdblk   E2E4   frder    E1D6   fseek    E39A   func     0000   fwder    E1FB   fwrblk   E320   ilgdev   E14D   latch    0403   lside    0400   lsk1     E3A9   lsk10    E3DC   lsk2     E3AD   lsk3     E3BA   lsk4     E3BE   major    000D   nmihnd   E4C1   open     000A   parstab  E01E   pstep    0406   reset    E052   restore  E447   retry    0409   revision E000   romstck  045A   rretry   E018   rtiend   E4C1   sector   0402   seldrv   E171   setd2    E0DC   setd3    E0DE   side     000B   size     0004   skretry  E112   srchpm   E472   stat     0008   step     03F0   steprt   040A   tiop     03FF   track    0401   trghlt   E436   trkbuf   0800   warm     E07B   wrkprm   0407   xfer     0006   