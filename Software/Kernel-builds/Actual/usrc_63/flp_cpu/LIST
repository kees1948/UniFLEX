                     *                     * GPPFLPDRV, ROM code for CPU09GPP with 09FLP add-on                     *                     * 2021-03-05: write track, no retry. return error if drive/diskette absent                     *                     * 2021-04-30: minor bug fixes, different approach for WD2791                     *                     * 2021-08-31: correction in fseek, ready test now OK                     *                     * 2021-11-12: added double step, 40 track disk in 80 track drive                     *                     * 2021-12-04: implemented read track, flpdrvr.t is already done                     *                     * 2021-12-07: buffer clear read-track, ttyset to disable error check                     *                     * 2024-07-25: corrected drive table for 4 drives, added individual                     *             steprate settings per drive via DPR location                     *                     *                     * supports:  read block 128,256,512 byte size                     *            write block 128,256,512 byte size                     *            read track 125kBit, 250kBit, 500 kBit rate                     *            write track 125kBit, 250 kBit, 500 kBit rate                     *                     *            supports 8", 5.25" and 3.5" in single /                     *            double side and single / double / high density                     *                     *            runs with Interrupts disabled                     *            almost no 63X09 code                     *                     *                     * compatibillity with FLEX improved                     *                     *                     *                     *                     *                     *                     *                     *                     *                               opt    lis,exp   |                               opt    nop                                          *                     *  for DEBUG program is RAM based                     *               E000  ROMBASE   equ    $E000                                    FFF0  VECTORS   equ    $FFF0                                                         0400  RAMBASE   equ    $0400     just above Dual Port Ram               0800  BUFFER    equ    $0800     track buffer                                    0040  STACKSZ   equ    64        enough?                                    9C40  RDYWAIT   equ    40000     delay count                                          * hardware dependent values               0005  LA_DS0    equ    LA_SEL0   drive select 0               000A  LA_DS1    equ    LA_SEL1   drive select 1                                          *                     * DPR, command exchange withe kernel                     *               0091  CMDMSK    equ    %10010001 command mask               0011  CMDRSC    equ    %00010001 read sector               0001  CMDWSC    equ    %00000001 write sector               0091  CMDRTK    equ    %10010001 read track               0081  CMDWTK    equ    %10000001 write track                     *                     *                                                               * for a WD2793 (default) leave this at 0                     * for a WD2791 set it to 1               0000  WD2791    set    0                                    0001  MXDMSK    equ    %00000001 max drive mask 0,1               0003  MXSTPM    equ    %00000011 max step rate mask                     *               0080  SBDCRC    equ    %10000000 side info, disable CRC               0001  SBDSID    equ    %00000001 side infi, double (other) side               0010  DBDSTP    equ    %00010000 dens info, double step               0001  DBDDEN    equ    %00000001 dens info, doubel dens                     *               0015  FDSTP1    equ    %00010101 FDC TYPE 1 status mask               0004  FDSTZR    equ    %00000100 FDC TYPE 1, track zero                                                                                                           0400                         org    RAMBASE                       0400               lside     rmb    1         actual latch side  0401               track     rmb    1  0402               sector    rmb    1  0403               latch     rmb    1         latch backup  0404               curdrv    rmb    1         last selected drive  0405               diserr    rmb    1         disable (read) error check  0406               trktab    rmb    4         track numbers / drive  040A               ltctab    rmb    4         latch settings /drive                     *  040E               pstep     rmb    1         debug for progress  040F               wrkprm    rmb    2         pointer to drive info table entry  0411               retry     rmb    1         retry count  0412               steprt    rmb    1         step rate modifier                     *               0413  drvtab    equ    *  0413               dtrack    rmb    4         track#  0417               ddens     rmb    4         latch  041B               dstep     rmb    4         step rate  041F                         rmb    STACKSZ               045F  romstck   equ    *                                    045F  RAMEND    equ    *                       0800                         org    BUFFER  0800               trkbuf    rmb    12500     track buffer                       E000                         org    ROMBASE                       E000 47 50 50 20   revision  fcc    "GPP 09FLP ROM 20240725"                                          *                     * configuration constants                     *  E016 02            rretry    fcb    2                     * drive 0 and 1 obey the IBM PC selects  E017 05 0A         drvsel    fcb    LA_DS0,LA_DS1 driver select bytes                     * drive 2 and 3 have no specific setup  E019 04 08                   fcb    %00000100,%00001000                     *  E01B 11 00         parstab   fcb    CMDRSC,0  E01D E146                    fdb    do_rdsc  E01F 01 00                   fcb    CMDWSC,0  E021 E16B                    fdb    do_wrsc  E023 91 00                   fcb    CMDRTK,0  E025 E190                    fdb    do_rdtk  E027 81 00                   fcb    CMDWTK,0  E029 E213                    fdb    do_wrtk  E02B 0000 0000               fdb    0,0       end of table                                    000C  dens      equ    flpdpr+fltden               000B  side      equ    flpdpr+fltsid               0004  size      equ    flpdpr+fltsiz               0006  xfer      equ    flpdpr+fltxfr               0009  driv      equ    flpdpr+fldriv               03F0  step      equ    flpdpr+flpstp               0008  stat      equ    flpdpr+flstat               000A  open      equ    flpdpr+flnwop               0000  func      equ    flpdpr+flrflg               0001  addrh     equ    flpdpr+flblkh               0002  addrm     equ    flpdpr+flblkm               0003  addrl     equ    flpdpr+flblkl               03FF  tiop      equ    flpdpr+flptel               03FE  fiop      equ    flpdpr+flpint                                          *                     * cold start                     *               E02F  reset     equ    *  E02F 1A   50                 orcc   #$50  E031 10CE 045F               lds    #romstck  E035 86   80                 lda    #fdbasp  E037 1F   8B                 tfr    a,dp               0080            setdp  fdbasp                     * NATIVE 63X09 !!  E039 11 3D 03                fcb    $11,$3d,$03 6309                     *  E03C 8E   0000               ldx    #flpdpr   go clear the Dual Port Ram  E03F 4F                      clra  E040 5F                      clrb  E041 ED   81       01        std    0,x++  E043 8C   03FF               cmpx   #flpdpr+flptel  E046 25   F9                 blo    01b                     *  E048 8E   0400               ldx    #RAMBASE  E04B ED   81       02        std    0,x++  E04D 8C   045F               cmpx   #RAMEND  E050 25   F9                 blo    02b                     * set default disk type  E052 8E   E40C               ldx    #flpdfl  E055 BF   040F               stx    wrkprm    set pointer                     ****************************************************************                     *                     * normally the driver loops here                     *                     ****************************************************************               E058  warm      equ    *  E058 1A   50                 orcc   #$50  E05A 10CE 045F               lds    #romstck                     *  E05E BD   E141     01        jsr    flpcmd    new message from main CPU  E061 27   FB                 beq    01b       wait                     * save previous settings for track register and latch  E063 BD   E127               jsr    seldrv    save old setttings  E066 D6   01                 ldb    <fo2trk  E068 E7   84                 stb    0,x  E06A F6   0403               ldb    latch  E06D E7   04                 stb    4,x                     * restore the correct setting for the current drive  E06F F6   0009               ldb    driv      get drive  0,1  E072 C4   01                 andb   #MXDMSK  E074 F7   0404               stb    curdrv  E077 BD   E127               jsr    seldrv  E07A E6   84                 ldb    0,x  E07C D7   01                 stb    <fo2trk  E07E E6   04                 ldb    4,x  E080 F7   0403               stb    latch  E083 E6   88 DD              ldb    (step-drvtab),x get ROM bits E3F0...E3F3  E086 C4   03                 andb   #MXSTPM   correct  E088 F7   0412               stb    steprt                     * set drive select bits  E08B F6   0404               ldb    curdrv  E08E 8E   E017               ldx    #drvsel  E091 3A                      abx  E092 F6   0403               ldb    latch  E095 C4   F8                 andb   #$f8      leave these intact  E097 34   04                 pshs   b  E099 E6   84                 ldb    0,x  E09B EA   E0                 orb    0,s+  E09D F7   0403               stb    latch     clean higher bits                     *                     * update other settings                     *  E0A0 B6   E016               lda    rretry    rom setting  E0A3 B7   0411               sta    retry                     * test 5"/8"  E0A6 F6   0403               ldb    latch  E0A9 B6   000B               lda    side  E0AC 85   40                 bita   #LA_8_5   5/8" select  E0AE 27   04                 beq    setd2  E0B0 CA   40                 orb    #LA_8_5  E0B2 20   02                 bra    setd3                     *  E0B4 C4   BF       setd2     andb   #255-LA_8_5  E0B6 CA   80       setd3     orb    #$80  E0B8 F7   0403               stb    latch  E0BB D7   04                 stb    <fo4lat   set latch                     *  E0BD 84   80                 anda   #SBDCRC   disable read error check  E0BF B7   0405               sta    diserr                     *                     * everything is set                     *  E0C2 BD   E399               jsr    chkrdy    see if drive is on-line  E0C5 B7   0008               sta    stat  E0C8 27   02                 beq    03f  E0CA 20   55                 bra    fend1                     * if new open force restore  E0CC B6   000A     03        lda    open      new open?  E0CF 27   09                 beq    04f       yes, skip forced restore                     *                     * retry loops here                     *  E0D1 BD   E3CC     skretry   jsr    restore   restore drive  E0D4 84   15                 anda   #FDSTP1  E0D6 81   04                 cmpa   #FDSTZR   should be there  E0D8 26   35                 bne    flerr                     *  E0DA 7F   000A     04        clr    open      remove flag                     *  E0DD C6   01                 ldb    #1        set progress  E0DF F7   040E               stb    pstep                     *  E0E2 7F   0008               clr    stat      initialize return status                     *  E0E5 BD   E399               jsr    chkrdy    drive still ready?  E0E8 4D                      tsta  E0E9 26   24                 bne    flerr                     *  E0EB BD   E3ED     06        jsr    srchpm    scan drive table                     *  E0EE C6   02                 ldb    #2  E0F0 F7   040E               stb    pstep  E0F3 B6   0000               lda    func      check command for valid  E0F6 84   91                 anda   #CMDMSK  E0F8 8E   E01B               ldx    #parstab  search function  E0FB A1   84       21        cmpa   0,x  E0FD 27   0D                 beq    20f  E0FF 30   04                 leax   4,x  E101 6D   84                 tst    0,x  E103 26   F6                 bne    21b                     *  E105 86   BF                 lda    #FD_ERR+63  E107 B7   0008               sta    stat  E10A 20   15                 bra    fend1                     *  E10C AD   98 02    20        jsr    [2,x]                     *  E10F B7   0008     flerr     sta    stat                     *  E112 C6   07       fend      ldb    #7  E114 F7   040E               stb    pstep  E117 4D                      tsta             error  E118 27   07                 beq    fend1  E11A 7A   0411               dec    retry >E11D 1026 FFB0               lbne   skretry  E121 12            fend1     nop  E122 8D   0E                 bsr    flpack    tell main CPU about it                     *  E124 7E   E058               jmp    warm                                          *                     * seldrv                     *  E127 34   04       seldrv    pshs   b  E129 8E   0413               ldx    #drvtab  E12C F6   0404               ldb    curdrv  E12F 3A                      abx  E130 35   84                 puls   b,pc                                          *                     *  write MAILBOX to other CPU I'm done                     *  E132 C6   08       flpack    ldb    #8  E134 F7   040E               stb    pstep  E137 7F   03FF               clr    tiop      acknowledge main CPU  E13A 86   FF                 lda    #$ff  E13C B7   03FE               sta    fiop      tell him I'am done  E13F 12                      nop  E140 39                      rts                                          *                     * flpcmd, test MAILBOX for new data from main CPU                     *  E141 B6   03FF     flpcmd    lda    tiop      command present?  E144 12                      nop  E145 39                      rts                                          *                     * Y = fdcbase                     *               E146  do_rdsc   equ    *  E146 C6   03                 ldb    #3  E148 F7   040E               stb    pstep                     *  E14B BD   E2CB               jsr    clcpos    block# -> trk/sec/sid  E14E 4D                      tsta  E14F 26   18                 bne    frder     error                     *  E151 C6   04                 ldb    #4  E153 F7   040E               stb    pstep  E156 BD   E32D               jsr    fseek  E159 4D                      tsta  E15A 26   0D                 bne    frder                     *  E15C C6   05                 ldb    #5  E15E F7   040E               stb    pstep  E161 CE   0020               ldu    #flpdpr+flpfifo where data is to land  E164 86   80                 lda    #FD_SRD  E166 BD   E277               jsr    frdblk                     *  E169 12            frder     nop  E16A 39                      rts                                          *                     * Y = fdcbase                     *               E16B  do_wrsc   equ    *  E16B C6   03                 ldb    #3  E16D F7   040E               stb    pstep                     *  E170 BD   E2CB               jsr    clcpos    block# -> trk/sec/sid  E173 4D                      tsta  E174 26   18                 bne    fwder     error                     *  E176 C6   04                 ldb    #4  E178 F7   040E               stb    pstep  E17B BD   E32D               jsr    fseek  E17E 4D                      tsta  E17F 26   0D                 bne    fwder                     *  E181 C6   05                 ldb    #5  E183 F7   040E               stb    pstep  E186 CE   0020               ldu    #flpdpr+flpfifo where data is present  E189 86   A0                 lda    #FD_SWR  E18B BD   E2B3               jsr    fwrblk                     *  E18E 12            fwder     nop  E18F 39                      rts                                          *                     * We read the designated track into buffer and transfer                     * that back to the System                     *               E190  do_rdtk   equ    *  E190 34   70                 pshs   x,y,u                     *  clear track buffer  E192 FC   0004               ldd    size  E195                         trfr   D,W  E195 1F                      fcb    $1f  E196 06                      fcb    D<<4|W                               endm  E197 8E   0800               ldx    #trkbuf  E19A 6F   E2                 clr    0,-s  E19C                         tfm4   S,X  E19C 113B                    fdb    $113b  E19E 41                      fcb    S<<4|X                               endm  E19F 32   61                 leas   1,s                     *  E1A1 86   01                 lda    #1        no retry!  E1A3 B7   0411               sta    retry  E1A6 C6   03                 ldb    #3  E1A8 F7   040E               stb    pstep                     *  E1AB B6   0003               lda    addrl     track address << 1 + side bit  E1AE 5F                      clrb  E1AF 44                      lsra             strip side bit  E1B0 24   01                 bcc    08f  E1B2 5C                      incb             set side select  E1B3 F7   0400     08        stb    lside     read  track on other side                     *  E1B6 B7   0401               sta    track  E1B9 26   03                 bne    18f       make sure we  start at track 00  E1BB BD   E3CC               jsr    restore   restore if target is 0                     *  E1BE 86   01       18        lda    #1        set sector register  E1C0 B7   0402               sta    sector                     *  E1C3 BD   E32D               jsr    fseek     should set latch  E1C6 4D                      tsta  E1C7 26   47                 bne    10f                     *                     * do actual Read Track here                     *  E1C9 C6   04                 ldb    #4  E1CB F7   040E               stb    pstep  E1CE CE   0800               ldu    #trkbuf   do read into large buffer  E1D1 86   E0                 lda    #FD_RTR  E1D3 BD   E277               jsr    frdblk  E1D6 12                      nop  E1D7 4D                      tsta  E1D8 27   05                 beq    20f  E1DA 7D   0405               tst    diserr    if error and not set, abort  E1DD 27   31                 beq    10f                     *                     * copy trkbuf data to DPR, first direct, next on INT's                     *  E1DF BC   0004     20        cmpx   size      set size of result is smaller  E1E2 24   03                 bhs    21f  E1E4 BF   0004               stx    size  E1E7 C6   05       21        ldb    #5  E1E9 F7   040E               stb    pstep  E1EC 8E   0800               ldx    #trkbuf   data source  E1EF FC   0006     03        ldd    xfer      is updated by kernel driver  E1F2 10B3 0004               cmpd   size      did we enough?  E1F6 24   17                 bhs    02f                     *  E1F8 CE   0020               ldu    #flpdpr+flpfifo  E1FB                         ldwi   BUFSIZ    immediate load  E1FB 1086                    fdb    $1086  E1FD 0200                    fdb    BUFSIZ                               endm  E1FF                         tfm1   X,U       data to main side  E1FF 1138                    fdb    $1138  E201 13                      fcb    X<<4|U                               endm  E202 4F                      clra  E203 BD   E132               jsr    flpack    tell him  I have it                     *  E206 0D   08       01        tst    <fo4sta   keep motor running  E208 BD   E141               jsr    flpcmd    wait for him to grab it  E20B 27   F9                 beq    01b       postbox empty  E20D 20   E0                 bra    03b       loop until all                     *  E20F 4F            02        clra             set no error                     *  E210 12            10        nop              debug  E211 35   F0                 puls   x,y,u,pc                                          *                     * We arrive here when the DPR contains the first BUFSIZ                     * bytes of the track image                     *               E213  do_wrtk   equ    *  E213 34   70                 pshs   x,y,u  E215 8E   0800               ldx    #trkbuf                     *                     * copy DPR data to trkbuf                     *  E218 12            03        nop  E219 CE   0020               ldu    #flpdpr+flpfifo  E21C                         ldwi   BUFSIZ    immediate load  E21C 1086                    fdb    $1086  E21E 0200                    fdb    BUFSIZ                               endm  E220                         tfm1   U,X  E220 1138                    fdb    $1138  E222 31                      fcb    U<<4|X                               endm  E223 FC   0006               ldd    xfer      is updated by kernel driver  E226 10B3 0004               cmpd   size      we have all  E22A 24   0D                 bhs    02f  E22C 4F                      clra  E22D BD   E132               jsr    flpack    tell hime I took it                     *  E230 0D   08       01        tst    <fo4sta   keep motor running  E232 BD   E141               jsr    flpcmd    wait for next data  E235 27   F9                 beq    01b       postbox empty  E237 20   DF                 bra    03b       loop until all                     *                     * all data present                     *  E239 12            02        nop              TRAP  E23A 86   01                 lda    #1        no retry!  E23C B7   0411               sta    retry  E23F C6   03                 ldb    #3  E241 F7   040E               stb    pstep                     *  E244 B6   0003               lda    addrl     track address << 1 + side bit  E247 5F                      clrb  E248 44                      lsra             strip side bit  E249 24   01                 bcc    08f  E24B 5C                      incb  E24C F7   0400     08        stb    lside     format track on other side                     *  E24F B7   0401               sta    track  E252 26   03                 bne    18f       make sure we  start at track 00  E254 BD   E3CC               jsr    restore   restore if target is 0                     *  E257 86   01       18        lda    #1  E259 B7   0402               sta    sector                     *  E25C C6   04                 ldb    #4  E25E F7   040E               stb    pstep  E261 BD   E32D               jsr    fseek  E264 4D                      tsta  E265 26   0D                 bne    10f                     *                     * restore the registers for the write                     *  E267 C6   05                 ldb    #5  E269 F7   040E               stb    pstep  E26C CE   0800               ldu    #trkbuf  E26F 86   F0                 lda    #FD_WTR >E271 BD   E2B3               jsr    fwrblk                     *  E274 12            10        nop  E275 35   F0                 puls   x,y,u,pc                                          *                     * code routine, to read one dataset from FDC                     * U = buffer address,                     * Y = base address hardware                     * A = command                     *                     * can read sector or track                     * drive select, density and such alreay set up                     * time out from INT fdc                     *               E277  frdblk    equ    *  E277 34   70                 pshs   x,y,u  E279 C6   1F                 ldb    #31       very long              create timeout  E27B 8E   0000               ldx    #0        65536*2*25/4 cycles                     *  E27E 97   00                 sta    <fo2cmd                     *  E280 1A   50       01        orcc   #$50      disable ints  E282 20   04                 bra    03f                     * loop here  E284 96   03       02        lda    <fo2dat   get data  E286 A7   C0                 sta    0,u+      transfer                     * poll fdc for DRQ  E288 96   08       03        lda    <fo4sta  E28A 48                      asla  E28B 25   F7                 bcs    02b       DRQ  E28D 2B   07                 bmi    90f  E28F 30   01                 leax   1,x       count up  E291 26   F5                 bne    03b  E293 5A                      decb             at zero dec B  E294 26   F2                 bne    03b       if zero abort                     * end of command  E296 11A3 64       90        cmpu   4,s       nothing got?  E299 27   0D                 beq    98f       unexpected                     * normal end of read  E29B 96   00       97        lda    <fo2cmd   read status  E29D EF   E4                 stu    0,s       preset X                     *  E29F 7D   0405     95        tst    diserr  E2A2 27   02                 beq    99f  E2A4 84   E7                 anda   #%11100111 remove CRC/RNF error (if any)                     *  E2A6 35   F0       99        puls   x,y,u,pc  A = result status                                          * timeout occurred  E2A8 86   D0       98        lda    #FD_FI0   force interrupt  E2AA 97   00                 sta    <fo2cmd  E2AC BD   E3E5               jsr    delay  E2AF 86   10                 lda    #$10      not found  E2B1 20   EC                 bra    95b                                          *                     * code routine, to write one dataset to the FDC                     * U = buffer address                     * Y = hardware base                     * A = command                     *                     * drive select, density and such alreay set up                     * time out from INT fdc                     *               E2B3  fwrblk    equ    *  E2B3 34   70                 pshs   x,y,u                     *  E2B5 97   00                 sta    <fo2cmd                     *  E2B7 1A   50       01        orcc   #$50      disable ints  E2B9 20   02                 bra    04f                       E2BB 97   03                 sta    <fo2dat   put data                     *  E2BD A6   C0       04        lda    0,u+                     *  E2BF D6   08       03        ldb    <fo4sta  E2C1 2B   F8                 bmi    02b  E2C3 C5   40                 bitb   #ST_INT   INT  E2C5 27   F8                 beq    03b                     *  E2C7 96   00                 lda    <fo2cmd   read status                     *  E2C9 35   F0       99        puls   x,y,u,pc                                          *                     * clcpos, transfer block# into track/sector/side                     *                     * Y = fdcbase                     *               E2CB  clcpos    equ    *  E2CB 34   70                 pshs   x,y,u  E2CD 7F   0400               clr    lside     result side of calc  E2D0 FC   0002               ldd    addrm     block# M/L                     *  E2D3 BE   0004               ldx    size      check special addressing  E2D6 8C   0100               cmpx   #256  E2D9 27   05                 beq    21f  E2DB 8C   0080               cmpx   #128  E2DE 26   12                 bne    20f                     *                     *  absolute addressing                     *  E2E0 B7   0401     21        sta    track  E2E3 F7   0402               stb    sector  E2E6 B6   000B               lda    side      from ttyset  E2E9 84   03                 anda   #%00000011 DS or Biased  E2EB 27   39                 beq    88f  E2ED 7C   0400               inc    lside     set side 1  E2F0 20   34                 bra    88f                     *                     * regular 512 byte block to track/sector                     *  E2F2 BE   040F     20        ldx    wrkprm    fresh copy of drive params                     *  E2F5 7F   0401               clr    track     track = 0                     *  E2F8 A3   03       02        subd   3,x       sec/trk  E2FA 2B   05                 bmi    01f                     *  E2FC 7C   0401               inc    track     up track #  E2FF 20   F7                 bra    02b                     *  E301 E3   03       01        addd   3,x       adjust                     * sector in B, track# on stack  E303 B6   000B               lda    side      is double sided?  E306 85   03                 bita   #%00000011 DS or biased  E308 27   11                 beq    05f       no                     *  E30A 74   0401               lsr    track     track# / 2  E30D 24   0C                 bcc    05f       even track                     * odd track, add bias  E30F 7C   0400               inc    lside                     * TEST Biased here!  E312 B6   000B               lda    side  E315 85   02                 bita   #%00000010  E317 26   02                 bne    05f       no  E319 EB   04                 addb   4,x       biased sector#                     *  E31B 5C            05        incb             1 relative  E31C F7   0402               stb    sector    set sector#                     *  E31F B6   0401     08        lda    track  E322 A1   02                 cmpa   2,x       test against max  E324 22   03                 bhi    91f                     * normal return  E326 4F            88        clra             set OK  E327 35   F0                 puls   x,y,u,pc                     * errors  E329 86   10       91        lda    #FS_SKER  track > max  E32B 35   F0                 puls   x,y,u,pc                                          *                     * fseek, move head to track#, set registers                     * Y = hardware base                     *               E32D  fseek     equ    *  E32D 34   70                 pshs   x,y,u  E32F B6   0400               lda    lside  E332 85   01                 bita   #SBDSID  E334 27   06                 beq    lsk1  E336                         oime   LA_SID,latch 1 = side 1  E336 71                      fcb    $71  E337 10                      fcb    LA_SID  E338 0403                    fdb    latch                               endm  E33A 20   04                 bra    lsk2  E33C               lsk1      aime   !LA_SID,latch 0 = side 0  E33C 72                      fcb    $72  E33D EF                      fcb    !LA_SID  E33E 0403                    fdb    latch                               endm                     *  E340 B6   000C     lsk2      lda    dens  E343 85   01                 bita   #DBDDEN  E345 26   06                 bne    lsk3  E347                         oime   LA_SDN,latch  E347 71                      fcb    $71  E348 20                      fcb    LA_SDN  E349 0403                    fdb    latch                               endm  E34B 20   04                 bra    lsk4  E34D               lsk3      aime   !LA_SDN,latch  E34D 72                      fcb    $72  E34E DF                      fcb    !LA_SDN  E34F 0403                    fdb    latch                               endm                     *  E351 B6   0403     lsk4      lda    latch  E354 97   04                 sta    <fo4lat                     *  E356 B6   0402               lda    sector  E359 97   02                 sta    <fo2sec   set sector register                     *  E35B B6   0401               lda    track  E35E 91   01                 cmpa   <fo2trk  E360 27   28                 beq    04f                     *                     * test double step function,                     *  E362 F6   000C               ldb    dens  E365 C5   10                 bitb   #DBDSTP   double step  E367 27   06                 beq    lsk10                     * it is double step  E369 D6   01                 ldb    <fo2trk   logical track#  E36B 58                      aslb             *2  E36C D7   01                 stb    <fo2trk   physical track#  E36E 48                      asla                     *                     * track is no the same, do SEEK                     *  E36F 97   03       lsk10     sta    <fo2dat  E371 86   18                 lda    #FD_SEK  E373 BA   0412               ora    steprt    update steprate  E376 97   00                 sta    <fo2cmd                     *  E378 96   08       01        lda    <fo4sta  E37A 85   40                 bita   #ST_INT  E37C 27   FA                 beq    01b                     *                     *                     *  E37E F6   000C               ldb    dens  E381 C5   10                 bitb   #%00010000 double step  E383 27   05                 beq    04f                     *  E385 D6   01                 ldb    <fo2trk   physical track#  E387 57                      asrb             /2  E388 D7   01                 stb    <fo2trk   logical track#                     *                     *                     *  E38A 96   00       04        lda    <fo2cmd                       E38C 84   D9                 anda   #!(FS_TRK0|FS_IDX|FS_HLD) remove these from status                     * check if we need to pass write protect  E38E F6   0000               ldb    func  E391 C5   10                 bitb   #%00010000 command is read  E393 27   02                 beq    02f  E395 84   BF                 anda   #!FS_WRP                     *  E397 35   F0       02        puls   x,y,u,pc                                          *                     * chkrdy, check if drive is ready                     * Y = fdcbase                     *  E399 C6   07       chkrdy    ldb    #7        multiply  E39B B6   0403               lda    latch  E39E 97   04                 sta    <fo4lat >E3A0 BD   E3E5               jsr    delay                     *  E3A3 8E   7FFF     10        ldx    #$7fff    long delay                     *  E3A6 B6   0403     11        lda    latch  E3A9 97   04                 sta    <fo4lat  E3AB 96   00                 lda    <fo2cmd  E3AD 2A   0A                 bpl    12f                     *  E3AF 30   1F                 leax   -1,x      decrement counter  E3B1 26   F3                 bne    11b                     *  E3B3 5A                      decb             multiply  E3B4 26   ED                 bne    10b                     *  E3B6 86   80                 lda    #FS_NRDY  E3B8 39                      rts                     *  E3B9 4F            12        clra  E3BA 39                      rts                                          *                     * trigger headload delay from outside FDC                     * like when drive select is changed                     *  E3BB 34   02       trghlt    pshs   a  E3BD B6   0403               lda    latch  E3C0 84   7F                 anda   #$7f      trigger headsettling delay  E3C2 97   04                 sta    <fo4lat  E3C4 1E   11                 exg    x,x  E3C6 8A   80                 ora    #$80  E3C8 97   04                 sta    <fo4lat  E3CA 35   82                 puls   a,pc                                          *                     * restore, set drive at track 0                     * Y = fdcbase                     *  E3CC 86   08       restore   lda    #FD_RST  E3CE BA   0412               ora    steprt    adjust  E3D1 97   00                 sta    <fo2cmd  E3D3 96   08       20        lda    <fo4sta  E3D5 0D   04                 tst    <fo4lat   ??  E3D7 85   40                 bita   #ST_INT  E3D9 27   F8                 beq    20b  E3DB 96   00                 lda    <fo2cmd  E3DD 85   64                 bita   #00000100  E3DF 26   03                 bne    21f  E3E1 7F   0401               clr    track     update info  E3E4 39            21        rts                                          *                     * delay, spend some time , no registers affected                     *  E3E5 8D   00       delay     bsr    del1  E3E7 8D   00       del1      bsr    del2  E3E9 34   76       del2      pshs   d,x,y,u  E3EB 35   F6                 puls   d,x,y,u,pc                                          *                     * srchpm, search drive param table, used for track/sector calculations                     * Y = fdcbase                     *  E3ED 34   70       srchpm    pshs   x,y,u  E3EF 8E   E40C               ldx    #fltabl   start table  E3F2 FC   000B               ldd    side      get ttyset/ttyget bytes  E3F5 84   40                 anda   #%01000000 side bits 5/8" flag  E3F7 C4   C1                 andb   #%11000001 dens bits HD,10s,DD  E3F9 10A3 84       31        cmpd   0,x  E3FC 27   09                 beq    30f  E3FE 30   06                 leax   6,x       size of entry  E400 6D   02                 tst    2,x  E402 26   F5                 bne    31b  E404 8E   E40C               ldx    #flpdfl                     *  E407 BF   040F     30        stx    wrkprm  E40A 35   F0                 puls   x,y,u,pc                                    E40C  fltabl    equ    *  E40C 00 00 4C 00   flpdfl    fcb    $00,$00,76,0,8,0 FD-XS  E412 00 01 4C 00             fcb    $00,$01,76,0,16,0 FD-DX  E418 40 00 4F 00             fcb    $40,$00,79,0,5,0 F5-SX  E41E 40 01 4F 00             fcb    $40,$01,79,0,9,0 F5-XD  E424 40 41 4F 00             fcb    $40,$41,79,0,10,0 F5-XDE  E42A 00 81 4F 00             fcb    $00,$81,79,0,18,0 F3-XD  E430 00 C1 4F 00             fcb    $00,$c1,79,0,20,0 F3-XH  E436 00 00 00 00             fcb    0,0,0,0,0,0                                                               * all process registers stacked               E43C  nmihnd    equ    *                                          *                     * signal any interrupt at location in DPR                     *  E43C 86   55       rtiend    lda    #$55  E43E B7   03F8               sta    flpdpr+$03f8 give warning in DPR  E441 3B                      rti                       FFF0                         org    VECTORS                       FFF0 E43C                    fdb    rtiend  FFF2 E43C                    fdb    rtiend  FFF4 E43C                    fdb    rtiend  FFF6 E43C                    fdb    rtiend  FFF8 E43C                    fdb    rtiend  FFFA E43C                    fdb    rtiend  FFFC E43C                    fdb    nmihnd  FFFE E02F                    fdb    reset                                                    end0 Error(s) detected     3 Excessive BRANCH/JUMP(S) detectedSymbol Table:Absolute Symbols:A        0008   ALARMS   000A   B        0009   BADBFD   0002   BARGS    0007   BSPCH    007F   BUFFER   0800   BUFPR    0032   BUFSIZ   0200   CBIT     0001   CC       000A   CDBLKS   0064   CFDN     0032   CMDMSK   0091   CMDRSC   0011   CMDRTK   0091   CMDWSC   0001   CMDWTK   0081   CNCLC    0018   CR       000D   D        0000   DBDDEN   0001   DBDSTP   0010   DBG      0000   DBGA     0000   DIRSIZ   000E   DP       000B   DPLCNT   000A   DPLSIZ   0009   DRVPAG   0009   DSKADS   0003   E        000E   EARGC    0013   EBADF    0007   EBAL     0021   EBARG    000C   EBBIG    0016   EBDCL    001A   EBDEV    0012   EBIT     0080   EBSY     0010   ECN      0000   EDFUL    0005   EDTOF    0003   EFAULT   0002   EFLX     000B   EINTR    001B   EIO      0001   EISDR    0014   ELOCK    001F   EMSDR    0009   EMT2S    0008   EMTS     0004   ENBLK    000F   ENCHD    0018   ENDR     0004   ENMNT    0011   ENOFL    0008   ENOTB    0015   ENTSK    001C   ENTTY    001D   EOTCH    0004   EPIPE    001E   EPRM     000A   ESEEK    000D   ESOCK    0020   ESTOF    0017   ETMFL    0006   ETMTS    0019   EXCSIZ   0008   EXDEV    000E   F        000F   FALTS    0007   FDC      0AE9   FDNPR    0064   FDSTP1   0015   FDSTZR   0004   FD_ERR   0080   FD_FI0   00D0   FD_MRD   0090   FD_MWR   00B0   FD_RST   0008   FD_RTR   00E0   FD_SEK   0018   FD_SRD   0080   FD_SWR   00A0   FD_WTR   00F0   FF       0040   FLP      0001   FS_BUSY  0001   FS_CRC   0008   FS_DRQ   0002   FS_HLD   0020   FS_IDX   0002   FS_LOST  0004   FS_NRDY  0080   FS_RNF   0010   FS_RWOK  00D8   FS_SKER  0010   FS_TRK0  0004   FS_WRP   0040   GPPDBG   0001   HANGS    0001   HOLDC    001B   IDE      0001   IF       0010   INTRC    0003   INTS     0002   IOP      0000   IS       0003   IU       0002   IX       0000   IY       0001   KILLS    0005   LA_8_5   0040   LA_DS0   0005   LA_DS1   000A   LA_HLT   0080   LA_MOT   0008   LA_SDN   0020   LA_SEL0  0005   LA_SEL1  000A   LA_SID   0010   LOOP     0001   MAPSIZ   000D   MAXDRV   0001   MAXPAG   0100   MAXPAGES 0010   MAXPIP   1000   MXDMSK   0001   MXSTPM   0003   MXUMEM   FE00   NET      0001   NETBLCK  0000   NFDNPR   0050   NL       000A   NOACIA   0000   NODEV    FFFF   NONRAM   00F8   PAGSIZ   1000   PC       0005   PIPEPR   FFFB   PRCSIZ   0100   QUITC    001C   QUITS    0003   RAMBASE  0400   RAMDSK   0000   RAMEND   045F   RDYWAIT  9C40   REGSIZ   0008   RESTM    0009   ROMBASE  E000   ROMDBG   0000   S        0004   SBDCRC   0080   SBDSID   0001   SBUF     000C   SBUFFR   C000   SIGCNT   000C   SLEPPR   FFB0   SMAPSZ   0100   SPACE    0020   SPI      0000   STABPG   0001   STACKSZ  0040   STKOFS   0F38   ST_DRQ   0080   ST_INT   0040   SWAPPR   0078   SYSBLK   000F   SYSLOC   0000   SYSPAG   0000   SYSSTK   BF38   SYSTXT   0005   TABCH    0009   TERMS    000B   TIMES    0009   TRACS    0008   TTYIPR   FFF6   TTYOPR   FFEC   U        0003   UA       0001   UB       0002   UCC      0000   UD       0001   UIO      0000   UNFILS   0010   UPB      0007   UPC      0005   USERBL   BF38   USERPR   FFA6   USERS    000C   USRLOC   000B   USTKO    0E00   UX       0003   V        0007   VECTORS  FFF0   VID      0000   W        0006   WAITPR   FFD8   WBUFPR   001E   WD2791   0000   WMEMPR   FFFB   WPIPES   0006   X        0001   XBUF     000D   XBUFFR   D000   XOFFC    0013   XONC     0011   Y        0002   addrh    0001   addrl    0003   addrm    0002   chkrdy   E399   clcpos   E2CB   curdrv   0404   ddens    0417   del1     E3E7   del2     E3E9   delay    E3E5   dens     000C   diserr   0405   do_rdsc  E146   do_rdtk  E190   do_wrsc  E16B   do_wrtk  E213   driv     0009   drvsel   E017   drvtab   0413   dstep    041B   dtrack   0413   fcp2io   03FD   fdbasp   0080   fdcbas   8000   fend     E112   fend1    E121   fio2cp   03FC   fiop     03FE   flblkh   0001   flblkl   0003   flblkm   0002   fldriv   0009   flerr    E10F   flnwop   000A   flpack   E132   flpcmd   E141   flpdfl   E40C   flpdpr   0000   flpfifo  0020   flpint   03FE   flpstp   03F0   flptel   03FF   flrflg   0000   flstat   0008   fltabl   E40C   fltden   000C   fltsid   000B   fltsiz   0004   fltxfr   0006   fo2cmd   8000   fo2dat   8003   fo2sec   8002   fo2trg   800C   fo2trk   8001   fo4lat   8004   fo4sta   8008   frdblk   E277   frder    E169   fseek    E32D   func     0000   fwder    E18E   fwrblk   E2B3   latch    0403   lside    0400   lsk1     E33C   lsk10    E36F   lsk2     E340   lsk3     E34D   lsk4     E351   ltctab   040A   nmihnd   E43C   open     000A   parstab  E01B   pstep    040E   reset    E02F   restore  E3CC   retry    0411   revision E000   romstck  045F   rretry   E016   rtiend   E43C   sector   0402   seldrv   E127   setd2    E0B4   setd3    E0B6   side     000B   size     0004   skretry  E0D1   srchpm   E3ED   stat     0008   step     03F0   steprt   0412   tiop     03FF   track    0401   trghlt   E3BB   trkbuf   0800   trktab   0406   warm     E058   wrkprm   040F   xfer     0006   