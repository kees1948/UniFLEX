          lib     ./environment.h        if      ((IOP|UIO|NET)=1)          opt     nol          lib     ../include/macdefs.h          lib     ../include/task.h          lib     ../include/sysdefs.h          lib     ../include/fio.h          lib     ../include/fio_ctrl.h          lib     ../include/fio_codes.h        if      (IOP=1)        lib     ../include/iop_dev.h        endif        if      (NET=1)        lib     ../include/nwp_codes.h        endif        data          opt     lis        sttl    FIO Routines        global  fio_send,FIFO_get,FIFOgeta,FIFO_put,FIFOputa,fio_irq,fio_msg        global  MBX_lock,MBX_unlock,find_slot        global  get_F_S,FIFO_put,FIFO_get,FIFO_unlock* keep this at zero if you share normal serial ports with IO_CPU portsACT_COST  set     0          Activity cost for IO_CPU transactionfio_wait  fcb     0          Count of tasks waiting for FIO access (global)** fio_irq - Process FIO interrupt, testing for INT already reset the IRQ*   Y - FIO Control structure*fio_irq   pshs    x,y,u          ldu     fio_dba,y          ldd     fio_cpu3,u device info          pshs    d          lda     fio_cpu2,u move transaction data (interrupt#)          pshs    a          ldd     fio_cpu1,u                       (terminal#)          pshs    d          -- Sequence /Task ID                1          lda     fio_cpu,u                        (response)          pshs    a          -- Response code                    0          ldx     fio_dsz,y  should work for all FIFO sizes          leax    -2,x          addr    U,X        U + X > X          clr     0,x        fio_cpuF indicate message received** stack contains resp code, seq#, fil, data, x ,y** fio_cpu3  4/5 device info           2* fio_cpu2  3   transaction data      1* fio_cpu1  1/2 task ID  / sequence   2* fio_cpu   0   response code         1          lda     0,s        fio_cpu get response code          cmpa    #R_INTRPT          bne     10f** handle programmed INTERRUPT from IO CPU* this is a high priority action (OOB)* fio_cp u  = R_INTRPT* fio_cpu1  = task ID* fio_cpu2  = signal* fio_cpu3  = device info*          if      (IOP=1)          ldb     3,s           signal          ldx     4,s           device info          jsr     tt_int        do high priority for TTY          endif          if      (NET=1)          ldb     3,s           signal          ldx     1,s           task ID          jsr     nw_int        do high priority for NET          endif*          leas    6,s        clean up stack          bra     99f        exit** 0,s - response code* 1,s - task ID* 3,s - transaction specific returned value* 4,s - device info*10        ldb     fio_mxtrn,y   MAX_TRAN          leay    fio_tran,y point to transaction list          pshs    b15        ldd     2,s        check transaction #          cmpd    tran_seq,y match?          beq     20f        yes - go*16        leay    TRAN_SIZ,y next transaction          dec     0,s        any more?          bne     15b* -- Unsolicited response!          leas    7,s        clean up stack          bra     99f        exit*20        puls    b          clean up stack          lda     0,s        get response code          sta     tran_resp,y save response code          lda     3,s        get transaction data          sta     tran_val,y          leas    6,s        clean up stack          jsr     wakeup     wake up sender99        puls    x,y,u,pc     return** fio_msg - Send a value via the FIO Mailbox & wait for response*   U - Device info, sock address or maj/min*   D - Value to send (B = Command, A = Specific data)*   Y - FIO control block*   jsr fio_msg*   D - Value returned (B = Error response, A = Specific data)*fio_msg   pshs    cc,d,x,y,u save registers* -- Find an empty transaction box10        seti               turn off interrupts          ldy     5,s        get FIO control address          jsr     MBX_lock   get access to FIO          lbsr    find_slot  go find a slot          beq     15f        jump if one found Y=transaction*          ldy     5,s        restore FIO structure pointer          jsr     MBX_unlock give up FIO until slot available          lbsr    find_slot  make sure no slots available          beq     10b        jump if there is one*          ldy     5,s        get FIO pointer          leay    fio_tflg,y sleep on transaction slots          ldb     #FIOPRI          jsr     sleep      wait for available message slot          bra     10b        try for a transaction slot* Y=transaction slot15        ldx     utask      set sequence # in slot ???          ldd     tstid,x    use task# as sequence          std     tran_seq,y          stu     tran_dev,y use U as device indicator*          ldb     0,s        enable (old) interrupts          tfr     b,cc*          ldb     2,s        restore message code (B)          lda     1,s        restore specific data (A)          sta     tran_oval,y                         (A)          stb     tran_msg,y                          (B)          tfr     y,x        X is now transaction slot          pshs    y          save transaction slot pointer          ldy     7,s        restore FIO structure pointer          lbsr    fio_send   SEND mailbox transaction          jsr     MBX_unlock release mailbox + wakeup* here when response comes back20        puls    y          get transaction slot address          seti               mask interrupts          tst     tran_resp,y any response yet?          bne     30f        yes - go process** wait for it*          ldx     5,s        get FIO control address          ldd     fio_fifo,x does this task own the FIFO?          bne     25f        yes - don't allow interrupts!*          pshs    y,u        save registers          ldd     umark1     set up to allow interruptable sleep          pshs    d          ldx     #27f       interrupt handling label          pshs    x          sts     umark1          ldb     #TTYIPR    set interruptable priority          jsr     A_sleep    wait for IO_CPU response          puls    d,x,y,u    restore registers          stx     umark1     restore interrupt point          bra     30f        continue** process Interrupted call*27        puls    x,y,u      Interrupt happened! - (D) already popped          stx     umark1     restore stack mark          lda     #E_ABORT   aborted transaction!          sta     tran_resp,y  set active          ldb     #O_INTRPT          pshs    y          save transaction slot pointer          tfr     y,x        X is transaction slot          ldy     7,s        restore FIO control pointer          jsr     MBX_lock   get access to mailbox          jsr     fio_send          jsr     MBX_unlock release mailbox          puls    y          restore transaction slot pointer          bra     30f** wait loop*25        ldb     #FIOPRI          pshs    x,y,u      save registers          jsr     A_sleep          puls    x,y,u      restore registers** start processing response*30        ldx     utask          seti               turn off interrupts while fiddling with transaction slots* -- See if there is a response.  It is possible to* -- get here without one if an interrupt happened which* -- was being ignored.  In this case, the IO_CPU doesn't* -- need to be notified of any interrupt, but we must* -- wait for the IO_CPU response to actually arrive.          ldb     tran_resp,y get response code          bne     35f        jump if response present*          pshs    y          reset stack          bra     20b        wait for response** B holds response code*35        clra               release transaction slot          sta     tran_seq,y          sta     tran_seq+1,y          clr     tran_resp,y          lda     tran_val,y [A] get transaction value          std     1,s        set return value [B] = transresp          ldy     5,s        wake anybody waiting for this slot          leay    fio_tflg,y          jsr     wakeup          cmpb    #E_ABORT          bne     50f        no - continue*          lds     umark1     yes - get out          rts*50        tstb               error response?          bpl     51f          sta     uerror     error code*51        puls    cc,d,x,y,u,pc return** A_sleep - Sleep until event with no decrease in activity*A_sleep   jsr     sleep      wait for event          pshs    a,x        upgrade activity          ldx     utask          lda     tsact,x          adda    #ACT_COST          bcc     00f*          lda     #$FF*00        sta     tsact,x          puls    a,x,pc** fio_send - Send a message via the FIO Mailbox*   Y - FIO control block*   X - transaction slot*   B - Message code to send (one byte)*   A - Message specific data*   U - Sequence #/Terminal #*   bsr fio_send*fio_send pshs   cc,d,x,u        save register        ldu     fio_dba,y        seti                    mask interrupts!        LEDON   LB_FIO0        stb     cpu_fio,u       set up mailbox value        sta     cpu_fio2,u      message specific data*        ldd     tran_seq,x        std     cpu_fio1,u        ldd     tran_dev,x     (old U) sequence #/terminal #        std     cpu_fio3,u*        lda     #$FF            tell IO_CPU mailbox full        ldx     fio_dsz,y       works for all DPR sizes        leax    -1,x* X will be used where U can't        addr    U,X            U + X > X        sta     0,x            cpu_fioF let the IO_CPU know it's there        LEDOFF  LB_FIO0        puls    cc,d,x,u,pc** FIFO_get - Fetch character from FIFO*   Y - FIO control block*   B - Character fetched*FIFOgeta pshs   b        bsr     FIFO_get        puls    a        exg     a,b        rts**   Y - FIO control block*-- Pointers in FIFO are relative to 0*FIFO_get pshs cc,a,x,u        seti                    -- interrupts must be masked        ldu     fio_dba,y       point to hardware        ldd     fifo_cnt,u      any data?        beq     99f             no - exit*        decd                    yes - adjust count        std     fifo_cnt,u        ldx     fifo_get,u      get consumer pointer        pshs    x        addr    U,X             U+X => X        ldb     fifo,x          fetch byte        puls    x        leax    1,x             bump pointer        cmpx    fio_fsz,y       end of fifo?        blo     10f*        ldx     #0              reset pointer*10      stx     fifo_get,u*99      puls    cc,a,x,u,pc** FIFO_put - Place character into FIFO*   Y - FIO control block*   B - Character fetched*FIFOputa pshs   b        tfr     a,b        bsr     FIFO_put        puls    b,pc**   Y - FIO control block*FIFO_put pshs   cc,a,x,u        seti                    -- interrups must be masked        ldu     fio_dba,y       point to hardware        ldx     fifo_put,u      get consumer pointer        pshs    x        addr    U,X             U + X => X        stb     fifo,x          store byte        puls    x        leax    1,x             bump pointer        cmpx    fio_fsz,y       end of fifo?        blo     10f        ldx     #0              reset pointer*10      stx     fifo_put,u        ldd     fifo_cnt,u        incd        std     fifo_cnt,u      update count*99      puls    cc,a,x,u,pc** find_slot - find a transaction slot*   Y - FIO control address*   jsr find_slot*   Y - Transaction slot*   <NE> if none available*find_slot pshs    d,y      save register          ldb     fio_mxtrn,y  MAX_TRAN          leay    fio_tran,y point to transactions          tstb          pshs    b          beq     40f* look for OUR slot first10        pshs    x          ldx     utask          ldd     tstid,x          puls    x          cmpd    tran_seq,y          beq     30f        yes - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     10b*          ldy     3,s        restore FIO pointer          ldb     fio_mxtrn,y  MAX_TRAN          leay    fio_tran,y point to transactions          stb     0,s          beq     40f* next search free slot20        ldd     tran_seq,y entry busy?          beq     30f        no - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     20b*40        lda     #1         return NE - no slot          bra     99f*30        sty     3,s        return slot          clra               return EQ - slot found*99        leas    1,s        remove counter          puls    d,y,pc     clean stack & return**  get_F_S - Allocate a transaction slot and the FIFO*    Y - FIO control*get_F_S   pshs    cc,d,x,y,u save registers          seti    mask       interrupts          jsr     find_slot  allocate transaction slot          beq     10f        jump if one found*          ldy     5,s        wait for slot          leay    fio_tflg,y          ldb     #FIOPRI          jsr     sleep          puls    cc,d,x,y,u restore registers          bra     get_F_S    try again*10        ldx     utask      "allocate" slot          ldd     tstid,x          std     tran_seq,y          puls    cc,d,x,y,u restore interrupts/registers          jmp     FIFO_lock  lock FIO access** MBX_lock - Lock the FIO interface*    Y - FIO Control address*MBX_lock  pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     fio_mbx,y  mailbox already locked?          beq     10f        no - go check FIFO*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     fio_fifo,y FIFO locked?          beq     50f        no - go lock mailbox*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        inc     fio_wait          ldb     #FIOPRI          pshs    y          preserve register          jsr     sleep    yes - sleep until available          puls    y          restore register          dec     fio_wait          puls    cc,d,x,y,u restore environ          bra     MBX_lock   try again*50        ldd     tstid,x    lock mailbox          std     fio_mbx,y          clr     fio_ict,y  no missed interrupts*99        puls    cc,d,x,y,u,pc return** MBX_unlock - unlock the FIO interface**    Y - FIO Control address*MBX_unlock pshs    cc,d,x,y,u          seti               turn off interrupts          lda     fio_ict,y  did we miss an interrupt?          beq     05f        no - continue*          jsr     fio_irq    yes - pretend we're seeing it now!*05        clr     fio_ict,y  reset flag          ldd     #0          std     fio_mbx,y  reset lock          jsr     wakeup     wake up anybody waiting on this FIO          ldy     5,s        restore pointer          lda     fio_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return** FIFO_lock - Lock the FIO FIFO buffer*    Y - FIO Control address*FIFO_lock pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     fio_fifo,y FIFO locked?          beq     10f        no - go check mailbox*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     fio_mbx,y  mailbox already locked?          beq     50f        no - go lock FIFO*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK20        ldb     #FIOPRI          inc     fio_wait   mark somebody waiting          pshs    y          save pointer          jsr     sleep    yes - sleep until available          puls    y          restore pointer          dec     fio_wait          puls    cc,d,x,y,u restore environ          bra     FIFO_lock  try again*50        ldd     tstid,x    lock FIFO          std     fio_fifo,y          ldu     fio_dba,y          ldd     #0          std     fifo_put,u reset pointers          std     fifo_get,u*99        puls    cc,d,x,y,u,pc return** FIFO_unlock - unlock the FIO FIFO buffer**    Y - FIO Control address*FIFO_unlock pshs    cc,d,x,y,u          seti               turn off interrupts          ldd     #0          std     fio_fifo,y reset lock          jsr     wakeup     wake up anybody waiting on this FIFO          ldy     5,s        restore pointer          lda     fio_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return          endif          end