          lib     environment.h          sttl    System     Call Processor          pag          name    syscal          global  syscl,syscP_TRC     equ     0** syscl** Process a system call.  This is called thru SWI3.*syscl     lda     upostb     get post byte          clr     uerror     clear error status          clr     uskerr     clear socket error          cmpa    #1         check for indirections          beq     sysnx      is it stack ind?          blo     sysnd      is it indirection?sysc      lbsr    gsysr      get sys args          bne     syscr      error?sysc6     bsr     dosys      do system call          tst     uinter     interrupted?          beq     sysc65          ldb     #EINTR     set error          stb     uerror          bra     sysc7      go reportsysc65    ldb     uerror     check error          beq     sysc8sysc7     clra    make       16 bit error          std     urglst+UD  return to caller in D          lda     urglst+UCC get his cc          ora     #CBIT      set error bit (carry)          sta     urglst+UCC save new cc* socket errors are passed in X register          cmpb    #ESOCK     IS it socket error          bne     sysc8          ldb     uskerr     get the posted error          stb     urglst+UA  pass in high bits!!*sysc8     lbsr    tstint     test for interrupt          beq     sysc9          lbsr    sdoint     process interruptsysc9     ldx     utask      get task table entry          lbsr    fixpri     adjust priority          stb     jobpri     set new job prioritysysc95    rts     return** syscr** Error in system call*syscr     ldb     #EBDCL     set error          stb     uerror     save error          bra     sysc7      go finish** sysnd, sysnx** Process system calls for indirection and for* stack type indirection.*sysnd     ldx     urglst+UPC get user pc          leau    2,x        bump past ind address          pshs    u          save pc          lbsr    gtuwrd     get the ind address          tfr     d,xsysnd2    leau    1,x        bump past post byte          stu     urglst+UPC save as pc for args          lbsr    gtubyt     get the function code          cmpb    #1         check for indirection          bls     sysnd4     if so, error          tfr     b,a          bsr     gsysr      get sys args          bne     sysnd4     error?          puls    d          get real pc          std     urglst+UPC          bra     sysc6      go do callsysnd4    puls    d          reset user pc          std     urglst+UPC          bra     syscr      report error*sysnx     ldd     urglst+UPC get user pc          pshs    d          save it          ldx     urglst+UX  get x register          bra     sysnd2          pag** dosys** This routine is called by syscl so that system* time interrupts may be detected.  This is* desirable, although it won't be explained here.*dosys     lda     #1         set the interrupt flag          sta     uinter          sts     umark1     save stack pointer location          if      P_TRC          pshs    d,x,y          ldx     #msg00          jsr     Pdata          lda     upostb          jsr     Phex          ldx     #msg01          jsr     Pdata          lda     4,s          jsr     Phex          lda     5,s          jsr     Phex          puls    d,x,y          endif          jsr     0,y        go do system call          clr     uinter     clear interrupt flag          rts     return     (no interrupt)          if      P_TRC*msg00     fcc     $d,'Syscall $',0msg01     fcc     ', at $',0          endif** gsysr** Get system call args.  Return 'ne' if error.*gsysr     cmpa    #MAXCAL    check range of post byte          bhi     gsysr8     if out of range, error          suba    #2         remove call bias          ldx     #osctab    point to table of calls          ldb     #3         3 is size of table entry          mul     find       table position          leax    d,x        point to requested call          ldy     0,x        get routine's address          ldb     2,x        get arg count          beq     gsysr6     no args?          pshs    b,y        save info          ldy     #usarg0    point to arg listgsysr4    ldx     urglst+UPC get arg pointer          leau    2,x        bump to next arg          stu     urglst+UPC save new pointer          lbsr    gtuwrd     get the arg          std     0,y++      save in arg list          dec     0,s        dec the arg count          bne     gsysr4          ldd     usarg0     get arg 0          std     ucname     save as file name          puls    b,y        reset infogsysr6    sez     set        ok statusgsysr8    rts     return          pag** osctab** This is the table of system calls.  Make sure* MAXCAL gets updated when adding new calls.*osctab          fdb     exec       2          fcb     2          fdb     fork       3          fcb     0          fdb     wait       4          fcb     0          fdb     term       5          fcb     0          fdb     break      6          fcb     1          fdb     stack      7          fcb     0          fdb     cpint      8          fcb     2          fdb     spint      9          fcb     1          fdb     open       10          fcb     2          fdb     create     11          fcb     2          fdb     read       12    read(buffer, count)          fcb     2          fdb     write      13    write(buffer, count)          fcb     2          fdb     seek       14    seek(offset32, whence)          fcb     3          fdb     close      15          fcb     0          fdb     dup        16          fcb     0          fdb     dups       17          fcb     0          fdb     link       18          fcb     2          fdb     unlink     19          fcb     1          fdb     crtsd      20          fcb     3          fdb     chdir      21          fcb     1          fdb     lock       22          fcb     1          fdb     chown      23          fcb     2          fdb     chprm      24          fcb     2          fdb     chkacc     25          fcb     2          fdb     defacc     26          fcb     1          fdb     ofstat     27          fcb     1          fdb     status     28          fcb     2          fdb     mount      29          fcb     3          fdb     unmnt      30          fcb     1          fdb     crpipe     31          fcb     0          fdb     gtid       32          fcb     0          fdb     guid       33          fcb     0          fdb     suid       34          fcb     0          fdb     setpr      35          fcb     0          fdb     cdata      36          fcb     1          fdb     profil     37          fcb     4          fdb     trap       38          fcb     1          fdb     time       39          fcb     1          fdb     stime      40          fcb     0          fdb     ttime      41          fcb     1          fdb     update     42          fcb     0          fdb     alarm      43          fcb     0          fdb     stop       44          fcb     0          fdb     ttyget     45          fcb     1                address of arguments ttybuf (6 bytes)          fdb     ttyset     46          fcb     1                address of arguments ttybuf          fdb     lrec       47          fcb     1          fdb     urec       48          fcb     0          fdb     systat     49          fcb     1          fdb     sacct      50          fcb     1          fdb     ttynum     51          fcb     0          fdb     filtim     52          fcb     1*          if      (NET=1)** socket interface*          fdb   skopen       53  socket(fam, type, proto)          fcb   3          fdb   skbind       54  bind(myaddr, addrelen)          fcb   2          fdb   sklist       55  listen(backlog)          fcb   1          fdb   skconn       56  connect(servaddr,addrlen)          fcb   2          fdb   skacpt       57  accept(servaddr, addrlen)          fcb   2          fdb   skrecv       58  recv(buff, len, servaddr, servaddrlen)          fcb   4          fdb   sksend       59  send(buff, len, servaddr, servaddrlen)          fcb   4          endif************************************************************* end of system call table************************************************************MAXCAL    equ     ((*-osctab)/3)+1   (max numerical call)