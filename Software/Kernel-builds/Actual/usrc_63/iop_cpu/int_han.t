          sttl    Interrupt  Processing          pag** This routine handles all IRQ interrupts**IRQ_han*-- Check for clock interrupt*          lda     #%10000000 get clock mask*          bita    CLOCK      check clock int*          beq     00f        no - try something else**          sta     CLOCKI     reset interrupt*          jsr     clkint     go process interrupt*          lbra    99f        exit*00        ldu     #dev_tab   scan devices          ldd     #0         start with device 0*10        ldx     dev_addr,u get device address          beq     20f        jump if none there*          ldy     dev_type,u get device type15        jsr     [D_inthan,y] call interrupt poller/handler          lbcs    99f        exit if interrupt serviced*20        addd    #1         next device          leau    DEV_SIZE,u          cmpd    #MAX_DEV   any more devices?          blo     10b** Check for FIO Mailbox interrupt*          ldu     fio_dsz          leau    -1,u       top location          lda     0,u        cpu_fioF   see if mailbox interrupt          beq     50f        no - move on*25        ldx     int_ptr    input message pointer          lda     cpu_fio    move REQUEST          sta     ,x+          ldd     cpu_fio1   sequence # TASK ID          std     ,x++          lda     cpu_fio2   specific DATA          sta     ,x+          ldd     cpu_fio3   device major/minor          std     ,x++** X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device*          clr     0,u       cpu_fioF   indicate message consumed*          stx     int_ptr    update pointer          ldy     #int_buf   get message from buffer          lda     0,y        -- Send interrupt command?          cmpa    #O_INTRPT          bne     30f*          sty     int_ptr    reset pointer          ldb     5,y        get terminal #          ldx     fifo_us0          cmpb    NUM_TRM,x  is this a TTY device?          bhs     99f        no - ignore message*          jsr     send_int          bra     99f        exit** normal command* acquire free task slot*30        ldx     tsktab     search for an available task          pshs    x          ldx     fifo_us0          ldb     NUM_TSK,x  Number of tasks in system          puls    x*32        lda     tsstat,x          cmpa    #TFREE     looking for a "free" task          beq     40f*          leax    TSKSIZ,x          decb          bne     32b*          ldb     #E_SYSBSY  can't process - IOP saturated!          jsr     fio_msg          bra     99f        exit** X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device*40        ldy     #int_buf   get message from buffer          sty     int_ptr    reset pointer          ldb     ,y+        command byte  REQUEST          stb     tscmd,x    save for task          ldd     ,y++       sequence #    task ID          std     tsseq,x          ldb     ,y+        command specific DATA          stb     tstval,x          ldd     ,y++       associate with terminal major/minor          std     tsdev,x** -- Removed 2/21/85** lda #RUNPRI make highest possible priority** sta tsprir,x          jsr     makrdy     make task ready to run** ldx utask don't switch if this was the system running** cmpx tsktab** beq 99f** jsr change -- whatever I was doing can wait...          bra     99f        exit*50        lbsr    DB_check   enter debugger?          bcc     99f*          lbsr    DB_main*99        rts                return from interrupt*IRQmsg10  fcc     $d,'IOP Got: ',000        fcc     '-- No tasks!',0