  0000                         absSWTPc Intelligent I/O Processor      13:32:10  Feb 27, 1985   Page    1Hardware Definitions                                                                          *                     * Various useful constants                     *                                          * Include Debug info                                    0001  DBG_SYS   equ    %0000000000000001 Debug system (scheduler, etc)               0002  DBG_8274  equ    %0000000000000010 Debug ACIA drivers               0004  DBG_INT   equ    %0000000000000100 Debug Interrupt routine               0008  DBG_TRMI  equ    %0000000000001000 Debug terminal interrupts               0010  DBG_IO    equ    %0000000000010000 Debug I/O Main routine               0020  DBG_HAN   equ    %0000000000100000 Debug terminal handler               0040  DBG_SLP   equ    %0000000001000000 Debug Sleep/Wakeup               0080  DBG_TASK  equ    %0000000010000000 Debug tasking               0100  DBG_CMD   equ    %0000000100000000 Debug I/O tasks               0200  DBG_MSG   equ    %0000001000000000 Debug high level messages               0400  DBG_INIT  equ    %0000010000000000 Print initialization messages               0800  DBG_OPEN  equ    %0000100000000000 Debug Open actions                     *               0D04  DEBUG     equ    %0000110100000100               0F3F  DEBUG_CONTROL set %0000111100111111               0000  DEBUG_CONTROL set %0000000000000000                                    0001  DO_HISTORY set   1         Include transaction history mechanism               0000  DO_IXON   set    0         Include Input XON/XOFF Handshaking                                          * Character Constants                                    0003  INTRC     equ    $03       DEL character               0004  EOTCH     equ    $04       EOT character               0008  BSPCH     equ    $08       back space character               0009  TABCH     equ    $09       tab character               000A  NL        equ    $0A       Line Feed               000D  CR        equ    $0D       Carriage Return               0010  DLE       equ    $10       Data Link Escape (DLE)               0013  XOFFC     equ    $13       XOFF character               0011  XONC      equ    $11       XON character               0018  CNCLC     equ    $18       line cancel char               001B  HOLDC     equ    $1B       ESC - suspend output               001C  QUITC     equ    $1C       FS character               0020  SPACE     equ    $20       space character                                          * Process Priorities                                    0046  RUNPRI    equ    70        Must run NOW               FFF6  TTYIPR    equ    -10       Waiting for terminal input               FFEC  TTYOPR    equ    -20       Waiting for terminal output - in ttywrt               FFE2  TTYSPR    equ    -30       Waiting for space in output Q - in req_write               FFDD  TTYLOCK   equ    -35       Waiting for access to TTY table               FFD8  TIQPRI    equ    -40       Waiting for a terminal interrupt to process               FFCE  FIOPRI    equ    -50       Waiting for the FIOSWTPc Intelligent I/O Processor      13:32:11  Feb 27, 1985   Page    2Hardware Definitions                                               FFC4  CLOCKPR   equ    -60       Waiting for a clock tick                                          * UniFLEX signals                                    0001  HANGS     equ    1         Device hangup               0002  INTS      equ    2         Program quit (Control-C)               0003  QUITS     equ    3         Program abort (Control-backslash)                                          * -- Configuration constants                                    000A  MAX_TI    equ    10        # Queued terminal interrupts               0020  MAX_TTY   equ    32        # terminal devices               0003  MAX_PPR   equ    3         # printer devices               0001  MAX_NEC   equ    1         # NEC printers               007C  MAX_CL    equ    124       upper limit on # CLISTS               0400  MAX_OB    equ    8*128     upper limit on output buffer size               0120  MIN_OB    equ    (2*128)+32 lower limit on output buffer size               0028  MAX_TSK   equ    40        52 upper limit on # of tasks               0024  MIN_TSK   equ    36        lower limit on # of tasks                     *               0025  MAX_DEV   equ    MAX_TTY+MAX_PPR+MAX_NEC+1 (Includes TOD clock)                     SWTPc Intelligent I/O Processor      13:32:12  Feb 27, 1985   Page    3Macro Definitions                                                                             *                     * This file contains all macro definitions                     * used in the system.                     *                                    0040  F         equ    $40       FIRQ Interrupt Mask               0010  I         equ    $10       IRQ Interrupt Mask                                          *                     * Set interrupt flags (I and F)                     *                                          seti      macro                               orcc   #F|I                               endm                                                               *                     * Clear interrupt flags (I and F)                     *                                          clri      macro                               andcc  #!(F|I)                               endmSWTPc Intelligent I/O Processor      13:32:12  Feb 27, 1985   Page    4Device Table Structure                                                                        *                     * Possible module types table                     *  0000                         org    $0  0000               mod_type  rmb    2         device control table address  0002               mod_name  rmb    2         pointer to module name                     *  0004               MOD_SIZE  rmb    0                                                               *                     * Device table structure                     *  0000                         org    0  0000               dev_addr  rmb    2         Device base address  0002               dev_type  rmb    2         Device type table                     *  0004               DEV_SIZE  rmb    0         Size of device entry                                          *                     * Control structure for a device                     *  0000                         org    $0000  0000                         rmb    2  0002               D_OPEN    rmb    2  0004               D_CLOSE   rmb    2  0006               D_TTYS    rmb    2  0008               D_TTYG    rmb    2  000A               D_RQWR    rmb    2  000C               D_WRITE   rmb    2  000E               D_WRC     rmb    2  0010               D_RQRD    rmb    2  0012               D_SEND    rmb    2  0014               D_INTRPT  rmb    2  0016                         rmb    2  0018                         rmb    2  001A                         rmb    2  001C                         rmb    2  001E               D_CLOCK   rmb    2  0020               D_inthan  rmb    2         Interrupt poller/handler  0022               D_init    rmb    2         Device initialization  0024               D_test    rmb    2         Test for device present                     *  0026               D_END     rmb    0         End of common handlers                                          *                     * TTY Specific device routines                     *  0026                         org    D_END  0026               D_ttconf  rmb    2  0028               D_ttputc  rmb    2SWTPc Intelligent I/O Processor      13:32:12  Feb 27, 1985   Page    5Device Table Structure                                002A               D_ttgetc  rmb    2  002C               D_ttenxr  rmb    2  002E               D_ttdisx  rmb    2  0030               D_ttenr   rmb    2  0032               D_ttenx   rmb    2  0034               D_ttenno  rmb    2  0036               D_ttxbsy  rmb    2  0038               D_tttstx  rmb    2  003A               D_ttiscts rmb    2  003C               D_tttstr  rmb    2  003E               D_tttstb  rmb    2  0040               D_tttsts  rmb    2  0042               D_tttstc  rmb    2  0044               D_tttstd  rmb    2  0046               D_tttste  rmb    2  0048               D_ttend   rmb    2  004A               D_ttwcts  rmb    2  004C               D_ttwdcd  rmb    2SWTPc Intelligent I/O Processor      13:32:13  Feb 27, 1985   Page    6History Queue Record Structure                                             0000                         org    0  0000               hst_cmd   rmb    1         Command  0001               hst_seq   rmb    1         Sequence #  0002               hst_tty   rmb    1         TTY #  0003               hst_val   rmb    1         Message dependent data                     *  0004               HRECSIZ   rmb    0                                          *                     * Number of history records supported                     *               0010  MAXHIST   equ    16SWTPc Intelligent I/O Processor      13:32:13  Feb 27, 1985   Page    7IOP Memory Layout                                                        *                     * Basic Memory Layout                     *               0100  RAMorg    equ    $0100     16K of RAM - Thru $3FFF               3FFF  RAMend    equ    $3FFF               8C00  RAMscratch equ   $8C00     1K of scratchpad RAM               8F00  RAMscrend equ    $8F00               8FFF  ROMstack  equ    $8FFF     High end of ROM Stack               D000  ROMLOorg  equ    $D000     4K of ROM - Thru $DFFF               F000  ROMHIorg  equ    $F000     4K of ROM - Thru $FFFF               B000  DEBUGROM  equ    $B000     4K of Debug ROM $B000-$BFFF               FFF0  CPUtraps  equ    $FFF0     CPU Trap Vectors                                    8080  SYS_ACIA  equ    $8080               8000  SYS_8274  equ    $8000               80C0  CLOCK     equ    $80C0     6840 Timer               0008  NUM_SLOTS equ    8         Number of Physical I/O slots               8000  BASE_SLOT equ    $8000     Base address for I/O slots               0010  NEXT_SLOT equ    $0010     Offest between slots               8090  PIA_SLOT  equ    $8090     On PPI PIA               80A0  TOD_ADDR  equ    $80A0     Byte address for Time of Day               80B0  TOD_DATA  equ    $80B0     Data access to Time of Day Clock               000E  TOD_SIZE  equ    14        Number of bytes in TOD register spaceSWTPc Intelligent I/O Processor      13:32:14  Feb 27, 1985   Page    8Clist Structure                                                                               *                     * Clist Structure                     *                     * The clist structure is the head of a linked list of                     * characters used for i/o.  A head and tail pointer                     * are kept, as well as a character count of active                     * characters on the queue.                     *                                          * struct clist                       0000                         org    0                       0000               clcnt     rmb    1         character count  0001               clfst     rmb    2         head character pointer  0003               cllst     rmb    2         tail character pointer                     *               0005  QH_SIZE   equ    *         Size of Queue Header                                                               *                     * Clist Buffer                     *                     * The characters for i/o are placed in buffers as                     * needed.  Each buffer contains 32 bytes, the first                     * two contain a chain pointer, the next 30 hold                     * the actual characters.                     *                       0000                         org    0                                    0020  CBSIZE    equ    32  0000               cbstrt    rmb    2  0002               cbchrs    rmb    CBSIZE-2                                          * Input Queue limits                                    0100  PRCSIZ    equ    256       Max size of terminal input line               00FF  CHRLIM    equ    PRCSIZ-1  Input Queue max size               00F5  XOF_POINT equ    CHRLIM-10 XOFF send after this many charsSWTPc Intelligent I/O Processor      13:32:14  Feb 27, 1985   Page    9Output Queue Structure                                                                        *                     * This is the definition of the output queue used                     * to buffer characters going to a terminal.  It is                     * different from the "clist" mechanism for efficiency                     * concerns.                     *                       0000                         org    0  0000               oq_count  rmb    2         Number of characters in Q  0002               oq_buf    rmb    2         Start of Q buffer  0004               oq_put    rmb    2         Address of next character to insert  0006               oq_get    rmb    2         Address of next character to consume  0008               oq_end    rmb    2         Limiting address of Q                     *  000A               OQH_SIZE  rmb    0         Size of output Queue headerTask Structure                       13:32:15  Feb 27, 1985   Page   10Output Queue Structure                                                   *                     * Task Table                     *                       0000                         org    0                                          * struct task                                    0064  USTSIZ    equ    100       User Stack Size (big enough??)  0000               tslink    rmb    2         list link of running tasks  0002               tsslnk    rmb    2         list link of sleeping tasks  0004               tsstat    rmb    1         * see below *  0005               tsprir    rmb    1         priority - negative is low  0006               tsevnt    rmb    2         event task is waiting on  0008               tsdev     rmb    1         Terminal task is servicing  0009               tssgnl    rmb    1         Signal waiting for task  000A               tscmd     rmb    1         Saved mailbox command  000B               tsseq     rmb    2         Saved message sequence #  000D               tstval    rmb    1         Saved transaction value  000E               usp       rmb    2         Saved User Stack Pointer  0010               umark0    rmb    2         Stack Frame Markers  0012               umark1    rmb    2  0014                         rmb    USTSIZ    space for per/process stack                                    0078  TSKSIZ    equ    *         task structure size                     * stat codes                                    0001  TRUN      equ    1         running               0002  TSLEEP    equ    2         sleep with high priority               0003  TWAIT     equ    3         sleep with low priority               0004  TFREE     equ    4         task is free (uncommitted)               0005  TSYS      equ    5         system taskTask Structure                       13:32:15  Feb 27, 1985   Page   11TTY Structure                                                                                 *                     * TTY Structure                     *                     * A tty structure is required for each character type                     * i/o device used for standard terminal i/o.                     *                                          * struct tty                       0000                         org    0                       0000               tqin      rmb    2         pointer to in q clist str  0002               tqproc    rmb    2         pointer to proccessed q clist str  0004               tqout     rmb    2         pointer to out q clist str  0006               taddr     rmb    2         device address  0008               tflags    rmb    1         mode flags  0009               tdelay    rmb    1         time out definitions  000A               tdevic    rmb    1         device name  000B               tdel      rmb    1         raw delimiter count  000C               tcolm     rmb    1         printing column  000D               tbksp     rmb    1         back space character  000E               tcncl     rmb    1         line cancel character  000F               tbaud     rmb    1         device baud rates  0010               tbaud2    rmb    1         actual baud rate (for baud rate generator)  0011               tstate    rmb    1         internal state  0012               tstate2   rmb    1         additional states  0013               tstate3   rmb    1         states of CTS,DCD  0014               tlock     rmb    1         structure lock  0015               tsold     rmb    2         amount of output queue already "sold"  0017               tregs     rmb    8         copy of device registers (for 8274)                                    001F  TTYSIZ    equ    *                                                               * modes                                    0001  RAW       equ    %00000001 raw or cooked mode               0002  ECHO      equ    %00000010 echo characters               0004  XTABS     equ    %00000100 expand tabs               0008  LCASE     equ    %00001000 map to lower case               0010  CRMOD     equ    %00010000 map NL to CR & LF               0020  BSECH     equ    %00100000 backspace echo flag               0040  SCHR      equ    %01000000 single character input               0080  CNTRL     equ    %10000000 ignore control characters                                          * internal states                                    0001  TIMOUT    equ    %00000001 timeout in progress               0002  HOLD      equ    %00000010 output suspended               0004  TOPEN     equ    %00000100 terminal has been opened               0008  TRANSPNT  equ    %00001000 Transparent modeTask Structure                       13:32:16  Feb 27, 1985   Page   12TTY Structure                                                      0010  IXONXOF   equ    %00010000 Use XON/XOFF to control input               0010  TOPWOC    equ    %00010000 Device opened without carrier present               0020  XANY      equ    %00100000 Allow any character to break HOLD               0040  XONXOF    equ    %01000000 XON/XOFF protocol               0080  ESCOFF    equ    %10000000 Disable ESC as HOLD character                     *               00F8  PROTOCOL  equ    ESCOFF|XANY|XONXOF|IXONXOF|TRANSPNT                                    0001  DSR_OK    equ    %00000001 OK to send               0002  SEND_XON  equ    %00000010 Send XON next               0004  SEND_XOF  equ    %00000100 Send XOFF next               0008  SEND_DLE  equ    %00001000 Send DLE next               0010  XOF_SENT  equ    %00010000 We shut the other guy down               0020  DLE_SENT  equ    %00100000 DLE sequence started               0040  DLE_GOT   equ    %01000000 DLE sequence receivedTask Structure                       13:32:16  Feb 27, 1985   Page   13Parallel Printer Control Structure                                                            *                     * Parallel Printer Device Structure                     *                                    018A  PPBUFSIZ  equ    (3*128)+10 Queue Buffer Size               0105  PPLOC     equ    PPBUFSIZ-FIFO_SIZE-5 low water mark               0189  PPHI      equ    PPBUFSIZ-1               002E  PPCOND    equ    $2e       disable interrupts               002F  PPCONE    equ    $2f       enable interrupts                       0000                         org    0  0000               ppopen    rmb    1         device open flag  0001               ppadr     rmb    2         PIA base address (B Side)  0003               ppcnt     rmb    2         character counter  0005               ppbusy    rmb    1         busy flag (kludge!)  0006               ppipt     rmb    2         input q pointer  0008               ppopt     rmb    2         output q pointer  000A               ppbuf     rmb    PPBUFSIZ  print buffer               0194  ppbnd     equ    *         buffer end                     *               0194  PPSIZ     equ    *Task Structure                       13:32:17  Feb 27, 1985   Page   14NEC Printer Tables                                                                            *                     *   character equates used by drivers                     *               0008  bs        equ    $08       necdbs character               000A  nl        equ    $0A       new line character               000C  vt        equ    $0C       vertical tab character               000D  cr        equ    $0D       carriage necrtn character               0012  xo        equ    $12       punch on character               0020  sp        equ    $20       necspc character                                          * -- Flag values                                    0001  rawnec    equ    %00000001 1 => Raw Mode I/O selected               0010  necnlo    equ    %00010000 1 => Treat CR as new line               0020  neclof    equ    %00100000 1 => issue new line on line overflow               0040  necnop    equ    %01000000 1 => device is already open               0080  necioe    equ    %10000000 1 => permanent I/O error                       0000                         org    0  0000               necinq    rmb    OQH_SIZE  Input queue header  000A               necarg0   rmb    2         TTYSET - Input arguments  000C               necarg1   rmb    2  000E               necarg2   rmb    2  0010               necpos    rmb    2         fdb     0                   requested character position  0012               necold    rmb    2         fdb     0                   previous character position  0014               carage    rmb    2         fdb     0                   current carage position  0016               necfps    rmb    2         fdb     0                   requested form position  0018               nectrc    rmb    2         fdb     0                   current nectrc position  001A               necssp    rmb    2         fdb     necqbf             necstb stuff pointer  001C               necsfp    rmb    2         fdb     necqbf             necstb fetch pointer  001E               necsnd    rmb    2         fdb     necqbf+NECBSIZ  0020               necsct    rmb    1         fcb     0                  in-buffer necstb count  0021               necbsy    rmb    1         fcb     0                                          *                     *   tty information table                     *  0022               necflg    rmb    0  0022               necU      rmb    1         fcb     %00110000           control flag byte                       0023               neclef    rmb    1         fcb     6                   left margin, in 12'ths of an inch  0024               necpch    rmb    1         fcb     10                  pitch designation, in chars/inch  0025               necdep    rmb    1         fcb     6                   depth designation, in lines/inch  0026               necfrm    rmb    1         fcb     132                 form length, in 12'ths of an inch  0027               necwid    rmb    1         fcb     168                 form width, in 12'ths of an inch                     *                     *   driver variables and other stuff                     *  0028               pitch     rmb    1         fcb     12                  character pitch value  0029               depth     rmb    1         fcb     8                   line depth value  002A               margin    rmb    2         fdb     48                  left margin offsetTask Structure                       13:32:18  Feb 27, 1985   Page   15NEC Printer Tables                                    002C               frmlen    rmb    2         fdb     528                 length of standard form  002E               normal    rmb    2         fdb     0                   form normalization constant  0030               rtlimt    rmb    2         fdb     1686                maximum carriage position                     *               0100  NECBSIZ   equ    256       size of strobe buffer, in bytes  0032               necqbf    rmb    NECBSIZ   output strobe buffer  0132               necqnd    rmb    0         end of buffer                     *  0132               NEC_SIZ   rmb    0         -- Size of NEC control structure                     *                     *   necadr descriptions and equates                     *                                    0000  d_lsp     equ    0         lsp data register offset               0001  d_msp     equ    1         msp data register offset               0002  cr_a      equ    2         A-side control register offset               0003  cr_b      equ    3         B-side control register offset                                    0040  s_tof     equ    %01000000 top of form necstb               0060  s_rpf     equ    %01100000 right paper feed necstb               0080  s_pfd     equ    %10000000 paper feed necstb               00A0  s_car     equ    %10100000 carage motion necstb               00C0  s_chr     equ    %11000000 character necstb               00E0  s_rst     equ    %11100000 restore necstb                                    0008  back      equ    %00001000 down or left necstb modifier                     *                     *   necadr initialization equates                     *               0036  c_acr     equ    %00110110 basic A-side register values               0008  c_lift    equ    %00001000 ribbon lift modifier                                    003E  c_bcr     equ    %00111110 basic B-side register values               0001  c_irq     equ    %00000001 irq enable modifier               0004  c_ddr     equ    %00000100 direction register select               0008  c_stb     equ    %00001000 Strobe line outputTask Structure                       13:32:18  Feb 27, 1985   Page   16Variable Space                                                             0100                         org    RAMorg                       0100               sys_vars  rmb    0         -- start of system variables                                          * Configuration "constants"  0100               NUM_CL    rmb    1         Number of Clists  0101               NUM_TRM   rmb    1         Number of terminal devices  0102               NUM_NEC   rmb    1         Number of NEC devices  0103               NUM_PPR   rmb    1         Number of parallel printer devices  0104               NUM_TSK   rmb    1         Number of tasks  0105               OBUF_SIZE rmb    2         Size of TTY Output Queues  0107               OQHI      rmb    2         Output Queue High-water mark  0109               OQLO      rmb    2         Output Queue Low-water mark  010B               slot_tbl  rmb    2*NUM_SLOTS slot configuration                       011B               DB_iflg   rmb    1         Debug terminal initialized  011C               DB_cntrl  rmb    2         Debug control flags                     *  011E               runlst    rmb    2         Pointer to active tasks  0120               slplst    rmb    4         Pointer to waiting tasks  0124               utask     rmb    2         Currently executing task  0126               jobpri    rmb    1         Current job priority (for scheduling)  0127               chproc    rmb    1         Set if must switch users of CPU (reschedule)  0128               cfreel    rmb    2         Pointer to first free Clist buffer  012A               cbufct    rmb    1         Count of Clist buffers in use  012B               lcbuf     rmb    1         Limit on Clist buffers  012C               idle      rmb    1         idle loop flag for scheduler  012D               TI_Q      rmb    2*MAX_TI  Max Terminal Interrupts  0141               TI_Q_ptr  rmb    2         current Q pointer  0143               FIO_lock  rmb    1         FIO in use lock  0144               int_buf   rmb    4         Current Message in  0148               int_ptr   rmb    2         Message in pointer  014A               clock_tick rmb   1         Clock tick counter  014B               prcbuf    rmb    PRCSIZ    buffer for erase and kill  024B               hstbuf    rmb    HRECSIZ*MAXHIST  028B               hstptr    rmb    2         next "put" pointer in history queue                     * Pointers to system tables - configuration dependent  028D               CLISTS    rmb    2         Space for Clists  028F               TTYTABS   rmb    2         Terminal tables  0291               TTYQS     rmb    2         TTY Input Queue Headers  0293               OBUFRS    rmb    2         TTY Output Queues  0295               tsktab    rmb    2         Task Control Tables  0297               tskend    rmb    2         End of task table  0299               PPstr     rmb    2         Pointer to parallel device tables  029B               NECstr    rmb    2         Pointer to NEC device tables  029D               dev_tab   rmb    DEV_SIZE*MAX_DEV system configuration table  0331               NEC_IQ    rmb    2         Pointer to NEC input queue  0333               NECADR    rmb    2         Address of NEC printer                     *  0335               SYS_TABS  rmb    0         Start of dynamic system tables                     Task Structure                       13:32:19  Feb 27, 1985   Page   17Variable Space                                                     3FFF  end_vars  equ    RAMend    End of System Variables                     Task Structure                       13:32:19  Feb 27, 1985   Page   18Variable Space                                                           *                     * ACIA Structure                     *                                          * struct acia                       0000                         org    0                       0000               csr       rmb    1         control - status  0001               dbuf      rmb    1         data buffer                                          * status codes                                    0001  ACRBSY    equ    %00000001 receive busy               0002  ACTBSY    equ    %00000010 transmit busy               0000  DSBXIN    equ    %00000000 disable transmit int               0020  ENBXIN    equ    %00100000 enable transmit int               0080  ENBRIN    equ    %10000000 enable read interupt               0014  AWORD     equ    %00010100 ACIA word setup               0001  ADIVID    equ    %00000001 clock divide rateTask Structure                       13:32:19  Feb 27, 1985   Page   19FIO Simulation Structure                                                                      *                     * Control structure used to simulate Z8038 FIO                     *                                    0080  FIFO_SIZE equ    128       Size of FIFO buffer                       0000                         org    $0000     -- Shared Dual Port RAM  0000               irq_gen   rmb    1         IRQ generator cell  0001               iop_cpu   rmb    1         IOP -> CPU Mailbox cell  0002               iop_cpu1  rmb    1         -- Additional cell  0003               iop_cpu2  rmb    1         --  0004               iop_cpu3  rmb    1         --  0005               iop_cpuF  rmb    1         Non-zero when mailbox has data  0006               cpu_iop   rmb    1         CPU -> IOP Mailbox cell  0007               cpu_iop1  rmb    1         -- Additional cell  0008               cpu_iop2  rmb    1         --  0009               cpu_iop3  rmb    1         --  000A               cpu_iopF  rmb    1         Non-zero when mailbox has data  000B               fifo_cnt  rmb    1         Count of data in FIFO  000C               fifo_get  rmb    2         FIFO consumer pointer  000E               fifo_put  rmb    2         FIFO producre pointer  0010                         rmb    16-*      ** Filler **  0010               fifo      rmb    FIFO_SIZE actual FIFO                     *                     * IOP ROM Version #                     *               0014  ROM_VERSION equ  $14       Major/Minor Version of IOP ROM                                          *                     * Error codes                     *               0080  REJECT    equ    %10000000 Error/Reject bit in command response               0081  E_BADCMD  equ    REJECT+$01 Illegal command               0082  E_SYSBSY  equ    REJECT+$02 IOP saturated               0083  E_NTOPEN  equ    REJECT+$03 Selected device not open               0084  E_BADDEV  equ    REJECT+$04 Illegal device # (=3)               0085  E_DEVBSY  equ    REJECT+$05 Device is already open (exclusive)               0086  E_IOERR   equ    REJECT+$06 Some sort of I/O error               00BE  E_INTRPT  equ    REJECT+$3E Terminal interrupt (send by IOP to UniFLEX)               00BF  E_ABORT   equ    REJECT+$3F Transaction aborted by UniFLEX (not sent by IOP)                                          *                     * Normal responses                     *               0001  R_RESET   equ    $01       System reset & functioning               0002  R_OPEN    equ    $02       Device open successful               0003  R_CLOSE   equ    $03       Device close successful               0004  R_REQOK   equ    $04       Write request now granted               0005  R_WRITE   equ    $05       Write data complete               0006  R_TTY     equ    $06       TTYSET/GET complete               0007  R_RDOK    equ    $07       Read data now availableTask Structure                       13:32:20  Feb 27, 1985   Page   20FIO Simulation Structure                                           0008  R_SNDNC   equ    $08       Read data in FIFO & no more data is available               0009  R_RD1C    equ    $09       Single character available               000A  R_INTRPT  equ    $0A       Interrupt complete               000B  R_SNDMC   equ    $0B       Read data in FIFO & there is more available               000C  R_CLOCK   equ    $0C       Interval timer tick                                          *                     * Request codes (from Main CPU)                     *               0010  O_OPEN    equ    $10       Open device               0020  O_CLOSE   equ    $20       Close device               0030  O_TTYS    equ    $30       TTY Set               0040  O_TTYG    equ    $40       TTY Get               0050  O_RQWR    equ    $50       Request write               0060  O_WRITE   equ    $60       Write data               0070  O_WRC     equ    $70       Write single character               0080  O_RQRD    equ    $80       Request read data               0090  O_SEND    equ    $90       Send data for read               00A0  O_INTRPT  equ    $A0       Interrupt all tasks on a terminal               00F0  O_CLOCK   equ    $F0       Start interval timer                     Task Structure                       13:32:21  Feb 27, 1985   Page   21CPU Vectors                                                                FFF0                         org    CPUtraps  FFF0 0000                    fdb    0         Unused  FFF2 D09E                    fdb    rom_swi3  SWI3  FFF4 D097                    fdb    rom_swi2  SWI2  FFF6 D08A                    fdb    rom_firq  FIRQ  FFF8 D4FC                    fdb    IRQ_han   IRQ  FFFA D091                    fdb    rom_swi   SWI  FFFC D084                    fdb    rom_nmi   NMI  FFFE D05A                    fdb    rom_init  Reset                     Task Structure                       13:32:21  Feb 27, 1985   Page   22System RESET Code                                                          D000                         org    ROMLOorg                       D000 0D 49 4F 50   DBmsg00   fcc    $d,'IOP ROM',0  D009 0D 53 79 73   DBmsg01   fcc    $d,'System Initialization Complete',0  D029 0D 43 50 55   DBmsg02   fcc    $d,'CPU RESET Complete',0  D03D 0D 0D 53 79   CPU_down  fcc    $d,$d,'System CPU not functioning',0                                          *                     * System RESET code                     *  D05A 10CE 8FFF     rom_init  lds    #ROMstack initialize stack pointer  D05E 8E   0100               ldx    #sys_vars clear all of RAM  D061 CC   0000               ldd    #0  D064 ED   81       10        std    ,x++  D066 8C   3FFF               cmpx   #end_vars  D069 25   F9                 blo    10b >D06B 17   0051     20        lbsr   stbinit   go initialize system memory  D06E 10FE 0295     30        lds    tsktab    Task 0 Stack  D072 32   E8 78              leas   TSKSIZ,s  D075 17   0311               lbsr   fio_reset                                          *                     * Initialization complete - Start executing commands                     *  D078               fio_start  D078 C6   14                 ldb    #ROM_VERSION  D07A D7   02                 stb    iop_cpu1  D07C C6   01                 ldb    #R_RESET  send "system reset & running" message  D07E 17   033D               lbsr   fio_msg  D081 7E   F05A     10        jmp    rsched                     Task Structure                       13:32:21  Feb 27, 1985   Page   23ROM Interrupt Fielders                                                     D084 8D   1F       rom_nmi   bsr    rom_int  D086 4E 4D 49 00             fcc    'NMI',0  D08A 8D   19       rom_firq  bsr    rom_int  D08C 46 49 52 51             fcc    'FIRQ',0  D091 8D   12       rom_swi   bsr    rom_int  D093 53 57 49 00             fcc    'SWI',0  D097 8D   0C       rom_swi2  bsr    rom_int  D099 53 57 49 32             fcc    'SWI2',0  D09E 8D   05       rom_swi3  bsr    rom_int  D0A0 53 57 49 33             fcc    'SWI3',0                       D0A5 8E   D0B2     rom_int   ldx    #ROM_ERR  D0A8 BD   FD65               jsr    DB_pdata  D0AB 35   10                 puls   x  D0AD BD   FD65               jsr    DB_pdata  D0B0 20   FE       rom_bad   bra    *                     *  D0B2 0D 52 4F 4D   ROM_ERR   fcc    $d,'ROM Error: ',0Task Structure                       13:32:22  Feb 27, 1985   Page   24Table Initialization                                                                          *                     * stbinit - Initialize System Memory Tables                     *  D0BF 8E   0100     stbinit   ldx    #sys_vars clear all variables  D0C2 CC   0000               ldd    #0  D0C5 ED   81       10        std    ,x++  D0C7 8C   3FFF               cmpx   #end_vars done yet?  D0CA 25   F9                 blo    10b  D0CC CC   0D04               ldd    #DEBUG  D0CF FD   011C               std    DB_cntrl >D0D2 17   001F               lbsr   set_tables go figure out configuration, tables, etc                     * Initialize history queue  D0D5 8E   024B               ldx    #hstbuf  D0D8 BF   028B               stx    hstptr                     * Initialize Terminal Interrupt Queue  D0DB 8E   012D     15        ldx    #TI_Q     set queue empty  D0DE BF   0141               stx    TI_Q_ptr  D0E1 8E   0144               ldx    #int_buf  reset message in pointer  D0E4 BF   0148               stx    int_ptr  D0E7 17   01AC               lbsr   clinit    initialize Clists  D0EA 17   01CD     16        lbsr   ttyinit   initialize TTY tables  D0ED 17   021A     17        lbsr   tskinit   initialize tasks  D0F0 17   2C90     18        lbsr   DB_config display configuration  D0F3 39                      rts                                          *                     * Set up system tables                     *  D0F4               set_tables                     * -- Force in the on-board PIA  D0F4 CC   8090     09        ldd    #PIA_SLOT  D0F7 AD   9F D66F            jsr    [D_test+DEV_L2]                     * -- Force in the TOD interface  D0FB 108E 032D               ldy    #dev_tab+((MAX_DEV-1)*DEV_SIZE)  D0FF 8E   F000               ldx    #DEV_TOD  D102 AF   22                 stx    dev_type,y                     * Compute configuration  D104 86   08                 lda    #NUM_SLOTS  D106 34   02                 pshs   a  D108 CC   8000               ldd    #BASE_SLOT set port address  D10B 8E   010B               ldx    #slot_tbl  D10E 34   10                 pshs   x  D110 CE   D281     10        ldu    #no_dev  D113 EF   84                 stu    0,x  D115 CE   D35C               ldu    #mod_tbl  D118 AE   C4       12        ldx    mod_type,u  D11A 27   0D                 beq    20f       jump if end of module table  D11C AD   98 24              jsr    [D_test,x] check for device  D11F 25   04                 bcs    15f       jump if found  D121 33   44                 leau   MOD_SIZE,u  D123 20   F3                 bra    12bTask Structure                       13:32:23  Feb 27, 1985   Page   25Table Initialization                                  D125 AE   42       15        ldx    mod_name,u  D127 AF   F4                 stx    [0,s]  D129 C3   0010     20        addd   #NEXT_SLOT advance address  D12C AE   E4                 ldx    0,s       update slot table pointer  D12E 30   02                 leax   2,x  D130 AF   E4                 stx    0,s  D132 6A   62                 dec    2,s       any more slots  D134 26   DA                 bne    10b  D136 35   12                 puls   a,x                     * -- All done setting up configuration                     * Set up constants based on configuration  D138 86   7C       22        lda    #MAX_CL  D13A B7   0100               sta    NUM_CL                     *  D13D 86   28                 lda    #MAX_TSK  D13F B7   0104               sta    NUM_TSK                     *  D142 CC   0400               ldd    #MAX_OB  D145 FD   0105               std    OBUF_SIZE                     * Now figure out where system tables go, based on configuration  D148 FC   0105     30        ldd    OBUF_SIZE  D14B 83   000A               subd   #10  D14E FD   0107               std    OQHI  D151 83   0085               subd   #(FIFO_SIZE+5)  D154 FD   0109               std    OQLO  D157 CC   0335               ldd    #SYS_TABS start of system tables                     * -- Round up to CBSIZE boundary  D15A C3   001F               addd   #CBSIZE-1  D15D C4   E0                 andb   #!(CBSIZE-1)  D15F 1F   03                 tfr    d,u                     * -- CLISTS  D161 86   20                 lda    #CBSIZE  D163 F6   0100               ldb    NUM_CL  D166 3D                      mul  D167 FF   028D               stu    CLISTS  D16A 17   011B               lbsr   sto_chk   check for system table space overflow  D16D 1025 0088               lbcs   40f       jump if it happens                     * -- TTY Control tables  D171 86   1F                 lda    #TTYSIZ  D173 F6   0101               ldb    NUM_TRM  D176 3D                      mul  D177 FF   028F               stu    TTYTABS   point to tty table  D17A 17   010B               lbsr   sto_chk   check for system table space overflow  D17D 25   7A                 bcs    40f       jump if it happens                     * -- TTY Queue headers  D17F 86   0A                 lda    #2*QH_SIZE  D181 F6   0101               ldb    NUM_TRM  D184 3D                      mul  D185 FF   0291               stu    TTYQS  D188 17   00FD               lbsr   sto_chk   check for system table space overflow  D18B 25   6C                 bcs    40f       jump if it happens  D18D 86   0A                 lda    #OQH_SIZETask Structure                       13:32:23  Feb 27, 1985   Page   26Table Initialization                                  D18F F6   0101               ldb    NUM_TRM  D192 3D                      mul  D193 17   00F2               lbsr   sto_chk   check for system table space overflow  D196 25   61                 bcs    40f       jump if it happens                     * -- TTY Output Queues  D198 4F                      clra  D199 F6   0101               ldb    NUM_TRM  D19C 1F   01                 tfr    d,x  D19E CC   0000               ldd    #0  D1A1 F3   0105     10        addd   OBUF_SIZE  D1A4 30   1F                 leax   -1,x  D1A6 26   F9                 bne    10b  D1A8 FF   0293               stu    OBUFRS  D1AB 17   00DA               lbsr   sto_chk   check for system table space overflow  D1AE 25   49                 bcs    40f       jump if it happens                     * -- Task table  D1B0 86   78                 lda    #TSKSIZ  D1B2 F6   0104               ldb    NUM_TSK  D1B5 3D                      mul  D1B6 FF   0295               stu    tsktab  D1B9 17   00CC               lbsr   sto_chk   check for system table space overflow  D1BC 25   3B                 bcs    40f       jump if it happens  D1BE FF   0297               stu    tskend                     * -- Allocate space for printers  D1C1 F6   0103               ldb    NUM_PPR  D1C4 27   16                 beq    34f  D1C6 34   04                 pshs   b  D1C8 CC   0000               ldd    #0  D1CB C3   0194     32        addd   #PPSIZ  D1CE 6A   E4                 dec    0,s  D1D0 26   F9                 bne    32b  D1D2 32   61                 leas   1,s       clean up stack  D1D4 FF   0299               stu    PPstr  D1D7 17   00AE               lbsr   sto_chk   check for system table space overflow  D1DA 25   1D                 bcs    40f       jump if so                     * -- NEC tables  D1DC F6   0102     34        ldb    NUM_NEC  D1DF 27   6F                 beq    60f       jump if not there  D1E1 CC   0132               ldd    #NEC_SIZ  D1E4 FF   029B               stu    NECstr    NEC control structure  D1E7 17   009E               lbsr   sto_chk   check for system table space overflow  D1EA 25   0D                 bcs    40f       jump if so  D1EC FF   0331               stu    NEC_IQ    NEC input queue  D1EF FC   0105               ldd    OBUF_SIZE  D1F2 17   0093               lbsr   sto_chk   check for system table space overflow  D1F5 25   02                 bcs    40f       jump if so  D1F7 20   57                 bra    60f                     * -- System table space has overflowed!                     * -- Try adjusting some parameters to get it under control  D1F9 FC   0105     40        ldd    OBUF_SIZE first step, reduce output buffer size  D1FC 83   0020               subd   #32  D1FF FD   0105               std    OBUF_SIZETask Structure                       13:32:24  Feb 27, 1985   Page   27Table Initialization                                  D202 1083 0120               cmpd   #MIN_OB  D206 2C   45                 bge    50f       jump if still something left  D208 CC   0400               ldd    #MAX_OB   start over & try something else  D20B FD   0105               std    OBUF_SIZE  D20E B6   0104               lda    NUM_TSK   try reducing # tasks  D211 80   01                 suba   #1  D213 B7   0104               sta    NUM_TSK  D216 F6   0101               ldb    NUM_TRM  D219 FB   0103               addb   NUM_PPR  D21C FB   0102               addb   NUM_NEC  D21F CB   03                 addb   #3  D221 34   04                 pshs   b  D223 A1   E0                 cmpa   ,s+  D225 2C   26                 bge    50f  D227 86   28                 lda    #MAX_TSK  D229 B7   0104               sta    NUM_TSK  D22C B6   0100               lda    NUM_CL    crank back on # clists  D22F 80   01                 suba   #1  D231 B7   0100               sta    NUM_CL  D234 B1   0101               cmpa   NUM_TRM  D237 2C   14                 bge    50f  D239 C6   7C                 ldb    #MAX_CL  D23B F7   0100               stb    NUM_CL  D23E 8E   D26A               ldx    #00f  D241 BD   FD65               jsr    DB_pdata  D244 BD   FD83               jsr    DB_config  D247 BD   FD5F               jsr    DB_main  D24A 7E   D05A               jmp    rom_init  ... what else can I do???  D24D 16   FEF8     50        lbra   30b       go try it all again                     *-- Initialize devices  D250 CE   029D     60        ldu    #dev_tab  D253 5F            62        clrb  D254 34   04       70        pshs   b  D256 AE   C4                 ldx    dev_addr,u get device address  D258 27   06                 beq    75f       jump if none there  D25A 10AE 42                 ldy    dev_type,u get device kind  D25D AD   B8 22              jsr    [D_init,y] go initialize device  D260 33   44       75        leau   DEV_SIZE,u  D262 35   04                 puls   b  D264 5C                      incb  D265 C1   24                 cmpb   #MAX_DEV-1  D267 26   EB                 bne    70b                     * -- All done  D269 39            90        rts                     *  D26A 0D 2E 2E 2E   00        fcc    $d,"...Can't size tables!",0                     *  D281 2E 2E 4E 6F   no_dev    fcc    '..None',0                                                               *                     * Allocate some system table spaceTask Structure                       13:32:24  Feb 27, 1985   Page   28Table Initialization                                                     *   D - Space being consumed                     *   U - Current end of table space                     *   jsr sto_chk (System Table Overflow check)                     *   <CS> if overflow                     *  D288 33   CB       sto_chk   leau   d,u       compute new end pointer  D28A 1183 3FFF               cmpu   #end_vars overflow?  D28E 22   03                 bhi    10f       yes - return error  D290 1C   FE                 clc              no - return OK  D292 39                      rts  D293 1A   01       10        sec              .. bad owies  D295 39                      rts                                          *                     * clinit                     *                     * Initialize character buffer lists.  This routine                     * is only called once at startup time.                     *                       D296 BE   028D     clinit    ldx    CLISTS    point to clist  D299 F6   0100               ldb    NUM_CL    set count  D29C BF   0128               stx    cfreel    set head pointer  D29F 31   88 20    clini2    leay   CBSIZE,x  D2A2 10AF 84                 sty    0,x       set fwd link  D2A5 1F   21                 tfr    y,x       advance to next  D2A7 5A                      decb  D2A8 26   F5                 bne    clini2  D2AA B6   0100               lda    NUM_CL    get buffer count  D2AD 80   02                 suba   #2  D2AF B7   012B               sta    lcbuf     set max count  D2B2 4F                      clra             make d=0  D2B3 ED   88 E0              std    -CBSIZE,x clear last link  D2B6 7F   012A               clr    cbufct  D2B9 39                      rts              all done!                                          *                     * ttyinit                     *                     * Init the tty tables and queues.                     *                       D2BA 10BE 0291     ttyinit   ldy    TTYQS     point to q tables  D2BE 6F   E2                 clr    ,-s       terminal # counter  D2C0 F6   0101               ldb    NUM_TRM   get terminal count  D2C3 34   04                 pshs   b  D2C5 FE   0293               ldu    OBUFRS    output buffer  D2C8 BE   028F               ldx    TTYTABS   point to TTY Tables  D2CB 10AF 84       10        sty    tqin,x    set input q  D2CE 31   25                 leay   QH_SIZE,y get next q  D2D0 10AF 02                 sty    tqproc,x  set pr q  D2D3 31   25                 leay   QH_SIZE,y set next qTask Structure                       13:32:25  Feb 27, 1985   Page   29Table Initialization                                  D2D5 10AF 04                 sty    tqout,x   set output q  D2D8 EF   22                 stu    oq_buf,y  ** Init output Q **  D2DA EF   26                 stu    oq_get,y  D2DC EF   24                 stu    oq_put,y  D2DE FC   0105               ldd    OBUF_SIZE  D2E1 33   CB                 leau   d,u  D2E3 EF   28                 stu    oq_end,y  D2E5 31   2A                 leay   OQH_SIZE,y get next q  D2E7 86   14                 lda    #%101<<2  8 bits, no parity, 1 stop bit  D2E9 A7   0F                 sta    tbaud,x   set conf word  D2EB A6   61                 lda    1,s       get terminal #  D2ED A7   0A                 sta    tdevic,x  set in table  D2EF 34   46                 pshs   d,u  D2F1 C6   04                 ldb    #DEV_SIZE  D2F3 3D                      mul  D2F4 CE   029D               ldu    #dev_tab  D2F7 33   CB                 leau   d,u  D2F9 EC   C4                 ldd    dev_addr,u -- device address  D2FB ED   06                 std    taddr,x  D2FD 35   46                 puls   d,u  D2FF 6C   61                 inc    1,s       bump terminal #  D301 30   88 1F              leax   TTYSIZ,x  next tty entry  D304 6A   E4                 dec    0,s       dec the count  D306 26   C3                 bne    10b       repeat?  D308 35   86                 puls   d,pc      clean up stack & return                                          *                     * tskinit - Initialize all tasks                     *  D30A BE   0295     tskinit   ldx    tsktab  D30D BF   0124               stx    utask  D310 F6   0104               ldb    NUM_TSK   # tasks in system  D313 34   04                 pshs   b  D315 10BE 0295               ldy    tsktab    task 1  D319 31   A8 78              leay   TSKSIZ,y  D31C               10  D31C 86   04       11        lda    #TFREE    mark all tasks free  D31E BC   0295               cmpx   tsktab    is this the system task?  D321 26   02                 bne    15f  D323 96   05                 lda    TSYS      the system task is never free  D325 A7   04       15        sta    tsstat,x  D327 86   FF                 lda    #$FF      not associated with a terminal  D329 A7   08                 sta    tsdev,x  D32B 33   88 78              leau   TSKSIZ,x  initialize stack  D32E CC   D482               ldd    #IO_han  D331 34   20                 pshs   y  D333 AC   E1                 cmpx   ,s++      task 1?  D335 26   03                 bne    20f       no - normal I/O handling task  D337 CC   D5F0               ldd    #TI_HAN   yes - special terminal interrupt handling task  D33A 36   06       20        pshu   d  D33C EF   0E                 stu    usp,x  D33E EF   88 10              stu    umark0,xTask Structure                       13:32:26  Feb 27, 1985   Page   30Table Initialization                                  D341 30   88 78              leax   TSKSIZ,x  D344 6A   E4                 dec    0,s       done?  D346 26   D4                 bne    10b  D348 32   61                 leas   1,s       clean up stack  D34A CC   0000               ldd    #0        nothing running or sleeping  D34D FD   011E               std    runlst  D350 FD   0120               std    slplst  D353 FD   0122               std    slplst+tsslnk  D356 30   A4                 leax   0,y       start interrupt handling task  D358 BD   F100               jsr    makrdy  D35B 39                      rtsTask Structure                       13:32:26  Feb 27, 1985   Page   31IOP Configuration                                                                       D35C  mod_tbl   equ    *  D35C D64B D37A               fdb    DEV_L2,L2_name  D360 D822 D380               fdb    DEV_NEC,NEC_name  D364 F8BF D36E               fdb    DEV_8274,S4_name  D368 FBC7 D374               fdb    DEV_6850,S2_name  D36C 0000                    fdb    0                     *  D36E 4D 50 2D 53   S4_name   fcc    'MP-S4',0  D374 4D 50 2D 53   S2_name   fcc    'MP-S2',0  D37A 4D 50 2D 4C   L2_name   fcc    'MP-L2',0  D380 4E 45 43 2F   NEC_name  fcc    'NEC/Qume',0Task Structure                       13:32:26  Feb 27, 1985   Page   32FIO Simulation Routines                                                                       *                     * Reset CPU-IOP Interface                     *  D389               fio_reset  D389 8E   0001               ldx    #iop_cpu  clear control structure  D38C 6F   80       00        clr    ,x+  D38E 8C   0010               cmpx   #fifo  D391 26   F9                 bne    00b  D393 8E   0000               ldx    #0  D396 9F   0C                 stx    fifo_get  set Q pointers  D398 9F   0E                 stx    fifo_put  D39A 86   99                 lda    #$99      tell CPU I'm ready  D39C 97   00                 sta    irq_gen  D39E CE   0400               ldu    #1024     -- Reset Time-Out value  D3A1 C6   FF       fio_wait  ldb    #255      Spin counter  D3A3 0D   00       00        tst    irq_gen   wait for CPU to clear  D3A5 27   16                 beq    10f  D3A7 5A                      decb  D3A8 26   F9                 bne    00b       jump back if not ready  D3AA 33   5F                 leau   -1,u  D3AC 1183 0000               cmpu   #0  D3B0 26   EF                 bne    fio_wait  D3B2 8E   D03D               ldx    #CPU_down  D3B5 17   29AD               lbsr   DB_pdata  D3B8 17   29A4               lbsr   DB_main  D3BB 20   CC                 bra    fio_reset  D3BD 39            10        rts                                          *                     * fio_msg - Send a message via the FIO Mailbox                     *   B - Message code to send (one byte)                     *   iop_cpu1..3 already set up                     *                       D3BE 34   14       fio_msg   pshs   b,x       save register  D3C0 D7   01                 stb    iop_cpu   set up mailbox value  D3C2 C1   0C                 cmpb   #R_CLOCK  -- don't record clock transactions  D3C4 27   03                 beq    05f  D3C6 BD   DCD0               jsr    H_iop     record outgoing traffic  D3C9 12            05        nop  D3CA 86   FF       5         lda    #$FF      tell CPU mailbox full  D3CC 97   05                 sta    iop_cpuF  D3CE 97   00                 sta    irq_gen   let the CPU know it's there  D3D0 8E   FFFF     05        ldx    #$FFFF    time-out counter  D3D3 96   05       10        lda    iop_cpuF  wait till value consumed  D3D5 27   14                 beq    20f       jump if consumed  D3D7 30   1F                 leax   -1,x      time-out yet?  D3D9 26   F8                 bne    10b  D3DB 8E   D3ED               ldx    #00f  D3DE BD   FD65               jsr    DB_pdata  D3E1 A6   E4                 lda    0,sTask Structure                       13:32:27  Feb 27, 1985   Page   33FIO Simulation Routines                               D3E3 BD   FD6B               jsr    DB_phex  D3E6 17   2976               lbsr   DB_main  D3E9 20   E5                 bra    05b       try again  D3EB 35   94       20        puls   b,x,pc  D3ED 0D 46 49 4F   00        fcc    $d,'FIO Time-out, Value = $',0                                          *                     * fio_response - Return a response code/sequence #                     *    B - Response code                     *    A - Transaction specific value                     *  D406 34   16       fio_response pshs d,x  D408 8D   12                 bsr    FIO_get   access FIO  D40A BE   0124               ldx    utask  D40D A6   0B                 lda    tsseq,x  D40F 97   02                 sta    iop_cpu1  D411 A6   E4                 lda    0,s       get transaction specific value  D413 97   03                 sta    iop_cpu2 >D415 BD   D3BE               jsr    fio_msg  D418 8D   17                 bsr    FIO_rel   release FIO  D41A 35   96                 puls   d,x,pc    return                                          *                     * FIO_get - Get access to FIO device                     * -- Sleep till available                     *  D41C 34   76       FIO_get   pshs   d,x,y,u   save registers  D41E 108E 0143     10        ldy    #FIO_lock is the device locked  D422 6D   A4                 tst    0,y  D424 27   07                 beq    20f       no - go get it  D426 C6   CE                 ldb    #FIOPRI   waiting for the FIO  D428 BD   F13A               jsr    sleep  D42B 20   F1                 bra    10b       try again  D42D 6C   A4       20        inc    0,y       mark in use  D42F 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIO_rel - Release access to FIO                     *  D431 34   76       FIO_rel   pshs   d,x,y,u  D433 108E 0143               ldy    #FIO_lock  D437 6F   A4                 clr    0,y  D439 BD   F116               jsr    wakeup  D43C 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIFO_get - Fetch character from FIFO                     *   B - Character fetched                     *  D43E 34   04       FIFOgeta  pshs   b  D440 8D   05                 bsr    FIFO_get  D442 35   02                 puls   aTask Structure                       13:32:27  Feb 27, 1985   Page   34FIO Simulation Routines                               D444 1E   89                 exg    a,b  D446 39                      rts                     *  D447 34   10       FIFO_get  pshs   x  D449 D6   0B                 ldb    fifo_cnt  any data?  D44B 27   14                 beq    99f       no - exit  D44D 5A                      decb             yes - adjust count  D44E D7   0B                 stb    fifo_cnt  D450 9E   0C                 ldx    fifo_get  get consumer pointer  D452 E6   88 10              ldb    fifo,x    fetch byte  D455 30   01                 leax   1,x       bump pointer  D457 8C   0080               cmpx   #FIFO_SIZE end of fifo?  D45A 26   03                 bne    10f  D45C 8E   0000               ldx    #0        reset pointer  D45F 9F   0C       10        stx    fifo_get  D461 35   90       99        puls   x,pc                                          *                     * FIFO_put - Place character into FIFO                     *   B - Character fetched                     *  D463 34   04       FIFOputa  pshs   b  D465 1F   89                 tfr    a,b  D467 8D   02                 bsr    FIFO_put  D469 35   84                 puls   b,pc                     *  D46B 34   10       FIFO_put  pshs   x  D46D 9E   0E                 ldx    fifo_put  get consumer pointer  D46F E7   88 10              stb    fifo,x    store byte  D472 30   01                 leax   1,x       bump pointer  D474 8C   0080               cmpx   #FIFO_SIZE end of FIFO?  D477 26   03                 bne    10f  D479 8E   0000               ldx    #0        reset pointer  D47C 9F   0E       10        stx    fifo_put  D47E 0C   0B                 inc    fifo_cnt  update count  D480 35   90       99        puls   x,pcTask Structure                       13:32:28  Feb 27, 1985   Page   35IO Command Handler                                                                            *                     * IO_han - I/O Command Handler                     *   This routine comprises the main processing loop                     * for each task in the system.  Whenever an I/O command                     * is detected (via the message interrupt), a task will                     * be scheduled to process it.  This is that task.                     *   The command is saved in the "tscmd" field of the                     * task control block.                     *                                            D482               IO_han    clri   allow     interrupts  D484 BE   0124               ldx    utask     get task control block address  D487 A6   0A                 lda    tscmd,x   get I/O command  D489 44            10        lsra             isolate command  D48A 44                      lsra  D48B 44                      lsra  D48C 44                      lsra  D48D E6   08                 ldb    tsdev,x   get device #  D48F C1   25                 cmpb   #MAX_DEV  check for legal device #  D491 26   04                 bne    10f       jump if OK  D493 C6   84                 ldb    #E_BADDEV return illegal device error  D495 20   23                 bra    20f       exit  D497 48            10        lsla             -- word index on command  D498 8E   029D               ldx    #dev_tab  D49B 34   06                 pshs   d  D49D 86   04                 lda    #DEV_SIZE  D49F 3D                      mul  D4A0 30   8B                 leax   d,x  D4A2 AE   02                 ldx    dev_type,x get handler table address  D4A4 35   06                 puls   d  D4A6 10AE 86                 ldy    a,x       get processor address  D4A9 4F                      clra  D4AA 8E   D4BD     10        ldx    #IO_end   interrupt handler address  D4AD 34   10                 pshs   x  D4AF BE   0124               ldx    utask  D4B2 10EF 88 12              sts    umark1,x  D4B6 AD   A4                 jsr    0,y       perform operation & return status  D4B8 32   62                 leas   2,s       clean up stack  D4BA BD   D406     20        jsr    fio_response  D4BD               IO_end    seti   mask      interrupts  D4BF BE   0124               ldx    utask     restore task control block address  D4C2 A7   0D                 sta    tstval,x  remember transaction value sent  D4C4 E7   0A                 stb    tscmd,x   and command response  D4C6 86   04                 lda    #TFREE    mark task "terminated & free"  D4C8 A7   04                 sta    tsstat,x  D4CA 86   FF                 lda    #$FF      disassociate from any terminal  D4CC A7   08                 sta    tsdev,x  D4CE 6F   09                 clr    tssgnl,x  no waiting signals  D4D0 BD   F05A               jsr    rsched    run other tasks >D4D3 16   FFAC               lbra   IO_hanTask Structure                       13:32:29  Feb 27, 1985   Page   36IO Command Handler                                                                            *                     * Illegal command                     *  D4D6               bad_cmd  D4D6 C6   81                 ldb    #E_BADCMD error code  D4D8 39                      rtsTask Structure                       13:32:29  Feb 27, 1985   Page   37Device Table for Illegal Device                                            D4D9               DEV_BAD  D4D9 D4F9                    fdb    bad_dev   0  D4DB D4F9                    fdb    bad_dev   1  D4DD D4F9                    fdb    bad_dev   2  D4DF D4F9                    fdb    bad_dev   3  D4E1 D4F9                    fdb    bad_dev   4  D4E3 D4F9                    fdb    bad_dev   5  D4E5 D4F9                    fdb    bad_dev   6  D4E7 D4F9                    fdb    bad_dev   7  D4E9 D4F9                    fdb    bad_dev   8  D4EB D4F9                    fdb    bad_dev   9  D4ED D4F9                    fdb    bad_dev   A  D4EF D4F9                    fdb    bad_dev   B  D4F1 D4F9                    fdb    bad_dev   C  D4F3 D4F9                    fdb    bad_dev   D  D4F5 D4F9                    fdb    bad_dev   E  D4F7 D4F9                    fdb    bad_dev   F                                          *  D4F9 C6   84       bad_dev   ldb    #E_BADDEV  D4FB 39                      rtsTask Structure                       13:32:30  Feb 27, 1985   Page   38Interrupt Processing                                                                          *                     * This routine handles all IRQ interrupts                     *                     *  D4FC               IRQ_han                     *-- Check for clock interrupt  D4FC 86   80                 lda    #CLKMSK   get clock mask  D4FE B5   80C1               bita   CLKSEL    check clock int  D501 27   09                 beq    00f       no - try something else  D503 FC   80C2               ldd    CLKLAT    reset timer interrupt  D506 BD   FD56               jsr    clkint    go process interrupt  D509 16   00A5               lbra   99f       exit                     *  D50C CE   029D     00        ldu    #dev_tab  scan devices  D50F CC   0000               ldd    #0        start with device 0  D512 AE   C4       10        ldx    dev_addr,u get device address  D514 27   0A                 beq    20f       jump if none there  D516 10AE 42                 ldy    dev_type,u get device type  D519 AD   B8 20    15        jsr    [D_inthan,y] call interrupt poller/handler  D51C 1025 0091               lbcs   99f       exit if interrupt serviced  D520 C3   0001     20        addd   #1        next device  D523 33   44                 leau   DEV_SIZE,u  D525 1083 0025               cmpd   #MAX_DEV  any more devices?  D529 25   E7                 blo    10b                     * Check for FIO Mailbox interrupt  D52B 96   0A                 lda    cpu_iopF  see if mailbox interrupt  D52D 27   7A                 beq    50f       no - move on  D52F BD   DCAC               jsr    H_cpu     record transaction in history Queue  D532 BE   0148     25        ldx    int_ptr   input message pointer  D535 96   06                 lda    cpu_iop   move message  D537 A7   80                 sta    ,x+  D539 96   07                 lda    cpu_iop1  D53B A7   80                 sta    ,x+  D53D 96   08                 lda    cpu_iop2  D53F A7   80                 sta    ,x+  D541 96   09                 lda    cpu_iop3  D543 A7   80                 sta    ,x+  D545 0D   00                 tst    irq_gen   reset interrupt  D547 0F   0A                 clr    cpu_iopF  indicate message consumed  D549 BF   0148               stx    int_ptr   update pointer  D54C 108E 0144               ldy    #int_buf  get message from buffer  D550 A6   A4                 lda    0,y       -- Send interrupt command?  D552 81   A0                 cmpa   #O_INTRPT  D554 26   10                 bne    30f  D556 10BF 0148               sty    int_ptr   reset pointer  D55A E6   23                 ldb    3,y       get terminal #  D55C F1   0101               cmpb   NUM_TRM   is this a TTY device?  D55F 24   50                 bhs    99f       no - ignore message  D561 BD   F8A4               jsr    send_int  D564 20   4B                 bra    99f       exit                     *Task Structure                       13:32:30  Feb 27, 1985   Page   39Interrupt Processing                                  D566 BE   0295     30        ldx    tsktab    search for an available task  D569 F6   0104               ldb    NUM_TSK   Number of tasks in system  D56C A6   04       32        lda    tsstat,x  D56E 81   04                 cmpa   #TFREE    looking for a "free" task  D570 27   1A                 beq    40f  D572 30   88 78              leax   TSKSIZ,x  D575 5A                      decb  D576 26   F4                 bne    32b  D578 34   16                 pshs   d,x  D57A 8E   D5BD               ldx    #00f  D57D BD   FD65               jsr    DB_pdata  D580 BD   FD5F               jsr    DB_main  D583 35   16                 puls   d,x  D585 C6   82                 ldb    #E_SYSBSY can't process - IOP saturated!  D587 BD   D3BE               jsr    fio_msg  D58A 20   25                 bra    99f       exit  D58C 108E 0144     40        ldy    #int_buf  get message from buffer  D590 10BF 0148               sty    int_ptr   reset pointer  D594 E6   A0                 ldb    ,y+       command byte  D596 E7   0A                 stb    tscmd,x   save for task  D598 A6   A0                 lda    ,y+       sequence #  D59A A7   0B                 sta    tsseq,x  D59C E6   A0                 ldb    ,y+       command specific data  D59E E7   0D                 stb    tstval,x  D5A0 A6   A0                 lda    ,y+       associate with terminal  D5A2 A7   08                 sta    tsdev,x                     ** -- Removed 2/21/85                     ** lda #RUNPRI make highest possible priority                     ** sta tsprir,x  D5A4 BD   F100               jsr    makrdy    make task ready to run                     ** ldx utask don't switch if this was the system running                     ** cmpx tsktab                     ** beq 99f                     ** jsr change -- whatever I was doing can wait...  D5A7 20   08                 bra    99f       exit                     *  D5A9 17   27D1     50        lbsr   DB_check  enter debugger?  D5AC 24   03                 bcc    99f  D5AE 17   27AE               lbsr   DB_main                     *  D5B1 3B            99        rti              return from interrupt                     *  D5B2 0D 49 4F 50   IRQmsg10  fcc    $d,'IOP Got: ',0  D5BD 2D 2D 20 4E   00        fcc    '-- No tasks!',0Task Structure                       13:32:31  Feb 27, 1985   Page   40Interrupt All Tasks                                                                           *                     * Interrupt all tasks associated with a given device                     *   A - Device #                     *   jsr int_all                     * Note: The current task is skipped, along with                     * the system and the interrupt handler task (1).                     *  D5CA 34   36       int_all   pshs   d,x,y  D5CC F6   0104               ldb    NUM_TSK  D5CF C0   02                 subb   #2  D5D1 BE   0295               ldx    tsktab  D5D4 30   89 00F0            leax   2*TSKSIZ,x  D5D8 A1   08       10        cmpa   tsdev,x   is this guy associated with the device?  D5DA 26   0C                 bne    20f  D5DC BC   0124               cmpx   utask     make sure I don't get blown away  D5DF 27   07                 beq    20f  D5E1 34   16                 pshs   d,x  D5E3 BD   F16F               jsr    xmtint    interrupt task  D5E6 35   16                 puls   d,x  D5E8 30   88 78    20        leax   TSKSIZ,x  next task  D5EB 5A                      decb             any more tasks?  D5EC 26   EA                 bne    10b  D5EE 35   B6                 puls   d,x,y,pc  returnTask Structure                       13:32:32  Feb 27, 1985   Page   41Terminal Interrupt Handling Task                                                              *                     * TI_HAN Terminal interrupt handler                     *  D5F0 108E 012D     TI_HAN    ldy    #TI_Q     Terminal Interrupt Queue  D5F4                         seti  D5F6 FE   0141               ldu    TI_Q_ptr  get current Q ptr  D5F9 1183 012D               cmpu   #TI_Q     anything in Q?  D5FD 26   07                 bne    20f       yes - go process it  D5FF C6   D8                 ldb    #TIQPRI   wait for something to do  D601 BD   F13A               jsr    sleep  D604 20   EA                 bra    TI_HAN  D606 E6   C2       20        ldb    ,-u       B = Interrupt #  D608 A6   C2                 lda    ,-u       A = Device #  D60A FF   0141               stu    TI_Q_ptr  update pointer  D60D 34   06                 pshs   d         save registers  D60F E6   E4                 ldb    0,s       set up to flush all input for this terminal  D611 BD   F2D3               jsr    ttftab  D614 BD   F688               jsr    flushi  D617                         clri   allow     interrupts  D619 BD   D41C               jsr    FIO_get   get access to FIO  D61C E6   E0                 ldb    ,s+       terminal #  D61E D7   02                 stb    iop_cpu1  D620 E6   E0                 ldb    ,s+       interrupt #  D622 D7   03                 stb    iop_cpu2  D624 C6   0A                 ldb    #R_INTRPT  D626 BD   D3BE               jsr    fio_msg   send interrupt message  D629 BD   D431               jsr    FIO_rel   release access to FIO  D62C 20   C2                 bra    TI_HAN    process more if needed                                          *                     * Send_TI - Send a terminal interrupt                     *   B = Interrupt #                     *   X = TTY Table                     *   jsr send_TI                     *  D62E 34   76       send_TI   pshs   d,x,y,u   save registers  D630 FE   0141               ldu    TI_Q_ptr  get Q head  D633 1183 0141               cmpu   #TI_Q_ptr check for overflow  D637 24   09                 bhs    90f       exit if so - sorry  D639 A6   0A                 lda    tdevic,x  get terminal #  D63B A7   C0                 sta    ,u+       place value in Queue  D63D E7   C0                 stb    ,u+  D63F FF   0141               stu    TI_Q_ptr  update pointer  D642 108E 012D     90        ldy    #TI_Q     wake up Queue server  D646 BD   F116               jsr    wakeup  D649 35   F6                 puls   d,x,y,u,pc returnTask Structure                       13:32:33  Feb 27, 1985   Page   42Parallel Printer Driver                                                                       *                     * MP-L2 Parallel Printer                     *  D64B               DEV_L2  D64B D4D6                    fdb    bad_cmd   0 -  D64D D671                    fdb    ppopn     1 -  D64F D6AF                    fdb    ppcls     2 -  D651 D4D6                    fdb    bad_cmd   3 -  D653 D4D6                    fdb    bad_cmd   4 -  D655 D770                    fdb    preq_write 5 -  D657 D791                    fdb    pwrite_data 6 -  D659 D79A                    fdb    pwrt_sc   7 -  D65B D4D6                    fdb    bad_cmd   8 -  D65D D4D6                    fdb    bad_cmd   9 -  D65F D4D6                    fdb    bad_cmd   10 -  D661 D4D6                    fdb    bad_cmd   11 -  D663 D4D6                    fdb    bad_cmd   12 -  D665 D4D6                    fdb    bad_cmd   13 -  D667 D4D6                    fdb    bad_cmd   14 -  D669 FD13                    fdb    clock_on  15 -  D66B D747                    fdb    ppint  D66D D7BC                    fdb    pp_init  D66F D7D5                    fdb    pp_test                                          *                     * ppopn                     *                     * Open device                     *                       D671               ppopn  D671 8D   2C                 bsr    ppsel     go select printer  D673 6D   A4                 tst    ppopen,y  is the device already open?  D675 26   25                 bne    20f       yes - error  D677 EE   21                 ldu    ppadr,y   get PIA address  D679 4F                      clra             reset pia  D67A A7   41                 sta    1,u  D67C 86   FF                 lda    #$ff      set direction in pia  D67E A7   C4                 sta    0,u       send to pia  D680 30   2A                 leax   ppbuf,y   set in & out ptrs  D682 AF   26                 stx    ppipt,y  D684 AF   28                 stx    ppopt,y  D686 6F   23                 clr    ppcnt,y   clear out count  D688 6F   24                 clr    ppcnt+1,y  D68A 6F   25                 clr    ppbusy,y  D68C 86   01                 lda    #1        set open flag  D68E A7   A4                 sta    ppopen,y  D690 A6   C4                 lda    0,u       clear any ints  D692 86   2F                 lda    #PPCONE   enable interrupts and configure  D694 A7   41                 sta    1,u  D696 C6   02                 ldb    #R_OPEN   - Device Opened OKTask Structure                       13:32:34  Feb 27, 1985   Page   43Parallel Printer Driver                               D698 39                      rts              return                     *  D699 C6   84       10        ldb    #E_BADDEV Illegal device #  D69B 39                      rts                     *  D69C C6   85       20        ldb    #E_DEVBSY Device already open  D69E 39                      rts                                          *                     * ppsel - select a printer                     *   set Y to point to printer control structure                     *  D69F 10BE 0299     ppsel     ldy    PPstr     point at ppr structures  D6A3 C0   20                 subb   #MAX_TTY  make number relative to printers  D6A5 27   07                 beq    20f  D6A7 31   A9 0194  10        leay   PPSIZ,y  D6AB 5A                      decb  D6AC 26   F9                 bne    10b  D6AE 39            20        rts                                                               *                     * ppcls                     *                     * Close routine                     *                       D6AF 34   04       ppcls     pshs   b         save device #  D6B1 8D   EC                 bsr    ppsel     get control structure  D6B3 6F   A4                 clr    ppopen,y  device not open any more...  D6B5 35   02                 puls   a         restore device #  D6B7 BD   D5CA               jsr    int_all   interrupt any associated tasks  D6BA C6   03                 ldb    #R_CLOSE  - Close OK  D6BC 39                      rts              return                                          *                     * ppwrt                     *                     * Write to parallel printer                     *                       D6BD 34   01       ppwrt     pshs   cc        turn off interrupts  D6BF                         seti  D6C1 D6   0B       10        ldb    fifo_cnt  anything in FIFO?  D6C3 27   07                 beq    20f       no - get out  D6C5 17   FD7F               lbsr   FIFO_get  fetch character  D6C8 8D   0A                 bsr    ppout     output char to q  D6CA 20   F5                 bra    10b       repeat  D6CC 6D   25       20        tst    ppbusy,y  busy?  D6CE 26   02                 bne    20f  D6D0 8D   45                 bsr    ppstrt    kick port  D6D2 35   81       20        puls   cc,pc     returnTask Structure                       13:32:34  Feb 27, 1985   Page   44Parallel Printer Driver                                                                       *                     * ppout                     *                     * Output character to q.                     *                       D6D4 AE   26       ppout     ldx    ppipt,y   get input pointer  D6D6 E7   80                 stb    0,x+      put char in q  D6D8 33   A9 0194            leau   ppbnd,y   end of buffer?  D6DC 34   40                 pshs   u  D6DE AC   E1                 cmpx   ,s++  D6E0 26   02                 bne    ppout2  D6E2 30   2A                 leax   ppbuf,y   reset pointer  D6E4 AF   26       ppout2    stx    ppipt,y   save pointer  D6E6 34   06                 pshs   d  D6E8 EC   23                 ldd    ppcnt,y   count zero?  D6EA 27   10                 beq    ppout4  D6EC C3   0001               addd   #1  D6EF ED   23                 std    ppcnt,y   bump count  D6F1 35   06                 puls   d  D6F3 C1   0D                 cmpb   #$d       is it cr?  D6F5 26   04                 bne    ppout3  D6F7 C6   0A                 ldb    #$a       set up line feed  D6F9 20   D9                 bra    ppout  D6FB 39            ppout3    rts              return  D6FC C3   0001     ppout4    addd   #1  D6FF ED   23                 std    ppcnt,y   bump count  D701 35   06                 puls   d  D703 34   05                 pshs   cc,b      save status  D705                         seti   mask      ints  D707 6D   25                 tst    ppbusy,y  printer busy?  D709 26   02                 bne    ppout6  D70B 8D   0A                 bsr    ppstrt    kick port  D70D 35   05       ppout6    puls   cc,b  D70F C1   0D                 cmpb   #$d       is it cr?  D711 26   E8                 bne    ppout3  D713 C6   0A                 ldb    #$a       setup line feed  D715 20   BD                 bra    ppout                                          *                     * ppstrt                     *                     * Start output on the parallel port                     *                                            D717 EE   21       ppstrt    ldu    ppadr,y   get PIA address  D719 A6   C4                 lda    0,u       clear out interrupt  D71B 6F   25                 clr    ppbusy,y  D71D EC   23                 ldd    ppcnt,y   check char count  D71F 27   25                 beq    ppstr4Task Structure                       13:32:35  Feb 27, 1985   Page   45Parallel Printer Driver                               D721 AE   28                 ldx    ppopt,y   get output ptr  D723 E6   80                 ldb    0,x+      get a char  D725 34   40                 pshs   u         save PIA address  D727 33   A9 0194            leau   ppbnd,y   end of q?  D72B 34   40                 pshs   u  D72D AC   E1                 cmpx   ,s++  D72F 35   40                 puls   u         restore PIA address  D731 26   02                 bne    ppstr2  D733 30   2A                 leax   ppbuf,y   reset pointer  D735 AF   28       ppstr2    stx    ppopt,y   save output ptr  D737 34   06                 pshs   d  D739 EC   23                 ldd    ppcnt,y   dec the count  D73B 83   0001               subd   #1  D73E ED   23                 std    ppcnt,y  D740 35   06                 puls   d  D742 E7   C4                 stb    0,u       output character  D744 6C   25                 inc    ppbusy,y  set busy status  D746 39            ppstr4    rts              return                                          *                     * ppint                     *                     * Parallel driver interrupt routine                     *  D - Device #                     *  X - Device address                     *  Return CS if interrupt processed                     *                       D747 34   76       ppint     pshs   d,x,y,u   save registers  D749 A6   01                 lda    1,x       get status register  D74B E6   84                 ldb    0,x       clear interrupt if present  D74D 85   80                 bita   #%10000000 any interrupt?  D74F 27   17                 beq    80f       no - get out  D751 EC   E4                 ldd    0,s       restore device #  D753 17   FF49               lbsr   ppsel     select printer structure >D756 17   FFBE               lbsr   ppstrt    output a character  D759 EC   23                 ldd    ppcnt,y   check count  D75B 27   06                 beq    10f  D75D 1083 0105               cmpd   #PPLOC    low water?  D761 26   09                 bne    90f  D763 BD   F116     10        jsr    wakeup    awaken  D766 20   04                 bra    90f  D768 1C   FE       80        clc              return - no interrupt here  D76A 20   02                 bra    99f  D76C 1A   01       90        sec              return - interrupt processed  D76E 35   F6       99        puls   d,x,y,u,pc                     Task Structure                       13:32:36  Feb 27, 1985   Page   46Parallel Printer Driver                                                                       *                     * preq_write - Request permission to write data                     *  D770 BD   D69F     preq_write jsr   ppsel     get printer table  D773 34   01                 pshs   cc        mask interrupts while fiddling  D775               10        seti  D777 EC   23                 ldd    ppcnt,y   get queue length  D779 C3   0080               addd   #FIFO_SIZE and assume the CPU will send this many more  D77C 1083 0189               cmpd   #PPHI     space available?  D780 2F   0B                 ble    20f       yes - OK  D782 34   76                 pshs   d,x,y,u   no - save registers  D784 C6   E2                 ldb    #TTYSPR  D786 BD   F13A               jsr    sleep  D789 35   76                 puls   d,x,y,u   restore registers  D78B 20   E8                 bra    10b       try again  D78D C6   04       20        ldb    #R_REQOK  request granted code  D78F 35   81                 puls   cc,pc     return                                          *                     * pwrite_data - Write data to a printer                     *  D791               pwrite_data  D791 BD   D69F               jsr    ppsel     get printer control table pointer  D794 BD   D6BD               jsr    ppwrt     go consume data  D797 C6   05                 ldb    #R_WRITE  D799 39                      rts              return                                          *                     * Write single character                     *  -- Character passed via transaction message                     *  D79A 34   01       pwrt_sc   pshs   cc        save interrupt state  D79C                         seti  D79E BD   D69F               jsr    ppsel     compute printer table address  D7A1 EC   23       00        ldd    ppcnt,y   check for overrun  D7A3 1083 0189               cmpd   #PPHI  D7A7 23   07                 bls    10f       jump if space  D7A9 C6   EC                 ldb    #TTYOPR   wait a while  D7AB BD   F13A               jsr    sleep  D7AE 20   F1                 bra    00b       try again  D7B0 BE   0124     10        ldx    utask     fetch character  D7B3 E6   0D                 ldb    tstval,x  D7B5 BD   D6D4               jsr    ppout     send to output queue  D7B8 C6   05                 ldb    #R_WRITE  D7BA 35   81                 puls   cc,pc     return                                          *                     * Initialize MP-L2 device                     *   B - Device number                     *   X - Device address                     *Task Structure                       13:32:36  Feb 27, 1985   Page   47Parallel Printer Driver                               D7BC 34   76       pp_init   pshs   d,x,u,y  D7BE 17   FEDE               lbsr   ppsel     get control structure  D7C1 AF   21                 stx    ppadr,y  D7C3 86   2E                 lda    #$2e      set up pia  D7C5 A7   01                 sta    1,x  D7C7 34   06                 pshs   d         delay  D7C9 35   06                 puls   d  D7CB A6   84                 lda    0,x  D7CD 34   06                 pshs   d  D7CF 35   06                 puls   d  D7D1 6D   01                 tst    1,x  D7D3 35   F6                 puls   d,x,y,u,pc                                          *                     * Decide if a device is an MP-L2                     *   D - Device address                     *   Y - Device table                     *   CS - Device is not MP-L2                     *  D7D5 34   56       pp_test   pshs   d,x,u  D7D7 1F   03                 tfr    d,u  D7D9 86   2E                 lda    #$2E      set up pia  D7DB A7   41                 sta    1,u  D7DD A7   43                 sta    3,u       -- check both sides  D7DF 34   06                 pshs   d         delay  D7E1 35   06                 puls   d  D7E3 A6   41                 lda    1,u       must come back the same  D7E5 84   3F                 anda   #$3F      -- ignore interrupt bits  D7E7 81   2E                 cmpa   #$2E  D7E9 26   33                 bne    10f       not MP-L2  D7EB A6   43                 lda    3,u  D7ED 84   3F                 anda   #$3F      -- ignore interrupt bits  D7EF 81   2E                 cmpa   #$2E  D7F1 26   2B                 bne    10f  D7F3 1183 8090               cmpu   #PIA_SLOT is this an L2?  D7F7 27   04                 beq    05f       no - won't have a latch  D7F9 86   0F                 lda    #$0F      Initialize direction latch  D7FB A7   4F                 sta    15,u  D7FD B6   0103     05        lda    NUM_PPR   compute device table address  D800 8B   20                 adda   #MAX_TTY  D802 C6   04                 ldb    #DEV_SIZE  D804 3D                      mul  D805 108E 029D               ldy    #dev_tab  D809 31   AB                 leay   d,y  D80B 1F   30                 tfr    u,d       set up device table  D80D C3   0002               addd   #2  D810 ED   A4                 std    dev_addr,y  D812 8E   D64B               ldx    #DEV_L2  D815 AF   22                 stx    dev_type,y  D817 7C   0103               inc    NUM_PPR   adjust device count  D81A 1A   01                 sec  D81C 20   02                 bra    99fTask Structure                       13:32:37  Feb 27, 1985   Page   48Parallel Printer Driver                                                  *  D81E 1C   FE       10        clc  D820 35   D6       99        puls   d,x,u,pcTask Structure                       13:32:37  Feb 27, 1985   Page   49NEC Printer Drivers                                                                           *                     * NEC/Qume Parallel Printer                     *  D822               DEV_NEC  D822 D4D6                    fdb    bad_cmd   0 -  D824 D848                    fdb    necopn    1 -  D826 D894                    fdb    neccls    2 -  D828 DAAA                    fdb    nectys    3 -  D82A DB2B                    fdb    nectyg    4 -  D82C DB3E                    fdb    nreq_write 5 -  D82E DB63                    fdb    nwrite_data 6 -  D830 DB88                    fdb    nwrt_sc   7 -  D832 D4D6                    fdb    bad_cmd   8 -  D834 D4D6                    fdb    bad_cmd   9 -  D836 D4D6                    fdb    bad_cmd   10 -  D838 D4D6                    fdb    bad_cmd   11 -  D83A D4D6                    fdb    bad_cmd   12 -  D83C D4D6                    fdb    bad_cmd   13 -  D83E D4D6                    fdb    bad_cmd   14 -  D840 FD13                    fdb    clock_on  15 -  D842 DC88                    fdb    nec_int  D844 DBC0                    fdb    nec_init  D846 DC48                    fdb    nec_test                                          *                     *   set up the interface and arm the interrupts                     *  D848               necopn  D848 34   01                 pshs   cc  D84A                         seti >D84C BD   D8CC               jsr    setuy     initialize: U=data; Y=NECADR  D84F A6   C8 22              lda    necflg,u  get device status flag  D852 85   40                 bita   #necnop  D854 27   04                 beq    necdop    do the open processing  D856 C6   85                 ldb    #E_DEVBSY  D858 35   81                 puls   cc,pc                     *                     *   do the open on the device                     *  D85A 8A   40       necdop    ora    #necnop   indicate device is open  D85C 84   7F                 anda   #$7f      insure no I/O error  D85E A7   C8 22              sta    necflg,u  stuff into flag byte  D861 BD   D8F7               jsr    neclro    clear out all the buffer stuff                     *                     *   configure the I/O channel                     *  D864 86   36                 lda    #c_acr    set up a-side data register  D866 A7   22                 sta    cr_a,y    stuff into control register  D868 C6   3A                 ldb    #c_bcr-c_ddr select the direction register  D86A E7   23                 stb    cr_b,y    stuff into control register  D86C C6   FF                 ldb    #!0       then assign all lines asTask Structure                       13:32:38  Feb 27, 1985   Page   50NEC Printer Drivers                                   D86E E7   21                 stb    d_msp,y   output lines on b side  D870 C6   3F                 ldb    #c_bcr+c_irq select b-side data registers  D872 E7   23                 stb    cr_b,y    by writing control register  D874 6D   A4                 tst    0,y  D876 6D   21                 tst    1,y                     *                     *   set up initial values for the variables                     *  D878 BD   DAD8               jsr    necclc    perform the nectys calculations  D87B 4F                      clra             set positions to zero now  D87C 5F                      clrb  D87D ED   C8 14              std    carage,u  stuff into carage position slot  D880 ED   C8 18              std    nectrc,u  and also into nectrc position  D883 ED   C8 16              std    necfps,u  indicate we are at top of form                     *                     *   lift the ribbon and restore the printer                     *  D886 86   3F                 lda    #c_acr+c_lift+c_irq then lift ribbon  D888 A7   22                 sta    cr_a,y    by setting control register  D88A CC   E000               ldd    #s_rst*256+0 load a restore necstb  D88D BD   DA28               jsr    necstb    send it off to the printer  D890 C6   02                 ldb    #R_OPEN  D892 35   81                 puls   cc,pc                     *                     *   do form feed and place printer at left margin                     *  D894 34   04       neccls    pshs   b         save device #  D896 8D   34                 bsr    setuy     initialize: U=data; Y=NECADR                     * -- Wait for device to go idle  D898 34   61       10        pshs   cc,u,y  D89A                         seti  D89C 6D   C8 22              tst    necflg,u  if I/O error - don't wait  D89F 2B   0F                 bmi    30f  D8A1 EC   C4                 ldd    oq_count+necinq,u  D8A3 27   0B                 beq    30f  D8A5 31   C4                 leay   necinq,u  D8A7 C6   EC                 ldb    #TTYOPR  D8A9 BD   F13A               jsr    sleep  D8AC 35   61                 puls   cc,u,y  D8AE 20   E8                 bra    10b  D8B0 35   61       30        puls   cc,u,y  D8B2 35   02                 puls   a  D8B4 BD   D5CA               jsr    int_all   interrupt any associated tasks  D8B7 A6   C8 22              lda    necflg,u  get the flag byte  D8BA 85   40                 bita   #necnop   see if device is open  D8BC 27   0B                 beq    necclx    nope, don't need to close  D8BE BD   D9C5               jsr    necvrt    issue a form feed  D8C1 A6   C8 22              lda    necflg,u  get status byte  D8C4 84   BF                 anda   #!necnop  indicate not open device  D8C6 A7   C8 22              sta    necflg,u  D8C9 C6   03       necclx    ldb    #R_CLOSE  D8CB 39                      rtsTask Structure                       13:32:39  Feb 27, 1985   Page   51NEC Printer Drivers                                                      *                     *  setuy - setup U and Y registers                     *  D8CC FE   029B     setuy     ldu    NECstr    point U register to variables  D8CF 10BE 0333               ldy    NECADR    get I/O device address  D8D3 39                      rts                     *                     *   write a buffer in either raw mode or other                     *  D8D4 8D   F6       necwrt    bsr    setuy     initialize: U=data; Y=NECADR  D8D6 A6   C8 22              lda    necflg,u  pick up the tty flag bytes  D8D9 85   01                 bita   #rawnec   check for doing raw-mode I/O  D8DB 27   49                 beq    cooked    (bne)             if not, enter cooked processing                     *                     *   process next raw mode necstb word                     * >D8DD BD   D92C     eatraw    jsr    necpass   get msp of necstb byte  D8E0 2B   49                 bmi    necdon    if no more, done with it  D8E2 34   04                 pshs   b         save byte on the stack >D8E4 BD   D92C               jsr    necpass   get lsp of necstb byte  D8E7 35   02                 puls   a         get back msp from stack  D8E9 2B   40                 bmi    necdon    if no more, forget it  D8EB BD   DA28               jsr    necstb    send strobe off to necadr  D8EE 8D   55                 bsr    necbfc    check buffer status  D8F0 6D   C8 22              tst    necflg,u  check for I/O error  D8F3 2A   E8                 bpl    eatraw                     *                     *   permanent I/O error while processing                     *  D8F5 C6   81       necfio    ldb    #E_BADCMD ???       return failing status  D8F7 6F   C8 21    neclro    clr    necbsy,u  clear out busy flag  D8FA 6F   C8 20              clr    necsct,u  zap the buffer count  D8FD 30   C8 32              leax   necqbf,u  get the buffer address  D900 AF   C8 1C              stx    necsfp,u  stuff fetch pointer  D903 AF   C8 1A              stx    necssp,u  and also the store pointer  D906 EC   42                 ldd    oq_buf+necinq,u  D908 ED   46                 std    oq_get+necinq,u  D90A ED   44                 std    oq_put+necinq,u  D90C CC   0000               ldd    #0  D90F ED   C4                 std    oq_count+necinq,u  D911 34   20                 pshs   y  D913 BD   F116               jsr    wakeup    kick anybody waiting  D916 31   C4                 leay   necinq,u  D918 BD   F116               jsr    wakeup  D91B 35   A0                 puls   y,pc                     *                     *   process the next character from the user buffer                     *  D91D 8D   33       steamed   bsr    necdch    process the character  D91F 8D   24                 bsr    necbfc    check for room in the queue  D921 6D   C8 22              tst    necflg,u  check for I/O error  D924 2B   CF                 bmi    necfio    if so, terminate the writeTask Structure                       13:32:40  Feb 27, 1985   Page   52NEC Printer Drivers                                  >D926 BD   D92C     cooked    jsr    necpass   get character from buffer  D929 2A   F2                 bpl    steamed   if one exists, put on to cook  D92B 39            necdon    rts                     *                     * Get input character from queue                     *  D92C 34   22       necpass   pshs   y,a  D92E 31   C4                 leay   necinq,u  D930 BD   F22B               jsr    get_oq    fetch character  D933 26   03                 bne    10f       jump if none there  D935 4F                      clra             return with data  D936 20   02                 bra    90f  D938 86   FF       10        lda    #$FF      return - no more data  D93A 35   A2       90        puls   a,y,pc                     *                     *   check necstb buffer for room for more stuff                     *  D93C 8D   8E       necbfw    bsr    setuy     initialize: U=data; Y=NECADR  D93E C6   EC                 ldb    #TTYOPR   load priority  D940 BD   F13A               jsr    sleep     quiesce the process for now  D943 35   01                 puls   cc  D945 34   01       necbfc    pshs   cc  D947                         seti   disable   interrupts  D949 A6   C8 20              lda    necsct,u  get the buffer count  D94C 81   78                 cmpa   #NECBSIZ/2-8 see if room left in buffer  D94E 24   EC                 bhs    necbfw    nope, go wait some  D950 35   81                 puls   cc,pc                     *                     *   process a character destined for the printer                     *  D952 C1   20       necdch    cmpb   #sp       check for a necspc character  D954 22   19                 bhi    necdtt    if higher, active data character  D956 27   22                 beq    necspc    if equal, space character                     *                     *   decode possible control characters                     *  D958 C1   0D                 cmpb   #cr       check for carage necrtn  D95A 27   41                 beq    necrtn  D95C C1   0A                 cmpb   #nl       check for new line  D95E 27   4D                 beq    necnlr  D960 C1   0C                 cmpb   #vt       check for vertical tab  D962 27   61                 beq    necvrt  D964 C1   08                 cmpb   #bs       check for necdbs  D966 27   7E                 beq    necdbs  D968 C1   12                 cmpb   #xo       check for X-ON character  D96A 1027 0088               lbeq   posit  D96E 39                      rts                     *                     *   data character - do positioning and print character                     *  D96F C4   7F       necdtt    andb   #%01111111 check for data bits  D971 17   0082               lbsr   posit     issue the position necstbTask Structure                       13:32:41  Feb 27, 1985   Page   53NEC Printer Drivers                                   D974 58                      lslb             shift character left one bit  D975 86   C0                 lda    #s_chr    indicate a character necstb  D977 BD   DA28               jsr    necstb    issue a character print strobe                     *                     *   necspc character just advances horizontal position                     *  D97A EC   C8 10    necspc    ldd    necpos,u  pick up character position  D97D ED   C8 12              std    necold,u  store into previous position  D980 EB   C8 28              addb   pitch,u   add in the pitch value  D983 89   00                 adca   #0        add carry, if any, into msp  D985 ED   C8 10              std    necpos,u  store position into fcb                     *                     *   check to see if still on form width                     *  D988 EC   C8 30              ldd    rtlimt,u  pick up rightmost limit  D98B 27   58                 beq    necexi    if zero, just exit here  D98D 10A3 C8 10              cmpd   necpos,u  compare to character position  D991 24   52                 bhs    necexi    if higher, then exit                     *                     *   line has overflowed - see if we should issue necrtn, etc.                     *  D993 ED   C8 10              std    necpos,u  reset to right limit  D996 A6   C8 22              lda    necflg,u  pick up tty flag byte  D999 85   20                 bita   #neclof   test line overflow flag  D99B 27   48                 beq    necexi    if not, just exit here                     *                     *   carage necrtn function                     *  D99D EC   C8 2A    necrtn    ldd    margin,u  get left margin offset  D9A0 ED   C8 10              std    necpos,u  stuff into carage position  D9A3 ED   C8 12              std    necold,u  also reset previous position  D9A6 A6   C8 22              lda    necflg,u  pick up the tty flag byte  D9A9 85   10                 bita   #necnlo   check for new line option  D9AB 27   38                 beq    necexi                     *                     *   new line function -- set vertical position offset                     *  D9AD E6   C8 29    necnlr    ldb    depth,u   get character depth  D9B0 1D                      sex              convert into a 16-bit word  D9B1 E3   C8 16              addd   necfps,u  add into vertical position  D9B4 ED   C8 16              std    necfps,u  stuff back into position  D9B7 10A3 C8 2C              cmpd   frmlen,u  compare against form length  D9BB 25   28                 blo    necexi    if still on page, leave it                     *                     *   we are overflowing a page boundary, normalize things                     *  D9BD E3   C8 2E              addd   normal,u  add in normalize constant  D9C0 ED   C8 16              std    necfps,u  stuff the form position  D9C3 20   16                 bra    necvr2                     *                     *   vertical tab function sets up new top of form                     *Task Structure                       13:32:42  Feb 27, 1985   Page   54NEC Printer Drivers                                   D9C5 EC   C8 16    necvrt    ldd    necfps,u  get current form pos  D9C8 27   1B                 beq    necvrx    if at top of form, forget it  D9CA EC   C8 2C              ldd    frmlen,u  get form length word  D9CD 27   DE                 beq    necnlr    if zero, do a new line  D9CF ED   C8 16              std    necfps,u  stuff the form position  D9D2 EC   C8 2A              ldd    margin,u  reset margin, too  D9D5 ED   C8 10              std    necpos,u  set carriage position  D9D8 ED   C8 12              std    necold,u  set old position, too  D9DB 8D   19       necvr2    bsr    posit     issue the position strobe  D9DD 4F                      clra             set position to zero  D9DE 5F                      clrb  D9DF ED   C8 16              std    necfps,u  stuff into form position  D9E2 ED   C8 18              std    nectrc,u  and stuff into nectrc position  D9E5               necexi  D9E5 39            necvrx    rts                     *                     *   necdbs function backs up positon                     *  D9E6 EC   C8 12    necdbs    ldd    necold,u  pick up previous carage position  D9E9 ED   C8 10              std    necpos,u  stuff back into slot  D9EC 39                      rts                     *                     *  negate - negate value in d register then 'and' with "back"                     *  D9ED 34   06       negate    pshs   d  D9EF 4F                      clra  D9F0 5F                      clrb  D9F1 A3   E1                 subd   0,s++  D9F3 8A   08                 ora    #back  D9F5 39                      rts                     *                     *   posit function issues necstbs to position the carage                     *  D9F6 34   06       posit     pshs   a,b       save data registers on stack  D9F8 EC   C8 16              ldd    necfps,u  pick up forms position  D9FB A3   C8 18              subd   nectrc,u  compare to nectrc position  D9FE 27   10                 beq    nechpz    if equal, just do horizontal position  DA00 58                      aslb             multiply quantity by two  DA01 49                      rola  DA02 2A   02                 bpl    necvpz    if positive, do vertical position  DA04 8D   E7                 bsr    negate    make motion downward direction                     *                     *   perform the vertical position                     *  DA06 8A   80       necvpz    ora    #s_pfd    indicate a paper feed necstb  DA08 8D   1E                 bsr    necstb    then strobe the printer  DA0A EC   C8 16              ldd    necfps,u  stuff into file control block  DA0D ED   C8 18              std    nectrc,u  as current nectrc position                     *                     *   position the carage                     *  DA10 EC   C8 10    nechpz    ldd    necpos,u  get character positionTask Structure                       13:32:42  Feb 27, 1985   Page   55NEC Printer Drivers                                   DA13 A3   C8 14              subd   carage,u  subtract from carage position  DA16 27   0E                 beq    xposit    if zero, just necexi position  DA18 2A   02                 bpl    necdpq    if positive, do the position  DA1A 8D   D1                 bsr    negate    indicate leftwards motion                     *                     *   perform the carage position                     *  DA1C 8A   A0       necdpq    ora    #s_car    set carage motion necstb  DA1E 8D   08                 bsr    necstb    send position strobe  DA20 EC   C8 10              ldd    necpos,u  get character position  DA23 ED   C8 14              std    carage,u  and indicate new carage position  DA26 35   86       xposit    puls   a,b,pc                     *                     *   place a necstb word into the strobe buffer                     *  DA28 34   01       necstb    pshs   cc        save condition flags  DA2A                         seti  DA2C AE   C8 1A              ldx    necssp,u  get necstb place pointer  DA2F ED   81                 std    0,x++     stuff into the buffer  DA31 AC   C8 1E              cmpx   necsnd,u  check for end of buffer  DA34 26   03                 bne    necppy    if not, just set pointer  DA36 30   C8 32              leax   necqbf,u  point back at the buffer                     *                     *   store the new output pointer and check for interrupts active                     *  DA39 AF   C8 1A    necppy    stx    necssp,u  stuff back the pointer  DA3C 6C   C8 20              inc    necsct,u  increment the necstb count  DA3F 6D   C8 21              tst    necbsy,u  DA42 26   02                 bne    necsx1  DA44 8D   02                 bsr    neccup    simulate a necadr interrupt  DA46 35   81       necsx1    puls   cc,pc     cc                     *                     *   take an interrupt from the printer interface                     *  DA48 17   FE81     neccup    lbsr   setuy     initialize: U=data; Y=NECADR  DA4B 6F   C8 21              clr    necbsy,u  indicate no interrupt pending  DA4E 6D   A4                 tst    d_lsp,y   clear any pending interrupt  DA50 6D   C8 20              tst    necsct,u  test the necstb count  DA53 27   22                 beq    nechco    if zero, no more necstb words                     *                     *   get the next necstb word from the strobe queue                     *  DA55 AE   C8 1C              ldx    necsfp,u  get the necstb input pointer  DA58 EC   81                 ldd    0,x++     pick up the necstb word  DA5A AC   C8 1E              cmpx   necsnd,u  see if at end of buffer  DA5D 26   03                 bne    necpfp    if not, go set pointer  DA5F 30   C8 32              leax   necqbf,u  point at top of buffer  DA62 AF   C8 1C    necpfp    stx    necsfp,u  stuff back into pointer slot  DA65 8D   36                 bsr    nectag    tag the device  DA67 6C   C8 21              inc    necbsy,u  indicate pending interrupt                     *                     *   fixemup necstb counts, etcTask Structure                       13:32:44  Feb 27, 1985   Page   56NEC Printer Drivers                                                      *  DA6A A6   C8 20              lda    necsct,u  pick up the necstb count  DA6D 4A                      deca             decrement it by one  DA6E A7   C8 20              sta    necsct,u  stuff back into count field  DA71 27   04                 beq    nechco    if empty, wakeup  DA73 81   1A                 cmpa   #26       check for approx 26 necstbs  DA75 26   03                 bne    nechx1    which is 200 mSec, approx.  DA77 BD   F116     nechco    jsr    wakeup    wake up on the necadr  DA7A 39            nechx1    rts                     *                     *   check interrupt processing                     *  DA7B 17   FE4E     necafu    lbsr   setuy     initialize: U=data; Y=NECADR  DA7E 6D   21                 tst    d_msp,y   clear the interrupt  DA80 6F   C8 21              clr    necbsy,u  DA83 6F   C8 20              clr    necsct,u  clear out strobe buffer  DA86 A6   C8 22              lda    necflg,u  fix up flag bits  DA89 8A   80                 ora    #necioe  DA8B 84   BF                 anda   #!necnop  indicate device not open  DA8D A7   C8 22              sta    necflg,u                     *                     *   hard issue a restore to the device                     *  DA90 CC   E000               ldd    #s_rst*256  DA93 8D   08                 bsr    nectag    send strobe to device  DA95 86   36                 lda    #c_acr    quiesce the interface  DA97 A7   22                 sta    cr_a,y  DA99 BD   F116               jsr    wakeup    in case task sleeping  DA9C 39                      rts                     *                     *   issue the necstb to the printer                     *  DA9D A7   21       nectag    sta    d_msp,y   stuff the data stobe word  DA9F E7   A4                 stb    d_lsp,y  DAA1 86   36                 lda    #c_bcr-c_stb load control necstb  DAA3 A7   23                 sta    cr_b,y  DAA5 86   3F                 lda    #c_bcr+c_irq bring necstb high and arm IRQ  DAA7 A7   23                 sta    cr_b,y  DAA9 39                      rts                     *                     *   nectys and nectyg processing                     *  DAAA 17   FE1F     nectys    lbsr   setuy     initialize: U=data; Y=NECADR                     *                     *   before altering nectys table, perform limit check on parameters                     *  DAAD 30   4A                 leax   necarg0,u  DAAF 86   06                 lda    #6  DAB1 17   F993     10        lbsr   FIFO_get  DAB4 E7   80                 stb    ,x+  DAB6 4A                      deca  DAB7 26   F8                 bne    10bTask Structure                       13:32:44  Feb 27, 1985   Page   57NEC Printer Drivers                                   DAB9 EC   4C                 ldd    necarg1,u  DABB 81   06                 cmpa   #6        check lower pitch limit  DABD 25   69                 blo    necoop  DABF 81   18                 cmpa   #24       check upper pitch limit  DAC1 22   65                 bhi    necoop  DAC3 C1   04                 cmpb   #4        check lower depth limit  DAC5 25   61                 blo    necoop  DAC7 C1   20                 cmpb   #32       check upper depth limit  DAC9 22   5D                 bhi    necoop  DACB ED   C8 24              std    necflg+2,u                     *                     *   copy rest of nectys parameters into local table                     *  DACE EC   4A                 ldd    necarg0,u get first two bytes  DAD0 ED   C8 22              std    necflg,u  DAD3 EC   4E                 ldd    necarg2,u get last user argument  DAD5 ED   C8 26              std    necflg+4,u                     *                     *   perform calculations on nectys parameters                     *  DAD8 A6   C8 26    necclc    lda    necfrm,u  pick up the form length  DADB C6   04                 ldb    #4        set scale offset value  DADD 3D                      mul              calculate form length, in units  DADE ED   C8 2C              std    frmlen,u  DAE1 A6   C8 23              lda    neclef,u  pick up the left margin offset  DAE4 C6   0A                 ldb    #10       set the units scale value  DAE6 3D                      mul              calculate offset, in horiz units  DAE7 ED   C8 2A              std    margin,u  DAEA ED   C8 10              std    necpos,u  provide for a fixed left margin  DAED ED   C8 12              std    necold,u                     *                     *   calculate maximum width parameter                     *  DAF0 A6   C8 27              lda    necwid,u  pick up the form width  DAF3 C6   0A                 ldb    #10       set scale offset value  DAF5 3D                      mul              calculate width, in units  DAF6 27   03                 beq    necstp    if zero, just set the width  DAF8 E3   C8 2A              addd   margin,u  add in the left margin value  DAFB ED   C8 30    necstp    std    rtlimt,u                     *                     *   calculate pitch info from nectys parms                     *  DAFE CC   78FF               ldd    #120*256+$FF set up initial pitch constants  DB01 5C            necpdv    incb             increment pitch constant  DB02 A0   C8 24              suba   necpch,u  subtract off the pitch limit  DB05 24   FA                 bcc    necpdv    loop until divided  DB07 E7   C8 28              stb    pitch,u   stuff the pitch value                     *                     *   calculate depth info from nectys parms                     *  DB0A CC   30FF               ldd    #48*256+$FF set up initial depth constants  DB0D 5C            necddv    incb             increment the quotient valueTask Structure                       13:32:45  Feb 27, 1985   Page   58NEC Printer Drivers                                   DB0E A0   C8 25              suba   necdep,u  subtract out the divisor  DB11 24   FA                 bcc    necddv    loop until divided out  DB13 E7   C8 29              stb    depth,u   stuff back into depth slot                     *                     *   calculate form normalization constant                     *  DB16 4F                      clra             make depth double precision  DB17 34   06                 pshs   d         save depth value on the stack  DB19 EC   C8 2C              ldd    frmlen,u  pick up the form length  DB1C A3   E4       necsnm    subd   0,s       subtract off the depth value  DB1E 24   FC                 bcc    necsnm    loop back if not cleared  DB20 E3   E1                 addd   0,s++     add back to get normalizer value  DB22 ED   C8 2E              std    normal,u  stuff into form normalizer  DB25 C6   06                 ldb    #R_TTY    normal return  DB27 39                      rts                     *                     *   oops, some value is out of range                     *  DB28 C6   81       necoop    ldb    #E_BADCMD set an error indicating out of range  DB2A 39                      rts                     *                     *   for nectyg command, necrtn the information                     *  DB2B 17   FD9E     nectyg    lbsr   setuy  DB2E 30   C8 22              leax   necflg,u  DB31 86   06                 lda    #6  DB33 E6   80       10        ldb    ,x+  DB35 17   F933               lbsr   FIFO_put  DB38 4A                      deca  DB39 26   F8                 bne    10b  DB3B C6   06                 ldb    #R_TTY  DB3D 39                      rtsTask Structure                       13:32:46  Feb 27, 1985   Page   59NEC Printer Drivers                                                                           *                     * nreq_write - Request permission to write data                     *  DB3E BD   D8CC     nreq_write jsr   setuy     set up registers  DB41 34   01                 pshs   cc        mask interrupts while fiddling  DB43               10        seti  DB45 6D   C8 22              tst    necflg,u  is the device in error?  DB48 2B   15                 bmi    30f       yes - get it back to UniFLEX  DB4A EC   C4                 ldd    oq_count+necinq,u get queue length  DB4C 27   0D                 beq    20f       only continue when empty  DB4E 34   76                 pshs   d,x,y,u   no - save registers  DB50 31   C4                 leay   necinq,u  DB52 C6   E2                 ldb    #TTYSPR  DB54 BD   F13A               jsr    sleep  DB57 35   76                 puls   d,x,y,u   restore registers  DB59 20   E8                 bra    10b       try again  DB5B C6   04       20        ldb    #R_REQOK  request granted code  DB5D 20   02                 bra    99f  DB5F C6   86       30        ldb    #E_IOERR  device is all screwed up...  DB61 35   81       99        puls   cc,pc     return                                          *                     * nwrite_data - Write data to a printer                     *  DB63               nwrite_data  DB63 BD   D8CC               jsr    setuy     get printer control table pointer  DB66 34   20                 pshs   y         save device address  DB68 96   0B       10        lda    fifo_cnt  any data left in FIFO?  DB6A 27   0A                 beq    20f       no - get output started  DB6C BD   D447               jsr    FIFO_get  go fetch character  DB6F 31   C4                 leay   necinq,u  point to input queue  DB71 BD   F24F               jsr    put_oq    put character into queue  DB74 20   F2                 bra    10b  DB76 C6   05       20        ldb    #R_WRITE  set response  DB78 BD   D406               jsr    fio_response  DB7B 35   20                 puls   y         restore device address  DB7D BD   D8D4               jsr    necwrt    go start getting data  DB80 31   C4                 leay   necinq,u  wake up anybody waiting on input queue  DB82 BD   F116               jsr    wakeup  DB85 32   62                 leas   2,s       -- abnormal (although it really is OK) return  DB87 39                      rts                                          *                     * Write single character                     *  -- Character passed via transaction message                     *  DB88 34   01       nwrt_sc   pshs   cc        save interrupt state  DB8A                         seti  DB8C BD   D8CC     00        jsr    setuy     compute printer table address  DB8F 6D   C8 22              tst    necflg,u  device OK?  DB92 2A   04                 bpl    05fTask Structure                       13:32:46  Feb 27, 1985   Page   60NEC Printer Drivers                                   DB94 C6   86                 ldb    #E_IOERR  no - return error code to UniFLEX  DB96 35   81                 puls   cc,pc  DB98 EC   C4       05        ldd    oq_count+necinq,u check for overrun  DB9A 27   09                 beq    10f       jump if OK  DB9C 31   C4                 leay   necinq,u  DB9E C6   EC                 ldb    #TTYOPR   wait a while  DBA0 BD   F13A               jsr    sleep  DBA3 20   E7                 bra    00b       try again  DBA5 BE   0124     10        ldx    utask     fetch character  DBA8 E6   0D                 ldb    tstval,x  DBAA 34   20                 pshs   y  DBAC 31   C4                 leay   necinq,u  DBAE BD   F24F               jsr    put_oq  DBB1 35   20                 puls   y  DBB3 C6   05                 ldb    #R_WRITE  DBB5 BD   D406               jsr    fio_response  DBB8 BD   D8D4               jsr    necwrt    send to output queue  DBBB 35   01                 puls   cc  DBBD 32   62                 leas   2,s       clean off stack  DBBF 39                      rts                                          *                     * Initialize NEC device                     *   B - Device number                     *   X - Device address                     *  DBC0 34   76       nec_init  pshs   d,x,u,y  DBC2 17   FD07               lbsr   setuy     get control structure  DBC5 BF   0333               stx    NECADR                     * -- Initialize Control structure  DBC8 10BE 0331               ldy    NEC_IQ  DBCC 10AF 42                 sty    oq_buf+necinq,u  DBCF 10AF 46                 sty    oq_get+necinq,u  DBD2 10AF 44                 sty    oq_put+necinq,u  DBD5 FC   0105               ldd    OBUF_SIZE  DBD8 31   AB                 leay   d,y  DBDA 10AF 48                 sty    oq_end+necinq,u  DBDD 31   C8 32              leay   necqbf,u  DBE0 10AF C8 1A              sty    necssp,u  DBE4 10AF C8 1C              sty    necsfp,u  DBE8 31   C9 0132            leay   necqnd,u  DBEC 10AF C8 1E              sty    necsnd,u  DBF0 86   06                 lda    #6  DBF2 A7   C8 23              sta    neclef,u  DBF5 86   0A                 lda    #10  DBF7 A7   C8 24              sta    necpch,u  DBFA 86   06                 lda    #6  DBFC A7   C8 25              sta    necdep,u  DBFF 86   84                 lda    #132  DC01 A7   C8 26              sta    necfrm,u  DC04 86   A8                 lda    #168  DC06 A7   C8 27              sta    necwid,uTask Structure                       13:32:47  Feb 27, 1985   Page   61NEC Printer Drivers                                   DC09 86   0C                 lda    #12  DC0B A7   C8 28              sta    pitch,u  DC0E 86   08                 lda    #8  DC10 A7   C8 29              sta    depth,u  DC13 CC   0030               ldd    #48  DC16 ED   C8 2A              std    margin,u  DC19 CC   0210               ldd    #528  DC1C ED   C8 2C              std    frmlen,u  DC1F CC   0000               ldd    #0  DC22 ED   C8 2E              std    normal,u  DC25 CC   0696               ldd    #1686  DC28 ED   C8 30              std    rtlimt,u  DC2B 86   30                 lda    #necnlo|neclof  DC2D A7   C8 22              sta    necflg,u  DC30 86   2E                 lda    #$2e      set up pia  DC32 A7   02                 sta    2,x  DC34 A7   03                 sta    3,x  DC36 34   06                 pshs   d         delay  DC38 35   06                 puls   d  DC3A A6   84                 lda    0,x  DC3C A6   01                 lda    1,x  DC3E 34   06                 pshs   d  DC40 35   06                 puls   d  DC42 6D   02                 tst    2,x  DC44 6D   03                 tst    3,x  DC46 35   F6                 puls   d,x,y,u,pc                                          *                     * Decide if a device is an NEC                     *   D - Device address                     *   Y - Device table                     *   CS - Device is not NEC                     *  DC48 34   56       nec_test  pshs   d,x,u  DC4A 1F   03                 tfr    d,u  DC4C 86   2E                 lda    #$2E      set up pia  DC4E A7   42                 sta    2,u  DC50 A7   43                 sta    3,u       -- check both sides  DC52 34   06                 pshs   d         delay  DC54 35   06                 puls   d  DC56 A6   42                 lda    2,u       must come back the same  DC58 84   3F                 anda   #$3F  DC5A 81   2E                 cmpa   #$2E  DC5C 26   26                 bne    10f       not NEC  DC5E A6   43                 lda    3,u  DC60 84   3F                 anda   #$3F  DC62 81   2E                 cmpa   #$2E  DC64 26   1E                 bne    10f  DC66 B6   0102               lda    NUM_NEC   compute device table address  DC69 8B   23                 adda   #MAX_TTY+MAX_PPR  DC6B C6   04                 ldb    #DEV_SIZE  DC6D 3D                      mulTask Structure                       13:32:48  Feb 27, 1985   Page   62NEC Printer Drivers                                   DC6E 108E 029D               ldy    #dev_tab  DC72 31   AB                 leay   d,y  DC74 1F   30                 tfr    u,d       set up device table  DC76 ED   A4                 std    dev_addr,y  DC78 8E   D822               ldx    #DEV_NEC  DC7B AF   22                 stx    dev_type,y  DC7D 7C   0102               inc    NUM_NEC   adjust device count  DC80 1A   01                 sec  DC82 20   02                 bra    99f                     *  DC84 1C   FE       10        clc  DC86 35   D6       99        puls   d,x,u,pc                                          *                     * NEC printer interrupt routine                     *  D - Device #                     *  X - Device address                     *  Return CS if interrupt processed                     *                       DC88 34   76       nec_int   pshs   d,x,y,u   save registers  DC8A A6   02                 lda    2,x       get status register  DC8C E6   03                 ldb    3,x  DC8E 108E DA48               ldy    #neccup   assume normal interrupt  DC92 85   80                 bita   #%10000000 any interrupt?  DC94 26   08                 bne    01f  DC96 108E DA7B               ldy    #necafu   error interrupt  DC9A C5   80                 bitb   #%10000000  DC9C 27   06                 beq    80f       no - get out  DC9E               01  DC9E EC   E4                 ldd    0,s       restore device #  DCA0 AD   A4                 jsr    0,y       go process interrupt  DCA2 20   04                 bra    90f  DCA4 1C   FE       80        clc              return - no interrupt here  DCA6 20   02                 bra    99f  DCA8 1A   01       90        sec              return - interrupt processed  DCAA 35   F6       99        puls   d,x,y,u,pcTask Structure                       13:32:49  Feb 27, 1985   Page   63History Entry Procedures                                                                      *                     * H_cpu - Place a transaction from the CPU into                     *         the history Queue.                     *  DCAC 34   16       H_cpu     pshs   d,x  DCAE BE   028B               ldx    hstptr    get history queue pointer  DCB1 96   06                 lda    cpu_iop  DCB3 A7   84                 sta    hst_cmd,x  DCB5 96   07                 lda    cpu_iop1  DCB7 A7   01                 sta    hst_seq,x  DCB9 96   09                 lda    cpu_iop3  DCBB A7   02                 sta    hst_tty,x  DCBD 96   08                 lda    cpu_iop2  DCBF A7   03                 sta    hst_val,x  DCC1 30   04                 leax   HRECSIZ,x  DCC3 8C   028B               cmpx   #hstptr   end of Queue?  DCC6 25   03                 blo    10f  DCC8 8E   024B               ldx    #hstbuf  DCCB BF   028B     10        stx    hstptr  DCCE 35   96                 puls   d,x,pc                                          *                     * H_iop - Place a transaction from the IOP into                     *         the history Queue.                     *  DCD0 34   16       H_iop     pshs   d,x  DCD2 BE   028B               ldx    hstptr    get history queue pointer  DCD5 96   01                 lda    iop_cpu  DCD7 A7   84                 sta    hst_cmd,x  DCD9 96   02                 lda    iop_cpu1  DCDB A7   01                 sta    hst_seq,x  DCDD 96   04                 lda    iop_cpu3  DCDF A7   02                 sta    hst_tty,x  DCE1 96   03                 lda    iop_cpu2  DCE3 A7   03                 sta    hst_val,x  DCE5 30   04                 leax   HRECSIZ,x  DCE7 8C   028B               cmpx   #hstptr   end of Queue?  DCEA 25   03                 blo    10f  DCEC 8E   024B               ldx    #hstbuf  DCEF BF   028B     10        stx    hstptr  DCF2 35   96                 puls   d,x,pc                       F000                         org    ROMHIorgTask Structure                       13:32:50  Feb 27, 1985   Page   64Time of Day Clock Handler                                                *                     * Time of Day Clock Device table                     *  F000               DEV_TOD  F000 D4D6                    fdb    bad_cmd   0 -  F002 F037                    fdb    open_tod  1 -  F004 F03A                    fdb    close_tod 2 -  F006 D4D6                    fdb    bad_cmd   3 -  F008 D4D6                    fdb    bad_cmd   4 -  F00A F03D                    fdb    treq_write 5 -  F00C F041                    fdb    twrite_data 6 -  F00E D4D6                    fdb    bad_cmd   7 -  F010 F020                    fdb    treq_read 8 -  F012 F025                    fdb    tread_data 9 -  F014 D4D6                    fdb    bad_cmd   10 -  F016 D4D6                    fdb    bad_cmd   11 -  F018 D4D6                    fdb    bad_cmd   12 -  F01A D4D6                    fdb    bad_cmd   13 -  F01C D4D6                    fdb    bad_cmd   14 -  F01E FD13                    fdb    clock_on  15 -Task Structure                       13:32:50  Feb 27, 1985   Page   65Time of Day Clock Handler                                                                     *                     * treq_read - CPU has informed us he wants to read                     * Tell him when some data is available.                     *  F020               treq_read  F020 86   0E                 lda    #TOD_SIZE -- Size of TOD information  F022 C6   07                 ldb    #R_RDOK   data available  F024 39                      rts                                          *                     * tread_data - CPU wants IOP to send data                     *  Max # chars to move in transaction speicific value                     *  F025               tread_data  F025 4F                      clra  F026 B7   80A0     10        sta    TOD_ADDR  F029 F6   80B0               ldb    TOD_DATA  move TOD data to FIFO  F02C BD   D46B               jsr    FIFO_put  F02F 4C                      inca  F030 81   0E                 cmpa   #TOD_SIZE  F032 26   F2                 bne    10b  F034 C6   08                 ldb    #R_SNDNC  data now available in FIFO  F036 39                      rts                                          *                     * open_tod - Perform device open                     *  F037               open_tod  F037 C6   02                 ldb    #R_OPEN  F039 39                      rts                                          *                     * close_tod - Perform device close                     *  F03A               close_tod  F03A C6   03                 ldb    #R_CLOSE  F03C 39                      rts                                          *                     * treq_write - Request permission to write data                     *  F03D               treq_write  F03D C6   04                 ldb    #R_REQOK  request granted code  F03F 35   80                 puls   pc        return                                          *                     * twrite_data - Write data to TOD                     *  F041               twrite_data  F041 4F                      clra  F042 BD   D447     10        jsr    FIFO_getTask Structure                       13:32:51  Feb 27, 1985   Page   66Time of Day Clock Handler                             F045 B7   80A0               sta    TOD_ADDR  F048 F7   80B0               stb    TOD_DATA  F04B 4C                      inca  F04C 81   0E                 cmpa   #TOD_SIZE  F04E 26   F2                 bne    10b  F050 C6   05                 ldb    #R_WRITE  F052 35   80                 puls   pc        returnTask Structure                       13:32:52  Feb 27, 1985   Page   67Scheduler routines                                                                            *                     * All routines in this file pertain to scheduling                     * operations.                     *                                          *                     * change & rsched                     *                     * Change will change tasks.  The current task is put                     * back on the linked list of running tasks.                     * Rsched will reschedule the cpu giving control to                     * another ready task.  If no tasks are ready, idle                     * looping is done until one becomes ready.  Rsched                     * does not put the current task back on the ready list!                     * This routine returns one to the caller.  All registers                     * are destroyed.                     *                       F054 BE   0124     change    ldx    utask     point to task table entry >F057 17   006D               lbsr   putrun    put on ready list                     *  F05A               rsched    seti   mask      interrupts  F05C BE   0124               ldx    utask     point to current task  F05F 10EF 88 10              sts    umark0,x  save stack pointers  F063 BE   0295               ldx    tsktab    point to task table  F066 8D   23                 bsr    swtchu    switch users  F068 7F   012C               clr    idle      reset idle/running flag  F06B 7F   0127     rsche2    clr    chproc    reset change flag >F06E 17   0025               lbsr   getjob    get a new task  F071 26   0C                 bne    rsche3    find one?  F073 86   7F       05        lda    #127      set higheset priority  F075 B7   0126               sta    jobpri    set as current  F078                         clri   clear     interrupts                     * idle work could go on here  F07A 12                      nop  F07B                         seti  F07D 20   EC                 bra    rsche2    loop til find a ready one  F07F F7   0126     rsche3    stb    jobpri    set new priority  F082 8D   07                 bsr    swtchu    switch users top page  F084 BE   0124               ldx    utask     point to task                     ** -- I don't think this will ever happen                     ** tst tssgnl,x any waiting signals?                     ** lbne sleep yes - this will blow task away...  F087 CC   0001               ldd    #1        return 1 to new task  F08A 39                      rts              return                                          *                     * Switch users                     *   X - Task entry for new task                     *  F08B 35   20       swtchu    puls   y         get return addressTask Structure                       13:32:52  Feb 27, 1985   Page   68Scheduler routines                                    F08D BF   0124               stx    utask     set up new running task  F090 10EE 88 10              lds    umark0,x  reset stack  F094 6E   A4       10        jmp    0,y       return to caller                                          Task Structure                       13:32:52  Feb 27, 1985   Page   69Scheduler routines                                                                            *                     * getjob                     *                     * Search ready list for ready task.  If none found,                     * return 'EQ' status.  Otherwise return task table                     * entry address in x.                     *                       F096 5F            getjob    clrb             clear flag  F097 BE   011E               ldx    runlst    point to head of list  F09A 27   1F                 beq    getjo6    empty list?  F09C A6   04       getjo1    lda    tsstat,x  get status byte  F09E 81   01                 cmpa   #TRUN     is it in run state?  F0A0 26   1B                 bne    getjo8  F0A2 5D                      tstb             first in list?  F0A3 27   06                 beq    getjo2  F0A5 EC   84                 ldd    tslink,x  remove from list  F0A7 ED   A4                 std    tslink,y  F0A9 20   07                 bra    getjo4  F0AB 10AE 84       getjo2    ldy    tslink,x  remove from list head  F0AE 10BF 011E               sty    runlst    set new head  F0B2 E6   05       getjo4    ldb    tsprir,x  get priority  F0B4 6F   84                 clr    tslink,x  zero out link  F0B6 6F   01                 clr    tslink+1,x so not run list  F0B8 86   FF                 lda    #$ff      set ne status  F0BA 39                      rts              return  F0BB 4F            getjo6    clra             set eq status  F0BC 39                      rts  F0BD 1F   12       getjo8    tfr    x,y       save old pos  F0BF AE   84                 ldx    tslink,x  follow link  F0C1 27   F8                 beq    getjo6  F0C3 C6   01                 ldb    #1        set flag  F0C5 20   D5                 bra    getjo1    repeat loop                     Task Structure                       13:32:53  Feb 27, 1985   Page   70Scheduler routines                                                                            *                     * putrun                     *                     * Put current task on ready list.  The list is                     * arranged with higher priority tasks at the top.                     * If equal priorities are found, the new one is                     * put at the end of the block.  On entry, x points                     * to the task table entry.  All registers are                     * destroyed except x.                     *                       F0C7 34   01       putrun    pshs   cc        save status  F0C9                         seti   mask      interrupts  F0CB 10BE 011E               ldy    runlst    point to head  F0CF 26   0A                 bne    putru2  F0D1 BF   011E               stx    runlst    set new head  F0D4 CC   0000     putru1    ldd    #0        set last link  F0D7 ED   84                 std    tslink,x  F0D9 35   81                 puls   cc,pc     return  F0DB E6   05       putru2    ldb    tsprir,x  get priority  F0DD E1   25                 cmpb   tsprir,y  look for correct prior slot  F0DF 2F   08                 ble    putru4  F0E1 FC   011E               ldd    runlst  F0E4 BF   011E               stx    runlst    set new head  F0E7 20   0F                 bra    putru5    link in rest  F0E9 1F   23       putru4    tfr    y,u       save last look  F0EB 10AE A4                 ldy    tslink,y  follow link  F0EE 27   0C                 beq    putru6  F0F0 E1   25                 cmpb   tsprir,y  check priority  F0F2 2F   F5                 ble    putru4  F0F4 EC   C4                 ldd    tslink,u  link into list here  F0F6 AF   C4                 stx    tslink,u  F0F8 ED   84       putru5    std    tslink,x  F0FA 35   81                 puls   cc,pc     return  F0FC AF   C4       putru6    stx    tslink,u  F0FE 20   D4                 bra    putru1    go zero last link                     Task Structure                       13:32:53  Feb 27, 1985   Page   71Scheduler routines                                                                            *                     * makrdy                     *                     * Make a task ready to run.  Enter with x                     * pointing to task table entry.  If new tasks                     * priority is higher than current, set the                     * 'chproc' flag so the system can change tasks.                     *                       F100 86   01       makrdy    lda    #TRUN     set status  F102 A7   04                 sta    tsstat,x  F104 CC   0000               ldd    #0        clear events flag  F107 ED   06                 std    tsevnt,x  F109 8D   BC                 bsr    putrun    put on ready list  F10B E6   05                 ldb    tsprir,x  get priority  F10D F1   0126               cmpb   jobpri    higher than current?  F110 2F   03                 ble    makrd6  F112 7C   0127               inc    chproc    set change flag  F115 39            makrd6    rts              returnTask Structure                       13:32:54  Feb 27, 1985   Page   72Sleep and Wakeup routines                                                                     *                     * wakeup                     *                     * Wakeup all tasks waiting the event designated                     * in the y register.  The x reg is preserved.                     *                       F116 34   57       wakeup    pshs   cc,d,x,u  save registers  F118                         seti   mask      interupts  F11A CE   0120               ldu    #slplst  F11D AE   42                 ldx    tsslnk,u  point to sleep list  F11F 27   0B                 beq    wakeu4  F121 10AC 06       wakeu2    cmpy   tsevnt,x  check event  F124 27   08                 beq    wakeu5  F126 33   84                 leau   0,x       mark this entry  F128 AE   02       wakeu3    ldx    tsslnk,x  follow chain  F12A 26   F5                 bne    wakeu2    end of list?  F12C 35   D7       wakeu4    puls   cc,d,x,u,pc return  F12E 34   70       wakeu5    pshs   x,y,u     save registers  F130 EC   02                 ldd    tsslnk,x  remove from list  F132 ED   42                 std    tsslnk,u  F134 8D   CA                 bsr    makrdy    put on ready list  F136 35   70                 puls   u,x,y  F138 20   EE                 bra    wakeu3    repeat                     Task Structure                       13:32:54  Feb 27, 1985   Page   73Sleep and Wakeup routines                                                                     *                     * sleep                     *                     * Sleep will put this task to sleep with priority                     * specified in the b register.  On entry, y is pointing                     * to the event which will be awakened.                     *                                            F13A 34   51       sleep     pshs   cc,x,u    save registers  F13C BE   0124               ldx    utask     point to task  F13F 6D   09       10        tst    tssgnl,x  any signals waiting?  F141 26   1F                 bne    sleep7  F143                         seti   mask      ints  F145 E7   05                 stb    tsprir,x  set priority  F147 10AF 06                 sty    tsevnt,x  set event  F14A 86   02                 lda    #TSLEEP   set status  F14C A7   04                 sta    tsstat,x  F14E FC   0122               ldd    slplst+tsslnk get head of list  F151 ED   02                 std    tsslnk,x  set new link  F153 BF   0122               stx    slplst+tsslnk set new head  F156 17   FF01               lbsr   rsched    reschedule cpu  F159 BE   0124     20        ldx    utask     get task entry  F15C 6D   09                 tst    tssgnl,x  any signals waiting?  F15E 26   02                 bne    sleep7  F160 35   D1                 puls   cc,x,u,pc return  F162 BE   0124     sleep7    ldx    utask     reset signal  F165 6F   09                 clr    tssgnl,x  F167 EC   88 12              ldd    umark1,x  stack reset point  F16A 35   51                 puls   cc,x,u    reset cc and registers  F16C 1F   04                 tfr    d,s       change stacks  F16E 39                      rts              returnTask Structure                       13:32:55  Feb 27, 1985   Page   74Sleep and Wakeup routines                                                                     *                     * xmtint - Send an interrupt to a task                     *  X - Task entry                     *  jsr xmtint                     *  F16F 34   76       xmtint    pshs   d,x,y,u   save registers  F171 A6   04                 lda    tsstat,x  get task state  F173 81   01                 cmpa   #TRUN     running?  F175 26   06                 bne    10f       no - try something else  F177 86   01                 lda    #1        set signal  F179 A7   09                 sta    tssgnl,x  F17B 20   0E                 bra    99f       exit  F17D 81   02       10        cmpa   #TSLEEP   task sleeping?  F17F 26   0A                 bne    99f       no - can't send interrupt  F181 86   01                 lda    #1        set signal  F183 A7   09                 sta    tssgnl,x  F185 10AE 06                 ldy    tsevnt,x  wake task up >F188 17   FF8B               lbsr   wakeup  F18B 35   F6       99        puls   d,x,y,u,pc returnTask Structure                       13:32:55  Feb 27, 1985   Page   75Clist - Get & Put Char Code                                                                   *                     * getc                     *                     * Get a character from a specified character q.                     * The q is pointed to by y upon entry.  The char                     * is returned in b.                     *                       F18D 34   15       getc      pshs   x,b,cc    save x  F18F                         seti  F191 AE   21                 ldx    clfst,y   get first pointer  F193 27   3A                 beq    getc4  F195 E6   80                 ldb    0,x+      get character  F197 E7   61                 stb    1,s  F199 AF   21                 stx    clfst,y   save new ptr  F19B 6A   A4                 dec    clcnt,y   dec the count  F19D 26   09                 bne    getc1  F19F CC   0000               ldd    #0        zero pointers  F1A2 ED   21                 std    clfst,y  F1A4 ED   23                 std    cllst,y  F1A6 20   0E                 bra    getc2  F1A8 1F   10       getc1     tfr    x,d  F1AA C5   1F                 bitb   #CBSIZE-1 check pointer  F1AC 26   1C                 bne    getc3  F1AE EC   88 E0              ldd    -CBSIZE,x  F1B1 C3   0002               addd   #2  F1B4 ED   21                 std    clfst,y   set new first  F1B6 1F   10       getc2     tfr    x,d  F1B8 83   0001               subd   #1  F1BB C4   E0                 andb   #!(CBSIZE-1) check pointer  F1BD 1F   01                 tfr    d,x       reset  F1BF FC   0128               ldd    cfreel    get free block  F1C2 ED   84                 std    0,x       set link  F1C4 BF   0128               stx    cfreel  F1C7 7A   012A               dec    cbufct    dec the buffer count  F1CA 35   01       getc3     puls   cc  F1CC 4F                      clra  F1CD 35   94                 puls   b,x,pc  F1CF 35   01       getc4     puls   cc  F1D1 86   FF                 lda    #$ff      set -1  F1D3 35   94                 puls   b,x,pc                     Task Structure                       13:32:56  Feb 27, 1985   Page   76Clist - Get & Put Char Code                                                                   *                     * putc                     *                     * Put a character on the specified q.  The q is                     * pointed to by y upon entry and the character                     * should be in b.                     *                       F1D5 34   15       putc      pshs   x,b,cc  F1D7                         seti  F1D9 AE   23                 ldx    cllst,y   get tail pointer  F1DB 26   16                 bne    putc1  F1DD BE   0128               ldx    cfreel    get free list  F1E0 27   43                 beq    putc4  F1E2 EC   84                 ldd    0,x       pickup pointer  F1E4 FD   0128               std    cfreel  F1E7 7C   012A               inc    cbufct    update buffer count  F1EA CC   0000               ldd    #0        zero fwd link  F1ED ED   81                 std    0,x++  F1EF AF   21                 stx    clfst,y   set first  F1F1 20   23                 bra    putc2  F1F3 1F   10       putc1     tfr    x,d       mask pointer  F1F5 C5   1F                 bitb   #CBSIZE-1  F1F7 26   1D                 bne    putc2  F1F9 34   20                 pshs   y  F1FB 10BE 0128               ldy    cfreel    get free list  F1FF 27   22                 beq    putc3  F201 EC   A4                 ldd    0,y       get pointer  F203 FD   0128               std    cfreel    save new head  F206 7C   012A               inc    cbufct    update buffer count  F209 10AF 88 E0              sty    -CBSIZE,x  F20D 1F   21                 tfr    y,x  F20F 35   20                 puls   y  F211 CC   0000               ldd    #0        clear fwd link  F214 ED   81                 std    0,x++  F216 E6   61       putc2     ldb    1,s       get character  F218 E7   80                 stb    0,x+      put in q  F21A AF   23                 stx    cllst,y   save last ptr  F21C 6C   A4                 inc    clcnt,y   update character count  F21E 35   01                 puls   cc  F220 4F                      clra  F221 35   94                 puls   b,x,pc    return  F223 35   20       putc3     puls   y  F225 35   01       putc4     puls   cc  F227 86   FF                 lda    #$ff      set error  F229 35   94                 puls   b,x,pc                     Task Structure                       13:32:56  Feb 27, 1985   Page   77Output Q Handling                                                                             *                     * get_oq                     *                     * Fetch the next character from the output Q                     *   Y - Output Queue Header                     *   jsr get_oq                     *   B - Character                     *   <EQ> if Queue was not empty                     *  F22B 34   13       get_oq    pshs   cc,a,x    save registers  F22D                         seti   no        interrupts allowed!  F22F EC   A4                 ldd    oq_count,y  F231 27   16                 beq    20f       Queue empty  F233 83   0001               subd   #1  F236 ED   A4                 std    oq_count,y update counter  F238 AE   26                 ldx    oq_get,y  source pointer  F23A E6   80                 ldb    ,x+       get data  F23C AC   28                 cmpx   oq_end,y  buffer overflow?  F23E 25   02                 blo    10f       no - continue  F240 AE   22                 ldx    oq_buf,y  yes - reset pointer  F242 AF   26       10        stx    oq_get,y  update pointer  F244 35   01                 puls   cc  F246 4F                      clra             Queue not empty  F247 35   92                 puls   a,x,pc    return  F249 35   01       20        puls   cc  F24B 86   FF                 lda    #$FF      Queue empty  F24D 35   92                 puls   a,x,pc                     Task Structure                       13:32:57  Feb 27, 1985   Page   78Output Q Handling                                                                             *                     * put_oq                     *                     * Put a character into an output Q                     *    Y - Output Q header                     *    B - Character to insert                     *    jsr put_oq                     *  F24F 34   17       put_oq    pshs   cc,d,x    save registers  F251                         seti   no        interrupts  F253 AE   24                 ldx    oq_put,y  get pointer  F255 E7   80                 stb    ,x+       put data into Q  F257 AC   28                 cmpx   oq_end,y  buffer overflow?  F259 25   02                 blo    10f       no - continue  F25B AE   22                 ldx    oq_buf,y  yes - reset pointer  F25D AF   24       10        stx    oq_put,y  save new pointer  F25F EC   A4                 ldd    oq_count,y update count  F261 C3   0001               addd   #1  F264 ED   A4                 std    oq_count,y  F266 35   97                 puls   cc,d,x,pc returnTask Structure                       13:32:57  Feb 27, 1985   Page   79Terminal Drivers                                                                              *                     * The routines in this file make up the main system                     * terminal drivers.  Most of the work is actually                     * performed by other internal routines.                     *                                          *                     * ttopn                     *                     * Open a terminal for use.  On entry, D has                     * the device number.                     *                       F268 34   06       ttopn     pshs   d         save device number  F26A 8D   67                 bsr    ttftab    get table address  F26C A6   88 11              lda    tstate,x  get states  F26F 85   04                 bita   #TOPEN    is it already open?  F271 26   02                 bne    ttopn8  F273 8D   08                 bsr    ttdopn    do actual open  F275 10AE 06       ttopn8    ldy    taddr,x   point to device  F278 AD   D8 30              jsr    [D_ttenr,u] enable rcv interrupts  F27B 35   86                 puls   d,pc      return                                                               *                     * ttdopn                     *                     * Do actual terminal open.  X points to tty entry.                     *                       F27D 10AE 06       ttdopn    ldy    taddr,x   get device address  F280 6F   88 13              clr    tstate3,x  F283 AD   D8 26    10        jsr    [D_ttconf,u] configure the port                     * response of NE implies open OK                     * if EQ then blocked by CTS if Carry is 0  F286 26   18                 bne    ttdop6    is it ready?  F288 25   0B                 bcs    ttdop5    branch if blocked by DCD  F28A 34   31                 pshs   cc,x,y    save regs  F28C                         seti   mask      ints  F28E AD   D8 4A              jsr    [D_ttwcts,u] wait for CTS  F291 35   31                 puls   cc,x,y    reset regs  F293 20   E8                 bra    ttdopn    repeat open  F295 34   31       ttdop5    pshs   cc,x,y    save regs  F297                         seti   mask      ints  F299 AD   D8 4C              jsr    [D_ttwdcd,u] wait for DCD  F29C 35   31                 puls   cc,x,y    reset regs  F29E 20   DD                 bra    ttdopn    repeat open  F2A0 86   36       ttdop6    lda    #ECHO|XTABS|CRMOD|BSECH  F2A2 A7   08                 sta    tflags,x  setup initial mode  F2A4 86   08                 lda    #BSPCH    get backspace char  F2A6 A7   0D                 sta    tbksp,x   save in tableTask Structure                       13:32:58  Feb 27, 1985   Page   80Terminal Drivers                                      F2A8 86   18                 lda    #CNCLC    get cancel character  F2AA A7   0E                 sta    tcncl,x   save in table  F2AC A6   88 11              lda    tstate,x  set OPEN flag  F2AF 8A   04                 ora    #TOPEN    set open status  F2B1 A7   88 11              sta    tstate,x  save in table  F2B4 86   01                 lda    #DSR_OK   allow transmitting  F2B6 A7   88 12              sta    tstate2,x  F2B9 39                      rts              return                     Task Structure                       13:32:58  Feb 27, 1985   Page   81Terminal Drivers                                                                              *                     * ttcls                     *                     * Close the terminal whode device number is in D.                     *                       F2BA 8D   17       ttcls     bsr    ttftab    find table entry  F2BC 17   0391               lbsr   flusho    flush out buffers  F2BF A6   88 11              lda    tstate,x  clear state bits  F2C2 84   F8                 anda   #PROTOCOL preserve protocol flags  F2C4 A7   88 11              sta    tstate,x  F2C7 6F   88 12              clr    tstate2,x  F2CA 6F   88 13              clr    tstate3,x  F2CD 10AE 06                 ldy    taddr,x   get device address  F2D0 6E   D8 34              jmp    [D_ttenno,u] close down the port                                          *                     * ttftab                     *                     * Find tty table entry associated with device in D.                     * Exit with entry pointed at by X.                     * Also compute device handler table in U.                     *                       F2D3 34   06       ttftab    pshs   d  F2D5 BE   028F               ldx    TTYTABS   point to table  F2D8 86   1F                 lda    #TTYSIZ   set size up  F2DA 3D                      mul              calculate offset  F2DB 30   8B                 leax   d,x       point to entry  F2DD 35   06                 puls   d  F2DF CE   029D               ldu    #dev_tab  F2E2 86   04                 lda    #DEV_SIZE  F2E4 3D                      mul  F2E5 33   CB                 leau   d,u  F2E7 EE   42                 ldu    dev_type,u get handler table address  F2E9 39                      rts              return                                          Task Structure                       13:32:59  Feb 27, 1985   Page   82Terminal Drivers                                                                              *                     * tintr                     *                     * TTY interrupt handler.  Determine if the interrupt                     * is a receive or transmit one and take appropriate                     * actions.                     *                       F2EA 8D   E7       tintr     bsr    ttftab    calculate table addresses  F2EC 10AE 06                 ldy    taddr,x   get device address  F2EF 34   20       01        pshs   y         save port address  F2F1 EC   64                 ldd    4,s       fetch device status (if present)  F2F3 AD   D8 3C              jsr    [D_tttstr,u] test for rcv int  F2F6 26   20                 bne    tintr2  F2F8 AD   D8 3E              jsr    [D_tttstb,u] test for break interrupt  F2FB 26   39                 bne    tintr5  F2FD AD   D8 42              jsr    [D_tttstc,u] test drop carrier int  F300 26   3C                 bne    tintr6  F302 AD   D8 40              jsr    [D_tttsts,u] test CTS change interrupt  F305 26   5F                 bne    tintr9  F307 AD   D8 44              jsr    [D_tttstd,u] test dsr change  F30A 26   41                 bne    tintr8  F30C AD   D8 46              jsr    [D_tttste,u] test error int  F30F 26   35                 bne    tintr7    ** should be 7? **  F311 AD   D8 38              jsr    [D_tttstx,u] test for xmit int  F314 26   0A                 bne    tintr3  F316 20   4E                 bra    tintr9  F318 AD   D8 2A    tintr2    jsr    [D_ttgetc,u] get character from port  F31B BD   F52E               jsr    ttyin     go buffer char  F31E 20   46                 bra    tintr9  F320 BD   F42A     tintr3    jsr    ttyst     go output another char  F323 EC   98 04              ldd    [tqout,x] check queue count  F326 27   06                 beq    tintr4  F328 10B3 0109               cmpd   OQLO      low water mark?  F32C 26   38                 bne    tintr9  F32E 10AE 04       tintr4    ldy    tqout,x   get output queue  F331 BD   F116               jsr    wakeup  F334 20   30                 bra    tintr9  F336 CC   0002     tintr5    ldd    #INTS     set INT interrupt  F339 BD   D62E               jsr    send_TI   send interrupt  F33C 20   28                 bra    tintr9  F33E CC   0001     tintr6    ldd    #HANGS    set hangup unt  F341 BD   D62E               jsr    send_TI   send interrupt  F344 20   20                 bra    tintr9  F346 C6   07       tintr7    ldb    #$07      set bell char  F348 BD   F52E               jsr    ttyin     go buffer it  F34B 20   19                 bra    tintr9    exit  F34D A6   88 12    tintr8    lda    tstate2,x get state  F350 85   01                 bita   #DSR_OK   was it OK to send before?  F352 27   0A                 beq    85f       no - must be now  F354 84   FE                 anda   #!DSR_OK  don't allow any sendingTask Structure                       13:32:59  Feb 27, 1985   Page   83Terminal Drivers                                      F356 A7   88 12              sta    tstate2,x  F359 AD   D8 2E              jsr    [D_ttdisx,u] disable transmitter  F35C 20   08                 bra    tintr9    exit  F35E 8A   01       85        ora    #DSR_OK   allow transmitting  F360 A7   88 12              sta    tstate2,x  F363 BD   F412               jsr    ttyren    restart transmission  F366 35   20       tintr9    puls   y         restore port address  F368 6E   D8 48              jmp    [D_ttend,u] clean up the port & return                     Task Structure                       13:33:00  Feb 27, 1985   Page   84Terminal Drivers                                                                              *                     * ttyset/ttyget                     *                     * Handle the actual get or put of data for ttyset                     * and ttyget.                     *                       F36B 17   FF65     ttyset    lbsr   ttftab    get tty table address  F36E 17   E0CD               lbsr   FIFOgeta  move data from FIFO  F371 E6   08                 ldb    tflags,x  save current flags  F373 A7   08                 sta    tflags,x  set flags  F375 C5   41                 bitb   #RAW|SCHR currently in RAW or Single Character mode?  F377 26   20                 bne    10f       yes - no change  F379 85   41                 bita   #RAW|SCHR going to one of those modes?  F37B 27   1C                 beq    10f       no - continue  F37D 6D   94                 tst    [tqin,x]  any unsolicited input?  F37F 27   06                 beq    00f       no - continue  F381 6D   0B                 tst    tdel,x    any delimiters?  F383 27   02                 beq    00f  F385 6C   0B                 inc    tdel,x    force a delimiter  F387 85   01       00        bita   #RAW      going into RAW mode?  F389 27   0E                 beq    10f       no  F38B A6   88 11              lda    tstate,x  yes - no HOLD processing in RAW mode  F38E 85   02                 bita   #HOLD     currently holding?  F390 27   07                 beq    10f       no - continue  F392 84   FD                 anda   #!HOLD  F394 A7   88 11              sta    tstate,x  F397 8D   79                 bsr    ttyren    kick output  F399 17   E0A2     10        lbsr   FIFOgeta  move data from FIFO  F39C A7   09                 sta    tdelay,x  set delays  F39E 17   E09D               lbsr   FIFOgeta  move data from FIFO  F3A1 A7   0E                 sta    tcncl,x   set cancel char  F3A3 17   E098               lbsr   FIFOgeta  move data from FIFO  F3A6 A7   0D                 sta    tbksp,x   set back space char  F3A8 17   E093               lbsr   FIFOgeta  move data from FIFO  F3AB 84   7F                 anda   #$7F  F3AD A7   0F                 sta    tbaud,x   set bauds  F3AF 17   E08C               lbsr   FIFOgeta  move data from FIFO  F3B2 34   02                 pshs   a  F3B4 84   F8                 anda   #PROTOCOL save protocol bits  F3B6 34   02                 pshs   a  F3B8 A6   88 11              lda    tstate,x  update state  F3BB 84   07                 anda   #(!PROTOCOL)&$FF clear current bits  F3BD AA   E0                 ora    ,s+       set new bits  F3BF A7   88 11              sta    tstate,x  F3C2 35   02                 puls   a  F3C4 84   0F                 anda   #$0F      get baud rate  F3C6 34   02                 pshs   a  F3C8 A6   88 10              lda    tbaud2,x  update baud rate  F3CB 84   F0                 anda   #$F0  F3CD AA   E0                 ora    ,s+Task Structure                       13:33:00  Feb 27, 1985   Page   85Terminal Drivers                                      F3CF A7   88 10              sta    tbaud2,x  F3D2 C6   06                 ldb    #R_TTY    return TTYSET OK  F3D4 39                      rts              return                                            F3D5 17   FEFB     ttyget    lbsr   ttftab    get table address  F3D8 A6   08                 lda    tflags,x  get flags byte  F3DA 17   E086               lbsr   FIFOputa  put data into FIFO  F3DD A6   09                 lda    tdelay,x  get delays  F3DF 17   E081               lbsr   FIFOputa  put data into FIFO  F3E2 A6   0E                 lda    tcncl,x   get cancel char  F3E4 17   E07C               lbsr   FIFOputa  put data into FIFO  F3E7 A6   0D                 lda    tbksp,x   get b.s. char  F3E9 17   E077               lbsr   FIFOputa  put data into FIFO  F3EC A6   0F                 lda    tbaud,x   get bauds  F3EE 84   7F                 anda   #$7F  F3F0 6D   0B                 tst    tdel,x    check delimiter count  F3F2 26   05                 bne    ttys45  F3F4 6D   98 02              tst    [tqproc,x] any chars in processed queue?  F3F7 27   02                 beq    ttysg5  F3F9 8A   80       ttys45    ora    #%10000000 set del bit  F3FB 17   E065     ttysg5    lbsr   FIFOputa  put data into FIFO  F3FE A6   88 11              lda    tstate,x  return protocol bits  F401 84   F8                 anda   #PROTOCOL  F403 34   02                 pshs   a  F405 A6   88 10              lda    tbaud2,x  get baud rate  F408 84   0F                 anda   #$0F  F40A AA   E0                 ora    ,s+  F40C 17   E054               lbsr   FIFOputa  put data into FIFO  F40F C6   06                 ldb    #R_TTY    response = TTYGET = OK  F411 39                      rts              returnTask Structure                       13:33:01  Feb 27, 1985   Page   86TTY Handlers                                                                                  *                     * All code in this section is the common tty handler                     * code.  The device dependent code resides with the                     * drivers.  This handler package requires an ACIA be used                     * for all character type devices.                     *                                                               *                     * ttyren                     *                     * Re-enable the tty output after a timeout operation.                     * Upon entry, x should point to the tty structure.                     *                       F412               ttyren  F412 A6   88 11              lda    tstate,x  check state  F415 85   02                 bita   #HOLD >F417 1026 0056               lbne   ttyst9  F41B 84   FE                 anda   #!TIMOUT  clear time out  F41D A7   88 11              sta    tstate,x  reset state  F420 10AE 06                 ldy    taddr,x >F423 1027 0036               lbeq   ttys55  F427 AD   D8 2C              jsr    [D_ttenxr,u] enable xmit interrupts                                          Task Structure                       13:33:01  Feb 27, 1985   Page   87TTY Handlers                                                                                  *                     * ttyst                     *                     * TTY start will output a character to the terminal.                     * Upon entry, x should point to the tty structure in                     * use.  Getc is called for the character.                     *                       F42A A6   88 12    ttyst     lda    tstate2,x is it ok to transmit?  F42D 85   01                 bita   #DSR_OK >F42F 1027 003E               lbeq   ttyst9    no - wait until it is  F433 10AE 06                 ldy    taddr,x   get device address  F436 27   25                 beq    ttys55  F438 AD   D8 36              jsr    [D_ttxbsy,u] test xmit busy?  F43B 27   20                 beq    ttys55  F43D A6   88 11    ttyst1    lda    tstate,x  F440 85   01                 bita   #TIMOUT >F442 1026 002B               lbne   ttyst9  F446               ttyst15  F446 10AE 04                 ldy    tqout,x   get out q  F449 17   FDDF               lbsr   get_oq    get character  F44C 26   23                 bne    ttyst9    exit if queue empty  F44E A6   08                 lda    tflags,x  F450 85   01                 bita   #RAW      test raw mode  F452 26   03                 bne    ttyst2  F454 5D                      tstb             char negative?  F455 2B   07                 bmi    ttyst6  F457 10AE 06       ttyst2    ldy    taddr,x   get device address  F45A 6E   D8 28              jmp    [D_ttputc,u] write characetr  F45D 39            ttys55    rts  F45E A6   88 11    ttyst6    lda    tstate,x  F461 85   60                 bita   #XANY|XONXOF HOLD processing enabled?  F463 26   04                 bne    ttyst65   yes  F465 85   80                 bita   #ESCOFF   ESCape HOLD disabled?  F467 26   F4                 bne    ttys55    yes - ignore HOLD character  F469 A6   88 11    ttyst65   lda    tstate,x  get states  F46C 8A   03                 ora    #TIMOUT|HOLD set hold mode  F46E A7   88 11              sta    tstate,x  reset states  F471 10AE 06       ttyst9    ldy    taddr,x   get port  F474 6E   D8 2E              jmp    [D_ttdisx,u] disable xmit interrupts                     Task Structure                       13:33:02  Feb 27, 1985   Page   88TTY Handlers                                                                                  *                     * ttyout                     *                     * Put the character in b into the output q.  Upon                     * entry, x should point to the tty structure.  Tab                     * expansions, upper case mapping, and special character                     * handling are all done here.                     *                       F477 A6   08       ttyout    lda    tflags,x  get flags  F479 85   01                 bita   #RAW      raw mode?  F47B 27   11                 beq    ttyo12  F47D A6   88 11              lda    tstate,x  no hold in RAW mode  F480 84   FD                 anda   #!HOLD  F482 A7   88 11              sta    tstate,x  F485 10AE 04                 ldy    tqout,x   point to out q  F488 17   FDC4               lbsr   put_oq    put char in q  F48B 16   0087               lbra   ttyoue    go finish  F48E C1   FF       ttyo12    cmpb   #$ff      special hold char?  F490 27   53                 beq    ttyou6  F492 C4   7F                 andb   #$7f      mask parity bit  F494 C1   09                 cmpb   #TABCH  F496 26   11                 bne    ttyou2  F498 A6   08                 lda    tflags,x  check mode  F49A 85   04                 bita   #XTABS    expand tabs?  F49C 27   0B                 beq    ttyou2  F49E C6   20       ttyo14    ldb    #SPACE  F4A0 8D   D5                 bsr    ttyout    output it  F4A2 A6   0C                 lda    tcolm,x   check column  F4A4 85   07                 bita   #7  F4A6 26   F6                 bne    ttyo14  F4A8 39                      rts  F4A9 A6   08       ttyou2    lda    tflags,x  check mode  F4AB 85   08                 bita   #LCASE    lower case mode?  F4AD 27   25                 beq    ttyou4  F4AF C1   61                 cmpb   #'a       lower case letter?  F4B1 25   08                 blo    ttyo22  F4B3 C1   7A                 cmpb   #'z  F4B5 22   04                 bhi    ttyo22  F4B7 C0   20                 subb   #$20      make upper  F4B9 20   19                 bra    ttyou4  F4BB 108E F523     ttyo22    ldy    #lcht     point to map  F4BF E1   A1       ttyo23    cmpb   0,y++  F4C1 26   0D                 bne    ttyo24  F4C3 E6   3F                 ldb    -1,y      get mapped char  F4C5 34   04                 pshs   b  F4C7 C6   5C                 ldb    #'\       output escape >F4C9 17   FFAB               lbsr   ttyout  F4CC 35   04                 puls   b  F4CE 20   15                 bra    ttyou6  F4D0 6D   A4       ttyo24    tst    0,y       end of list?Task Structure                       13:33:03  Feb 27, 1985   Page   89TTY Handlers                                          F4D2 26   EB                 bne    ttyo23  F4D4 C1   0D       ttyou4    cmpb   #CR  F4D6 26   0D                 bne    ttyou6  F4D8 A6   08                 lda    tflags,x  check mode  F4DA 85   10                 bita   #CRMOD  F4DC 27   07                 beq    ttyou6  F4DE C6   0A                 ldb    #NL       convert to NL >F4E0 17   FF94               lbsr   ttyout    output it  F4E3 C6   0D                 ldb    #CR       reset CR  F4E5 10AE 04       ttyou6    ldy    tqout,x   point to out q  F4E8 17   FD64               lbsr   put_oq  F4EB C1   0D                 cmpb   #CR  F4ED 22   20                 bhi    ttyou8  F4EF 26   02                 bne    ttyo75    is it cr?  F4F1 6F   0C                 clr    tcolm,x   clear out column count!  F4F3 C1   09       ttyo75    cmpb   #9        is it tab character?  F4F5 26   0A                 bne    ttyo77  F4F7 A6   0C                 lda    tcolm,x   get column count  F4F9 84   F8                 anda   #!7       mask low 3 bits  F4FB 8B   08                 adda   #8        add in tab  F4FD A7   0C                 sta    tcolm,x   save new column  F4FF 20   14                 bra    ttyoue  F501 C1   08       ttyo77    cmpb   #$08      hardware backspace?  F503 25   10                 blo    ttyoue  F505 26   08                 bne    ttyou8  F507 6D   0C                 tst    tcolm,x   column zero?  F509 27   0A                 beq    ttyoue  F50B 6A   0C                 dec    tcolm,x  F50D 20   06                 bra    ttyoue  F50F C1   20       ttyou8    cmpb   #SPACE    is it control char?  F511 25   02                 blo    ttyoue  F513 6C   0C                 inc    tcolm,x   bump column count  F515 A6   88 11    ttyoue    lda    tstate,x  ** kludge for ACIA **  F518 85   02                 bita   #HOLD  F51A 26   06                 bne    ttyoe1  F51C 10AE 06                 ldy    taddr,x   get device address  F51F 6E   D8 2C              jmp    [D_ttenxr,u] enable xmit interrupts  F522 39            ttyoe1    rts              return                       F523 7E 5E 7C 21   lcht      fcc    "~^|!{(})`'"  F52D 00                      fcb    0Task Structure                       13:33:03  Feb 27, 1985   Page   90TTY Handlers                                                                                  *                     * ttyin                     *                     * Place the character in b on the input q.                     * Upon entry, x should point to the tty structure.                     * Signal processing and character mapping are                     * performed in this roiutine.                     *                       F52E               ttyin  F52E A6   08                 lda    tflags,x  raw mode?  F530 85   01                 bita   #RAW  F532 26   51                 bne    ttyi44  F534 C4   7F                 andb   #$7f      mask par bit  F536 C1   20       ttyin0    cmpb   #SPACE    control char?  F538 24   4B                 bhs    ttyi44    skip junk if so  F53A C1   1C       ttyin2    cmpb   #QUITC  F53C 27   09                 beq    ttyi25  F53E C1   03                 cmpb   #INTRC  F540 26   0B                 bne    ttyin3  F542 CC   0002               ldd    #INTS     set signal  F545 20   03                 bra    ttyi27  F547 CC   0003     ttyi25    ldd    #QUITS    set signal  F54A 7E   D62E     ttyi27    jmp    send_TI   send interrupt & get out  F54D A6   88 11    ttyin3    lda    tstate,x  get state  F550 C1   1B                 cmpb   #HOLDC    Escape?  F552 26   10                 bne    ttyi34  F554 85   80                 bita   #ESCOFF   escape processing disabled?  F556 26   27                 bne    ttyin4    yes - ignore ESC as special character  F558 85   02                 bita   #HOLD     holding??  F55A 26   1B                 bne    ttyi36  F55C 8A   03       ttyi33    ora    #TIMOUT|HOLD set HOLDing  F55E A7   88 11              sta    tstate,x  F561 7E   F412               jmp    ttyren  F564 85   40       ttyi34    bita   #XONXOF   doing XON/XOFF processing?  F566 27   17                 beq    ttyin4    no - don't bother  F568 C1   13                 cmpb   #XOFFC    XOFF character?  F56A 26   07                 bne    ttyi35    no  F56C 85   02                 bita   #HOLD     already stopped?  F56E 27   EC                 beq    ttyi33    no - stop output  F570 16   00B4               lbra   ttyin9    ignore XOFF if already stopped!  F573 C1   11       ttyi35    cmpb   #XONC     XON character  F575 26   08                 bne    ttyin4    no - continue                     * -- HOLD off  F577 84   FD       ttyi36    anda   #!HOLD    clear hold mode  F579 A7   88 11              sta    tstate,x  F57C 7E   F412               jmp    ttyren  F57F C1   0D       ttyin4    cmpb   #CR       new line?  F581 26   02                 bne    ttyi44  F583 6F   0C                 clr    tcolm,x   clear out column  F585 A6   88 11    ttyi44    lda    tstate,x  get current stateTask Structure                       13:33:04  Feb 27, 1985   Page   91TTY Handlers                                          F588 85   20                 bita   #XANY     allow any character to restart?  F58A 27   04                 beq    ttyi46    no - continue on  F58C 85   02                 bita   #HOLD     currently stopped?  F58E 26   E7                 bne    ttyi36    yes - go restart it  F590 10AE 84       ttyi46    ldy    tqin,x    input Q pointer  F593 A6   A4                 lda    0,y       check q count  F595 81   FF                 cmpa   #CHRLIM   hit limit?  F597 1024 008D               lbhs   flusht    flush this guy!  F59B B6   012A               lda    cbufct    check buffer count  F59E B1   012B               cmpa   lcbuf  F5A1 1022 0083               lbhi   flusht    if overflow, flush!  F5A5 A6   08       49        lda    tflags,x  check mode  F5A7 85   01                 bita   #RAW      raw mode?  F5A9 27   10                 beq    ttyin5  F5AB 17   FC27               lbsr   putc      put char in q  F5AE 10AE 84                 ldy    tqin,x    get in q  F5B1 34   04                 pshs   b         save char  F5B3 17   FB60               lbsr   wakeup    awaken those waiting  F5B6 35   04                 puls   b         get character  F5B8 6C   0B                 inc    tdel,x    bump delimiter count  F5BA 39                      rts              return  F5BB 85   08       ttyin5    bita   #LCASE  F5BD 27   0A                 beq    ttyin6  F5BF C1   41                 cmpb   #'A       capital letter?  F5C1 25   06                 blo    ttyin6  F5C3 C1   5A                 cmpb   #'Z  F5C5 22   02                 bhi    ttyin6  F5C7 CB   20                 addb   #$20      make lower case  F5C9 10AE 84       ttyin6    ldy    tqin,x    point to input q  F5CC 17   FC06               lbsr   putc  F5CF A6   08                 lda    tflags,x  check mode  F5D1 85   40                 bita   #SCHR     single char mode?  F5D3 26   0A                 bne    ttyi65  F5D5 C1   0D                 cmpb   #CR  F5D7 22   12                 bhi    ttyin7  F5D9 27   04                 beq    ttyi65  F5DB C1   04                 cmpb   #EOTCH  F5DD 26   0C                 bne    ttyin7  F5DF 10AE 84       ttyi65    ldy    tqin,x    point to input q  F5E2 34   04                 pshs   b  F5E4 17   FB2F               lbsr   wakeup    wake up waiting  F5E7 6C   0B                 inc    tdel,x    bump count  F5E9 35   04       ttyi67    puls   b         reset char  F5EB E1   0E       ttyin7    cmpb   tcncl,x   kill character?  F5ED 26   18                 bne    ttyin8  F5EF A6   08                 lda    tflags,x  check mode  F5F1 85   40                 bita   #SCHR     single character?  F5F3 26   12                 bne    ttyin8  F5F5 C6   5E                 ldb    #'^       output '^x\n'  F5F7 17   FE7D               lbsr   ttyout  F5FA C6   78                 ldb    #'x  F5FC 17   FE78               lbsr   ttyoutTask Structure                       13:33:05  Feb 27, 1985   Page   92TTY Handlers                                          F5FF C6   0D                 ldb    #CR  F601 17   FE73               lbsr   ttyout  F604 7E   F42A               jmp    ttyst  F607 A6   08       ttyin8    lda    tflags,x  check mode  F609 85   02                 bita   #ECHO  F60B 27   1A                 beq    ttyin9  F60D E1   0D                 cmpb   tbksp,x   back space?  F60F 26   10                 bne    ttyi85  F611 85   20                 bita   #BSECH    echo bs?  F613 27   0C                 beq    ttyi85  F615 C6   08                 ldb    #$08      set bs  F617 17   FE5D               lbsr   ttyout  F61A C6   20                 ldb    #SPACE    set space  F61C 17   FE58               lbsr   ttyout  F61F C6   08                 ldb    #$08      reset char  F621 17   FE53     ttyi85    lbsr   ttyout    echo character  F624 7E   F42A               jmp    ttyst     start output  F627 39            ttyin9    rts              return                     Task Structure                       13:33:06  Feb 27, 1985   Page   93TTY Handlers                                                                                  *                     * flusht                     *                     * Flush all queues belonging to this terminal.                     *                       F628               flusht >F628 17   005D               lbsr   flushi    flush Input queues  F62B 10AE 04                 ldy    tqout,x   point to out q  F62E 17   FBFA     10        lbsr   get_oq    flush out q  F631 2A   FB                 bpl    10b  F633 10AE 84                 ldy    tqin,x    get input q  F636 17   FADD               lbsr   wakeup    wakeup input q waiters  F639 10AE 04                 ldy    tqout,x   wake up out q waiters  F63C 17   FAD7               lbsr   wakeup  F63F A6   88 11              lda    tstate,x  get states  F642 84   FC                 anda   #!(HOLD|TIMOUT) clear hold mode  F644 A7   88 11              sta    tstate,x  F647 CC   0000               ldd    #0        no pre-sold output  F64A ED   88 15              std    tsold,x  F64D 7E   F42A               jmp    ttyst                                          *                     * flusho                     *                     * Flush all this guys queues after waiting for the                     * output q to empty.                     *                       F650 A6   88 11    flusho    lda    tstate,x  check state  F653 85   02                 bita   #HOLD     holding?  F655 27   08                 beq    fluso1  F657 84   FC       fluso0    anda   #!(HOLD|TIMOUT)  F659 A7   88 11              sta    tstate,x  clear hold  F65C 17   FDB3               lbsr   ttyren    kick output  F65F EC   98 04    fluso1    ldd    [tqout,x] check char count >F662 1027 FFC2               lbeq   flusht  F666 A6   88 11              lda    tstate,x  check for hold  F669 85   02                 bita   #HOLD  F66B 26   EA                 bne    fluso0  F66D 34   10                 pshs   x         save ptr  F66F AE   06                 ldx    taddr,x   get device address  F671 AD   D8 3A              jsr    [D_ttiscts,u] check for CTS  F674 35   10                 puls   x         reset tty ptr >F676 1027 FFAE               lbeq   flusht    if not - just flush the guy  F67A 10AE 04                 ldy    tqout,x   point to out q  F67D C6   EC                 ldb    #TTYOPR   set priority  F67F 34   10                 pshs   x         save x  F681 17   FAB6               lbsr   sleep  F684 35   10                 puls   x  F686 20   D7                 bra    fluso1Task Structure                       13:33:06  Feb 27, 1985   Page   94TTY Handlers                                                                                  *                     * flushi - Flush input Queues only                     *  F688               flushi  F688 10AE 02                 ldy    tqproc,x  get procd q  F68B 17   FAFF     10        lbsr   getc      get character  F68E 2A   FB                 bpl    10b  F690 10AE 84                 ldy    tqin,x    flush input q  F693 17   FAF7     20        lbsr   getc  F696 2A   FB                 bpl    20b  F698 6F   0B                 clr    tdel,x    clear delim count  F69A 39                      rts                                                                                    *                     * xtprcq                     *                     * Transfer characters from input q to procd q.  If not                     * in raw mode, do escape, backspace, and cancel                     * processing.  Enter with x pointing to tty structure.                     *                       F69B 34   01       xtprcq    pshs   cc        save cc  F69D                         seti   mask      ints  F69F 6D   0B                 tst    tdel,x    delimiters yet?  F6A1 26   10                 bne    xtprc0  F6A3 10AE 84                 ldy    tqin,x    sleep on input q  F6A6 C6   F6                 ldb    #TTYIPR  F6A8 34   10                 pshs   x         save x  F6AA 17   FA8D               lbsr   sleep  F6AD 35   10                 puls   x  F6AF 35   01                 puls   cc        reset cc  F6B1 20   E8                 bra    xtprcq  F6B3 35   01       xtprc0    puls   cc        reset cc  F6B5 6D   94                 tst    [tqin,x]  input q empty?  F6B7 26   04                 bne    xtprc1  F6B9 6A   0B                 dec    tdel,x    dec the del count  F6BB 20   DE                 bra    xtprcq    repeat test  F6BD 108E 014D     xtprc1    ldy    #prcbuf+2 point to buffer  F6C1 5F                      clrb  F6C2 34   24                 pshs   b,y       delimiter flag  F6C4 6D   E4       xtprc2    tst    0,s       delimiter?  F6C6 27   10                 beq    xtpr22  F6C8 6F   E4                 clr    0,s       clear del flag  F6CA 6D   0B                 tst    tdel,x    check del count  F6CC 27   02                 beq    xtpr21    if 0 - skip  F6CE 6A   0B                 dec    tdel,x    dec the del count  F6D0 A6   08       xtpr21    lda    tflags,x  get flags  F6D2 85   41                 bita   #RAW|SCHR in raw mode?  F6D4 1027 0081               lbeq   xtprc5Task Structure                       13:33:07  Feb 27, 1985   Page   95TTY Handlers                                          F6D8 10AE 84       xtpr22    ldy    tqin,x    point to in q  F6DB 17   FAAF               lbsr   getc      get a character  F6DE 2B   79                 bmi    xtprc5    none left?  F6E0 C1   0D                 cmpb   #CR       check for delim  F6E2 27   0C                 beq    xtpr25  F6E4 C1   04                 cmpb   #EOTCH  F6E6 26   0A                 bne    xtprc3  F6E8 6C   E4                 inc    0,s       set del flag  F6EA A6   08                 lda    tflags,x  get flags  F6EC 85   40                 bita   #SCHR     single char mode?  F6EE 26   D4                 bne    xtprc2  F6F0 6C   E4       xtpr25    inc    0,s       set del flag  F6F2 A6   08       xtprc3    lda    tflags,x  check mode  F6F4 85   41                 bita   #RAW|SCHR  F6F6 27   04                 beq    xtpr31  F6F8 6C   E4                 inc    0,s       set del flag for each raw char  F6FA 20   4D                 bra    xtpr45  F6FC 10AE 61       xtpr31    ldy    1,s       point to buffer  F6FF A6   3F                 lda    -1,y      check previous  F701 81   5C                 cmpa   #'\       escape?  F703 26   13                 bne    xtca32  F705 C1   04                 cmpb   #EOTCH    is it eot?  F707 27   08                 beq    xtp315  F709 E1   0D                 cmpb   tbksp,x   backspace char?  F70B 27   04                 beq    xtp315  F70D E1   0E                 cmpb   tcncl,x   cancel char?  F70F 26   07                 bne    xtca32  F711 31   3F       xtp315    leay   -1,y      backup over slash  F713 10AF 61                 sty    1,s       save new ptr  F716 20   31                 bra    xtpr45  F718 E1   0D       xtca32    cmpb   tbksp,x   backspace char?  F71A 26   0D                 bne    xtca33  F71C 108C 014D               cmpy   #prcbuf+2 buffer begin?  F720 27   A2                 beq    xtprc2  F722 31   3F                 leay   -1,y      backup pointer  F724 10AF 61                 sty    1,s  F727 20   9B                 bra    xtprc2  F729 C1   04       xtca33    cmpb   #EOTCH    eot char?  F72B 27   97                 beq    xtprc2  F72D E1   0E                 cmpb   tcncl,x   cancel char?  F72F 26   04                 bne    xtprc4  F731 35   24                 puls   b,y       -- caution (order)  F733 20   88                 bra    xtprc1    repeat all  F735 C1   20       xtprc4    cmpb   #$20      check for control char  F737 24   10                 bhs    xtpr45  F739 C1   0D                 cmpb   #CR       is it cr?  F73B 27   0C                 beq    xtpr45  F73D C1   09                 cmpb   #9        is it tab char?  F73F 27   08                 beq    xtpr45  F741 A6   08                 lda    tflags,x  get flags  F743 85   80                 bita   #CNTRL    control char ignore?  F745 1026 FF7B               lbne   xtprc2Task Structure                       13:33:08  Feb 27, 1985   Page   96TTY Handlers                                          F749 10AE 61       xtpr45    ldy    1,s       get pointer  F74C E7   A0                 stb    0,y+      transfer char  F74E 10AF 61                 sty    1,s       save pointer  F751 108C 024B               cmpy   #prcbuf+PRCSIZ overflow??  F755 1025 FF6B               lblo   xtprc2  F759 35   04       xtprc5    puls   b         remove del flag from stack  F75B 10AE 02                 ldy    tqproc,x  get procd q  F75E 34   10                 pshs   x  F760 8E   014D               ldx    #prcbuf+2 point to processed buf  F763 AC   62       xtprc6    cmpx   2,s       end of buffer?  F765 24   07                 bhs    xtprc7  F767 E6   80                 ldb    0,x+      get character  F769 17   FA69               lbsr   putc  F76C 20   F5                 bra    xtprc6  F76E               xtprc7  F76E CC   FFFF               ldd    #-1       set good  F771 35   B0                 puls   x,y,pc    return                     Task Structure                       13:33:08  Feb 27, 1985   Page   97TTY Handlers                                                                                  *                     * req_read - CPU has informed us he wants to read                     * Tell him when some data is available.                     *  F773 17   FB5D     req_read  lbsr   ttftab    get TTY table address  F776 A6   98 02              lda    [tqproc,x] anything available?  F779 26   03                 bne    00f       yes - go use it  F77B 17   FF1D               lbsr   xtprcq    go process input (wait if none there)  F77E A6   98 02    00        lda    [tqproc,x] get input processed count  F781 27   0A                 beq    05f       jump for EOF detected  F783 81   01                 cmpa   #1        special case for single character  F785 27   09                 beq    10f  F787 E6   08                 ldb    tflags,x  single character & RAW always return 1 char  F789 C5   41                 bitb   #RAW|SCHR  F78B 26   03                 bne    10f  F78D C6   07       05        ldb    #R_RDOK   inform CPU data now available  F78F 39                      rts  F790 10AE 02       10        ldy    tqproc,x  go fetch character  F793 17   F9F7               lbsr   getc  F796 86   09                 lda    #R_RD1C   inform CPU single character returned  F798 1E   89                 exg    a,b  F79A 39                      rts                                          *                     * read_data - CPU wants IOP to send data                     *  Max # chars to move in transaction speicific value                     *  F79B 17   FB35     read_data lbsr   ttftab    get TTY table address  F79E FE   0124               ldu    utask     see how many chars to send  F7A1 10AE 02                 ldy    tqproc,x  input queue pointer  F7A4 6F   E2                 clr    ,-s       set FIFO counter  F7A6 A6   A4       10        lda    0,y       any more characters?  F7A8 27   0C                 beq    20f       no - done  F7AA 17   F9E0               lbsr   getc      fetch character  F7AD 17   DCBB               lbsr   FIFO_put  put into FIFO  F7B0 6C   E4                 inc    0,s       bump FIFO count  F7B2 6A   4D                 dec    tstval,u  does the guy want more?  F7B4 26   F0                 bne    10b  F7B6 A6   E0       20        lda    ,s+       get # chars in FIFO  F7B8 C6   08                 ldb    #R_SNDNC  data now available in FIFO  F7BA 6D   A4                 tst    0,y       any more data in case guy wants it?  F7BC 27   02                 beq    30f  F7BE C6   0B                 ldb    #R_SNDMC  yes - special response  F7C0 39            30        rtsTask Structure                       13:33:09  Feb 27, 1985   Page   98TTY Handlers                                                                                  *                     * ttywrt                     *                     * The main terminal write routine.  Control is passed                     * to here from the device driver routine which calculates                     * the ttys structure location and passes it in x.                     *                       F7C1 D6   0B       ttywrt    ldb    fifo_cnt  get FIFO input length  F7C3 C1   00                 cmpb   #0        anything in FIFO?  F7C5 27   0E                 beq    90f       no - exit  F7C7 34   04                 pshs   b         save input length  F7C9 17   DC7B     10        lbsr   FIFO_get  fetch character  F7CC 17   FCA8               lbsr   ttyout    output it  F7CF 6A   E4                 dec    0,s       decrement count  F7D1 26   F6                 bne    10b       repeat  F7D3 35   02                 puls   a         clean up stack  F7D5 34   01       90        pshs   cc        save cc  F7D7                         seti   mask      ints  F7D9 17   FC4E               lbsr   ttyst     give output a kick  F7DC 35   81                 puls   cc,pc     return                                          *                     * open_tty - Perform device open                     *  F7DE               open_tty  F7DE BD   F268               jsr    ttopn     perform tty open  F7E1 C6   02       10        ldb    #R_OPEN  F7E3 39                      rts                                          *                     * close_tty - Perform device close                     *  F7E4               close_tty  F7E4 BD   F2BA               jsr    ttcls     perform tty close  F7E7 C6   03       10        ldb    #R_CLOSE  F7E9 39                      rts                                          *                     * req_write - Request permission to write data                     *  F7EA               req_write  F7EA BD   F2D3               jsr    ttftab    get TTY table  F7ED 34   01       05        pshs   cc        mask interrupts while fiddling  F7EF               10        seti  F7F1 10AE 04                 ldy    tqout,x   get output queue pointer  F7F4 EC   A4                 ldd    oq_count,y get queue length  F7F6 E3   88 15              addd   tsold,x   include any space already sold  F7F9 C3   0080               addd   #FIFO_SIZE and assume the CPU will send this many more  F7FC 10B3 0107               cmpd   OQHI      space available?  F800 2F   16                 ble    20f       yes - OKTask Structure                       13:33:09  Feb 27, 1985   Page   99TTY Handlers                                          F802 A6   09                 lda    tdelay,x  special flush bit?  F804 85   40                 bita   #$40  F806 27   05                 beq    15f       no - go to sleep  F808 BD   F650               jsr    flusho    yes - flush output  F80B 20   E2                 bra    10b       try again  F80D 34   76       15        pshs   d,x,y,u   no - save registers  F80F C6   E2                 ldb    #TTYSPR  F811 BD   F13A               jsr    sleep  F814 35   76                 puls   d,x,y,u   restore registers  F816 20   D7                 bra    10b       try again  F818 10BE 0124     20        ldy    utask     am I supposed to be dead?  F81C 6D   29                 tst    tssgnl,y  F81E 26   0D                 bne    30f       yes - abort  F820 EC   88 15              ldd    tsold,x   update amount pre-sold  F823 C3   0080               addd   #FIFO_SIZE -- assume entire FIFO load  F826 ED   88 15              std    tsold,x  F829 C6   04                 ldb    #R_REQOK  request granted code  F82B 35   81                 puls   cc,pc     return                     *  F82D 35   01       30        puls   cc        clean up stack  F82F 32   62                 leas   2,s       -- pop normal return  F831 39                      rts              abnormal I/O completion (no response)                                          *                     * write_data - Write data to a terminal                     *  F832               write_data  F832 BD   F2D3               jsr    ttftab    get tty table pointer >F835 BD   F7C1               jsr    ttywrt    go consume data  F838 34   01                 pshs   cc        save interrupt state  F83A                         seti   mask      interrupts  F83C EC   88 15              ldd    tsold,x  F83F 83   0080               subd   #FIFO_SIZE  F842 2A   03                 bpl    00f  F844 CC   0000               ldd    #0        don't screw up!  F847 ED   88 15    00        std    tsold,x   update count  F84A 10AE 04                 ldy    tqout,x   wake up anybody waiting for space  F84D BD   F116     10        jsr    wakeup  F850 C6   05                 ldb    #R_WRITE  F852 35   81                 puls   cc,pc     return  F854 0D 46 49 46   00        fcc    $d,'FIFO consumed, wakeup at $',0                                          *                     * Write single character                     *  -- Character passed via transaction message                     *  F870 34   01       wrt_sc    pshs   cc        save interrupt state  F872 BD   F2D3               jsr    ttftab    compute tty table address  F875 10AE 04       00        ldy    tqout,x   output Q pointer  F878 EC   A4                 ldd    oq_count,y check for overrun  F87A 10B3 0107               cmpd   OQHI  F87E 23   12                 bls    10f       jump if spaceTask Structure                       13:33:10  Feb 27, 1985   Page  100TTY Handlers                                          F880 A6   09                 lda    tdelay,x  special flush bit?  F882 85   40                 bita   #$40  F884 27   05                 beq    05f       no - wait for space  F886 BD   F650               jsr    flusho    yes - make space!  F889 20   EA                 bra    00b  F88B C6   EC       05        ldb    #TTYOPR   wait a while  F88D BD   F13A               jsr    sleep  F890 20   E3                 bra    00b       try again  F892 10BE 0124     10        ldy    utask     fetch character  F896 E6   2D                 ldb    tstval,y  F898 BD   F477               jsr    ttyout    send to output queue  F89B                         seti   mask      interrupts  F89D BD   F42A               jsr    ttyst     kick output - make sure it starts  F8A0 C6   05                 ldb    #R_WRITE  F8A2 35   81                 puls   cc,pc     return                                          *                     * send_int - Interrupt all tasks associated with a terminal                     *  F8A4 34   76       send_int  pshs   d,x,y,u  F8A6 BD   F2D3               jsr    ttftab    get TTY table address  F8A9 BD   F628               jsr    flusht    flush terminal buffers  F8AC A6   61                 lda    1,s       get terminal #  F8AE BD   D5CA               jsr    int_all   interrupt all associated tasks  F8B1 BE   0124               ldx    utask     also interrupt current task if appropriate  F8B4 A6   61                 lda    1,s  F8B6 A1   08                 cmpa   tsdev,x  F8B8 26   03                 bne    10f  F8BA BD   F16F               jsr    xmtint  F8BD 35   F6       10        puls   d,x,y,u,pc clean up stack & return                     Task Structure                       13:33:11  Feb 27, 1985   Page  1018274 interface routines                                                                       * The routines in this file are specific to an 8274.                     * They are called from the "ttyhan" and "ttydrv" files.                                          * constants                                    0002  cont      equ    2         control reg               0000  data      equ    0         data reg               0020  CTSBIT    equ    $20       Clear To Send bit in status reg.               0008  DCDBIT    equ    $08       Data Carrier Detect bit in status reg.                                    0000  OPN_WOC   equ    0         -- support for open without carrier                                          *                     * 8274 Device table                     *  F8BF               DEV_8274  F8BF D4D6                    fdb    bad_cmd   0 -  F8C1 F7DE                    fdb    open_tty  1 -  F8C3 F7E4                    fdb    close_tty 2 -  F8C5 F36B                    fdb    ttyset    3 -  F8C7 F3D5                    fdb    ttyget    4 -  F8C9 F7EA                    fdb    req_write 5 -  F8CB F832                    fdb    write_data 6 -  F8CD F870                    fdb    wrt_sc    7 -  F8CF F773                    fdb    req_read  8 -  F8D1 F79B                    fdb    read_data 9 -  F8D3 D4D6                    fdb    bad_cmd   10 -  F8D5 D4D6                    fdb    bad_cmd   11 -  F8D7 D4D6                    fdb    bad_cmd   12 -  F8D9 D4D6                    fdb    bad_cmd   13 -  F8DB D4D6                    fdb    bad_cmd   14 -  F8DD FD13                    fdb    clock_on  15 -  F8DF F90D                    fdb    S4_IRQ  F8E1 F94B                    fdb    S4_init  F8E3 F9A9                    fdb    S4_test                     *  F8E5 FA03                    fdb    S4ttconf  F8E7 FA98                    fdb    S4ttputc  F8E9 FA9B                    fdb    S4ttgetc  F8EB FA9E                    fdb    S4ttenxr  F8ED FAA1                    fdb    S4ttdisx  F8EF FA9F                    fdb    S4ttenr  F8F1 FAA0                    fdb    S4ttenx  F8F3 FAA6                    fdb    S4ttenno  F8F5 FACA                    fdb    S4ttxbsy  F8F7 FACF                    fdb    S4tttstx  F8F9 FAD5                    fdb    S4ttiscts  F8FB FADE                    fdb    S4tttstr  F8FD FAE4                    fdb    S4tttstb  F8FF FAEF                    fdb    S4tttsts  F901 FB16                    fdb    S4tttstcTask Structure                       13:33:12  Feb 27, 1985   Page  1028274 interface routines                               F903 FB13                    fdb    S4tttstd  F905 FB67                    fdb    S4tttste  F907 FB96                    fdb    S4ttend  F909 FBA4                    fdb    S4ttwcts  F90B FBA8                    fdb    S4ttwdcd                                          *                     * S4_IRQ - Interrupt poller/handler for MP-S4 device                     *   D - Device #                     *   X - Device address                     *  F90D 34   76       S4_IRQ    pshs   d,x,y,u   save registers in case no interrupt  F90F C5   01                 bitb   #1        second device? - skip out  F911 26   33                 bne    20f  F913 86   02                 lda    #2        poll the device  F915 A7   03                 sta    3,x  F917 A6   03                 lda    3,x       get response  F919 E6   02                 ldb    2,x  F91B C5   02                 bitb   #%00000010 interrupt pending?  F91D 27   20                 beq    15f       no - jump  F91F 34   06                 pshs   d         place device status on stack for handler  F921 85   04                 bita   #$04      channel B (second device)?  F923 26   08                 bne    12f  F925 30   01                 leax   1,x       get side B address  F927 6C   63                 inc    2+1,s     change device #  F929 E6   02                 ldb    2,x       get proper status for B side  F92B E7   61                 stb    1,s       place on stack  F92D A6   E4       12        lda    0,s  F92F 84   FB                 anda   #!$04  F931 A7   E4                 sta    0,s  F933 EC   62                 ldd    2,s       get device #  F935 BD   F2EA     13        jsr    tintr     go process interrupt  F938 32   62                 leas   2,s       clean up stack (remove device status)  F93A 35   76                 puls   d,x,y,u   clean up stack  F93C 1A   01                 sec              interrupt processed!  F93E 39                      rts  F93F 35   76       15        puls   d,x,y,u   restore registers  F941 5C                      incb             consume 2 slots  F942 33   44                 leau   DEV_SIZE,u  F944 20   02                 bra    99f  F946 35   76       20        puls   d,x,y,u   restore registers  F948 1C   FE       99        clc              no interrupt serviced  F94A 39                      rts                                          *                     * Initialize 8274 port                     *   B - Device number                     *   X - Port address                     *  F94B 34   76       S4_init   pshs   d,x,y,u  F94D C5   01                 bitb   #1        don't initialize B side this way...  F94F 26   39                 bne    30fTask Structure                       13:33:12  Feb 27, 1985   Page  1038274 interface routines                               F951 1F   12                 tfr    x,y       save device port address  F953 BD   F2D3               jsr    ttftab    get TTY table address  F956 86   18                 lda    #$18      send initialize code  F958 A7   22                 sta    2,y  F95A A7   23                 sta    3,y  F95C 34   06                 pshs   d         delay  F95E 35   06                 puls   d  F960 A6   22                 lda    2,y       check response  F962 CE   F98C     00        ldu    #cnfstr   point to configuration string  F965 A6   C0       20        lda    0,u+      send to port  F967 27   21                 beq    30f  F969 2B   0B                 bmi    25f  F96B A7   22                 sta    2,y  F96D E6   C0                 ldb    ,u+  F96F E7   22                 stb    2,y  F971 17   00DA               lbsr   S4_setreg  F974 20   EF                 bra    20b  F976 84   7F       25        anda   #$7F      strip high bit  F978 A7   23                 sta    3,y  F97A E6   C0                 ldb    ,u+  F97C E7   23                 stb    3,y  F97E 34   10                 pshs   x  F980 30   88 1F              leax   TTYSIZ,x  F983 17   00C8               lbsr   S4_setreg  F986 35   10                 puls   x  F988 20   DB                 bra    20b  F98A 35   F6       30        puls   d,x,y,u,pc return                                          * configuration data                       F98C 02 14 04 4C   cnfstr    fcb    $02,$14,$04,$4c,$03,$E1,$05,$ea,$01,$04,$10,$30,$28,$F8  F99A 82 00 84 4C             fcb    $82,$00,$84,$4c,$83,$E1,$85,$ea,$81,$04,$90,$30,$A8,$F8  F9A8 00                      fcb    0                                          *                     * Test for presence of 8274 device                     *   D - Port address                     *   Y - Device table address                     *   CS - Device not an 8274                     *  F9A9 34   56       S4_test   pshs   d,x,u  F9AB 1F   03                 tfr    d,u       get port address  F9AD 86   18                 lda    #$18      send initialize code  F9AF A7   42                 sta    2,u  F9B1 A7   43                 sta    3,u  F9B3 34   06                 pshs   d         delay  F9B5 35   06                 puls   d  F9B7 A6   42                 lda    2,u       check response  F9B9 84   87                 anda   #$87  F9BB 81   04                 cmpa   #$04      check for "xmit buffer empty"  F9BD 27   04                 beq    00f  F9BF 1C   FE                 clcTask Structure                       13:33:13  Feb 27, 1985   Page  1048274 interface routines                               F9C1 20   3E                 bra    99f       exit not an 8274  F9C3 B6   0101     00        lda    NUM_TRM   compute device table address  F9C6 C6   04                 ldb    #DEV_SIZE  F9C8 3D                      mul  F9C9 108E 029D               ldy    #dev_tab  F9CD 31   AB                 leay   d,y  F9CF EC   E4                 ldd    0,s       set device table  F9D1 8E   F8BF               ldx    #DEV_8274  F9D4 ED   A4                 std    dev_addr,y  F9D6 AF   22                 stx    dev_type,y  F9D8 31   24                 leay   DEV_SIZE,y  F9DA C3   0001               addd   #1  F9DD ED   A4                 std    dev_addr,y  F9DF AF   22                 stx    dev_type,y  F9E1 31   24                 leay   DEV_SIZE,y  F9E3 EC   E4                 ldd    0,s  F9E5 C3   0004               addd   #4  F9E8 ED   A4                 std    dev_addr,y  F9EA AF   22                 stx    dev_type,y  F9EC 31   24                 leay   DEV_SIZE,y  F9EE C3   0001               addd   #1  F9F1 ED   A4                 std    dev_addr,y  F9F3 AF   22                 stx    dev_type,y  F9F5 31   24                 leay   DEV_SIZE,y  F9F7 B6   0101               lda    NUM_TRM   count terminals  F9FA 8B   04                 adda   #4  F9FC B7   0101               sta    NUM_TRM  F9FF 1A   01                 sec  FA01 35   D6       99        puls   d,x,u,pc  return                                                               *                     * ttconf                     *                     * Configure the port pointed at by the Y register.  The X                     * register is pointing to the terminal table.  All registers                     * except D should be preserved.                     *                                          *  FA03               S4ttconf  FA03 17   00FF               lbsr   clstat    reset status  FA06 C6   EE                 ldb    #$ee      load configuration byte  FA08 17   00A3               lbsr   setupx    do auto enable and DTR/RTS  FA0B 17   00F7               lbsr   clstat    reset status  FA0E A6   22                 lda    cont,y    read status  FA10 85   20       10        bita   #CTSBIT   is CTS on?  FA12 26   03                 bne    ttcnf2    skip if on  FA14 1C   FE                 clc              Zero bit already set, no Carry->no CTS  FA16 39                      rts  FA17               ttcnf2  FA17 85   08                 bita   #DCDBIT   is DCD on?Task Structure                       13:33:14  Feb 27, 1985   Page  1058274 interface routines                               FA19 26   03                 bne    ttcnf4    skip if on  FA1B 1A   01                 sec              Zero bit already set, Carry->no DCD  FA1D 39                      rts  FA1E               ttcnf4  FA1E A6   0F                 lda    tbaud,x   get port configuration  FA20 84   1C                 anda   #$1C  FA22 44                      lsra  FA23 34   40                 pshs   u  FA25 CE   FA70               ldu    #config_8274  FA28 EE   C6                 ldu    a,u                     *-- Set registers based on configuration  FA2A 86   03                 lda    #3  FA2C C6   3F                 ldb    #$3F  FA2E 8D   2B                 bsr    S4_chgreg                     *  FA30 86   04                 lda    #4  FA32 C6   F0                 ldb    #$F0  FA34 8D   25                 bsr    S4_chgreg                     *  FA36 86   05                 lda    #5  FA38 C6   9F                 ldb    #$9F  FA3A 8D   1F                 bsr    S4_chgreg                     *  FA3C 35   40                 puls   u  FA3E 17   013F               lbsr   reset     reset pending interrupts  FA41 86   01                 lda    #1        select interrupt cntrl reg  FA43 C6   1F                 ldb    #$1F      turn on interrupts  FA45 A7   22                 sta    cont,y  FA47 E7   22                 stb    cont,y  FA49 8D   03                 bsr    S4_setreg  FA4B 16   008D               lbra   S4true    return true                                          *                     * Set 8274 register (image)                     *   A - Register #                     *   B - Value                     *   X - TTY Table                     *   bsr S4_setreg                     *  FA4E 34   10       S4_setreg pshs   x  FA50 81   07                 cmpa   #$07      valid register #  FA52 22   05                 bhi    99f       no - don't screw up...  FA54 30   88 17    10        leax   tregs,x  FA57 E7   86                 stb    a,x  FA59 35   90       99        puls   x,pc      return                                          *                     * Update 8274 register                     *   A - Register #                     *   B - Mask of bits to save                     *   U - Bits to be added                     *   X - TTY Table addressTask Structure                       13:33:14  Feb 27, 1985   Page  1068274 interface routines                                                  *   Y - Port address                     *   bsr S4_chgreg                     *   U modified                     *  FA5B 34   14       S4_chgreg pshs   b,x  FA5D A7   22                 sta    cont,y  FA5F 30   88 17              leax   tregs,x  FA62 30   86                 leax   a,x       point to copy of registers  FA64 E6   84                 ldb    0,x       get old value  FA66 E4   E0       10        andb   ,s+  FA68 EA   C0                 orb    ,u+  FA6A E7   22                 stb    cont,y    set new value  FA6C E7   84                 stb    0,x       save in table  FA6E 35   90       10        puls   x,pc      return                                            FA70               config_8274  FA70 FA80                    fdb    00f       7 Data, 2 Stop, Even  FA72 FA83                    fdb    01f       7 Data, 2 Stop, Odd  FA74 FA86                    fdb    02f       7 Data, 1 Stop, Even  FA76 FA89                    fdb    03f       7 Data, 1 Stop, Odd  FA78 FA8C                    fdb    04f       8 Data, 2 Stop, None  FA7A FA8F                    fdb    05f       8 Data, 1 Stop, None  FA7C FA92                    fdb    06f       8 Data, 1 Stop, Even  FA7E FA95                    fdb    07f       8 Data, 1 Stop, Odd                       FA80 40 0F 20      00        fcb    $40,$0F,$20  FA83 40 0D 20      01        fcb    $40,$0D,$20  FA86 40 07 20      02        fcb    $40,$07,$20  FA89 40 05 20      03        fcb    $40,$05,$20  FA8C C0 0C 60      04        fcb    $C0,$0C,$60  FA8F C0 04 60      05        fcb    $C0,$04,$60  FA92 C0 07 60      06        fcb    $C0,$07,$60  FA95 C0 05 60      07        fcb    $C0,$05,$60                                          *                     * ttputc                     *                     * Send the character in the B register to the ACIA.  All                     * registers should be preserved.  Y points to the device.                     *                       FA98 E7   A4       S4ttputc  stb    data,y    send character  FA9A 39                      rts              return                                                               *                     * ttgetc                     *                     * Get the character from the device and return in the B                     * register.  Y points to the device and all registers                     * should be preserved.Task Structure                       13:33:16  Feb 27, 1985   Page  1078274 interface routines                                                  *                       FA9B E6   A4       S4ttgetc  ldb    data,y    get the character  FA9D 39                      rts                                          *                     * ttenxr                     *                     * Enable the transmit interrupts and leave the receive                     * interrupt enabled (it is enabled upon routine entry).                     * Y points to the device and X points to to the terminal                     * table entry.  Preserve all registers but D.                     *                     *                       FA9E 39            S4ttenxr  rts                                                               *                     * ttenr                     *                     * Enable the receive interrupts only.  The transmit                     * interrupts should be turned off.  Y points to the device                     * and X point to the terminal table entry.  Preserve all                     * but the D register.                     *                       FA9F 39            S4ttenr   rts                                                               *                     * ttenx                     *                     * Enable the transmit interrupts only.  The receive                     * interrupts should be left disabled.  Y points to the                     * device and X points to the terminal table entry.                     * All registers but D shoud be preserved.                     *                       FAA0 39            S4ttenx   rts              do nothing for now                                                               *                     * ttdisx                     *                     * Disable the transmit interrupt and leave the receive                     * interrupt enabled.  Y points to the device and X points                     * to the terminal table entry.  Preserve all but D.                     *                       FAA1               S4ttdisx  FAA1 86   28                 lda    #$28      reset transmit interrupt commandTask Structure                       13:33:16  Feb 27, 1985   Page  1088274 interface routines                               FAA3 A7   22                 sta    cont,y  FAA5 39                      rts                                                               *                     * ttenno                     *                     * Disable all interrupts from device and drop the RTS                     * line.  Y points to the device and X points to the                     * terminal table entry.  Preserve all but D register.                     *                       FAA6 86   01       S4ttenno  lda    #1        select interrupt cntrl reg  FAA8 A7   22                 sta    cont,y    select reg 1  FAAA 6F   22                 clr    cont,y    reset all bits  FAAC C6   6C                 ldb    #$6c      turn off DTR and RTS  FAAE 34   40       setupx    pshs   u  FAB0 C4   9F                 andb   #$9F      isolate important bits  FAB2 34   04                 pshs   b  FAB4 86   03                 lda    #3        select register 3  FAB6 C6   FF                 ldb    #$FF  FAB8 CE   FAC9               ldu    #S4_auto  set to restore auto enables >FABB 17   FF9D               lbsr   S4_chgreg  FABE 86   05                 lda    #5        select xmit control reg  FAC0 C6   60                 ldb    #$60  FAC2 33   E4                 leau   0,s >FAC4 17   FF94               lbsr   S4_chgreg  FAC7 35   C4                 puls   b,u,pc    return                     *  FAC9 20            S4_auto   fcb    $20       Auto enable mode                                          *                     * ttxbsy                     *                     * Test if the transmit buffer is empty.  Return TRUE if                     * it is empty (N.E. status). Y points to the device and                     * all but A needs preserved.                     *                       FACA               S4ttxbsy  FACA A6   22                 lda    cont,y  FACC 85   04                 bita   #4  FACE 39                      rts                                          *                     * tttstx                     *                     * Test device pointed at by Y for a transmit interrupt.                     * Return TRUE if interrupt present.  Preserve all but                     * the A register.                     *                     Task Structure                       13:33:17  Feb 27, 1985   Page  1098274 interface routines                               FACF               S4tttstx  FACF 81   00                 cmpa   #0  FAD1 26   19                 bne    S4false   is it xmit int?  FAD3 20   06                 bra    S4true                                          *                     * ttiscts                     *                     * Test device pointed at by X for "Clear to Send"                     * -- Return TRUE (not equal) if yes                     *  FAD5 A6   02       S4ttiscts lda    cont,x    check for CTS  FAD7 85   20                 bita   #%00100000 is CTS down?  FAD9 27   11                 beq    S4false  FADB 1C   FB       S4true    clz              no - return TRUE  FADD 39                      rts                                                               *                     * tttstr                     *                     * Test device pointed at by Y for a receive interrupt.                     * Return TRUE if interrupt present.  Preserve all                     * registers.                     *                       FADE               S4tttstr  FADE 81   02                 cmpa   #2        is it rcv int?  FAE0 26   0A                 bne    S4false  FAE2 20   F7                 bra    S4true                                                               *                     * tttstb                     *                     * Test device pointed at by Y for a "break" condition.                     * Return TRUE if found.  Preserve all registers                     * and return NULL in B (for break character).                     *                       FAE4               S4tttstb  FAE4 81   01                 cmpa   #1        is it break condition?  FAE6 26   04                 bne    S4false  FAE8 C5   80                 bitb   #$80  FAEA 26   13                 bne    clsint    clear int. & show true  FAEC 1A   04       S4false   sez              yes - return FALSE  FAEE 39                      rts                                                               * Test device pointed at by Y for a "CTS" interrupt.                     *                     Task Structure                       13:33:17  Feb 27, 1985   Page  1108274 interface routines                               FAEF               S4tttsts  FAEF 81   01                 cmpa   #1        is it special interrupt?  FAF1 26   F9                 bne    S4false  FAF3 86   20                 lda    #CTSBIT   use CTS bit position  FAF5 8D   3D                 bsr    hilo      see if bit went hi  FAF7 27   06                 beq    clsint    if lo, go clear int.  FAF9 8D   0F                 bsr    chkopn    was terminal open?  FAFB 26   02                 bne    clsint    clear int & exit if so  FAFD 8D   5E                 bsr    wake      wakeup blocked open                                          *                     * clear interrupt and return true status                     *                       FAFF 86   01       clsint    lda    #1        select int. control reg.  FB01 A7   22                 sta    cont,y  FB03 A6   22                 lda    cont,y    clear interrupt  FB05 86   10       clstat    lda    #$10      reset port  FB07 A7   22                 sta    cont,y  FB09 39                      rts              return true                                                                                    *                     * check for device open                     *  FB0A 34   02       chkopn    pshs   a  FB0C A6   88 11              lda    tstate,x  FB0F 85   04                 bita   #TOPEN  FB11 35   82                 puls   a,pc                                          *                     * tttstd                     *                     * Test device for change in DSR status.                     *  FB13               S4tttstd  FB13 1A   04                 sez              -- not supported  FB15 39                      rts                                                               *                     * tttstc                     *                     * Test device pointed at by Y for drop "Carrier Detect"                     * type interrupt.  Return TRUE if so.  Preserve all registers                     * but A.                     *                       FB16               S4tttstc  FB16 81   01                 cmpa   #1        special interrupt type?  FB18 26   D2                 bne    S4false   exit if notTask Structure                       13:33:18  Feb 27, 1985   Page  1118274 interface routines                               FB1A 86   08                 lda    #DCDBIT   setup DCD bit position  FB1C 8D   16                 bsr    hilo      see if bit went hi or lo  FB1E 26   06                 bne    3f        branch if high  FB20 8D   E8                 bsr    chkopn    was terminal open?  FB22 27   08                 beq    flsclr    if not, clear int. & show false  FB24 20   D9                 bra    clsint    clr int & show true (HANGUP)  FB26 8D   E2       3         bsr    chkopn    was terminal open?  FB28 26   02                 bne    flsclr    if so, clr int & show false  FB2A 8D   31                 bsr    wake      waken blocked open                       FB2C 34   02       flsclr    pshs   a  FB2E 8D   CF                 bsr    clsint    clear interrupt  FB30 35   02                 puls   a  FB32 20   B8                 bra    S4false   show false response                                          *                     * See if bit in position supplied in a went high or low                     *                       FB34 34   02       hilo      pshs   a         save bit position  FB36 1F   98                 tfr    b,a  FB38 A8   88 13              eora   tstate3,x see if bit has changed  FB3B A4   E4                 anda   0,s       look at only the desired bit  FB3D 26   06                 bne    1f        branch if changed  FB3F 32   63                 leas   3,s       remove return address  FB41 86   01                 lda    #1        restore interrupt type  FB43 20   A7                 bra    S4false   go straight to false  FB45 A6   88 13    1         lda    tstate3,x preload saved bits  FB48 E5   E4                 bitb   0,s       did bit go high?  FB4A 26   09                 bne    2f        branch if went high  FB4C 63   E4                 com    0,s       prepare to clear bit  FB4E A4   E0                 anda   0,s+      clear saved bit  FB50 8D   05                 bsr    3f        put back >FB52 16   FF97               lbra   S4false   show bit went low  FB55 AA   E0       2         ora    0,s+      set saved bit  FB57 A7   88 13    3         sta    tstate3,x  FB5A 86   01                 lda    #1        restore interrupt type  FB5C 39                      rts              (returning true (NE))                                                               *                     * wakeup routine for CTS and DCD                     *  FB5D 34   76       wake      pshs   d,x,y,u  FB5F 10AE 04                 ldy    tqout,x   get address for wakeup  FB62 BD   F116               jsr    wakeup  FB65 35   F6                 puls   d,x,y,u,pc                                                               *                     * tttste                     *Task Structure                       13:33:19  Feb 27, 1985   Page  1128274 interface routines                                                  * Test device pointed at by Y for error conditions.                     * Handle all errors local to this routine - no status                     * returned.  Preserve all but A.                     *                       FB67               S4tttste  FB67 81   01                 cmpa   #1        special condition?  FB69 27   C1                 beq    flsclr    yes - jump  FB6B 81   00                 cmpa   #0  FB6D 1027 FF7B               lbeq   S4false  FB71 86   01                 lda    #1        reset error condition  FB73 A7   22                 sta    cont,y  FB75 A6   22                 lda    cont,y  FB77 86   30                 lda    #$30  FB79 A7   22                 sta    cont,y  FB7B A6   A4                 lda    data,y    read data register - just to be sure >FB7D 16   FF85               lbra   clstat    clear status                                                               *                     * reset impending interrupts and determine current                     * status of CTS and DCD                     *                       FB80 17   FF7C     reset     lbsr   clsint    clear interrupts  FB83 A6   22                 lda    cont,y    get status  FB85 84   28                 anda   #CTSBIT|DCDBIT just CTS and DCD  FB87 E6   88 13              ldb    tstate3,x  FB8A C4   D7                 andb   #!(CTSBIT|DCDBIT) turn off  FB8C E7   88 13              stb    tstate3,x  FB8F AA   88 13              ora    tstate3,x add in new bits  FB92 A7   88 13              sta    tstate3,x  FB95 39            ret       rts                                                               *                     * ttend                     *                     * Terminate i/o operation for device pointed at by Y.                     * Preserve all but D.                     *                       FB96 34   26       S4ttend   pshs   d,y       save port address  FB98 EC   62                 ldd    2,s       compute base address for chip  FB9A C4   FE                 andb   #$FE  FB9C 1F   02                 tfr    d,y  FB9E 86   38                 lda    #$38      reset port  FBA0 A7   22                 sta    cont,y  FBA2 35   A6                 puls   d,y,pc    return                                                               *Task Structure                       13:33:19  Feb 27, 1985   Page  1138274 interface routines                                                  * ttwcts                     *                     * Wait for CTS to go high.  (Sleep on it).                     *                                          * Same as ttwdcd, so fall through                                          *                     * ttwdcd                     *                     * Wait for DCD to go high.  (Sleep on it).                     *                       FBA4 86   20       S4ttwcts  lda    #CTSBIT  FBA6 20   02                 bra    ttw2  FBA8 86   08       S4ttwdcd  lda    #DCDBIT  FBAA 34   02       ttw2      pshs   a  FBAC 8D   D2                 bsr    reset     reset impending interrupts  FBAE 86   01                 lda    #1        select interrupt control reg.  FBB0 A7   22                 sta    cont,y  FBB2 86   05                 lda    #$05      enable only ext/status interrupts  FBB4 A7   22                 sta    cont,y  FBB6 17   FF4C               lbsr   clstat  FBB9 A6   22                 lda    cont,y    get status  FBBB A4   E0                 anda   0,s+  FBBD 26   D6                 bne    ret  FBBF C6   EC                 ldb    #TTYOPR   set priority  FBC1 10AE 04                 ldy    tqout,x   point to something  FBC4 7E   F13A               jmp    sleep     sleep on DCDTask Structure                       13:33:20  Feb 27, 1985   Page  114ACIA interface routines                                                                       * The routines in this file are specific to an ACIA (6850).                     * They are called from the "ttyhan" and "ttydrv" files.                                          *                     * 6850 Device table                     *  FBC7               DEV_6850  FBC7 D4D6                    fdb    bad_cmd   0 -  FBC9 F7DE                    fdb    open_tty  1 -  FBCB F7E4                    fdb    close_tty 2 -  FBCD F36B                    fdb    ttyset    3 -  FBCF F3D5                    fdb    ttyget    4 -  FBD1 F7EA                    fdb    req_write 5 -  FBD3 F832                    fdb    write_data 6 -  FBD5 F870                    fdb    wrt_sc    7 -  FBD7 F773                    fdb    req_read  8 -  FBD9 F79B                    fdb    read_data 9 -  FBDB D4D6                    fdb    bad_cmd   10 -  FBDD D4D6                    fdb    bad_cmd   11 -  FBDF D4D6                    fdb    bad_cmd   12 -  FBE1 D4D6                    fdb    bad_cmd   13 -  FBE3 D4D6                    fdb    bad_cmd   14 -  FBE5 FD13                    fdb    clock_on  15 -  FBE7 FC15                    fdb    S2_IRQ  FBE9 FC2A                    fdb    S2_init  FBEB FC36                    fdb    S2_test                     *  FBED FC78                    fdb    S2ttconf  FBEF FC9C                    fdb    S2ttputc  FBF1 FC9F                    fdb    S2ttgetc  FBF3 FCA2                    fdb    S2ttenxr  FBF5 FCA9                    fdb    S2ttdisx  FBF7 FCB0                    fdb    S2ttenr  FBF9 FCB7                    fdb    S2ttenx  FBFB FCBE                    fdb    S2ttenno  FBFD FCC5                    fdb    S2ttxbsy  FBFF FCCA                    fdb    S2tttstx  FC01 FCD2                    fdb    S2ttiscts  FC03 FCDE                    fdb    S2tttstr  FC05 FCE4                    fdb    S2tttstb  FC07 FCF3                    fdb    S2tttsts  FC09 FCF5                    fdb    S2tttstc  FC0B FD03                    fdb    S2tttstd  FC0D FCFE                    fdb    S2tttste  FC0F FD06                    fdb    S2ttend  FC11 FD07                    fdb    S2ttwcts  FC13 FD11                    fdb    S2ttwdcd                                          *                     * Check for and process an ACIA interrupt                     *  D - Device #Task Structure                       13:33:21  Feb 27, 1985   Page  115ACIA interface routines                                                  *  X - Device address                     *  FC15 34   76       S2_IRQ    pshs   d,x,y,u   save registers just in case  FC17 A6   84                 lda    csr,x     check for interrupt  FC19 85   80                 bita   #$80  FC1B 27   09                 beq    10f       jump if no interrupt  FC1D EC   E4                 ldd    0,s       restore device #  FC1F BD   F2EA               jsr    tintr     go process interrupt  FC22 1A   01                 sec              -- interrupt processed  FC24 20   02                 bra    99f  FC26 1C   FE       10        clc              -- no interrupt processed  FC28 35   F6       99        puls   d,x,y,u,pc                                          *                     * Initialize ACIA port                     *   B - Device #                     *   X - Device address                     *  FC2A 34   76       S2_init   pshs   d,x,y,u  FC2C 86   43                 lda    #$43      set up reset code  FC2E A7   84                 sta    0,x       reset acia  FC30 34   06                 pshs   d         delay  FC32 35   06                 puls   d  FC34 35   F6                 puls   d,x,y,u,pc                                          *                     * Determine if MP-S2 ACIA board is present                     *  D - ACIA port address                     *  Y - Device table address                     *  <CS> if present & ACIA                     *  FC36 34   56       S2_test   pshs   d,x,u  FC38 1F   03                 tfr    d,u  FC3A 86   43                 lda    #$43      set up reset code  FC3C A7   C4                 sta    0,u       reset acia  FC3E 34   06                 pshs   d         delay  FC40 35   06                 puls   d  FC42 A6   C4                 lda    0,u       check response  FC44 27   08                 beq    00f  FC46 84   F3                 anda   #%11110011  FC48 27   04                 beq    00f  FC4A 1C   FE                 clc              -- not an 8250  FC4C 20   28                 bra    99f  FC4E B6   0101     00        lda    NUM_TRM   compute device table address  FC51 C6   04                 ldb    #DEV_SIZE  FC53 3D                      mul  FC54 108E 029D               ldy    #dev_tab  FC58 31   AB                 leay   d,y  FC5A 7C   0101               inc    NUM_TRM   -- bump by 2  FC5D 7C   0101               inc    NUM_TRM  FC60 EC   E4                 ldd    0,s  FC62 8E   FBC7               ldx    #DEV_6850Task Structure                       13:33:22  Feb 27, 1985   Page  116ACIA interface routines                               FC65 ED   A4                 std    dev_addr,y  FC67 AF   22                 stx    dev_type,y  FC69 31   24                 leay   DEV_SIZE,y  FC6B C3   0004               addd   #4  FC6E ED   A4                 std    dev_addr,y  FC70 AF   22                 stx    dev_type,y  FC72 31   24                 leay   DEV_SIZE,y  FC74 1A   01                 sec  FC76 35   D6       99        puls   d,x,u,pc                                                               *                     * ttconf                     *                     * Configure the port pointed at by the Y register.  The X                     * register is pointing to the terminal table.  All registers                     * except D should be preserved.                     *                       FC78 86   03       S2ttconf  lda    #3        reset the acia  FC7A A7   A4                 sta    csr,y  FC7C 34   06                 pshs   d         delay some here  FC7E 35   06                 puls   d  FC80 A6   A4                 lda    csr,y     get status - see if acia is really here  FC82 27   04                 beq    2f        if 0 status - then ok  FC84 85   F3                 bita   #$f3      see if funny status is ok  FC86 26   0C                 bne    4f  FC88 A6   0F       2         lda    tbaud,x   get configuration word from table  FC8A 8A   01                 ora    #ADIVID   set up full configuration  FC8C A7   A4                 sta    csr,y     (no ints enabled & RTS brought high)  FC8E A6   A4                 lda    csr,y     get new status  FC90 85   08                 bita   #$8       is CTS ok?  FC92 27   05                 beq    6f  FC94 1A   04       4         sez              set false status  FC96 1C   FE                 clc              show wait for CTS  FC98 39                      rts              return  FC99 1C   FB       6         clz              set true status  FC9B 39                      rts              return                                                               *                     * ttputc                     *                     * Send the character in the B register to the ACIA.  All                     * registers should be preserved.  Y points to the device.                     *                       FC9C E7   21       S2ttputc  stb    dbuf,y    send character  FC9E 39                      rts              return                                                               *Task Structure                       13:33:22  Feb 27, 1985   Page  117ACIA interface routines                                                  * ttgetc                     *                     * Get the character from the device and return in the B                     * register.  Y points to the device and all registers                     * should be preserved.                     *                       FC9F E6   21       S2ttgetc  ldb    dbuf,y    get the character  FCA1 39                      rts              return                                                               *                     * ttenxr                     *                     * Enable the transmit interrupts and leave the receive                     * interrupt enabled (it is enabled upon routine entry).                     * Y points to the device and X points to to the terminal                     * table entry.  Preserve all registers but D.                     *                     *                       FCA2 A6   0F       S2ttenxr  lda    tbaud,x   get configuration  FCA4 8A   A1                 ora    #ENBXIN|ADIVID|ENBRIN enable int bits  FCA6 A7   A4                 sta    csr,y     send to acia  FCA8 39                      rts              return                                                               *                     * ttdisx                     *                     * Disable the transmit interrupt and leave the receive                     * interrupt enabled.  Y points to the device and X points                     * to the terminal table entry.  Preserve all but D.                     *                       FCA9 A6   0F       S2ttdisx  lda    tbaud,x   get configuration word  FCAB 8A   81                 ora    #ADIVID|ENBRIN|DSBXIN set bits  FCAD A7   A4                 sta    csr,y     send to acia  FCAF 39                      rts              return                                                               *                     * ttenr                     *                     * Enable the receive interrupts only.  The transmit                     * interrupts should be turned off.  Y points to the device                     * and X point to the terminal table entry.  Preserve all                     * but the D register.                     *                       FCB0 A6   0F       S2ttenr   lda    tbaud,x   get configuration word  FCB2 8A   81                 ora    #ADIVID|ENBRIN|DSBXIN set bitsTask Structure                       13:33:23  Feb 27, 1985   Page  118ACIA interface routines                               FCB4 A7   A4                 sta    csr,y     send to acia  FCB6 39                      rts              return                                                               *                     * ttenx                     *                     * Enable the transmit interrupts only.  The receive                     * interrupts should be left disabled.  Y points to the                     * device and X points to the terminal table entry.                     * All registers but D shoud be preserved.                     *                       FCB7 A6   0F       S2ttenx   lda    tbaud,x   get configuration word  FCB9 8A   21                 ora    #ADIVID|ENBXIN set bits  FCBB A7   A4                 sta    csr,y     send to acia  FCBD 39                      rts              return                                                               *                     * ttenno                     *                     * Disable all interrupts from device and drop the RTS                     * line.  Y points to the device and X points to the                     * terminal table entry.  Preserve all but D register.                     *                       FCBE A6   0F       S2ttenno  lda    tbaud,x   get configuration word  FCC0 8A   41                 ora    #ADIVID|$40 set bits  FCC2 A7   A4                 sta    csr,y     send to acia  FCC4 39                      rts              return                                                               *                     * ttxbsy                     *                     * Test if the transmit buffer is empty.  Return TRUE if                     * it is empty (N.E. status). Y points to the device and                     * all but A needs preserved.                     *                       FCC5 A6   A4       S2ttxbsy  lda    csr,y     get status  FCC7 85   02                 bita   #ACTBSY   is it busy?  FCC9 39                      rts              return                                                               *                     * tttstx                     *                     * Test device pointed at by Y for a transmit interrupt.                     * Return TRUE if interrupt present.  Preserve all but                     * the A register.Task Structure                       13:33:23  Feb 27, 1985   Page  119ACIA interface routines                                                  *                       FCCA A6   A4       S2tttstx  lda    csr,y     get status  FCCC 85   05                 bita   #ACRBSY|$04  FCCE 26   0B                 bne    S2false  FCD0 20   06                 bra    S2true                                                               *                     * ttiscts                     *                     * Test device pointed at by X for "Clear to Send"                     * -- Return TRUE (not equal) if yes                     *  FCD2 A6   84       S2ttiscts lda    csr,x     check for CTS  FCD4 85   08                 bita   #$8       is CTS down?  FCD6 26   03                 bne    S2false  FCD8 1C   FB       S2true    clz              no - return TRUE  FCDA 39                      rts  FCDB 1A   04       S2false   sez              yes - return FALSE  FCDD 39                      rts                                                               *                     * tttstr                     *                     * Test device pointed at by Y for a receive interrupt.                     * Return TRUE if interrupt present.  Preserve all but                     * the A register.                     *                       FCDE 85   34       S2tttstr  bita   #%00110100 check status  FCE0 26   F9                 bne    S2false  FCE2 20   F4                 bra    S2true                                                               *                     * tttstb                     *                     * Test device pointed at by Y for a "break" condition.                     * Return TRUE if found.  Preserve all registers but A                     * and return NULL in B (for break character).                     *                       FCE4 85   30       S2tttstb  bita   #$30      check for break condition  FCE6 27   0A                 beq    2f  FCE8 E6   21                 ldb    dbuf,y    get character from acia  FCEA 34   76                 pshs   d,x,y,u   delay some here  FCEC 35   76                 puls   d,x,y,u  FCEE A6   21                 lda    dbuf,y    get next garbage char if any  FCF0 1C   FB                 clz              set true  FCF2 39            2         rts              returnTask Structure                       13:33:24  Feb 27, 1985   Page  120ACIA interface routines                                                                                            *                     * tttsts                     *                     * Test device for "CTS" interrupt.                     *                       FCF3 20   E6       S2tttsts  bra    S2false   not currently implemented                                                               *                     * tttstc                     *                     * Test device pointed at by Y for drop "Carrier Detect"                     * type interrupt.  Return TRUE if so.  Preserve all registers                     * but A.                     *                       FCF5 85   04       S2tttstc  bita   #$04      check for carrier drop  FCF7 27   04                 beq    1f        jump if no error  FCF9 E6   21                 ldb    dbuf,y    read reg to reset status  FCFB 1C   FB                 clz              return true  FCFD 39            1         rts              return                                                               *                     * tttste                     *                     * Test device pointed at by Y for error conditions.                     * Handle all errors local to this routine - no status                     * returned.  Preserve all but A.                     *                       FCFE A6   21       S2tttste  lda    dbuf,y    read data register to clear any interrupt conditions  FD00 1C   FB                 clz              return true  FD02 39                      rts              return                                          *                     * tttstd - Test for drop in DTR                     *  FD03 1A   04       S2tttstd  sez              -- not supported by hardware  FD05 39                      rts                                                               *                     * ttend                     *                     * Terminate i/o operation for device pointed at by Y.                     * Preserve all but D.                     *                     Task Structure                       13:33:24  Feb 27, 1985   Page  121ACIA interface routines                               FD06 39            S2ttend   rts              return (nothing for acia)                                                               *                     * ttwcts                     *                     * Wait for CTS to go high (sleep on it).                     *                       FD07 8D   AE       S2ttwcts  bsr    S2ttenx   enable xmit ints only  FD09 C6   EC                 ldb    #TTYOPR   set priority  FD0B 10AE 04                 ldy    tqout,x   point to output q  FD0E 7E   F13A               jmp    sleep     sleep on CTS                                                               *                     * ttwdcd                     *                     * Wait for DCD to go high (sleep on it).                     *                       FD11 39            S2ttwdcd  rts              currently not implementedTask Structure                       13:33:25  Feb 27, 1985   Page  1226840 Interval Timer Handler                                                                   *                     * Clock structure                     *-- Use timer #1                     *               80C1  CLKSEL    equ    CLOCK+1   clock select and status register               80C2  CLKLAT    equ    CLOCK+2   clock timer latch               0040  CLKCON    equ    %01000000 clock control               0080  CLKMSK    equ    %10000000 clock interrupt mask               000B  HZTIM_60  equ    120/10-1  interrupt rate (60hz)               0009  HZTIM_50  equ    100/10-1  interrupt rate (50hz)                     *  FD12 00            sphz      fcb    0         --- TEMP ---                       FD13               clock_on  FD13 BE   0124               ldx    utask     disassociate from any terminal  FD16 86   FF                 lda    #$FF  FD18 A7   08                 sta    tsdev,x  FD1A 86   01                 lda    #1        reset the clock  FD1C B7   80C1               sta    CLKSEL  FD1F 86   80                 lda    #%10000000 set reset bit  FD21 B7   80C0               sta    CLOCK     save in control  FD24 7F   80C1               clr    CLKSEL    reset control  FD27 7D   FD12               tst    sphz      60 Hz or 50 Hz?  FD2A 26   05                 bne    0f  FD2C CC   000B               ldd    #HZTIM_60 set clock rate = 60 Hz  FD2F 20   03                 bra    1f  FD31 CC   0009     0         ldd    #HZTIM_50 set clock rate = 50 Hz  FD34 FD   80C2     1         std    CLKLAT    set latch count  FD37 86   01                 lda    #1        select control register 1  FD39 B7   80C1               sta    CLKSEL  FD3C 86   40                 lda    #CLKCON   turn on timer 1  FD3E B7   80C0               sta    CLOCK                     * -- Wait for clock interrupt  FD41 108E 014A     10        ldy    #clock_tick  FD45 C6   C4                 ldb    #CLOCKPR  FD47 BD   F13A               jsr    sleep  FD4A C6   0C       20        ldb    #R_CLOCK  interrupt the CPU  FD4C BD   D406               jsr    fio_response  FD4F 7A   014A               dec    clock_tick all ticks out?  FD52 26   F6                 bne    20b  FD54 20   EB                 bra    10b                                          *                     * Process clock interrupt                     *  FD56 108E 014A     clkint    ldy    #clock_tick wake up clock process  FD5A 6C   A4                 inc    0,y  FD5C 7E   F116               jmp    wakeupTask Structure                       13:33:26  Feb 27, 1985   Page  123Debug Interface Routines                                                   FD5F               DB_main  FD5F 8D   4F                 bsr    DB_test   see if debug routines present  FD61 6E   9F B002            jmp    [DEBUGROM+2]  FD65               DB_pdata  FD65 8D   49                 bsr    DB_test   see if debug routines present  FD67 6E   9F B004            jmp    [DEBUGROM+4]  FD6B               DB_phex  FD6B 8D   43                 bsr    DB_test   see if debug routines present  FD6D 6E   9F B006            jmp    [DEBUGROM+6]  FD71               DB_phex2  FD71 8D   3D                 bsr    DB_test   see if debug routines present  FD73 6E   9F B008            jmp    [DEBUGROM+8]  FD77               DB_pcrlf  FD77 8D   37                 bsr    DB_test   see if debug routines present  FD79 6E   9F B00A            jmp    [DEBUGROM+10]  FD7D               DB_check  FD7D 8D   31                 bsr    DB_test   see if debug routines present  FD7F 6E   9F B00C            jmp    [DEBUGROM+12]  FD83               DB_config  FD83 8D   2B                 bsr    DB_test   see if debug routines present  FD85 6E   9F B00E            jmp    [DEBUGROM+14]  FD89 34   17       DB_msg    pshs   cc,d,x  FD8B AE   65                 ldx    1+2+2,s   get return address  FD8D EC   81                 ldd    ,x++      get mask word  FD8F B4   011C               anda   DB_cntrl  FD92 F4   011D               andb   DB_cntrl+1  FD95 34   04                 pshs   b  FD97 AA   E0                 ora    ,s+  FD99 27   04                 beq    10f       jump if flag not set  FD9B 30   02                 leax   2,x       skip over false address & fall through  FD9D 20   02                 bra    20f  FD9F AE   84       10        ldx    ,x        get false branch label  FDA1 AF   65       20        stx    1+2+2,s   fix up return address  FDA3 35   97                 puls   cc,d,x,pc return                     *  FDA5               DB_pspace  FDA5               DB_outsp  FDA5 34   16                 pshs   d,x  FDA7 8E   FDAE               ldx    #00f  FDAA 8D   B9                 bsr    DB_pdata  FDAC 35   96                 puls   d,x,pc  FDAE 20 00         00        fcc    ' ',0                       FDB0 34   07       DB_test   pshs   cc,d  FDB2 FC   B000               ldd    DEBUGROM  Debug rom present?  FDB5 1083 1234               cmpd   #$1234    special marker  FDB9 27   05                 beq    99f       yes - exit  FDBB 35   07                 puls   cc,d      no - abort DB_xx function  FDBD 32   62                 leas   2,s  FDBF 39                      rts  FDC0 35   87       99        puls   cc,d,pc   returnTask Structure                       13:33:26  Feb 27, 1985   Page  124Debug Interface Routines                                                           end