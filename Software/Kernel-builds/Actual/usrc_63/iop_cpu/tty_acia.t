          sttl    ACIA       interface routines          pag          lib     dtab_acia.t* The routines in this file are specific to an ACIA (6850).* They are called from the "ttyhan" and "ttydrv" files.* preset table for baudrates at each port** baudrate latch backup bytes, for 2 acia's each** CB B2 B1 B0 CA A2 A1 A0       C=/CTS override, 0 = active* X2 X1 X0 are baudrate select bits 0K3/0K6/1K2/2K4/4K8/9K6/19K2/38K4* 111 is highest baudrate, 000 is lowest.*brbupr    fcb     $77           acia 0 and 1 board 1          fcb     $77           acia 2 and 3          fcb     $77           acia 4 and 5 board 2          fcb     $77           acia 6 and 7          fcb     $77           acia 8 and 9 board3          fcb     $77           acia 10 and 11BRTBSIZ   equ     *-brbupr          if      BRTBSIZ<(MAX_TTY/2)          err     "tty baudrate table mismatch, correct table"          endif** Check for and process an ACIA interrupt*  D - Device #*  X - Device address*SR4_IRQ    pshs    d,x,y,u    save registers just in case          lda     csr,x      check for interrupt          bita    #AS_IRQ          beq     10f        jump if no interrupt*          clrb          pshs    d*          ldd     2,s        restore device #          jsr     tintr      go process interrupt          leas    2,s        remove device status          sec     --         interrupt processed          bra     99f*10        clc     --         no interrupt processed*99        puls    d,x,y,u,pc** Initialize ACIA port*   B - Device #*   X - Device address*SR4_init   pshs    d,x,y,u          clr     2,x        init baudrate latch          lda     #AC_DRTS+AC_MRES   set up reset code          sta     0,x        reset acia          pshs    d          delay          puls    d          puls    d,x,y,u,pc** Determine if CPU09SR4 ACIA board is present*  D - ACIA port address*  Y - Device table address*  <CS> if present & ACIA*SR4_test   pshs    d,x,u          tfr     d,u          lda     #AC_DRTS+AC_MRES   set up reset code          sta     0,u        reset acia          pshs    d          delay          puls    d          lda     0,u        check response          beq     00f*          anda    #%11110011 todo: bit names          beq     00f*          clc     --         not an 6350          bra     99f** found an ACIA, fill in the port info*00        ldx     #CFGDAT    offset          lda     NUM_TRM,x  Compute device table address          ldb     #DEV_SIZE          mul          ldy     #dev_tab          leay    d,y          lda     NUM_TRM,x          rora               2 ports for each baudrate backup          ldu     #brbutb    address of table          leau    a,u* account for 4 ports CPU09SR4          ldb     NUM_TRM,x          addb    #4          stb     NUM_TRM,x*          ldd     0,s          port address          ldx     #DEV_6850          std     dev_addr,y   device address          stx     dev_type,y   handler dispatch table          stu     dev_brbu,y   baudrate latch backup          pshs    a          lda     (brbupr-brbutb),u  get rom preset          sta     0,u          puls    a          leay    DEV_SIZE,y          addd    #4            offset to next ACIA          std     dev_addr,y          stx     dev_type,y          stu     dev_brbu,y          leay    DEV_SIZE,y          addd    #4          leau    1,u          next backup location          std     dev_addr,y          stx     dev_type,y          stu     dev_brbu,y          pshs    a          lda     (brbupr-brbutb),u  get rom preset          sta     0,u          puls    a          leay    DEV_SIZE,y          addd    #4          std     dev_addr,y          stx     dev_type,y          stu     dev_brbu,y          leay    DEV_SIZE,y          sec99        puls    d,x,u,pc** ttconf** Configure the port pointed at by the Y register.  The X* register is pointing to the terminal table.  All registers* except D should be preserved.*SR4ttconf  lda     #AC_MRES   reset the acia          sta     csr,y          pshs    d          delay some here          puls    d          lda     csr,y      get status - see if acia is really here          beq     2f         if 0 status - then ok*          bita    #$f3       see if funny status is ok  todo: bit names          bne     4f*2         lda     tbaud,x    get configuration word from table          ora     #AC_DV16   set up full configuration          sta     csr,y      (no ints enabled & RTS brought high)*          pshs   d,x          lda    tdevic+1,x   get terminal id          ldb   #DEV_SIZE          mul          ldx   #dev_tab          leax  d,x          ldx   dev_brbu,x   set baudrate latch          lda   0,x          sta   brr,y          puls  d,x          lda     csr,y      get new status          bita    #AS_NCTS   is CTS ok?          beq     6f*4         sez                set        false status          clc                show       wait for CTS          rts                return*6         clz                set        true status          rts                return** ttputc** Send the character in the B register to the ACIA.  All* registers should be preserved.  Y points to the device.*SR4ttputc  stb     dbuf,y     send character          rts     return** ttgetc** Get the character from the device and return in the B* register.  Y points to the device and all registers* should be preserved.*SR4ttgetc  ldb     dbuf,y     get the character          rts     return** ttenxr** Enable the transmit interrupts and leave the receive* interrupt enabled (it is enabled upon routine entry).* Y points to the device and X points to to the terminal* table entry.  Preserve all registers but D.**SR4ttnxr  lda     tbaud,x    get configuration          ora     #AC_TEIN+AC_REIN+AC_DV16 enable int bits          sta     csr,y      send to acia          rts     return** ttdisx** Disable the transmit interrupt and leave the receive* interrupt enabled.  Y points to the device and X points* to the terminal table entry.  Preserve all but D.*SR4ttdisx  lda     tbaud,x    get configuration word          ora     #AC_REIN+AC_DV16  set bits          sta     csr,y      send to acia          rts     return** ttenr** Enable the receive interrupts only.  The transmit* interrupts should be turned off.  Y points to the device* and X point to the terminal table entry.  Preserve all* but the D register.*SR4ttnr   lda     tbaud,x    get configuration word          ora     #AC_REIN+AC_DV16  set bits          sta     csr,y      send to acia          rts     return** ttenx** Enable the transmit interrupts only.  The receive* interrupts should be left disabled.  Y points to the* device and X points to the terminal table entry.* All registers but D shoud be preserved.*SR4ttnx   lda     tbaud,x    get configuration word          ora     #AC_TEIN+AC_DV16 set bits          sta     csr,y      send to acia          rts     return** ttenno** Disable all interrupts from device and drop the RTS* line.  Y points to the device and X points to the* terminal table entry.  Preserve all but D register.*SR4ttnno  lda     tbaud,x    get configuration word          ora     #AC_DRTS+AC_DV16   set bits          sta     csr,y      send to acia          rts     return** ttxbsy** Test if the transmit buffer is empty.  Return TRUE if* it is empty (N.E. status). Y points to the device and* all but A needs preserved.*SR4ttxbsy  lda     csr,y      get status          bita    #AS_TDRE    is it busy?          rts     return** tttstx** Test device pointed at by Y for a transmit interrupt.* Return TRUE if interrupt present.  Preserve all but* the A register.*SR4ttstx  lda     csr,y      get status          bita    #AS_TDRE          bne     SR4true          bra     SR4false** ttiscts** Test device pointed at by X for "Clear to Send"* -- Return TRUE (not equal) if yes*SR4ttiscts          bita    #AS_NCTS    is CTS down?          bne     SR4falseSR4true    clz     no         - return TRUE          rtsSR4false   sez     yes        - return FALSE          rts** tttstr** Test device pointed at by Y for a receive interrupt.* Return TRUE if interrupt present.  Preserve all but* the A register.*SR4ttstr  lda     csr,y          bita    #AS_RDRF          bne     SR4true          bra     SR4false** tttstb** Test device pointed at by Y for a "break" condition.* Return TRUE if found.  Preserve all registers but A* and return NULL in B (for break character).*SR4ttstb  bita    #AS_OVRN+AS_FRME   check for break condition          beq     2f         ZERO = false*          ldb     dbuf,y     get character from acia          pshs    d,x,y,u    delay some here          puls    d,x,y,u          lda     dbuf,y     get next garbage char if any          clz     set        TRUE*2         rts     return** tttsts** Test device for "CTS" interrupt.*SR4ttsts  bra     SR4false    not currently implemented** tttstc** Test device pointed at by Y for drop "Carrier Detect"* type interrupt.  Return TRUE if so.  Preserve all registers* but A.*SR4ttstc  bita    #AS_NDCD   check for carrier drop          beq     1f         jump if no error*          ldb     dbuf,y     read reg to reset status          clz     return     true*1         rts     return** tttste** Test device pointed at by Y for error conditions.* Handle all errors local to this routine - no status* returned.  Preserve all but A.*SR4ttste  lda     dbuf,y     read data register to clear any interrupt conditions          sez                return false clz     return     true          rts     return** tttstd - Test for drop in DTR*SR4ttstd  sez     --         not supported by hardware          rts** ttend** Terminate i/o operation for device pointed at by Y.* Preserve all but D.*SR4ttnd   rts     return     (nothing for acia)** ttwcts** Wait for CTS to go high (sleep on it).*SR4ttwcts  bsr     SR4ttnx    enable xmit ints only          ldb     #TTYOPR    set priority          ldy     tqout,x    point to output q          jmp     sleep      sleep on CTS** ttwdcd** Wait for DCD to go high (sleep on it).*SR4ttwdcd  rts     currently  not implemented