CPU09IOP   Intelligent I/O Proce     16:35:46  Jan 23, 2026   Page    1Hardware   Definitions                                                                                                       opt    lisCPU09IOP   Intelligent I/O Proce     16:35:47  Jan 23, 2026   Page    2IOP        Memory Layout                                                 *                     * Basic Memory Layout                     *               0100  RAMorg    equ    $0100     28K of RAM - Thru $6FFF               6FFF  RAMend    equ    $6FFF               7000  RAMscratch equ   $7000     4K of scratchpad RAM               7F00  RAMscrend equ    $7F00               7FFF  ROMstack  equ    $7FFF     High end of ROM Stack               E000  ROMLOorg  equ    $E000     8K of ROM - $E000-$FFFF               C000  DEBUGROM  equ    $C000     8K of Debug ROM $C000-$DFFF               FFF0  CPUtraps  equ    $FFF0     CPU Trap Vectors                                          *                     * layout of hardware, up to 6 IO boards                     *               8000  SYS_ACIA  equ    $8000     first ACIA in first slot               0003  SR4_SLOTS equ    3         Number of Physical CPU09SR4 I/O slots               8000  BASE_SLOT equ    $8000     Base address for I/O slots               0010  NEXT_SLOT equ    $0010     Offest between slots                                          * clock hardware               8070  CLOCK     equ    $8070     hardware clock, status and control               8071  CLOCKI    equ    $8071     interrupt resetCPU09IOP   Intelligent I/O Proce     16:35:47  Jan 23, 2026   Page    3IOP        Memory Layout                                                                      *                     * Clist Structure                     *                     * The clist structure is the head of a linked list of                     * characters used for i/o.  A head and tail pointer                     * are kept, as well as a character count of active                     * characters on the queue.                     *                                          * struct clist                       0000                         org    0                       0000               clcnt     rmb    1         character count  0001               clfst     rmb    2         head character pointer  0003               cllst     rmb    2         tail character pointer                     *               0005  QH_SIZE   equ    *         Size of Queue Header                                                               *                     * Clist Buffer                     *                     * The characters for i/o are placed in buffers as                     * needed.  Each buffer contains 32 bytes, the first                     * two contain a chain pointer, the next 30 hold                     * the actual characters.                     *                       0000                         org    0                                    0020  CBSIZE    equ    32  0000               cbstrt    rmb    2  0002               cbchrs    rmb    CBSIZE-2CPU09IOP   Intelligent I/O Proce     16:35:48  Jan 23, 2026   Page    4Output     Queue Structure                                                                    *                     * This is the definition of the output queue used                     * to buffer characters going to a terminal.  It is                     * different from the "clist" mechanism for efficiency                     * concerns.                     *                       0000                         org    0  0000               oq_count  rmb    2         Number of characters in Q  0002               oq_buf    rmb    2         Start of Q buffer  0004               oq_put    rmb    2         Address of next character to insert  0006               oq_get    rmb    2         Address of next character to consume  0008               oq_end    rmb    2         Limiting address of Q                     *  000A               OQH_SIZE  rmb    0         Size of output Queue headerCPU09IOP   Intelligent I/O Proce     16:35:48  Jan 23, 2026   Page    5Task       Structure                                                     *                     * Task Table                     *                       0000                         org    0                                          * struct task                                    008A  USTSIZ    equ    138       User Stack Size (big enough??)                     *  0000               tslink    rmb    2         list link of running tasks  0002               tsslnk    rmb    2         list link of sleeping tasks  0004               tsstat    rmb    1         * see below *  0005               tsprir    rmb    1         priority - negative is low  0006               tsevnt    rmb    2         event task is waiting on  0008               tssgnl    rmb    1         Signal waiting for task                     *  0009               tscmd     rmb    1         Saved mailbox command  000A               tsseq     rmb    2         Saved message sequence #  000C               tstval    rmb    1         Saved transaction value  000D               tsdev     rmb    2         Terminal task is servicing  000F               tsdtix    rmb    1         device table entry index  0010               tsagin    rmb    2         Task re-entry pointer                     *  0012               usp       rmb    2         Saved User Stack Pointer  0014               umark0    rmb    2         Stack Frame Markers  0016               umark1    rmb    2  0018                         rmb    USTSIZ    space for per/process stack                                    00A2  TSKSIZ    equ    *         task structure size                     * stat codes                                    0001  TRUN      equ    1         running               0002  TSLEEP    equ    2         sleep with high priority               0003  TWAIT     equ    3         sleep with low priority               0004  TFREE     equ    4         task is free (uncommitted)               0005  TSYS      equ    5         system taskCPU09IOP   Intelligent I/O Proce     16:35:48  Jan 23, 2026   Page    6TTY        Structure                                                                          *                     * TTY Structure                     *                     * A tty structure is required for each character type                     * i/o device used for standard terminal i/o.                     *                                          * struct tty                       0000                         org    0                       0000               tqin      rmb    2         pointer to in q clist str  0002               tqproc    rmb    2         pointer to proccessed q clist str  0004               tqout     rmb    2         pointer to out q clist str  0006               taddr     rmb    2         device address  0008               tflags    rmb    1         mode flags  0009               tdelay    rmb    1         time out definitions  000A               tdevic    rmb    2         device name  000C               ttask     rmb    2         task ID  000E               tdel      rmb    1         raw delimiter count  000F               tcolm     rmb    1         printing column  0010               tbksp     rmb    1         back space character  0011               tcncl     rmb    1         line cancel character  0012               tbaud     rmb    1         device baud rates  0013               tbaud2    rmb    1         actual baud rate (for baud rate generator)  0014               tstate    rmb    1         internal state  0015               tstate2   rmb    1         additional states  0016               tstate3   rmb    1         states of CTS,DCD  0017               tlock     rmb    1         structure lock  0018               tsold     rmb    2         amount of output queue already "sold"  001A               tregs     rmb    8         copy of device registers (for 8274)                                    0022  TTYSIZ    equ    *                                                               * modes                                    0001  RAW       equ    %00000001 raw or cooked mode               0002  ECHO      equ    %00000010 echo characters               0004  XTABS     equ    %00000100 expand tabs               0008  LCASE     equ    %00001000 map to lower case               0010  CRMOD     equ    %00010000 map NL to CR & LF               0020  BSECH     equ    %00100000 backspace echo flag               0040  SCHR      equ    %01000000 single character input               0080  CNTRL     equ    %10000000 ignore control characters                                          * internal states                                    0001  TIMOUT    equ    %00000001 timeout in progress               0002  HOLD      equ    %00000010 output suspended               0004  TOPEN     equ    %00000100 terminal has been openedCPU09IOP   Intelligent I/O Proce     16:35:48  Jan 23, 2026   Page    7TTY        Structure                                               0008  TRANSPNT  equ    %00001000 Transparent mode               0010  IXONXOF   equ    %00010000 Use XON/XOFF to control input               0010  TOPWOC    equ    %00010000 Device opened without carrier present               0020  XANY      equ    %00100000 Allow any character to break HOLD               0040  XONXOF    equ    %01000000 XON/XOFF protocol               0080  ESCOFF    equ    %10000000 Disable ESC as HOLD character                     *               00F8  PROTOCOL  equ    ESCOFF|XANY|XONXOF|IXONXOF|TRANSPNT                                    0001  DSR_OK    equ    %00000001 OK to send               0002  SEND_XON  equ    %00000010 Send XON next               0004  SEND_XOF  equ    %00000100 Send XOFF next               0008  SEND_DLE  equ    %00001000 Send DLE next               0010  XOF_SENT  equ    %00010000 We shut the other guy down               0020  DLE_SENT  equ    %00100000 DLE sequence started               0040  DLE_GOT   equ    %01000000 DLE sequence receivedCPU09IOP   Intelligent I/O Proce     16:35:49  Jan 23, 2026   Page    8Variable   Space                                                           0100                         org    RAMorg                       0100               sys_vars  rmb    0         -- start of system variables                                          * Configuration "constants"  0100               OBUF_SIZE rmb    2         Size of TTY Output Queues  0102               OQHI      rmb    2         Output Queue High-water mark  0104               OQLO      rmb    2         Output Queue Low-water mark  0106               slot_tbl  rmb    2*SR4_SLOTS slot configuration                       010C               DB_iflg   rmb    1         Debug terminal initialized  010D               DB_cntrl  rmb    2         Debug control flags                     *  010F               runlst    rmb    2         Pointer to active tasks  0111               slplst    rmb    4         Pointer to waiting tasks  0115               utask     rmb    2         Currently executing task  0117               jobpri    rmb    1         Current job priority (for scheduling)  0118               chproc    rmb    1         Set if must switch users of CPU (reschedule)  0119               cfreel    rmb    2         Pointer to first free Clist buffer  011B               cbufct    rmb    1         Count of Clist buffers in use  011C               lcbuf     rmb    1         Limit on Clist buffers  011D               idle      rmb    1         idle loop flag for scheduler  011E               SI_Q      rmb    6*MAX_TI  Max Terminal Interrupts  015A               SI_Q_ptr  rmb    2         current Q pointer  015C               FIO_lock  rmb    1         FIO in use lock                     *  015D               int_buf   rmb    2*7       Current Message in (1+2+1+2+1)  016B               int_ptr   rmb    2         Message in pointer  016D               clock_tick rmb   1         Clock tick counter  016E               prcbuf    rmb    PRCSIZ    buffer for erase and kill                                                               * Pointers to system tables - configuration dependent  026E               CLISTS    rmb    2         Space for Clists  0270               TTYTABS   rmb    2         Terminal tables  0272               TTYQS     rmb    2         TTY Input Queue Headers  0274               OBUFRS    rmb    2         TTY Output Queues  0276               tsktab    rmb    2         Task Control Tables  0278               tskend    rmb    2         End of task table  027A               PPstr     rmb    2         Pointer to parallel device tables  027C               NECstr    rmb    2         Pointer to NEC device tables  027E               dev_tab   rmb    DEV_SIZE*MAX_DEV system configuration table  02CC               NEC_IQ    rmb    2         Pointer to NEC input queue  02CE               NECADR    rmb    2         Address of NEC printer                     *  02D0               brbutb    rmb    MAX_TTY/2 baudrate latch backup table                     *  02D6               SYS_TABS  rmb    0         Start of dynamic system tables                                    6FFF  end_vars  equ    RAMend    End of System VariablesCPU09IOP   Intelligent I/O Proce     16:35:49  Jan 23, 2026   Page    9Variable   Space                                                         *                     * ACIA Structure                     *                                          * struct acia                       0000                         org    0                                            0000               csr       rmb    1         control - status  0001               dbuf      rmb    1         data buffer  0002               brr       rmb    1         baudrate latch                                          *                     * status codes                     *               0001  AS_RDRF   equ    %00000001 receive data register full               0002  AS_TDRE   equ    %00000010 transmit data register empty               0004  AS_NDCD   equ    %00000100 DCD status bit, 1 is inactive               0008  AS_NCTS   equ    %00001000 CTS bit, 1 is inactive TX IRQ off               0010  AS_FRME   equ    %00010000 receive framing error               0020  AS_OVRN   equ    %00100000 receive overrun               0040  AS_PERR   equ    %01000000 receive parity error               0080  AS_IRQ    equ    %10000000 INT flag, 1 is active                     *                     * control codes                     *               0001  AC_DIV0   equ    %00000001 counter divide bit 0 :1/:16/:64/reset               0002  AC_DIV1   equ    %00000010 counter divide bit 1               0004  AC_WS0    equ    %00000100 word select 0 7E2/7O2/7E1/7O1               0008  AC_WS1    equ    %00001000 word select 1 8N2/8N1/8E1/8O1               0010  AC_WS2    equ    %00010000 word select 2               0020  AC_TEIN   equ    %00100000 transmit control 0  NRTS/NINT,NRTS/INTE               0040  AC_DRTS   equ    %01000000 transmit control 1  RTS/NINT,NRTS/SBRK/NINT               0080  AC_REIN   equ    %10000000 receive enable IRQ                     *               0001  AC_DV16   equ    %00000001 setting for clk/16               0003  AC_MRES   equ    AC_DIV1+AC_DIV0 master reset               0014  AC_8N1    equ    AC_WS2+AC_WS0 select for 8N1               0015  AC_SET    equ    AC_8N1+AC_DV16 ACIA default setupCPU09IOP   Intelligent I/O Proce     16:35:49  Jan 23, 2026   Page   10FIO in Dual Port RAM                                                                          *                     * is now performed by CY7C130 dual port RAM where (1024 * 8)                     * the RAM size is limited to the (upper) 256 bytes, which                     * contains the Interrupt handshake locations                     *                     *                       0000                         org    $0000     absolute addressed                                          ************************************************************                     * the first 32 bytes of a fifo/DPR area are the same                     * for ALL applications                     ************************************************************  0000               cpu_fio   rmb    1         Command code  0001               cpu_fio1  rmb    2         Task ID/sequence  0003               cpu_fio2  rmb    1         Message specific data  0004               cpu_fio3  rmb    2         Device designator  0006               cpu_fio4  rmb    2         UIO  0008               cpu_fio5  rmb    1         Device table index                     ************************************************************  0009               fio_cpu   rmb    1         Response code  000A               fio_cpu1  rmb    2         Task ID /sequence  000C               fio_cpu2  rmb    1         Transaction specific value  000D               fio_cpu3  rmb    2         --  000F               fio_cpu4  rmb    2         UIO  0011               fio_cpu5  rmb    1         --                     ************************************************************                     *  0012               fifo_cnt  rmb    2         Count of data in FIFO  0014               fifo_get  rmb    2         retrieval ponter  0016               fifo_put  rmb    2         storage pointer                     *                     * these values are initialized by the IO CPU                     *  0018               fifo_us0  rmb    2         FIFO offset to application data                     *  001A               fifo_us1  rmb    2         FIFO offset to user specific area2  001C               fifo_us2  rmb    2         FIFO offset to user specific area2  001E               fifo_us3  rmb    2         FIFO offset to user specific area3                     *  0020                         rmb    32-(*-cpu_fio) ** Filler **                     * end of defined area                                          ************************************************************  0020               fifo      rmb    1                     * the size of the fifo is defined in the parameter block                     ************************************************************                                          ************************************************************                     * the top 4 locations are also fixed and shared on all applications                     ************************************************************CPU09IOP   Intelligent I/O Proce     16:35:50  Jan 23, 2026   Page   11FIO in Dual Port RAM                                  0021               DEV2CPU   rmb    1         debug data from IOP/GPP  0022               CPU2DEV   rmb    1         debug data to IOP/GPP                     * should end up at the two top locations in the DUALPORT RAM  0023               fio_cpuF  rmb    1         INT + non-zero   contains info AND set CPU IRQ when written  0024               cpu_fioF  rmb    1         INT + non-zero   contains info AND set FIO IRQ when written                     **************************************************************                                          *                     * FIO Task Priority                     *   -- Set to make task uninterruptable while                     *   -- actually using the FIO                     *               000F  FIOPRI    set    15                                          *                     * FIO Control structures                     *                                          * Transaction slots                                                               *                     * IOP ROM Version #                     *               0020  ROM_VERSION equ  $20       Major/Minor Version of IOP ROM                                          *                     * generic and specific transaction codes for use with fio_han                     * these are for IOP                     *                                          *                     * Error codes                     *               0080  REJECT    equ    %10000000 Error/Reject bit in command response               0081  E_BADCMD  equ    REJECT+$01 Illegal command               0082  E_SYSBSY  equ    REJECT+$02 IOP saturated               0083  E_NTOPEN  equ    REJECT+$03 Selected device not open               0084  E_BADDEV  equ    REJECT+$04 Illegal device # (=3)               0085  E_DEVBSY  equ    REJECT+$05 Device is already open (exclusieve)               0086  E_IOERR   equ    REJECT+$06 Some sort of IO error               00BE  E_INTRPT  equ    REJECT+$3E Terminal interrupt (send by IOP to UniFLEX)               00BF  E_ABORT   set    REJECT+$3F Transaction aborted by UniFLEX (not sent by IOP)               00C0  E_SOCKET  equ    REJECT+$40 Socket error,                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     *               0008  O_OPEN    equ    $08       Open device               0010  O_CLOSE   equ    $10       Close device               0018  O_RQWR    equ    $18       Request write               0020  O_WRITE   equ    $20       Write data via fifo to IOPCPU09IOP   Intelligent I/O Proce     16:35:50  Jan 23, 2026   Page   12FIO in Dual Port RAM                                               0028  O_RQRD    equ    $28       Request read data               0030  O_READ    equ    $30       Read data for via fifo from IOP               0038  O_INTRPT  set    $38       Interrupt all tasks on a terminal               0040  O_WR1C    equ    $40       Write single character               0048  O_TTYS    equ    $48       TTY Set               0050  O_TTYG    equ    $50       TTY Get                                    0058  O_PGETD   equ    $58       Read baudrate settings               0060  O_PSETD   equ    $60       Write baudrate settings                                          *                     * Normal responses                     * error is with bit 7 set, A contains error code                     *               000F  R_RESET   equ    $0F       System reset & functioning               0001  R_OPEN    equ    $01       Device open successful               0002  R_CLOSE   equ    $02       Device close successful               0003  R_REQOK   equ    $03       Write request now granted               0004  R_WRITE   equ    $04       Write data complete               0005  R_RDOK    equ    $05       Read data now available               0006  R_READ    equ    $06       Read data in FIFO & no more data is available               0007  R_INTRPT  set    $07       Interrupt complete               0008  R_WR1C    equ    $08       Write single character               0009  R_RD1C    equ    $09       Single character available               000B  R_PDATA   equ    $0B       port data transaction succes               000C  R_READM   equ    $0C       Read data in fifo, more data waiting               000D  R_TTY     equ    $0D       TTYSET/GET complete               000E  R_CLOCK   equ    $0E       Interval Timer Tick                                          CPU09IOP   Intelligent I/O Proce     16:35:50  Jan 23, 2026   Page   13CPU        Vectors                                                         0025                         abs                       FFF0                         org    CPUtraps                       FFF0 E0BB                    fdb    rom_trap  Unused  FFF2 E0B4                    fdb    rom_swi3  SWI3  FFF4 E0AD                    fdb    rom_swi2  SWI2  FFF6 E0A0                    fdb    rom_firq  FIRQ  FFF8 E069                    fdb    irq_han   IRQ  FFFA E0A7                    fdb    rom_swi   SWI  FFFC E09A                    fdb    rom_nmi   NMI  FFFE E075                    fdb    rom_init  Reset                     CPU09IOP   Intelligent I/O Proce     16:35:50  Jan 23, 2026   Page   14System     RESET Code                                                                         *                     * this declaration makes it possible to address                     * NUM_TSK, NUM_TRM etc directly                     *                     *                     * starting device minor for IOP serial devices                     *                     * on the CPU side, serial devices may take up                     * from tty00 up to tty08                     *               0009  IOPTDMIN  equ    9         IOP tty lowest minor               00E0  CFGDAT    equ    $00E0     place in DPR where info is passed                       00E0                         org    CFGDAT  00E0               NUM_TSK   rmb    1  00E1               NUM_CL    rmb    1  00E2               NUM_TRM   rmb    1  00E3               NUM_PPR   rmb    1  00E4               NUM_NEC   rmb    1                                          *                     * the normal declaraction for this device                     *  E000                         org    ROMLOorg                       E000 0D 49 4F 50   DBmsg00   fcc    $d,'IOP ROM :260112',0  E011 0D 53 79 73   DBmsg01   fcc    $d,'System Initialization Complete',0  E031 0D 43 50 55   DBmsg02   fcc    $d,'CPU RESET Complete',0  E045 0D 0D 53 79   CPU_down  fcc    $d,$d,'System CPU not functioning',0                                                         E062  fio_fsz   equ    *               E064  fio_dsz   equ    *+2               E066  max_trn   equ    *+4                     *                     * share specific DUAL PORT RAM device initialization                     * between UniFLEX kernel and IOP CPU                     *  E062 0080                    fdb    128       fio_fsz FIFO SIZE  E064 0100                    fdb    256       fio_dsz DEVICE SIZE  E066 18                      fcb    24        fio_mxtrn MAX_TRANSACTIONS  E067 0000                    fdb    0                                          *                     * IRQ handler                     *               E069  irq_han   equ    *  E069 BD   E506               jsr    IRQ_han   do actual handler                     *                     * common return for all interrupts                     *CPU09IOP   Intelligent I/O Proce     16:35:51  Jan 23, 2026   Page   15System     RESET Code                                 E06C 7D   0118     intret    tst    chproc    change process?  E06F 27   03                 beq    01f  E071 BD   E5C7               jsr    change    change process  E074 3B            01        rti                                                               *                     * System RESET code, interrupts disabled                     *  E075 10CE 7FFF     rom_init  lds    #ROMstack initialize stack pointer  E079                         ldmd   3                       E07C 8E   0000               ldx    #0        clear all of RAM, including FIFO  E07F CC   0000               ldd    #0  E082 ED   81       10        std    ,x++  E084 8C   6FFF               cmpx   #end_vars  E087 25   F9                 blo    10b                                           >E089 17   0050     20        lbsr   stbinit   go initialize system memory                                            E08C 10FE 0276     30        lds    tsktab  E090 32   E9 00A2            leas   TSKSIZ,s  Task 0 Stack  E094 17   02AB               lbsr   fio_reset                                          *                     * Initialization complete - Start executing commands                     *  E097               fio_start                     *         ldb     #ROM_VERSION                     *         stb     fio_cpu1                     *         ldb     #R_RESET   send "system reset & running" message                     *         lbsr    fio_msg                                            E097 7E   E5CD     10        jmp    rsched                     CPU09IOP   Intelligent I/O Proce     16:35:51  Jan 23, 2026   Page   16ROM        Interrupt Fielders                                              E09A 8D   26       rom_nmi   bsr    rom_int  E09C 4E 4D 49 00             fcc    'NMI',0  E0A0 8D   20       rom_firq  bsr    rom_int  E0A2 46 49 52 51             fcc    'FIRQ',0  E0A7 8D   19       rom_swi   bsr    rom_int  E0A9 53 57 49 00             fcc    'SWI',0  E0AD 8D   13       rom_swi2  bsr    rom_int  E0AF 53 57 49 32             fcc    'SWI2',0  E0B4 8D   0C       rom_swi3  bsr    rom_int  E0B6 53 57 49 33             fcc    'SWI3',0  E0BB 8D   05       rom_trap  bsr    rom_int  E0BD 54 52 41 50             fcc    'TRAP',0                       E0C2 8E   E0CF     rom_int   ldx    #ROM_ERR  E0C5 BD   F078               jsr    DB_pdata  E0C8 35   10                 puls   x  E0CA BD   F078               jsr    DB_pdata  E0CD 20   FE       rom_bad   bra    *                     *  E0CF 0D 52 4F 4D   ROM_ERR   fcc    $d,'ROM Error: ',0CPU09IOP   Intelligent I/O Proce     16:35:51  Jan 23, 2026   Page   17Table      Initialization                                                                                                               *                     * stbinit - Initialize System Memory Tables                     *  E0DC 8E   0100     stbinit   ldx    #sys_vars clear all variables  E0DF CC   0000               ldd    #0  E0E2 ED   81       10        std    ,x++  E0E4 8C   6FFF               cmpx   #end_vars done yet?  E0E7 25   F9                 blo    10b  E0E9 CC   0D04               ldd    #DEBUG  E0EC FD   010D               std    DB_cntrl                     * >E0EF 17   0019               lbsr   set_tables go figure out configuration, tables, etc                     * Initialize Terminal Interrupt Queue  E0F2 8E   011E     15        ldx    #SI_Q     set queue empty  E0F5 BF   015A               stx    SI_Q_ptr  E0F8 8E   015D               ldx    #int_buf  reset message in pointer  E0FB BF   016B               stx    int_ptr  E0FE 17   0169               lbsr   clinit    initialize Clists  E101 17   0188     16        lbsr   ttyinit   initialize TTY tables  E104 17   01D5     17        lbsr   tskinit   initialize tasks  E107 17   0F8C     18        lbsr   DB_config display configuration  E10A 39                      rts                                                               *                     * Set up system tables                     *  E10B               set_tables                     * -- Force in the on-board PIA                     *09        ldd     #PIA_SLOT                     *          jsr     [D_test+DEV_L2]                     * -- Force in the TOD interface                     *          ldy     #dev_tab+((MAX_DEV-1)*DEV_SIZE)                     *          ldx     #DEV_TOD                     *          stx     dev_type,y                                                               * Compute configuration  E10B 86   03                 lda    #SR4_SLOTS  E10D 34   02                 pshs   a  E10F CC   8000               ldd    #BASE_SLOT set port address  E112 8E   0106               ldx    #slot_tbl  E115 34   10                 pshs   x  E117 CE   E255     10        ldu    #no_dev  E11A EF   84                 stu    0,x  E11C CE   E333               ldu    #mod_tbl  tables with module refs  E11F AE   C4       12        ldx    mod_type,u  E121 27   0D                 beq    20f       jump if end of module table  E123 AD   98 24              jsr    [D_test,x] check for deviceCPU09IOP   Intelligent I/O Proce     16:35:51  Jan 23, 2026   Page   18Table      Initialization                             E126 25   04                 bcs    15f       jump if found  E128 33   44                 leau   MOD_SIZE,u  E12A 20   F3                 bra    12b  E12C AE   42       15        ldx    mod_name,u  E12E AF   F4                 stx    [0,s]  E130 C3   0010     20        addd   #NEXT_SLOT advance address  E133 AE   E4                 ldx    0,s       update slot table pointer  E135 30   02                 leax   2,x  E137 AF   E4                 stx    0,s  E139 6A   62                 dec    2,s       any more slots  E13B 26   DA                 bne    10b  E13D 35   12                 puls   a,x                     * -- All done setting up configuration                     * Set up constants based on configuration  E13F 86   7C       22        lda    #MAX_CL  E141 34   10                 pshs   x  E143 8E   00E0               ldx    #CFGDAT  E146 9F   18                 stx    fifo_us0  initialize config data pointer  E148 35   10                 puls   x  E14A 97   E1                 sta    NUM_CL                     *  E14C B6   E066               lda    max_trn   reserve for system tasks  E14F 8B   04                 adda   #4  E151 97   E0                 sta    NUM_TSK                     *  E153 CC   0400               ldd    #MAX_OB  E156 FD   0100               std    OBUF_SIZE                     * Now figure out where system tables go, based on configuration  E159 FC   0100     30        ldd    OBUF_SIZE  E15C 83   000A               subd   #10  E15F FD   0102               std    OQHI  E162 B3   E062               subd   fio_fsz  E165 83   0005               subd   #5  E168 FD   0104               std    OQLO  E16B CC   02D6               ldd    #SYS_TABS start of system tables                     * -- Round up to CBSIZE boundary  E16E C3   001F               addd   #CBSIZE-1  E171 C4   E0                 andb   #!(CBSIZE-1)  E173 1F   03                 tfr    d,u                     * -- CLISTS  E175 86   20                 lda    #CBSIZE  E177 D6   E1                 ldb    NUM_CL  E179 3D                      mul  E17A FF   026E               stu    CLISTS  E17D 17   00DC               lbsr   sto_chk   check for system table space overflow >E180 1025 004D               lbcs   40f       jump if it happens                     * -- TTY Control tables  E184 86   22                 lda    #TTYSIZ  E186 D6   E2                 ldb    NUM_TRM  E188 3D                      mul  E189 FF   0270               stu    TTYTABS   point to tty table  E18C 17   00CD               lbsr   sto_chk   check for system table space overflowCPU09IOP   Intelligent I/O Proce     16:35:52  Jan 23, 2026   Page   19Table      Initialization                             E18F 25   40                 bcs    40f       jump if it happens                     * -- TTY Queue headers  E191 86   0A                 lda    #2*QH_SIZE  E193 D6   E2                 ldb    NUM_TRM  E195 3D                      mul  E196 FF   0272               stu    TTYQS  E199 17   00C0               lbsr   sto_chk   check for system table space overflow  E19C 25   33                 bcs    40f       jump if it happens  E19E 86   0A                 lda    #OQH_SIZE  E1A0 D6   E2                 ldb    NUM_TRM  E1A2 3D                      mul  E1A3 17   00B6               lbsr   sto_chk   check for system table space overflow  E1A6 25   29                 bcs    40f       jump if it happens                     * -- TTY Output Queues  E1A8 4F                      clra  E1A9 D6   E2                 ldb    NUM_TRM  E1AB 1F   01                 tfr    d,x  E1AD CC   0000               ldd    #0  E1B0 F3   0100     10        addd   OBUF_SIZE  E1B3 30   1F                 leax   -1,x  E1B5 26   F9                 bne    10b  E1B7 FF   0274               stu    OBUFRS  E1BA 17   009F               lbsr   sto_chk   check for system table space overflow  E1BD 25   12                 bcs    40f       jump if it happens                     * -- Task table  E1BF 86   A2                 lda    #TSKSIZ  E1C1 D6   E0                 ldb    NUM_TSK  E1C3 3D                      mul  E1C4 FF   0276               stu    tsktab  E1C7 17   0092               lbsr   sto_chk   check for system table space overflow  E1CA 25   05                 bcs    40f       jump if it happens  E1CC FF   0278               stu    tskend                     *  E1CF 20   53                 bra    60f                     * -- System table space has overflowed!                     * -- Try adjusting some parameters to get it under control  E1D1 FC   0100     40        ldd    OBUF_SIZE first step, reduce output buffer size  E1D4 83   0020               subd   #32  E1D7 FD   0100               std    OBUF_SIZE  E1DA 1083 0120               cmpd   #MIN_OB  E1DE 2C   41                 bge    50f       jump if still something left  E1E0 CC   0400               ldd    #MAX_OB   start over & try something else  E1E3 FD   0100               std    OBUF_SIZE  E1E6 34   10                 pshs   x  E1E8 9E   18                 ldx    fifo_us0  pointer  E1EA 96   E0                 lda    NUM_TSK   try reducing # tasks  E1EC 80   01                 suba   #1  E1EE 97   E0                 sta    NUM_TSK  E1F0 D6   E2                 ldb    NUM_TRM  E1F2 DB   E3                 addb   NUM_PPR  E1F4 DB   E4                 addb   NUM_NEC  E1F6 35   10                 puls   xCPU09IOP   Intelligent I/O Proce     16:35:52  Jan 23, 2026   Page   20Table      Initialization                             E1F8 CB   03                 addb   #3  E1FA 34   04                 pshs   b  E1FC A1   E0                 cmpa   ,s+  E1FE 2C   21                 bge    50f  E200 86   28                 lda    #MAX_TSK  E202 97   E0                 sta    NUM_TSK  E204 96   E1                 lda    NUM_CL    crank back on # clists  E206 80   01                 suba   #1  E208 97   E1                 sta    NUM_CL  E20A 91   E2                 cmpa   NUM_TRM  E20C 2C   13                 bge    50f  E20E C6   7C                 ldb    #MAX_CL  E210 D7   E1                 stb    NUM_CL  E212 8E   E23E               ldx    #00f  E215 BD   F078               jsr    DB_pdata  E218 BD   F096               jsr    DB_config  E21B BD   F072               jsr    DB_main  E21E 7E   E075               jmp    rom_init  ... what else can I do???  E221 16   FF35     50        lbra   30b       go try it all again                     *-- Initialize devices  E224 CE   027E     60        ldu    #dev_tab  E227 5F            62        clrb  E228 34   04       70        pshs   b  E22A AE   C4                 ldx    dev_addr,u get device address  E22C 27   06                 beq    75f       jump if none there  E22E 10AE 42                 ldy    dev_type,u get device kind  E231 AD   B8 22              jsr    [D_init,y] go initialize device  E234 33   46       75        leau   DEV_SIZE,u  E236 35   04                 puls   b  E238 5C                      incb  E239 C1   0C                 cmpb   #MAX_DEV-1  E23B 26   EB                 bne    70b                     * -- All done  E23D 39            90        rts                     *  E23E 0D 2E 2E 2E   00        fcc    $d,"...Can't size tables!",0                     *  E255 2E 2E 4E 6F   no_dev    fcc    '..None',0                                          *                     * Allocate some system table space                     *   D - Space being consumed                     *   U - Current end of table space                     *   jsr sto_chk (System Table Overflow check)                     *   <CS> if overflow                     *  E25C 33   CB       sto_chk   leau   d,u       compute new end pointer  E25E 1183 6FFF               cmpu   #end_vars overflow?  E262 22   03                 bhi    10f       yes - return error  E264 1C   FE                 clc              no         - return OK  E266 39                      rts  E267 1A   01       10        sec              ..         bad owiesCPU09IOP   Intelligent I/O Proce     16:35:52  Jan 23, 2026   Page   21Table      Initialization                             E269 39                      rts                                          *                     * clinit                     *                     * Initialize character buffer lists.  This routine                     * is only called once at startup time.                     *                       E26A BE   026E     clinit    ldx    CLISTS    point to clist  E26D D6   E1                 ldb    NUM_CL    set count  E26F BF   0119               stx    cfreel    set head pointer  E272 31   88 20    clini2    leay   CBSIZE,x  E275 10AF 84                 sty    0,x       set fwd link  E278 1F   21                 tfr    y,x       advance to next  E27A 5A                      decb  E27B 26   F5                 bne    clini2  E27D 96   E1                 lda    NUM_CL    get buffer count  E27F 80   02                 suba   #2  E281 B7   011C               sta    lcbuf     set max count  E284 4F                      clra             make       d=0  E285 ED   88 E0              std    -CBSIZE,x clear last link  E288 7F   011B               clr    cbufct  E28B 39                      rts              all        done!                                          *                     * ttyinit                     *                     * Init the tty tables and queues.                     *                       E28C 10BE 0272     ttyinit   ldy    TTYQS     point to q tables  E290 6F   E2                 clr    ,-s       terminal # counter  E292 D6   E2                 ldb    NUM_TRM   get terminal count  E294 34   04                 pshs   b  E296 FE   0274               ldu    OBUFRS    output buffer  E299 BE   0270               ldx    TTYTABS   point to TTY Tables  E29C 10AF 84       10        sty    tqin,x    set input q  E29F 31   25                 leay   QH_SIZE,y get next q  E2A1 10AF 02                 sty    tqproc,x  set pr q  E2A4 31   25                 leay   QH_SIZE,y set next q  E2A6 10AF 04                 sty    tqout,x   set output q  E2A9 EF   22                 stu    oq_buf,y  ** Init output Q **  E2AB EF   26                 stu    oq_get,y  E2AD EF   24                 stu    oq_put,y  E2AF FC   0100               ldd    OBUF_SIZE  E2B2 33   CB                 leau   d,u  E2B4 EF   28                 stu    oq_end,y  E2B6 31   2A                 leay   OQH_SIZE,y get next q  E2B8 86   15                 lda    #AC_SET   #%101<<2   8 bits, no parity, 1 stop bit  E2BA A7   88 12              sta    tbaud,x   set conf word  E2BD A6   61                 lda    1,s       get terminal #CPU09IOP   Intelligent I/O Proce     16:35:53  Jan 23, 2026   Page   22Table      Initialization                             E2BF A7   0B                 sta    tdevic+1,x set in table  E2C1 34   46                 pshs   d,u  E2C3 C6   06                 ldb    #DEV_SIZE  E2C5 3D                      mul  E2C6 CE   027E               ldu    #dev_tab  E2C9 33   CB                 leau   d,u  E2CB EC   C4                 ldd    dev_addr,u -- device address  E2CD ED   06                 std    taddr,x  E2CF 35   46                 puls   d,u  E2D1 6C   61                 inc    1,s       bump terminal #  E2D3 30   88 22              leax   TTYSIZ,x  next tty entry  E2D6 6A   E4                 dec    0,s       dec the count  E2D8 26   C2                 bne    10b       repeat?  E2DA 35   86                 puls   d,pc      clean up stack & return                                          *                     * tskinit - Initialize all tasks                     *  E2DC 8E   0276     tskinit   ldx    #tsktab  E2DF BF   0115               stx    utask  E2E2 D6   E0                 ldb    NUM_TSK   # tasks in system  E2E4 34   04                 pshs   b  E2E6 10BE 0276               ldy    tsktab    task 1  E2EA 31   A9 00A2            leay   TSKSIZ,y  E2EE               10  E2EE 86   04       11        lda    #TFREE    mark all tasks free  E2F0 BC   0276               cmpx   tsktab    is this the system task?  E2F3 26   02                 bne    15f  E2F5 86   05                 lda    #TSYS     the system task is never free  E2F7 A7   04       15        sta    tsstat,x  E2F9 86   FF                 lda    #$FF      not associated with a terminal  E2FB A7   0D                 sta    tsdev,x  E2FD A7   0E                 sta    tsdev+1,x  E2FF 33   89 00A2            leau   TSKSIZ,x  initialize stack  E303 CC   E47E               ldd    #IO_han  E306 34   20                 pshs   y  E308 AC   E1                 cmpx   ,s++      task 1?  E30A 26   03                 bne    20f       no - normal I/O handling task  E30C CC   E562               ldd    #SI_HAN   yes - special signal interrupt handling task  E30F 36   06       20        pshu   d  E311 EF   88 12              stu    usp,x  E314 EF   88 14              stu    umark0,x  E317 30   89 00A2            leax   TSKSIZ,x  E31B 6A   E4                 dec    0,s       done?  E31D 26   CF                 bne    10b  E31F 32   61                 leas   1,s       clean up stack  E321 CC   0000               ldd    #0        nothing running or sleeping  E324 FD   010F               std    runlst  E327 FD   0111               std    slplst  E32A FD   0113               std    slplst+tsslnk  E32D 30   A4                 leax   0,y       start interrupt handling task  E32F BD   E673               jsr    makrdyCPU09IOP   Intelligent I/O Proce     16:35:53  Jan 23, 2026   Page   23Table      Initialization                             E332 39                      rtsCPU09IOP   Intelligent I/O Proce     16:35:53  Jan 23, 2026   Page   24IOP        Configuration                                                                      *                     * define which type of boards are present                     *               E333  mod_tbl   equ    *  E333 EEC9 E339               fdb    DEV_6850,SR4_name  E337 0000                    fdb    0                     *  E339 43 50 55 30   SR4_name  fcc    'CPU09SR4',0CPU09IOP   Intelligent I/O Proce     16:35:53  Jan 23, 2026   Page   25FIO        Simulation Routines                                                                *                     * Reset CPU-IOP Interface                     * it is assumed that the FIO (DPR) sits at $0000                     *  E342               fio_reset                     * when here, all storage locations have been erased already                     *  E342 8E   0000               ldx    #0  E345 9F   14                 stx    fifo_get  set Q pointers  E347 9F   16                 stx    fifo_put  E349 8E   00E0               ldx    #CFGDAT  E34C 9F   18                 stx    fifo_us0  so that kernel CPU can see it  E34E BE   E064               ldx    fio_dsz  E351 30   1E                 leax   -2,x      one from top  E353 CE   0400               ldu    #1024     -- Reset Time-Out value                     *  E356 C6   FF       fio_wait  ldb    #255      Spin counter                     *  E358               00  E358 6D   84                 tst    0,x       fio_cpuF  E35A 27   0D                 beq    10f                     *  E35C 5A                      decb  E35D 26   F9                 bne    00b       jump back if not ready  E35F 33   5F                 leau   -1,u  E361 1183 0000               cmpu   #0  E365 26   EF                 bne    fio_wait  E367 20   D9                 bra    fio_reset wait 'forever'                     * reset OK  E369 39            10        rtsCPU09IOP   Intelligent I/O Proce     16:35:53  Jan 23, 2026   Page   26FIO        Simulation Routines                                                                *                     * fio_msg - Send a message via the FIO Mailbox                     * it is assumed that the FIO (DPR) sits at $0000                     *   B - Message code to send (one byte)                     *   fio_cpu1..3 already set up                     *  E36A 34   54       fio_msg   pshs   b,x,u     save register  E36C FE   E064               ldu    fio_dsz  E36F 33   5E                 leau   -2,u      one off top  E371 D7   09                 stb    fio_cpu   set up mailbox value                       E373 86   FF       5         lda    #$FF      tell CPU mailbox full  E375 A7   C4                 sta    0,u       fio_cpuF  E377 8E   FFFF     05        ldx    #$FFFF    time-out counter                     *  E37A A6   C4       10        lda    0,u       fio_cpuF   wait till value consumed  E37C 27   06                 beq    20f       jump if consumed                     *  E37E 30   1F                 leax   -1,x      time-out yet?  E380 26   F8                 bne    10b                     *  E382 20   F3                 bra    05b       try again                     *  E384 35   D4       20        puls   b,x,u,pc                     *                                          *                     * fio_response - Return a response code/sequence #                     * it is assumed that the FIO (DPR) sits at $0000                     *    X = utask,                     *    B - Response code                     *    A - Transaction specific value                     *  E386 34   16       fio_response pshs d,x  E388 8D   18                 bsr    FIO_get   access FIO  E38A BE   0115               ldx    utask     task ID  E38D EC   0A                 ldd    tsseq,x  E38F DD   0A                 std    fio_cpu1  E391 EC   0D                 ldd    tsdev,x   device info  E393 DD   0D                 std    fio_cpu3  E395 A6   E4                 lda    0,s       get transaction specific value  E397 97   0C                 sta    fio_cpu2  E399 E6   61                 ldb    1,s       is RESPONSE code >E39B BD   E36A               jsr    fio_msg  E39E 8D   17                 bsr    FIO_rel   release FIO  E3A0 35   96                 puls   d,x,pc    return                                          *                     * FIO_get - Get access to FIO device                     * -- Sleep till available                     *CPU09IOP   Intelligent I/O Proce     16:35:54  Jan 23, 2026   Page   27FIO        Simulation Routines                        E3A2 34   76       FIO_get   pshs   d,x,y,u   save registers  E3A4 108E 015C     10        ldy    #FIO_lock is the device locked  E3A8 6D   A4                 tst    0,y  E3AA 27   07                 beq    20f       no - go get it                     *  E3AC C6   0F                 ldb    #FIOPRI   waiting for the FIO  E3AE BD   E6AD               jsr    sleep  E3B1 20   F1                 bra    10b       try again                     *  E3B3 6C   A4       20        inc    0,y       mark in use  E3B5 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIO_rel - Release access to FIO                     *  E3B7 34   76       FIO_rel   pshs   d,x,y,u  E3B9 108E 015C               ldy    #FIO_lock  E3BD 6F   A4                 clr    0,y  E3BF BD   E689               jsr    wakeup  E3C2 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIFO_get - Fetch character from FIFO                     *   B - Character fetched                     *  E3C4 34   04       FIFOgeta  pshs   b  E3C6 8D   05                 bsr    FIFO_get  E3C8 35   02                 puls   a  E3CA 1E   89                 exg    a,b  E3CC 39                      rts                     *  E3CD 34   12       FIFO_get  pshs   a,x  E3CF DC   12                 ldd    fifo_cnt  any data?  E3D1 27   15                 beq    99f       no - exit                     *  E3D3                         decd   yes       - adjust count  E3D5 DD   12                 std    fifo_cnt  E3D7 9E   14                 ldx    fifo_get  get consumer pointer  E3D9 E6   88 20              ldb    fifo,x    fetch byte  E3DC 30   01                 leax   1,x       bump pointer  E3DE BC   E062               cmpx   fio_fsz   end of fifo?  E3E1 26   03                 bne    10f                     *  E3E3 8E   0000               ldx    #0        reset pointer                     *  E3E6 9F   14       10        stx    fifo_get                     *  E3E8 35   92       99        puls   a,x,pc                                          *                     * FIFO_put - Place character into FIFO                     *   B - Character fetchedCPU09IOP   Intelligent I/O Proce     16:35:54  Jan 23, 2026   Page   28FIO        Simulation Routines                                           *  E3EA 34   04       FIFOputa  pshs   b  E3EC 1F   89                 tfr    a,b  E3EE 8D   02                 bsr    FIFO_put  E3F0 35   84                 puls   b,pc                     *  E3F2 34   16       FIFO_put  pshs   d,x  E3F4 9E   16                 ldx    fifo_put  get consumer pointer  E3F6 E7   88 20              stb    fifo,x    store byte  E3F9 30   01                 leax   1,x       bump pointer  E3FB BC   E062               cmpx   fio_fsz   end of FIFO?  E3FE 26   03                 bne    10f                     *  E400 8E   0000               ldx    #0        reset pointer  E403 9F   16       10        stx    fifo_put                     *  E405 DC   12                 ldd    fifo_cnt  E407                         incd  E409 DD   12                 std    fifo_cnt  E40B 35   96       99        puls   d,x,pcCPU09IOP   Intelligent I/O Proce     16:35:54  Jan 23, 2026   Page   29FIO        FIO IRQ code                                                                       *                     * FIO interrupt handler, called when IRQ was set (interrupt context)                     * for regular NWP and IOP purpose                     *  E40D BE   016B     fio_irq   ldx    int_ptr   input message pointer  E410 96   00                 lda    cpu_fio   move REQUEST  E412 A7   80                 sta    ,x+  E414 DC   01                 ldd    cpu_fio1  sequence # TASK ID  E416 ED   81                 std    ,x++  E418 96   03                 lda    cpu_fio2  specific DATA  E41A A7   80                 sta    ,x+  E41C DC   04                 ldd    cpu_fio3  device major/minor  E41E ED   81                 std    ,x++  E420 96   08                 lda    cpu_fio5  E422 A7   80                 sta    0,x+                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device, X[6]=devtab                     *  E424 FE   E064               ldu    fio_dsz  E427 33   5F                 leau   -1,u  E429 6F   C4                 clr    0,u       cpu_fioF indicate message consumed                     *  E42B BF   016B               stx    int_ptr   update pointer  E42E 108E 015D               ldy    #int_buf  get message from buffer  E432 A6   A4                 lda    0,y       -- Send interrupt command?  E434 81   38                 cmpa   #O_INTRPT  E436 26   0D                 bne    30f                     *                     * special case OOB signal                     *  E438 10BF 016B               sty    int_ptr   reset pointer  E43C E6   23                 ldb    3,y       signal  E43E AE   24                 ldx    4,y       DEVICE/SOCK reference                     *  E440 BD   EEA6               jsr    sdev_sig  send device signal  E443 20   38                 bra    fiointe   exit                     *                     * normal command                     * acquire free task slot                     *  E445 8E   0276     30        ldx    #tsktab   search for an available task  E448 D6   E0                 ldb    NUM_TSK   Number of tasks in system                     *  E44A A6   04       32        lda    tsstat,x  E44C 81   04                 cmpa   #TFREE    looking for a "free" task  E44E 27   0E                 beq    40f                     *  E450 30   89 00A2            leax   TSKSIZ,x  E454 5A                      decb  E455 26   F3                 bne    32b                     *CPU09IOP   Intelligent I/O Proce     16:35:54  Jan 23, 2026   Page   30FIO        FIO IRQ code                               E457 C6   82                 ldb    #E_SYSBSY can't process - IOP saturated!  E459 BD   E36A               jsr    fio_msg  E45C 20   1F                 bra    fiointe   exit                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device, X[6]=device table                     * move data over into task struct                     *  E45E 108E 015D     40        ldy    #int_buf  get message from buffer  E462 10BF 016B               sty    int_ptr   reset pointer  E466 E6   A0                 ldb    ,y+       command byte  REQUEST  E468 E7   09                 stb    tscmd,x   save for task  E46A EC   A1                 ldd    ,y++      sequence #    task ID  E46C ED   0A                 std    tsseq,x  E46E E6   A0                 ldb    ,y+       command specific DATA  E470 E7   0C                 stb    tstval,x  E472 EC   A1                 ldd    ,y++      associate with terminal major/minor  E474 ED   0D                 std    tsdev,x  E476 A6   A0                 lda    ,y+  E478 A7   0F                 sta    tsdtix,x  device table index  E47A BD   E673               jsr    makrdy    make task ready to run                     *  E47D 39            fiointe   rts              exitCPU09IOP   Intelligent I/O Proce     16:35:55  Jan 23, 2026   Page   31IO         Command Handler                                               *                     *                     * IO_han - I/O Command Handler                     *                     *   This routine comprises the main processing loop                     * for each task in the system.  Whenever an I/O command                     * is detected (via the message interrupt), a task will                     * be scheduled to process it.  This is that task.                     *   The command is saved in the "tscmd" field of the                     * task control block.                     *  E47E               IO_han                     *                     * we execute the task belonging to the transaction                     *  E47E                         clri  E480 BE   0115               ldx    utask     get task control block address  E483 A6   09                 lda    tscmd,x   get I/O command  E485 E6   0F                 ldb    tsdtix,x  get device table selector                     *                     * The command byte is shifted and used as an index                     * in a DEV_XXXX tab, max 32 commands allowed                     *  E487 44                      lsra             isolate    command  E488 44                      lsra  E489 44                      lsra                     *  E48A C1   0D                 cmpb   #MAX_DEV  invalid device?  E48C 25   04                 blo    00f  E48E C6   84                 ldb    #E_BADDEV  E490 20   53                 bra    20f                     *  E492 81   10       00        cmpa   #MAX_FCMD max. fifo commands  E494 25   04                 blo    01f  E496 C6   81                 ldb    #E_BADCMD  E498 20   4B                 bra    20f                     *                     * build 16 bit index in table                     *  E49A 48            01        lsla             --   word index on command  E49B 34   10                 pshs   x         TASK info  E49D 34   02                 pshs   a  E49F 8E   027E               ldx    #dev_tab  E4A2 86   06                 lda    #DEV_SIZE  E4A4 3D                      mul  E4A5 30   8B                 leax   d,x       right table selected  E4A7 AE   02                 ldx    dev_type,x get handler table address  E4A9 35   02                 puls   a  E4AB 10AE 86                 ldy    a,x       get processor address  E4AE 35   10                 puls   x  E4B0 34   20                 pshs   y         can be changed on stack..                     *CPU09IOP   Intelligent I/O Proce     16:35:55  Jan 23, 2026   Page   32IO         Command Handler                                               * Y=function code address, X = task                     *  E4B2 10AE 88 10              ldy    tsagin,x  if 0, d nothing  E4B6 27   0B                 beq    05f       else it is target ponter  E4B8 10AF E4                 sty    0,s       code asks for rerun, overwrite  E4BB 108E 0000               ldy    #0  E4BF 10AF 88 10              sty    tsagin,x  reset pointer                     *                     * TOS now holds correct execution address                     *  E4C3 35   20       05        puls   y         change address  E4C5 4F                      clra                     *  E4C6 8E   E4E8               ldx    #IO_end   interrupt handler address  E4C9 34   10                 pshs   x  E4CB BE   0115               ldx    utask     task pointer  E4CE 10EF 88 16              sts    umark1,x  E4D2 EE   0D                 ldu    tsdev,x   get sock reference                     *                     * CALL HANDLER: X=utask, Y=handler address, U=device reference                     * can be maj/min or wzsock address                     *  E4D4 AD   A4                 jsr    0,y       perform operation & return status  E4D6 32   62                 leas   2,s       clean up stack                     *                     * on return, Y= flag. -1 is resched, else end task                     * B = status , A = danta, X,U are lost                     *  E4D8 BE   0115               ldx    utask     restore task pointer  E4DB 108C FFFF               cmpy   #$ffff  E4DF 26   04                 bne    20f                     * task is NOT done yet, don't stop it! re-schedule  E4E1                         seti   set       interrupt mask  E4E3 20   18                 bra    91f       just escape (and come back)                     *                     * A=transaction value, B=response code, U=device reference                     * X = task pointer                     * in fio_response the task ID is added as sequence reference                     * SEND the response to the host CPU                     *                     *  E4E5 BD   E386     20        jsr    fio_response                     *                     * task is done                     *  E4E8               IO_end    seti   mask      interrupts  E4EA BE   0115               ldx    utask     restore task control block address  E4ED A7   0C                 sta    tstval,x  remember transaction value sent  E4EF E7   09                 stb    tscmd,x   and command response  E4F1 86   04                 lda    #TFREE    mark task "terminated & free"  E4F3 A7   04                 sta    tsstat,x  E4F5 86   FF                 lda    #$FF      disassociate from any terminalCPU09IOP   Intelligent I/O Proce     16:35:55  Jan 23, 2026   Page   33IO         Command Handler                            E4F7 A7   0D                 sta    tsdev,x  E4F9 A7   0E                 sta    tsdev+1,x  E4FB 6F   08                 clr    tssgnl,x  no waiting signals                     *                     * exit here to rescheduling                     *  E4FD BD   E5CD     91        jsr    rsched    run other tasks  E500 16   FF7B               lbra   IO_han                                          *                     * not implemented                     *  E503 C6   81       bad_cmd   ldb    #E_BADCMD error code  E505 39                      rtsCPU09IOP   Intelligent I/O Proce     16:35:55  Jan 23, 2026   Page   34Interrupt  Processing                                                                         *                     * This routine handles all IRQ interrupts                     *                     *  E506               IRQ_han                     *  E506 CE   027E     00        ldu    #dev_tab  scan devices  E509 CC   0000               ldd    #0        start with device 0                     *  E50C AE   C4       10        ldx    dev_addr,u get device address  E50E 27   0A                 beq    20f       jump if none there                     *  E510 10AE 42                 ldy    dev_type,u get device type  E513 AD   B8 20    15        jsr    [D_inthan,y] call interrupt poller/handler >E516 1025 0017               lbcs   99f       exit if interrupt serviced                     *  E51A C3   0001     20        addd   #1        next device  E51D 33   46                 leau   DEV_SIZE,u  E51F 1083 000D               cmpd   #MAX_DEV  any more devices?  E523 25   E7                 blo    10b                                          *                     * Check for FIO Mailbox interrupt                     *  E525 FE   E064               ldu    fio_dsz  E528 33   5F                 leau   -1,u      top location  E52A A6   C4                 lda    0,u       cpu_fioF   see if mailbox interrupt  E52C 27   03                 beq    99f       no - move on  E52E BD   E40D               jsr    fio_irq                                          *         lbsr    DB_main                     *  E531 39            99        rts              return from interrupt                     *CPU09IOP   Intelligent I/O Proce     16:35:55  Jan 23, 2026   Page   35Interrupt  All Tasks                                                                          *                     * Interrupt all tasks associated with a given device                     *   D - Device #, XL = SIG                     *   jsr int_all                     * Note: The current task is skipped, along with                     * the system and the interrupt handler task (1).                     *  E532 34   36       int_all   pshs   d,x,y  E534 D6   E0                 ldb    NUM_TSK  E536 C0   02                 subb   #2  E538 34   04                 pshs   b  E53A BE   0276               ldx    tsktab  E53D 30   89 0144            leax   2*TSKSIZ,x                     *  E541 EC   61       10        ldd    1,s  E543 10A3 0D                 cmpd   tsdev,x   is this guy associated with the device?  E546 26   0E                 bne    20f                     *  E548 BC   0115               cmpx   utask     make sure I don't get blown away  E54B 27   09                 beq    20f                     *  E54D 34   16                 pshs   d,x                     * B = signal #  E54F E6   64                 ldb    4,s       XL  E551 BD   E6E2               jsr    xmtint    interrupt task  E554 35   16                 puls   d,x                     *  E556 30   89 00A2  20        leax   TSKSIZ,x  next task  E55A 6A   E4                 dec    0,s       more tasks?  E55C 26   E3                 bne    10b  E55E 32   61                 leas   1,s                     *  E560 35   B6                 puls   d,x,y,pc  returnCPU09IOP   Intelligent I/O Proce     16:35:56  Jan 23, 2026   Page   36Generic Signal Handling Task                                                                  *                     * SI_HAN Signal interrupt handler                     *  E562 108E 011E     SI_HAN    ldy    #SI_Q     Terminal Interrupt Queue  E566                         seti  E568 FE   015A               ldu    SI_Q_ptr  get current Q ptr  E56B 1183 011E               cmpu   #SI_Q     anything in Q?  E56F 26   07                 bne    20f       yes - go process it                     *  E571 C6   D8                 ldb    #SIQPRI   wait for something to do  E573 BD   E6AD               jsr    sleep  E576 20   EA                 bra    SI_HAN                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *  E578 E6   C2       20        ldb    0,-u      B = Interrupt #  E57A 34   04                 pshs   b  E57C EC   C3                 ldd    0,--u     A = Device #  E57E 34   06                 pshs   d  E580 EC   C3                 ldd    0,--u     task ID  E582 34   06                 pshs   d         save registers  E584 FF   015A               stu    SI_Q_ptr  update pointer                     *                     * S[0][1]=task,U[2][3]=dev,U[4]=response                     *  E587 E6   63                 ldb    3,s       set up to flush all input for this terminal  E589                         clri   allow     interrupts                     *  E58B BD   E3A2               jsr    FIO_get   get access to FIO  E58E EC   E1                 ldd    0,s++     task ID  E590 DD   0A                 std    fio_cpu1  E592 EC   E1                 ldd    ,s++      terminal #  E594 DD   0D                 std    fio_cpu3  terminal  E596 E6   E0                 ldb    ,s+       interrupt #  E598 D7   0C                 stb    fio_cpu2  signal  E59A C6   07                 ldb    #R_INTRPT  E59C BD   E36A               jsr    fio_msg   send interrupt message  E59F BD   E3B7               jsr    FIO_rel   release access to FIO  E5A2 20   BE                 bra    SI_HAN    process more if needed                                          *                     * Send_SI - Send a Signal interrupt                     *   B = Interrupt #                     *   X = task struct                     *   jsr send_SI                     *  E5A4 34   76       send_SI   pshs   d,x,y,u   save registers  E5A6 FE   015A               ldu    SI_Q_ptr  get Q head  E5A9 1183 015A               cmpu   #SI_Q_ptr check for overflow  E5AD 24   0F                 bhs    90f       exit if so - sorry                     *CPU09IOP   Intelligent I/O Proce     16:35:56  Jan 23, 2026   Page   37Generic Signal Handling Task                          E5AF EC   0A                 ldd    tsseq,x   task ID @ master side  E5B1 ED   C1                 std    0,u++  E5B3 EC   0D                 ldd    tsdev,x   device #  E5B5 ED   C1                 std    0,u++     place value in Queue  E5B7 E6   61                 ldb    1,s       old B  E5B9 E7   C0                 stb    0,u+  E5BB FF   015A               stu    SI_Q_ptr  update pointer                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *                     *  E5BE 108E 011E     90        ldy    #SI_Q     wake up Queue server  E5C2 BD   E689               jsr    wakeup  E5C5 35   F6       99        puls   d,x,y,u,pc returnCPU09IOP   Intelligent I/O Proce     16:35:56  Jan 23, 2026   Page   38Scheduler  routines                                                                           *                     * All routines in this file pertain to scheduling                     * operations.                     *                                          *                     * change & rsched                     *                     * Change will change tasks.  The current task is put                     * back on the linked list of running tasks.                     * Rsched will reschedule the cpu giving control to                     * another ready task.  If no tasks are ready, idle                     * looping is done until one becomes ready.  Rsched                     * does not put the current task back on the ready list!                     * This routine returns one to the caller.  All registers                     * are destroyed.                     *                       E5C7 BE   0115     change    ldx    utask     point to task table entry >E5CA 17   006D               lbsr   putrun    put on ready list                     *  E5CD               rsched    seti   mask      interrupts  E5CF BE   0115               ldx    utask     point to current task  E5D2 10EF 88 14              sts    umark0,x  save stack pointers  E5D6 BE   0276               ldx    tsktab    point to task table  E5D9 8D   23                 bsr    swtchu    switch users  E5DB 7F   011D               clr    idle      reset idle/running flag                     *  E5DE 7F   0118     rsche2    clr    chproc    reset change flag >E5E1 17   0025               lbsr   getjob    get a new task  E5E4 26   0C                 bne    rsche3    find one?                       E5E6 86   7F       05        lda    #127      set higheset priority  E5E8 B7   0117               sta    jobpri    set as current  E5EB                         clri   clear     interrupts                     * idle work could go on here  E5ED 12                      nop  E5EE                         seti  E5F0 20   EC                 bra    rsche2    loop til find a ready one                     *  E5F2 F7   0117     rsche3    stb    jobpri    set new priority  E5F5 8D   07                 bsr    swtchu    switch users top page  E5F7 BE   0115               ldx    utask     point to task                     ** -- I don't think this will ever happen                     ** tst tssgnl,x any waiting signals?                     ** lbne sleep yes - this will blow task away...  E5FA CC   0001               ldd    #1        return 1 to new task  E5FD 39                      rts              return                                          *                     * Switch usersCPU09IOP   Intelligent I/O Proce     16:35:57  Jan 23, 2026   Page   39Scheduler  routines                                                      *   X - Task entry for new task                     *  E5FE 35   20       swtchu    puls   y         get return address  E600 BF   0115               stx    utask     set up new running task  E603 10EE 88 14              lds    umark0,x  reset stack  E607 6E   A4                 jmp    0,y       return to caller                     CPU09IOP   Intelligent I/O Proce     16:35:57  Jan 23, 2026   Page   40Scheduler  routines                                                                           *                     * getjob                     *                     * Search ready list for ready task.  If none found,                     * return 'EQ' status.  Otherwise return task table                     * entry address in x.                     *                       E609 5F            getjob    clrb             clear      flag  E60A BE   010F               ldx    runlst    point to head of list  E60D 27   1F                 beq    getjo6    empty list?                     *  E60F A6   04       getjo1    lda    tsstat,x  get status byte  E611 81   01                 cmpa   #TRUN     is it in run state?  E613 26   1B                 bne    getjo8                     *  E615 5D                      tstb             first      in list?  E616 27   06                 beq    getjo2                     *  E618 EC   84                 ldd    tslink,x  remove from list  E61A ED   A4                 std    tslink,y  E61C 20   07                 bra    getjo4                     *  E61E 10AE 84       getjo2    ldy    tslink,x  remove from list head  E621 10BF 010F               sty    runlst    set new head                     *  E625 E6   05       getjo4    ldb    tsprir,x  get priority  E627 6F   84                 clr    tslink,x  zero out link  E629 6F   01                 clr    tslink+1,x so not run list  E62B 86   FF                 lda    #$ff      set ne status  E62D 39                      rts              return                     *  E62E 4F            getjo6    clra             set        eq status  E62F 39                      rts                     *  E630 1F   12       getjo8    tfr    x,y       save old pos  E632 AE   84                 ldx    tslink,x  follow link  E634 27   F8                 beq    getjo6                     *  E636 C6   01                 ldb    #1        set flag  E638 20   D5                 bra    getjo1    repeat loop                     CPU09IOP   Intelligent I/O Proce     16:35:57  Jan 23, 2026   Page   41Scheduler  routines                                                                           *                     * putrun                     *                     * Put current task on ready list.  The list is                     * arranged with higher priority tasks at the top.                     * If equal priorities are found, the new one is                     * put at the end of the block.  On entry, x points                     * to the task table entry.  All registers are                     * destroyed except x.                     *                       E63A 34   01       putrun    pshs   cc        save status  E63C                         seti   mask      interrupts  E63E 10BE 010F               ldy    runlst    point to head  E642 26   0A                 bne    putru2  E644 BF   010F               stx    runlst    set new head                     *  E647 CC   0000     putru1    ldd    #0        set last link  E64A ED   84                 std    tslink,x  E64C 35   81                 puls   cc,pc     return                     *  E64E E6   05       putru2    ldb    tsprir,x  get priority  E650 E1   25                 cmpb   tsprir,y  look for correct prior slot  E652 2F   08                 ble    putru4                     *  E654 FC   010F               ldd    runlst  E657 BF   010F               stx    runlst    set new head  E65A 20   0F                 bra    putru5    link in rest                     *  E65C 1F   23       putru4    tfr    y,u       save last look  E65E 10AE A4                 ldy    tslink,y  follow link  E661 27   0C                 beq    putru6                     *  E663 E1   25                 cmpb   tsprir,y  check priority  E665 2F   F5                 ble    putru4                     *  E667 EC   C4                 ldd    tslink,u  link into list here  E669 AF   C4                 stx    tslink,u                     *  E66B ED   84       putru5    std    tslink,x  E66D 35   81                 puls   cc,pc     return                     *  E66F AF   C4       putru6    stx    tslink,u  E671 20   D4                 bra    putru1    go zero last link                     CPU09IOP   Intelligent I/O Proce     16:35:57  Jan 23, 2026   Page   42Scheduler  routines                                                                           *                     * makrdy                     *                     * Make a task ready to run.  Enter with x                     * pointing to task table entry.  If new tasks                     * priority is higher than current, set the                     * 'chproc' flag so the system can change tasks.                     *                       E673 86   01       makrdy    lda    #TRUN     set status  E675 A7   04                 sta    tsstat,x  E677 CC   0000               ldd    #0        clear events flag  E67A ED   06                 std    tsevnt,x  E67C 8D   BC                 bsr    putrun    put on ready list  E67E E6   05                 ldb    tsprir,x  get priority  E680 F1   0117               cmpb   jobpri    higher than current?  E683 2F   03                 ble    makrd6                     *  E685 7C   0118               inc    chproc    set change flag                     *  E688 39            makrd6    rts              returnCPU09IOP   Intelligent I/O Proce     16:35:57  Jan 23, 2026   Page   43Sleep      and Wakeup routines                                                                *                     * wakeup                     *                     * Wakeup all tasks waiting the event designated                     * in the y register.  The x reg is preserved.                     *                       E689 34   57       wakeup    pshs   cc,d,x,u  save registers  E68B                         seti   mask      interupts  E68D CE   0111               ldu    #slplst  E690 AE   42                 ldx    tsslnk,u  point to sleep list  E692 27   0B                 beq    wakeu4                     *  E694 10AC 06       wakeu2    cmpy   tsevnt,x  check event  E697 27   08                 beq    wakeu5  E699 33   84                 leau   0,x       mark this entry                     *  E69B AE   02       wakeu3    ldx    tsslnk,x  follow chain  E69D 26   F5                 bne    wakeu2    end of list?                     *  E69F 35   D7       wakeu4    puls   cc,d,x,u,pc return                     *  E6A1 34   70       wakeu5    pshs   x,y,u     save registers  E6A3 EC   02                 ldd    tsslnk,x  remove from list  E6A5 ED   42                 std    tsslnk,u  E6A7 8D   CA                 bsr    makrdy    put on ready list  E6A9 35   70                 puls   u,x,y  E6AB 20   EE                 bra    wakeu3    repeat                     CPU09IOP   Intelligent I/O Proce     16:35:58  Jan 23, 2026   Page   44Sleep      and Wakeup routines                                                                *                     * sleep                     *                     * Sleep will put this task to sleep with priority                     * specified in the b register.  On entry, y is pointing                     * to the event which will be awakened.                     *  E6AD 34   51       sleep     pshs   cc,x,u    save registers  E6AF BE   0115               ldx    utask     point to task  E6B2 6D   08                 tst    tssgnl,x  any signals waiting?  E6B4 26   1F                 bne    sleep7                     *  E6B6                         seti   mask      ints  E6B8 E7   05                 stb    tsprir,x  set priority  E6BA 10AF 06                 sty    tsevnt,x  set event  E6BD 86   02                 lda    #TSLEEP   set status  E6BF A7   04                 sta    tsstat,x  E6C1 FC   0113               ldd    slplst+tsslnk get head of list  E6C4 ED   02                 std    tsslnk,x  set new link  E6C6 BF   0113               stx    slplst+tsslnk set new head  E6C9 17   FF01               lbsr   rsched    reschedule cpu                       E6CC BE   0115     20        ldx    utask     get task entry  E6CF 6D   08                 tst    tssgnl,x  any signals waiting?  E6D1 26   02                 bne    sleep7                     *  E6D3 35   D1                 puls   cc,x,u,pc return                     *  E6D5 BE   0115     sleep7    ldx    utask     reset signal  E6D8 6F   08                 clr    tssgnl,x  E6DA EC   88 16              ldd    umark1,x  stack reset point  E6DD 35   51                 puls   cc,x,u    reset cc and registers  E6DF 1F   04                 tfr    d,s       change stacks  E6E1 39                      rts              returnCPU09IOP   Intelligent I/O Proce     16:35:58  Jan 23, 2026   Page   45Sleep      and Wakeup routines                                                                *                     * xmtint - Send an interrupt to a task                     *  X - Task entry                     *  B - signal#                     *  jsr xmtint                     *  E6E2 34   76       xmtint    pshs   d,x,y,u   save registers  E6E4 A6   04                 lda    tsstat,x  get task state  E6E6 81   01                 cmpa   #TRUN     running?  E6E8 26   04                 bne    10f       no - try something else                     *  E6EA E7   08                 stb    tssgnl,x  set signal  E6EC 20   0C                 bra    99f       exit                     *  E6EE 81   02       10        cmpa   #TSLEEP   task sleeping?  E6F0 26   08                 bne    99f       no - can't send interrupt                     *  E6F2 E7   08                 stb    tssgnl,x  set signal  E6F4 10AE 06                 ldy    tsevnt,x  wake task up >E6F7 17   FF8F               lbsr   wakeup                     *  E6FA 35   F6       99        puls   d,x,y,u,pc returnCPU09IOP   Intelligent I/O Proce     16:35:58  Jan 23, 2026   Page   46Clist      - Get & Put Char Code                                                              *                     * getc                     *                     * Get a character from a specified character q.                     * The q is pointed to by y upon entry.  The char                     * is returned in b.                     *                       E6FC 34   15       getc      pshs   x,b,cc    save x  E6FE                         seti  E700 AE   21                 ldx    clfst,y   get first pointer  E702 27   3A                 beq    getc4  E704 E6   80                 ldb    0,x+      get character  E706 E7   61                 stb    1,s  E708 AF   21                 stx    clfst,y   save new ptr  E70A 6A   A4                 dec    clcnt,y   dec the count  E70C 26   09                 bne    getc1  E70E CC   0000               ldd    #0        zero pointers  E711 ED   21                 std    clfst,y  E713 ED   23                 std    cllst,y  E715 20   0E                 bra    getc2  E717 1F   10       getc1     tfr    x,d  E719 C5   1F                 bitb   #CBSIZE-1 check pointer  E71B 26   1C                 bne    getc3  E71D EC   88 E0              ldd    -CBSIZE,x  E720 C3   0002               addd   #2  E723 ED   21                 std    clfst,y   set new first  E725 1F   10       getc2     tfr    x,d  E727 83   0001               subd   #1  E72A C4   E0                 andb   #!(CBSIZE-1) check pointer  E72C 1F   01                 tfr    d,x       reset  E72E FC   0119               ldd    cfreel    get free block  E731 ED   84                 std    0,x       set link  E733 BF   0119               stx    cfreel  E736 7A   011B               dec    cbufct    dec the buffer count  E739 35   01       getc3     puls   cc  E73B 4F                      clra  E73C 35   94                 puls   b,x,pc  E73E 35   01       getc4     puls   cc  E740 86   FF                 lda    #$ff      set -1  E742 35   94                 puls   b,x,pc                     CPU09IOP   Intelligent I/O Proce     16:35:58  Jan 23, 2026   Page   47Clist      - Get & Put Char Code                                                              *                     * putc                     *                     * Put a character on the specified q.  The q is                     * pointed to by y upon entry and the character                     * should be in b.                     *                       E744 34   15       putc      pshs   x,b,cc  E746                         seti  E748 AE   23                 ldx    cllst,y   get tail pointer  E74A 26   16                 bne    putc1  E74C BE   0119               ldx    cfreel    get free list  E74F 27   43                 beq    putc4  E751 EC   84                 ldd    0,x       pickup pointer  E753 FD   0119               std    cfreel  E756 7C   011B               inc    cbufct    update buffer count  E759 CC   0000               ldd    #0        zero fwd link  E75C ED   81                 std    0,x++  E75E AF   21                 stx    clfst,y   set first  E760 20   23                 bra    putc2  E762 1F   10       putc1     tfr    x,d       mask pointer  E764 C5   1F                 bitb   #CBSIZE-1  E766 26   1D                 bne    putc2  E768 34   20                 pshs   y  E76A 10BE 0119               ldy    cfreel    get free list  E76E 27   22                 beq    putc3  E770 EC   A4                 ldd    0,y       get pointer  E772 FD   0119               std    cfreel    save new head  E775 7C   011B               inc    cbufct    update buffer count  E778 10AF 88 E0              sty    -CBSIZE,x  E77C 1F   21                 tfr    y,x  E77E 35   20                 puls   y  E780 CC   0000               ldd    #0        clear fwd link  E783 ED   81                 std    0,x++  E785 E6   61       putc2     ldb    1,s       get character  E787 E7   80                 stb    0,x+      put in q  E789 AF   23                 stx    cllst,y   save last ptr  E78B 6C   A4                 inc    clcnt,y   update character count  E78D 35   01                 puls   cc  E78F 4F                      clra  E790 35   94                 puls   b,x,pc    return  E792 35   20       putc3     puls   y  E794 35   01       putc4     puls   cc  E796 86   FF                 lda    #$ff      set error  E798 35   94                 puls   b,x,pc                     CPU09IOP   Intelligent I/O Proce     16:35:59  Jan 23, 2026   Page   48Output     Q Handling                                                                         *                     * get_oq                     *                     * Fetch the next character from the output Q                     *   Y - Output Queue Header                     *   jsr get_oq                     *   B - Character                     *   <EQ> if Queue was not empty                     *  E79A 34   13       get_oq    pshs   cc,a,x    save registers  E79C                         seti   no        interrupts allowed!  E79E EC   A4                 ldd    oq_count,y  E7A0 27   16                 beq    20f       Queue empty  E7A2 83   0001               subd   #1  E7A5 ED   A4                 std    oq_count,y update counter  E7A7 AE   26                 ldx    oq_get,y  source pointer  E7A9 E6   80                 ldb    ,x+       get data  E7AB AC   28                 cmpx   oq_end,y  buffer overflow?  E7AD 25   02                 blo    10f       no - continue  E7AF AE   22                 ldx    oq_buf,y  yes - reset pointer  E7B1 AF   26       10        stx    oq_get,y  update pointer  E7B3 35   01                 puls   cc  E7B5 4F                      clra             Queue not empty  E7B6 35   92                 puls   a,x,pc    return  E7B8 35   01       20        puls   cc  E7BA 86   FF                 lda    #$FF      Queue empty  E7BC 35   92                 puls   a,x,pc                     CPU09IOP   Intelligent I/O Proce     16:35:59  Jan 23, 2026   Page   49Output     Q Handling                                                                         *                     * put_oq                     *                     * Put a character into an output Q                     *    Y - Output Q header                     *    B - Character to insert                     *    jsr put_oq                     *  E7BE 34   17       put_oq    pshs   cc,d,x    save registers  E7C0                         seti   no        interrupts  E7C2 AE   24                 ldx    oq_put,y  get pointer  E7C4 E7   80                 stb    ,x+       put data into Q  E7C6 AC   28                 cmpx   oq_end,y  buffer overflow?  E7C8 25   02                 blo    10f       no - continue  E7CA AE   22                 ldx    oq_buf,y  yes - reset pointer  E7CC AF   24       10        stx    oq_put,y  save new pointer  E7CE EC   A4                 ldd    oq_count,y update count  E7D0 C3   0001               addd   #1  E7D3 ED   A4                 std    oq_count,y  E7D5 35   97                 puls   cc,d,x,pc returnCPU09IOP   Intelligent I/O Proce     16:35:59  Jan 23, 2026   Page   50Terminal   Drivers                                                                            *                     * The routines in this file make up the main system                     * terminal drivers.  Most of the work is actually                     * performed by other internal routines.                     *                                          *                     * ttopn                     *                     * Open a terminal for use.  On entry, U has                     * the device number.                     *                       E7D7 34   06       ttopn     pshs   d         save device number  E7D9 BD   E868               jsr    ttftab    get table address  E7DC 25   11                 bes    30f  E7DE A6   88 14              lda    tstate,x  get states  E7E1 85   04                 bita   #TOPEN    is it already open?  E7E3 26   02                 bne    ttopn8  E7E5 8D   0D                 bsr    ttdopn    do actual open  E7E7 10AE 06       ttopn8    ldy    taddr,x   point to device  E7EA AD   D8 30              jsr    [D_ttenr,u] enable rcv interrupts  E7ED 35   86                 puls   d,pc      return  E7EF 32   62       30        leas   2,s       drop D  E7F1 16   05EA               lbra   tterxt                                          *                     * ttdopn                     *                     * Do actual terminal open.  X points to tty entry.                     *                       E7F4 10AE 06       ttdopn    ldy    taddr,x   get device address  E7F7 6F   88 16              clr    tstate3,x  E7FA 34   10                 pshs   x  E7FC BE   0115               ldx    utask  E7FF EC   0A                 ldd    tsseq,x  E801 35   10                 puls   x  E803 ED   0C                 std    ttask,x  E805 AD   D8 26    10        jsr    [D_ttconf,u] configure the port                     * response of NE implies open OK                                          * if EQ then blocked by CTS if Carry is 0  E808 26   18                 bne    ttdop6    is it ready?  E80A 25   0B                 bcs    ttdop5    branch if blocked by DCD  E80C 34   31                 pshs   cc,x,y    save regs  E80E                         seti   mask      ints  E810 AD   D8 4A              jsr    [D_ttwcts,u] wait for CTS  E813 35   31                 puls   cc,x,y    reset regs  E815 20   DD                 bra    ttdopn    repeat open  E817 34   31       ttdop5    pshs   cc,x,y    save regsCPU09IOP   Intelligent I/O Proce     16:35:59  Jan 23, 2026   Page   51Terminal   Drivers                                    E819                         seti   mask      ints  E81B AD   D8 4C              jsr    [D_ttwdcd,u] wait for DCD  E81E 35   31                 puls   cc,x,y    reset regs  E820 20   D2                 bra    ttdopn    repeat open  E822 86   36       ttdop6    lda    #ECHO|XTABS|CRMOD|BSECH  E824 A7   08                 sta    tflags,x  setup initial mode  E826 86   7F                 lda    #BSPCH    get backspace char  E828 A7   88 10              sta    tbksp,x   save in table  E82B 86   18                 lda    #CNCLC    get cancel character  E82D A7   88 11              sta    tcncl,x   save in table  E830 A6   88 14              lda    tstate,x  set OPEN flag  E833 8A   04                 ora    #TOPEN    set open status  E835 A7   88 14              sta    tstate,x  save in table  E838 86   01                 lda    #DSR_OK   allow transmitting  E83A A7   88 15              sta    tstate2,x  E83D 39                      rts              return                     CPU09IOP   Intelligent I/O Proce     16:36:00  Jan 23, 2026   Page   52Terminal   Drivers                                                                            *                     * ttcls                     *                     * Close the terminal whode device number is in U.                     *                       E83E 8D   28       ttcls     bsr    ttftab    find table entry  E840 1025 059A               lbes   tterxt    invalid  E844 A6   88 14              lda    tstate,x  was the port actually open?  E847 85   04                 bita   #TOPEN  E849 27   0E                 beq    10f       no - skip flush  E84B 84   FB                 anda   #!TOPEN   yes - clear bit  E84D A7   88 14              sta    tstate,x  ... so we don't get hung up ...  E850 17   03F3               lbsr   flusho    flush out buffers  E853 10AE 06                 ldy    taddr,x   get device address  E856 AD   D8 34              jsr    [D_ttenno,u] close down the port  E859 A6   88 14    10        lda    tstate,x  clear state bits  E85C 84   F8                 anda   #PROTOCOL preserve protocol flags  E85E A7   88 14              sta    tstate,x  E861 6F   88 15              clr    tstate2,x  E864 6F   88 16              clr    tstate3,x  E867 39                      rts                                          *                     * ttftab                     *                     * Find tty table entry associated with device in U.                     * Exit with entry pointed at by X.                     * exit with Y point to devtab entry                     * Also compute device handler table in U.                     *                       E868 1F   30       ttftab    tfr    u,d  E86A D1   E2                 cmpb   NUM_TRM   valid tty?  E86C 24   1A                 bhs    30f                     *                     * device reference now in D                     *  E86E 34   06       ttftb2    pshs   d  E870 BE   0270               ldx    TTYTABS   point to table  E873 86   22                 lda    #TTYSIZ   set size up  E875 3D                      mul              calculate  offset  E876 30   8B                 leax   d,x       point to entry  E878 35   06                 puls   d                     * TODO , use tsdvti  correctly  E87A 108E 027E               ldy    #dev_tab  E87E 86   06                 lda    #DEV_SIZE  E880 3D                      mul  E881 31   AB                 leay   d,y  E883 EE   22                 ldu    dev_type,y get handler table address                     *CPU09IOP   Intelligent I/O Proce     16:36:00  Jan 23, 2026   Page   53Terminal   Drivers                                    E885 1C   FE                 clc              clear error  E887 39                      rts              return                     *  E888 C6   84       30        ldb    #E_BADDEV  E88A 4F                      clra  E88B 1A   01                 sec              set error  E88D 39                      rts              return                     CPU09IOP   Intelligent I/O Proce     16:36:00  Jan 23, 2026   Page   54Terminal   Drivers                                                                            *                     * tintr                     *                     * TTY interrupt handler.  Determine if the interrupt                     * is a receive or transmit one and take appropriate                     * actions.                     *                       E88E 8D   DE       tintr     bsr    ttftb2    calculate table addresses  E890 10AE 06                 ldy    taddr,x   get device address  E893 34   20       01        pshs   y         save port address  E895 EC   64                 ldd    4,s       fetch device status (if present)                       E897 AD   D8 3C              jsr    [D_tttstr,u] test for rcv int  E89A 26   20                 bne    tintr2                       E89C AD   D8 3E              jsr    [D_tttstb,u] test for break interrupt  E89F 26   39                 bne    tintr5                       E8A1 AD   D8 42              jsr    [D_tttstc,u] test drop carrier int  E8A4 26   3C                 bne    tintr6                       E8A6 AD   D8 40              jsr    [D_tttsts,u] test CTS change interrupt  E8A9 26   5F                 bne    tintr9                       E8AB AD   D8 44              jsr    [D_tttstd,u] test dsr change  E8AE 26   41                 bne    tintr8                       E8B0 AD   D8 38              jsr    [D_tttstx,u] test for xmit int  E8B3 26   0F                 bne    tintr3                       E8B5 AD   D8 46              jsr    [D_tttste,u] test error int  E8B8 26   30                 bne    tintr7    ** should be 7? **                       E8BA 20   4E                 bra    tintr9  E8BC AD   D8 2A    tintr2    jsr    [D_ttgetc,u] get character from port  E8BF BD   EB22               jsr    ttyin     go buffer char  E8C2 20   46                 bra    tintr9  E8C4 BD   EA1E     tintr3    jsr    ttyst     go output another char  E8C7 EC   98 04              ldd    [tqout,x] check queue count  E8CA 27   06                 beq    tintr4  E8CC 10B3 0104               cmpd   OQLO      low water mark?  E8D0 26   38                 bne    tintr9  E8D2 10AE 04       tintr4    ldy    tqout,x   get output queue  E8D5 BD   E689               jsr    wakeup  E8D8 20   30                 bra    tintr9  E8DA CC   0002     tintr5    ldd    #INTS     set INT interrupt  E8DD BD   E5A4               jsr    send_SI   send interrupt  E8E0 20   28                 bra    tintr9  E8E2 CC   0001     tintr6    ldd    #HANGS    set hangup unt  E8E5 BD   E5A4               jsr    send_SI   send interruptCPU09IOP   Intelligent I/O Proce     16:36:00  Jan 23, 2026   Page   55Terminal   Drivers                                    E8E8 20   20                 bra    tintr9  E8EA C6   07       tintr7    ldb    #$07      set bell char  E8EC BD   EB22               jsr    ttyin     go buffer it  E8EF 20   19                 bra    tintr9    exit  E8F1 A6   88 15    tintr8    lda    tstate2,x get state  E8F4 85   01                 bita   #DSR_OK   was it OK to send before?  E8F6 27   0A                 beq    85f       no - must be now  E8F8 84   FE                 anda   #!DSR_OK  don't allow any sending  E8FA A7   88 15              sta    tstate2,x  E8FD AD   D8 2E              jsr    [D_ttdisx,u] disable transmitter  E900 20   08                 bra    tintr9    exit  E902 8A   01       85        ora    #DSR_OK   allow transmitting  E904 A7   88 15              sta    tstate2,x  E907 BD   EA06               jsr    ttyren    restart transmission  E90A 35   20       tintr9    puls   y         restore port address  E90C 6E   D8 48              jmp    [D_ttend,u] clean up the port & return                     CPU09IOP   Intelligent I/O Proce     16:36:01  Jan 23, 2026   Page   56Terminal   Drivers                                                                            *                     * ttyset/ttyget                     *                     * Handle the actual get or put of data for ttyset                     * and ttyget.                     *                       E90F 17   FF56     ttyset    lbsr   ttftab    get tty table address  E912 1025 04C8               lbes   tterxt  E916 17   FAAB               lbsr   FIFOgeta  move data from FIFO  E919 E6   08                 ldb    tflags,x  save current flags  E91B A7   08                 sta    tflags,x  set flags  E91D C5   41                 bitb   #RAW|SCHR currently in RAW or Single Character mode?  E91F 26   21                 bne    10f       yes - no change  E921 85   41                 bita   #RAW|SCHR going to one of those modes?  E923 27   1D                 beq    10f       no - continue  E925 6D   94                 tst    [tqin,x]  any unsolicited input?  E927 27   06                 beq    00f       no - continue  E929 6D   0E                 tst    tdel,x    any delimiters?  E92B 27   02                 beq    00f  E92D 6C   0E                 inc    tdel,x    force a delimiter  E92F 85   01       00        bita   #RAW      going into RAW mode?  E931 27   0F                 beq    10f       no  E933 A6   88 14              lda    tstate,x  yes - no HOLD processing in RAW mode  E936 85   02                 bita   #HOLD     currently holding?  E938 27   08                 beq    10f       no - continue  E93A 84   FD                 anda   #!HOLD  E93C A7   88 14              sta    tstate,x  E93F 17   00C4               lbsr   ttyren    kick output  E942 17   FA7F     10        lbsr   FIFOgeta  move data from FIFO  E945 A7   09                 sta    tdelay,x  set delays  E947 17   FA7A               lbsr   FIFOgeta  move data from FIFO  E94A A7   88 11              sta    tcncl,x   set cancel char  E94D 17   FA74               lbsr   FIFOgeta  move data from FIFO  E950 A7   88 10              sta    tbksp,x   set back space char  E953 17   FA6E               lbsr   FIFOgeta  move data from FIFO  E956 84   7F                 anda   #$7F  E958 A7   88 12              sta    tbaud,x   set bauds  E95B 17   FA66               lbsr   FIFOgeta  move data from FIFO  E95E 34   02                 pshs   a  E960 84   F8                 anda   #PROTOCOL save protocol bits  E962 34   02                 pshs   a  E964 A6   88 14              lda    tstate,x  update state  E967 84   07                 anda   #(!PROTOCOL)&$FF clear current bits  E969 AA   E0                 ora    ,s+       set new bits  E96B A7   88 14              sta    tstate,x  E96E 35   02                 puls   a  E970 84   0F                 anda   #$0F      get baud rate  E972 34   02                 pshs   a  E974 A6   88 13              lda    tbaud2,x  update baud rate  E977 84   F0                 anda   #$F0CPU09IOP   Intelligent I/O Proce     16:36:01  Jan 23, 2026   Page   57Terminal   Drivers                                    E979 AA   E0                 ora    ,s+  E97B A7   88 13              sta    tbaud2,x                     *  E97E C6   0D                 ldb    #R_TTY    return TTYSET OK  E980 39                      rts              return                       E981 17   FEE4     ttyget    lbsr   ttftab    get table address  E984 1025 0456               lbes   tterxt  E988 A6   08                 lda    tflags,x  get flags byte  E98A 17   FA5D               lbsr   FIFOputa  put data into FIFO  E98D A6   09                 lda    tdelay,x  get delays  E98F 17   FA58               lbsr   FIFOputa  put data into FIFO  E992 A6   88 11              lda    tcncl,x   get cancel char  E995 17   FA52               lbsr   FIFOputa  put data into FIFO  E998 A6   88 10              lda    tbksp,x   get b.s. char  E99B 17   FA4C               lbsr   FIFOputa  put data into FIFO  E99E A6   88 12              lda    tbaud,x   get bauds  E9A1 84   7F                 anda   #$7F  E9A3 6D   0E                 tst    tdel,x    check delimiter count  E9A5 26   05                 bne    ttys45  E9A7 6D   98 02              tst    [tqproc,x] any chars in processed queue?  E9AA 27   02                 beq    ttysg5  E9AC 8A   80       ttys45    ora    #%10000000 set del bit  E9AE 17   FA39     ttysg5    lbsr   FIFOputa  put data into FIFO  E9B1 A6   88 14              lda    tstate,x  return protocol bits  E9B4 84   F8                 anda   #PROTOCOL  E9B6 34   02                 pshs   a  E9B8 A6   88 13              lda    tbaud2,x  get baud rate  E9BB 84   0F                 anda   #$0F  E9BD AA   E0                 ora    ,s+  E9BF 17   FA28               lbsr   FIFOputa  put data into FIFO                     *  E9C2 C6   0D                 ldb    #R_TTY    response = TTYGET = OK  E9C4 39                      rts              return                                          *                     * get_pdat, get special port data                     *                     * X=utask, Y=handler address, U=device reference               E9C5  get_pdat  equ    *  E9C5 17   FEA0               lbsr   ttftab    get terminal base info  E9C8 1025 0412               lbes   tterxt                     * X=processing code, Y=devtab entry  E9CC 34   36                 pshs   d,x,y                     * extra device table entry....  E9CE AE   24                 ldx    dev_brbu,y baudrate backup  E9D0 A6   84                 lda    0,x       get baud info  E9D2 BD   E3EA               jsr    FIFOputa  E9D5 4F                      clra  E9D6 BD   E3EA               jsr    FIFOputa  E9D9 BD   E3EA               jsr    FIFOputa  E9DC BD   E3EA               jsr    FIFOputaCPU09IOP   Intelligent I/O Proce     16:36:01  Jan 23, 2026   Page   58Terminal   Drivers                                    E9DF 35   36                 puls   d,x,y                     *  E9E1 C6   0B                 ldb    #R_PDATA  E9E3 39                      rts                                          * X=utask, Y=handler address, U=device reference               E9E4  set_pdat  equ    *  E9E4 17   FE81               lbsr   ttftab    get terminal base info  E9E7 1025 03F3               lbes   tterxt  E9EB 34   36                 pshs   d,x,y  E9ED BD   E3C4               jsr    FIFOgeta                     * extra device table entry  E9F0 AE   24                 ldx    dev_brbu,y  E9F2 A7   84                 sta    0,x                     * write baudrate latch !!  E9F4 AE   A4                 ldx    dev_addr,y  E9F6 A7   02                 sta    brr,x     baudrate register  E9F8 BD   E3C4               jsr    FIFOgeta  E9FB BD   E3C4               jsr    FIFOgeta  E9FE BD   E3C4               jsr    FIFOgeta  EA01 35   36                 puls   d,x,y                     *  EA03 C6   0B                 ldb    #R_PDATA  EA05 39                      rtsCPU09IOP   Intelligent I/O Proce     16:36:02  Jan 23, 2026   Page   59TTY        Handlers                                                                           *                     * All code in this section is the common tty handler                     * code.  The device dependent code resides with the                     * drivers.  This handler package requires an ACIA be used                     * for all character type devices.                     *                                                               *                     * ttyren                     *                     * Re-enable the tty output after a timeout operation.                     * Upon entry, x should point to the tty structure.                     *                       EA06               ttyren  EA06 A6   88 14              lda    tstate,x  check state  EA09 85   02                 bita   #HOLD >EA0B 1026 0056               lbne   ttyst9                     *  EA0F 84   FE                 anda   #!TIMOUT  clear time out  EA11 A7   88 14              sta    tstate,x  reset state  EA14 10AE 06                 ldy    taddr,x >EA17 1027 0036               lbeq   ttys55                     *  EA1B AD   D8 2C              jsr    [D_ttenxr,u] enable xmit interrupts                                          CPU09IOP   Intelligent I/O Proce     16:36:02  Jan 23, 2026   Page   60TTY        Handlers                                                                           *                     * ttyst                     *                     * TTY start will output a character to the terminal.                     * Upon entry, x should point to the tty structure in                     * use.  Getc is called for the character.                     *                       EA1E A6   88 15    ttyst     lda    tstate2,x is it ok to transmit?  EA21 85   01                 bita   #DSR_OK >EA23 1027 003E               lbeq   ttyst9    no - wait until it is                     *  EA27 10AE 06                 ldy    taddr,x   get device address  EA2A 27   25                 beq    ttys55                     *  EA2C AD   D8 36              jsr    [D_ttxbsy,u] test xmit busy?  EA2F 27   20                 beq    ttys55                     *  EA31 A6   88 14    ttyst1    lda    tstate,x  EA34 85   01                 bita   #TIMOUT >EA36 1026 002B               lbne   ttyst9                                          ***+++                     ***---                       EA3A               ttyst15  EA3A 10AE 04                 ldy    tqout,x   get out q  EA3D 17   FD5A               lbsr   get_oq    get character  EA40 26   23                 bne    ttyst9    exit if queue empty                                          ***+++                     ***---                       EA42 A6   08                 lda    tflags,x  EA44 85   01                 bita   #RAW      test raw mode  EA46 26   03                 bne    ttyst2                     *  EA48 5D                      tstb             char       negative?  EA49 2B   07                 bmi    ttyst6                     *  EA4B 10AE 06       ttyst2    ldy    taddr,x   get device address  EA4E 6E   D8 28              jmp    [D_ttputc,u] write characetr                     *  EA51 39            ttys55    rts                     *  EA52 A6   88 14    ttyst6    lda    tstate,x  EA55 85   60                 bita   #XANY|XONXOF HOLD processing enabled?  EA57 26   04                 bne    ttyst65   yes                     *  EA59 85   80                 bita   #ESCOFF   ESCape HOLD disabled?  EA5B 26   F4                 bne    ttys55    yes - ignore HOLD characterCPU09IOP   Intelligent I/O Proce     16:36:02  Jan 23, 2026   Page   61TTY        Handlers                                                      *  EA5D A6   88 14    ttyst65   lda    tstate,x  get states  EA60 8A   03                 ora    #TIMOUT|HOLD set hold mode  EA62 A7   88 14              sta    tstate,x  reset states                     *  EA65 10AE 06       ttyst9    ldy    taddr,x   get port  EA68 6E   D8 2E              jmp    [D_ttdisx,u] disable xmit interrupts                     CPU09IOP   Intelligent I/O Proce     16:36:02  Jan 23, 2026   Page   62TTY        Handlers                                                                           *                     * ttyout                     *                     * Put the character in b into the output q.  Upon                     * entry, x should point to the tty structure.  Tab                     * expansions, upper case mapping, and special character                     * handling are all done here.                     *                       EA6B A6   08       ttyout    lda    tflags,x  get flags  EA6D 85   01                 bita   #RAW      raw mode?  EA6F 27   11                 beq    ttyo12                     *  EA71 A6   88 14              lda    tstate,x  no hold in RAW mode  EA74 84   FD                 anda   #!HOLD  EA76 A7   88 14              sta    tstate,x  EA79 10AE 04                 ldy    tqout,x   point to out q  EA7C 17   FD3F               lbsr   put_oq    put char in q  EA7F 16   0087               lbra   ttyoue    go finish                     *  EA82 C1   FF       ttyo12    cmpb   #$ff      special hold char?  EA84 27   53                 beq    ttyou6                     *  EA86 C4   7F                 andb   #$7f      mask parity bit  EA88 C1   09                 cmpb   #TABCH  EA8A 26   11                 bne    ttyou2                     *  EA8C A6   08                 lda    tflags,x  check mode  EA8E 85   04                 bita   #XTABS    expand tabs?  EA90 27   0B                 beq    ttyou2                     *  EA92 C6   20       ttyo14    ldb    #SPACE  EA94 8D   D5                 bsr    ttyout    output it  EA96 A6   0F                 lda    tcolm,x   check column  EA98 85   07                 bita   #7  EA9A 26   F6                 bne    ttyo14                     *  EA9C 39                      rts                     *  EA9D A6   08       ttyou2    lda    tflags,x  check mode  EA9F 85   08                 bita   #LCASE    lower case mode?  EAA1 27   25                 beq    ttyou4                     *  EAA3 C1   61                 cmpb   #'a       lower case letter?  EAA5 25   08                 blo    ttyo22                     *  EAA7 C1   7A                 cmpb   #'z  EAA9 22   04                 bhi    ttyo22                     *  EAAB C0   20                 subb   #$20      make upper  EAAD 20   19                 bra    ttyou4CPU09IOP   Intelligent I/O Proce     16:36:03  Jan 23, 2026   Page   63TTY        Handlers                                                      *  EAAF 108E EB17     ttyo22    ldy    #lcht     point to map                     *  EAB3 E1   A1       ttyo23    cmpb   0,y++  EAB5 26   0D                 bne    ttyo24                     *  EAB7 E6   3F                 ldb    -1,y      get mapped char  EAB9 34   04                 pshs   b  EABB C6   5C                 ldb    #'\       output escape >EABD 17   FFAB               lbsr   ttyout  EAC0 35   04                 puls   b  EAC2 20   15                 bra    ttyou6                     *  EAC4 6D   A4       ttyo24    tst    0,y       end of list?  EAC6 26   EB                 bne    ttyo23                     *  EAC8 C1   0D       ttyou4    cmpb   #CR  EACA 26   0D                 bne    ttyou6                     *  EACC A6   08                 lda    tflags,x  check mode  EACE 85   10                 bita   #CRMOD  EAD0 27   07                 beq    ttyou6                     *  EAD2 C6   0A                 ldb    #NL       convert to NL >EAD4 17   FF94               lbsr   ttyout    output it  EAD7 C6   0D                 ldb    #CR       reset CR                     *  EAD9 10AE 04       ttyou6    ldy    tqout,x   point to out q  EADC 17   FCDF               lbsr   put_oq  EADF C1   0D                 cmpb   #CR  EAE1 22   20                 bhi    ttyou8                     *  EAE3 26   02                 bne    ttyo75    is it cr?                     *  EAE5 6F   0F                 clr    tcolm,x   clear out column count!                     *  EAE7 C1   09       ttyo75    cmpb   #9        is it tab character?  EAE9 26   0A                 bne    ttyo77                     *  EAEB A6   0F                 lda    tcolm,x   get column count  EAED 84   F8                 anda   #!7       mask low 3 bits  EAEF 8B   08                 adda   #8        add in tab  EAF1 A7   0F                 sta    tcolm,x   save new column  EAF3 20   14                 bra    ttyoue                     *  EAF5 C1   08       ttyo77    cmpb   #$08      hardware backspace?  EAF7 25   10                 blo    ttyoue  EAF9 26   08                 bne    ttyou8  EAFB 6D   0F                 tst    tcolm,x   column zero?  EAFD 27   0A                 beq    ttyoue  EAFF 6A   0F                 dec    tcolm,x  EB01 20   06                 bra    ttyoueCPU09IOP   Intelligent I/O Proce     16:36:03  Jan 23, 2026   Page   64TTY        Handlers                                                      *  EB03 C1   20       ttyou8    cmpb   #SPACE    is it control char?  EB05 25   02                 blo    ttyoue                     *  EB07 6C   0F                 inc    tcolm,x   bump column count                     *  EB09 A6   88 14    ttyoue    lda    tstate,x  ** kludge for ACIA **  EB0C 85   02                 bita   #HOLD  EB0E 26   06                 bne    ttyoe1                     *  EB10 10AE 06                 ldy    taddr,x   get device address  EB13 6E   D8 2C              jmp    [D_ttenxr,u] enable xmit interrupts                     *  EB16 39            ttyoe1    rts              return                       EB17 7E 5E 7C 21   lcht      fcc    "~^|!{(})`'"  EB21 00                      fcb    0CPU09IOP   Intelligent I/O Proce     16:36:03  Jan 23, 2026   Page   65TTY        Handlers                                                                           *                     * ttyin                     *                     * Place the character in b on the input q.                     * Upon entry, x should point to the tty structure.                     * Signal processing and character mapping are                     * performed in this roiutine.                     *                       EB22               ttyin                                          ***+++                     ***---                       EB22 A6   08                 lda    tflags,x  raw mode?  EB24 85   01                 bita   #RAW  EB26 26   51                 bne    ttyi44                     *  EB28 C4   7F                 andb   #$7f      mask par bit                     *  EB2A C1   20       ttyin0    cmpb   #SPACE    control char?  EB2C 24   4B                 bhs    ttyi44    skip junk if so                     *  EB2E C1   1C       ttyin2    cmpb   #QUITC  EB30 27   09                 beq    ttyi25                     *  EB32 C1   03                 cmpb   #INTRC  EB34 26   0B                 bne    ttyin3                     *  EB36 CC   0002               ldd    #INTS     set signal  EB39 20   03                 bra    ttyi27                     *  EB3B CC   0003     ttyi25    ldd    #QUITS    set signal                     *  EB3E 7E   E5A4     ttyi27    jmp    send_SI   send interrupt & get out                     *  EB41 A6   88 14    ttyin3    lda    tstate,x  get state  EB44 C1   1B                 cmpb   #HOLDC    Escape?  EB46 26   10                 bne    ttyi34                     *  EB48 85   80                 bita   #ESCOFF   escape processing disabled?  EB4A 26   27                 bne    ttyin4    yes - ignore ESC as special character                     *  EB4C 85   02                 bita   #HOLD     holding??  EB4E 26   1B                 bne    ttyi36                     *  EB50 8A   03       ttyi33    ora    #TIMOUT|HOLD set HOLDing  EB52 A7   88 14              sta    tstate,x  EB55 7E   EA06               jmp    ttyren                     *  EB58 85   40       ttyi34    bita   #XONXOF   doing XON/XOFF processing?CPU09IOP   Intelligent I/O Proce     16:36:04  Jan 23, 2026   Page   66TTY        Handlers                                   EB5A 27   17                 beq    ttyin4    no - don't bother                     *  EB5C C1   13                 cmpb   #XOFFC    XOFF character?  EB5E 26   07                 bne    ttyi35    no                     *  EB60 85   02                 bita   #HOLD     already stopped?  EB62 27   EC                 beq    ttyi33    no - stop output                     *  EB64 16   00B6               lbra   ttyin9    ignore XOFF if already stopped!                     *  EB67 C1   11       ttyi35    cmpb   #XONC     XON character  EB69 26   08                 bne    ttyin4    no - continue                     * -- HOLD off  EB6B 84   FD       ttyi36    anda   #!HOLD    clear hold mode  EB6D A7   88 14              sta    tstate,x  EB70 7E   EA06               jmp    ttyren                     *  EB73 C1   0D       ttyin4    cmpb   #CR       new line?  EB75 26   02                 bne    ttyi44                     *  EB77 6F   0F                 clr    tcolm,x   clear out column                     *  EB79 A6   88 14    ttyi44    lda    tstate,x  get current state  EB7C 85   20                 bita   #XANY     allow any character to restart?  EB7E 27   04                 beq    ttyi46    no - continue on                     *  EB80 85   02                 bita   #HOLD     currently stopped?  EB82 26   E7                 bne    ttyi36    yes - go restart it                     *  EB84 10AE 84       ttyi46    ldy    tqin,x    input Q pointer  EB87 A6   A4                 lda    0,y       check q count                                          ***+++                     ***---                       EB89 81   FE                 cmpa   #CHRLIM   hit limit?  EB8B 1024 008F               lbhs   flusht    flush this guy!                     *  EB8F B6   011B               lda    cbufct    check buffer count  EB92 B1   011C               cmpa   lcbuf  EB95 1022 0085               lbhi   flusht    if overflow, flush!                     *  EB99 A6   08       49        lda    tflags,x  check mode  EB9B 85   01                 bita   #RAW      raw mode?  EB9D 27   10                 beq    ttyin5                     *  EB9F 17   FBA2               lbsr   putc      put char in q  EBA2 10AE 84                 ldy    tqin,x    get in q  EBA5 34   04                 pshs   b         save char  EBA7 17   FADF               lbsr   wakeup    awaken those waiting  EBAA 35   04                 puls   b         get character  EBAC 6C   0E                 inc    tdel,x    bump delimiter countCPU09IOP   Intelligent I/O Proce     16:36:04  Jan 23, 2026   Page   67TTY        Handlers                                   EBAE 39                      rts              return                     *  EBAF 85   08       ttyin5    bita   #LCASE  EBB1 27   0A                 beq    ttyin6                     *  EBB3 C1   41                 cmpb   #'A       capital letter?  EBB5 25   06                 blo    ttyin6                     *  EBB7 C1   5A                 cmpb   #'Z  EBB9 22   02                 bhi    ttyin6                     *  EBBB CB   20                 addb   #$20      make lower case                     *  EBBD 10AE 84       ttyin6    ldy    tqin,x    point to input q  EBC0 17   FB81               lbsr   putc  EBC3 A6   08                 lda    tflags,x  check mode  EBC5 85   40                 bita   #SCHR     single char mode?  EBC7 26   0A                 bne    ttyi65                     *  EBC9 C1   0D                 cmpb   #CR  EBCB 22   12                 bhi    ttyin7                     *  EBCD 27   04                 beq    ttyi65                     *  EBCF C1   04                 cmpb   #EOTCH  EBD1 26   0C                 bne    ttyin7                     *  EBD3 10AE 84       ttyi65    ldy    tqin,x    point to input q  EBD6 34   04                 pshs   b  EBD8 17   FAAE               lbsr   wakeup    wake up waiting  EBDB 6C   0E                 inc    tdel,x    bump count                     *  EBDD 35   04       ttyi67    puls   b         reset char                     *  EBDF E1   88 11    ttyin7    cmpb   tcncl,x   kill character?  EBE2 26   18                 bne    ttyin8                     *  EBE4 A6   08                 lda    tflags,x  check mode  EBE6 85   40                 bita   #SCHR     single character?  EBE8 26   12                 bne    ttyin8                     *  EBEA C6   5E                 ldb    #'^       output '^x\n'  EBEC 17   FE7C               lbsr   ttyout  EBEF C6   78                 ldb    #'x  EBF1 17   FE77               lbsr   ttyout  EBF4 C6   0D                 ldb    #CR  EBF6 17   FE72               lbsr   ttyout  EBF9 7E   EA1E               jmp    ttyst                     *  EBFC A6   08       ttyin8    lda    tflags,x  check mode  EBFE 85   02                 bita   #ECHO  EC00 27   1B                 beq    ttyin9CPU09IOP   Intelligent I/O Proce     16:36:04  Jan 23, 2026   Page   68TTY        Handlers                                                      *  EC02 E1   88 10              cmpb   tbksp,x   back space?  EC05 26   10                 bne    ttyi85                     *  EC07 85   20                 bita   #BSECH    echo bs?  EC09 27   0C                 beq    ttyi85                     *  EC0B C6   08                 ldb    #$08      set bs  EC0D 17   FE5B               lbsr   ttyout  EC10 C6   20                 ldb    #SPACE    set space  EC12 17   FE56               lbsr   ttyout  EC15 C6   08                 ldb    #$08      reset char                     *  EC17 17   FE51     ttyi85    lbsr   ttyout    echo character  EC1A 7E   EA1E               jmp    ttyst     start output                     *  EC1D 39            ttyin9    rts              return                     CPU09IOP   Intelligent I/O Proce     16:36:04  Jan 23, 2026   Page   69TTY        Handlers                                                                           *                     * flusht                     *                     * Flush all queues belonging to this terminal.                     *                       EC1E               flusht >EC1E 17   0050               lbsr   flushi    flush Input queues  EC21 10AE 04                 ldy    tqout,x   point to out q                     *  EC24 17   FB73     10        lbsr   get_oq    flush out q  EC27 2A   FB                 bpl    10b                     *  EC29 10AE 84                 ldy    tqin,x    get input q  EC2C 17   FA5A               lbsr   wakeup    wakeup input q waiters  EC2F 10AE 04                 ldy    tqout,x   wake up out q waiters  EC32 17   FA54               lbsr   wakeup  EC35 A6   88 14              lda    tstate,x  get states  EC38 84   FC                 anda   #!(HOLD|TIMOUT) clear hold mode  EC3A A7   88 14              sta    tstate,x  EC3D CC   0000               ldd    #0        no pre-sold output  EC40 ED   88 18              std    tsold,x  EC43 7E   EA1E               jmp    ttyst                                          *                     * flusho                     *                     * Flush all this guys queues after waiting for the                     * output q to empty.                     *                       EC46 A6   88 14    flusho    lda    tstate,x  check state  EC49 85   02                 bita   #HOLD     holding?  EC4B 27   08                 beq    fluso1                     *  EC4D 84   FC       fluso0    anda   #!(HOLD|TIMOUT)  EC4F A7   88 14              sta    tstate,x  clear hold  EC52 17   FDB1               lbsr   ttyren    kick output                     *  EC55 EC   98 04    fluso1    ldd    [tqout,x] check char count >EC58 1027 FFC2               lbeq   flusht  EC5C A6   88 14              lda    tstate,x  check for hold  EC5F 85   02                 bita   #HOLD  EC61 26   EA                 bne    fluso0                                          ***+++                     ***---                       EC63 10AE 04                 ldy    tqout,x   point to out q  EC66 C6   EC                 ldb    #TTYOPR   set priority  EC68 34   10                 pshs   x         save xCPU09IOP   Intelligent I/O Proce     16:36:05  Jan 23, 2026   Page   70TTY        Handlers                                   EC6A 17   FA40               lbsr   sleep  EC6D 35   10                 puls   x  EC6F 20   E4                 bra    fluso1                                          *                     * flushi - Flush input Queues only                     *  EC71               flushi  EC71 10AE 02                 ldy    tqproc,x  get procd q                     *  EC74 17   FA85     10        lbsr   getc      get character  EC77 2A   FB                 bpl    10b                     *  EC79 10AE 84                 ldy    tqin,x    flush input q                     *  EC7C 17   FA7D     20        lbsr   getc  EC7F 2A   FB                 bpl    20b                     *  EC81 6F   0E                 clr    tdel,x    clear delim count                                          ***+++                     ***---                       EC83 39                      rts                                                                                    *                     * xtprcq                     *                     * Transfer characters from input q to procd q.  If not                     * in raw mode, do escape, backspace, and cancel                     * processing.  Enter with x pointing to tty structure.                     *                       EC84 34   01       xtprcq    pshs   cc        save cc  EC86                         seti   mask      ints  EC88 6D   0E                 tst    tdel,x    delimiters yet?  EC8A 26   10                 bne    xtprc0                                          ***+++                     ***---                       EC8C 10AE 84                 ldy    tqin,x    sleep on input q  EC8F C6   F6                 ldb    #TTYIPR  EC91 34   10                 pshs   x         save x  EC93 17   FA17               lbsr   sleep  EC96 35   10                 puls   x  EC98 35   01                 puls   cc        reset cc  EC9A 20   E8                 bra    xtprcq                     *  EC9C 35   01       xtprc0    puls   cc        reset ccCPU09IOP   Intelligent I/O Proce     16:36:05  Jan 23, 2026   Page   71TTY        Handlers                                   EC9E 6D   94                 tst    [tqin,x]  input q empty?  ECA0 26   04                 bne    xtprc1                     *  ECA2 6A   0E                 dec    tdel,x    dec the del count  ECA4 20   DE                 bra    xtprcq    repeat test                     *  ECA6 108E 0170     xtprc1    ldy    #prcbuf+2 point to buffer  ECAA 5F                      clrb  ECAB 34   24                 pshs   b,y       delimiter flag                     *  ECAD 6D   E4       xtprc2    tst    0,s       delimiter?  ECAF 27   10                 beq    xtpr22                     *  ECB1 6F   E4                 clr    0,s       clear del flag  ECB3 6D   0E                 tst    tdel,x    check del count  ECB5 27   02                 beq    xtpr21    if 0 - skip                     *  ECB7 6A   0E                 dec    tdel,x    dec the del count                     *  ECB9 A6   08       xtpr21    lda    tflags,x  get flags  ECBB 85   41                 bita   #RAW|SCHR in raw mode?  ECBD 1027 0085               lbeq   xtprc5                     *  ECC1 10AE 84       xtpr22    ldy    tqin,x    point to in q  ECC4 17   FA35               lbsr   getc      get a character  ECC7 2B   7D                 bmi    xtprc5    none left?                     *  ECC9 C1   0D                 cmpb   #CR       check for delim  ECCB 27   0C                 beq    xtpr25                     *  ECCD C1   04                 cmpb   #EOTCH  ECCF 26   0A                 bne    xtprc3                     *  ECD1 6C   E4                 inc    0,s       set del flag  ECD3 A6   08                 lda    tflags,x  get flags  ECD5 85   40                 bita   #SCHR     single char mode?  ECD7 26   D4                 bne    xtprc2                     *  ECD9 6C   E4       xtpr25    inc    0,s       set del flag                     *  ECDB A6   08       xtprc3    lda    tflags,x  check mode  ECDD 85   41                 bita   #RAW|SCHR  ECDF 27   04                 beq    xtpr31                     *  ECE1 6C   E4                 inc    0,s       set del flag for each raw char  ECE3 20   51                 bra    xtpr45                     *  ECE5 10AE 61       xtpr31    ldy    1,s       point to buffer  ECE8 A6   3F                 lda    -1,y      check previous  ECEA 81   5C                 cmpa   #'\       escape?  ECEC 26   15                 bne    xtca32                     *CPU09IOP   Intelligent I/O Proce     16:36:06  Jan 23, 2026   Page   72TTY        Handlers                                   ECEE C1   04                 cmpb   #EOTCH    is it eot?  ECF0 27   0A                 beq    xtp315                     *  ECF2 E1   88 10              cmpb   tbksp,x   backspace char?  ECF5 27   05                 beq    xtp315                     *  ECF7 E1   88 11              cmpb   tcncl,x   cancel char?  ECFA 26   07                 bne    xtca32                     *  ECFC 31   3F       xtp315    leay   -1,y      backup over slash  ECFE 10AF 61                 sty    1,s       save new ptr  ED01 20   33                 bra    xtpr45                     *  ED03 E1   88 10    xtca32    cmpb   tbksp,x   backspace char?  ED06 26   0D                 bne    xtca33                     *  ED08 108C 0170               cmpy   #prcbuf+2 buffer begin?  ED0C 27   9F                 beq    xtprc2                     *  ED0E 31   3F                 leay   -1,y      backup pointer  ED10 10AF 61                 sty    1,s  ED13 20   98                 bra    xtprc2                     *  ED15 C1   04       xtca33    cmpb   #EOTCH    eot char?  ED17 27   94                 beq    xtprc2                     *  ED19 E1   88 11              cmpb   tcncl,x   cancel char?  ED1C 26   04                 bne    xtprc4                     *  ED1E 35   24                 puls   b,y       -- caution (order)  ED20 20   84                 bra    xtprc1    repeat all                     *  ED22 C1   20       xtprc4    cmpb   #$20      check for control char  ED24 24   10                 bhs    xtpr45                     *  ED26 C1   0D                 cmpb   #CR       is it cr?  ED28 27   0C                 beq    xtpr45                     *  ED2A C1   09                 cmpb   #9        is it tab char?  ED2C 27   08                 beq    xtpr45                     *  ED2E A6   08                 lda    tflags,x  get flags  ED30 85   80                 bita   #CNTRL    control char ignore?  ED32 1026 FF77               lbne   xtprc2                     *  ED36 10AE 61       xtpr45    ldy    1,s       get pointer  ED39 E7   A0                 stb    0,y+      transfer char  ED3B 10AF 61                 sty    1,s       save pointer  ED3E 108C 026E               cmpy   #prcbuf+PRCSIZ overflow??  ED42 1025 FF67               lblo   xtprc2                     *  ED46 35   04       xtprc5    puls   b         remove del flag from stackCPU09IOP   Intelligent I/O Proce     16:36:06  Jan 23, 2026   Page   73TTY        Handlers                                   ED48 10AE 02                 ldy    tqproc,x  get procd q  ED4B 34   10                 pshs   x  ED4D 8E   0170               ldx    #prcbuf+2 point to processed buf                     *  ED50 AC   62       xtprc6    cmpx   2,s       end of buffer?  ED52 24   07                 bhs    xtprc7                     *  ED54 E6   80                 ldb    0,x+      get character  ED56 17   F9EB               lbsr   putc  ED59 20   F5                 bra    xtprc6                     *  ED5B               xtprc7                                          ***+++                     ***---                       ED5B CC   FFFF               ldd    #-1       set good  ED5E 35   B0                 puls   x,y,pc    return                                          ***+++                     ***---                     *                     * most routines below are called from fio_mesg handler                     * A = specific data, B = command, U = device reference                     *CPU09IOP   Intelligent I/O Proce     16:36:06  Jan 23, 2026   Page   74TTY        Handlers                                                                           *                     * req_read - CPU has informed us he wants to read                     * Tell him when some data is available.                     * U = device reference                     *  ED60 17   FB05     req_read  lbsr   ttftab    get TTY table address  ED63 25   24                 bes    30f  ED65 A6   98 02              lda    [tqproc,x] anything available?  ED68 26   03                 bne    00f       yes - go use it                     *  ED6A 17   FF17               lbsr   xtprcq    go process input (wait if none there)                     *  ED6D A6   98 02    00        lda    [tqproc,x] get input processed count  ED70 27   0A                 beq    05f       jump for EOF detected                     *  ED72 81   01                 cmpa   #1        special case for single character  ED74 27   09                 beq    10f                     *  ED76 E6   08                 ldb    tflags,x  single character & RAW always return 1 char  ED78 C5   41                 bitb   #RAW|SCHR  ED7A 26   03                 bne    10f                     *  ED7C C6   05       05        ldb    #R_RDOK   inform CPU data now available  ED7E 39                      rts                     *  ED7F 10AE 02       10        ldy    tqproc,x  go fetch character  ED82 17   F977               lbsr   getc  ED85 86   09                 lda    #R_RD1C   inform CPU single character returned  ED87 1E   89                 exg    a,b  ED89 39            30        rts                                          *                     * read_data - CPU wants IOP to send data                     *  Max # chars to move in transaction speicific value                     *  ED8A 17   FADB     read_data lbsr   ttftab    get TTY table address  ED8D 25   22                 bes    30f  ED8F FE   0115               ldu    utask     see how many chars to send  ED92 10AE 02                 ldy    tqproc,x  input queue pointer  ED95 6F   E2                 clr    ,-s       set FIFO counter                     *  ED97 A6   A4       10        lda    0,y       any more characters?  ED99 27   0C                 beq    20f       no - done                     *  ED9B 17   F95E               lbsr   getc      fetch character  ED9E 17   F651               lbsr   FIFO_put  put into FIFO  EDA1 6C   E4                 inc    0,s       bump FIFO count  EDA3 6A   4C                 dec    tstval,u  does the guy want more?  EDA5 26   F0                 bne    10b                     *  EDA7 A6   E0       20        lda    ,s+       get # chars in FIFOCPU09IOP   Intelligent I/O Proce     16:36:06  Jan 23, 2026   Page   75TTY        Handlers                                   EDA9 C6   06                 ldb    #R_READ   data now available in FIFO  EDAB 6D   A4                 tst    0,y       any more data in case guy wants it?  EDAD 27   02                 beq    30f                     *  EDAF C6   0C                 ldb    #R_READM  yes - special response                     *  EDB1 39            30        rtsCPU09IOP   Intelligent I/O Proce     16:36:07  Jan 23, 2026   Page   76TTY        Handlers                                                                           *                     * ttywrt                     *                     * The main terminal write routine.  Control is passed                     * to here from the device driver routine which calculates                     * the ttys structure location and passes it in x.                     *                       EDB2 D6   13       ttywrt    ldb    fifo_cnt+1 get FIFO input length  EDB4 C1   00                 cmpb   #0        anything in FIFO?  EDB6 27   0E                 beq    90f       no - exit                     *  EDB8 34   04                 pshs   b         save input length                     *  EDBA 17   F610     10        lbsr   FIFO_get  fetch character  EDBD 17   FCAB               lbsr   ttyout    output it  EDC0 6A   E4                 dec    0,s       decrement count  EDC2 26   F6                 bne    10b       repeat                     *  EDC4 35   02                 puls   a         clean up stack                     *  EDC6 34   01       90        pshs   cc        save cc  EDC8                         seti   mask      ints  EDCA 17   FC51               lbsr   ttyst     give output a kick  EDCD 35   81                 puls   cc,pc     return                                          *                     * open_tty - Perform device open                     *  EDCF               open_tty  EDCF BD   E7D7               jsr    ttopn     perform tty open  EDD2 25   0A                 bes    tterxt                                          ***+++                     ***---                       EDD4 C6   01       10        ldb    #R_OPEN  EDD6 39                      rts                                          *                     * close_tty - Perform device close                     *  EDD7               close_tty  EDD7 BD   E83E               jsr    ttcls     perform tty close  EDDA 27   02                 beq    tterxt                                          ***+++                     ***---                       EDDC C6   02       10        ldb    #R_CLOSE  EDDE 39            tterxt    rtsCPU09IOP   Intelligent I/O Proce     16:36:07  Jan 23, 2026   Page   77TTY        Handlers                                                                           *                     * req_write - Request permission to write data                     *  EDDF               req_write  EDDF BD   E868               jsr    ttftab    get TTY table  EDE2 25   FA                 bes    tterxt                                          ***+++                     ***---                       EDE4 34   01       05        pshs   cc        mask interrupts while fiddling                     *  EDE6               10        seti  EDE8 10AE 04                 ldy    tqout,x   get output queue pointer  EDEB EC   A4                 ldd    oq_count,y get queue length  EDED E3   88 18              addd   tsold,x   include any space already sold  EDF0 F3   E062               addd   fio_fsz   and assume the CPU will send this many more  EDF3 10B3 0102               cmpd   OQHI      space available?  EDF7 2F   16                 ble    20f       yes - OK                     *  EDF9 A6   09                 lda    tdelay,x  special flush bit?  EDFB 85   40                 bita   #$40  EDFD 27   05                 beq    15f       no - go to sleep                     *  EDFF BD   EC46               jsr    flusho    yes - flush output  EE02 20   E2                 bra    10b       try again                     *  EE04 34   76       15        pshs   d,x,y,u   no - save registers  EE06 C6   E2                 ldb    #TTYSPR  EE08 BD   E6AD               jsr    sleep  EE0B 35   76                 puls   d,x,y,u   restore registers  EE0D 20   D7                 bra    10b       try again                     *  EE0F 10BE 0115     20        ldy    utask     am I supposed to be dead?  EE13 6D   28                 tst    tssgnl,y  EE15 26   0D                 bne    30f       yes - abort                     *  EE17 EC   88 18              ldd    tsold,x   update amount pre-sold  EE1A F3   E062               addd   fio_fsz   -- assume entire FIFO load  EE1D ED   88 18              std    tsold,x  EE20 C6   03                 ldb    #R_REQOK  request granted code  EE22 35   81                 puls   cc,pc     return                     *  EE24 35   01       30        puls   cc        clean up stack  EE26 32   62                 leas   2,s       -- pop normal return  EE28 39                      rts              abnormal   I/O completion (no response)                                          *                     * write_data - Write data to a terminal                     *  EE29               write_dataCPU09IOP   Intelligent I/O Proce     16:36:07  Jan 23, 2026   Page   78TTY        Handlers                                   EE29 BD   E868               jsr    ttftab    get tty table pointer >EE2C 1025 FFAE               lbes   tterxt  EE30 BD   EDB2               jsr    ttywrt    go consume data  EE33 34   01                 pshs   cc        save interrupt state  EE35                         seti   mask      interrupts  EE37 EC   88 18              ldd    tsold,x  EE3A B3   E062               subd   fio_fsz  EE3D 2A   03                 bpl    00f                     *  EE3F CC   0000               ldd    #0        don't screw up!                     *  EE42 ED   88 18    00        std    tsold,x   update count  EE45 10AE 04                 ldy    tqout,x   wake up anybody waiting for space                                          ***+++                     ***---                       EE48 BD   E689     10        jsr    wakeup  EE4B C6   04                 ldb    #R_WRITE  EE4D 35   81                 puls   cc,pc     return                     *  EE4F 0D 46 49 46   00        fcc    $d,'FIFO consumed, wakeup at $',0                                          *                     * Write single character                     *  -- Character passed via transaction message                     *  EE6B 34   01       wrt_sc    pshs   cc        save interrupt state  EE6D BD   E868               jsr    ttftab    compute tty table address  EE70 24   05                 bec    00f  EE72 32   61                 leas   1,s       drop old cc  EE74 16   FF67               lbra   tterxt                     *  EE77 10AE 04       00        ldy    tqout,x   output Q pointer  EE7A EC   A4                 ldd    oq_count,y check for overrun  EE7C 10B3 0102               cmpd   OQHI  EE80 23   12                 bls    10f       jump if space                     *  EE82 A6   09                 lda    tdelay,x  special flush bit?  EE84 85   40                 bita   #$40  EE86 27   05                 beq    05f       no - wait for space                     *  EE88 BD   EC46               jsr    flusho    yes - make space!  EE8B 20   EA                 bra    00b                     *  EE8D C6   EC       05        ldb    #TTYOPR   wait a while  EE8F BD   E6AD               jsr    sleep  EE92 20   E3                 bra    00b       try again                     *  EE94 10BE 0115     10        ldy    utask     fetch character  EE98 E6   2C                 ldb    tstval,y  EE9A BD   EA6B               jsr    ttyout    send to output queueCPU09IOP   Intelligent I/O Proce     16:36:08  Jan 23, 2026   Page   79TTY        Handlers                                   EE9D                         seti   mask      interrupts  EE9F BD   EA1E               jsr    ttyst     kick output - make sure it starts  EEA2 C6   04                 ldb    #R_WRITE  EEA4 35   81                 puls   cc,pc     return                     *                     * sdev_sig, generic function to deliver interrupts                     * from main CPU to slave CPU processes                     *                     * B = signal# , A = O_INTRPT/S_INTRPT                     * X = device reference                     * called from Interrupt context                     *  EEA6 1E   01       sdev_sig  exg    d,x                                          *                     * send_int - Interrupt all tasks associated with a terminal                     * D = device #  XL = signal#                     *  EEA8 34   76       send_int  pshs   d,x,y,u  EEAA D1   E2                 cmpb   NUM_TRM  EEAC 24   19                 bhs    10f       skip if invalid                     *  EEAE BD   E868               jsr    ttftab    get TTY table address  EEB1 BD   EC1E               jsr    flusht    flush terminal buffers  EEB4 EC   E4                 ldd    0,s       get terminal #  EEB6 AE   62                 ldx    2,s       XL = signal#                     * D = device , XL = signal#  EEB8 BD   E532               jsr    int_all   interrupt all associated tasks  EEBB BE   0115               ldx    utask     also interrupt current task if appropriate  EEBE A6   61                 lda    1,s  EEC0 A1   0E                 cmpa   tsdev+1,x  EEC2 26   03                 bne    10f                     *  EEC4 BD   E6E2               jsr    xmtint                     *  EEC7 35   F6       10        puls   d,x,y,u,pc clean up stack & return                                          ***+++                     ***----CPU09IOP   Intelligent I/O Proce     16:36:08  Jan 23, 2026   Page   80ACIA       interface routines                                                                                      *                     * 6850 Device table                     *  EEC9               DEV_6850  EEC9 E503                    fdb    bad_cmd   0 -  EECB EDCF                    fdb    open_tty  1 -  EECD EDD7                    fdb    close_tty 2 -  EECF EDDF                    fdb    req_write 3 -  EED1 EE29                    fdb    write_data 4 -  EED3 ED60                    fdb    req_read  5 -  EED5 ED8A                    fdb    read_data 6 -  EED7 EE6B                    fdb    wrt_sc    7 -  EED9 E90F                    fdb    ttyset    8 -  EEDB E981                    fdb    ttyget    9 -  EEDD E503                    fdb    bad_cmd   A -  EEDF E503                    fdb    bad_cmd   B -  EEE1 E503                    fdb    bad_cmd   C -  EEE3 E9C5                    fdb    get_pdat  D -  EEE5 E9E4                    fdb    set_pdat  E -  EEE7 E503                    fdb    bad_cmd   F -                     *                     * end of FIO command list                     *               0010  MAX_FCMD  equ    (*-DEV_6850)/2                       EEE9 EF1D                    fdb    SR4_IRQ  EEEB EF37                    fdb    SR4_init  EEED EF45                    fdb    SR4_test                     *  EEEF EFBE                    fdb    SR4ttconf  EEF1 EFF7                    fdb    SR4ttputc  EEF3 EFFA                    fdb    SR4ttgetc  EEF5 EFFD                    fdb    SR4ttnxr  EEF7 F005                    fdb    SR4ttdisx  EEF9 F00D                    fdb    SR4ttnr  EEFB F015                    fdb    SR4ttnx  EEFD F01D                    fdb    SR4ttnno  EEFF F025                    fdb    SR4ttxbsy  EF01 F02A                    fdb    SR4ttstx  EF03 F032                    fdb    SR4ttiscts  EF05 F03C                    fdb    SR4ttstr  EF07 F044                    fdb    SR4ttstb  EF09 F053                    fdb    SR4ttsts  EF0B F055                    fdb    SR4ttstc  EF0D F063                    fdb    SR4ttstd  EF0F F05E                    fdb    SR4ttste  EF11 F066                    fdb    SR4ttnd  EF13 F067                    fdb    SR4ttwcts  EF15 F071                    fdb    SR4ttwdcd                     *CPU09IOP   Intelligent I/O Proce     16:36:08  Jan 23, 2026   Page   81ACIA       interface routines                                                                 * The routines in this file are specific to an ACIA (6850).                     * They are called from the "ttyhan" and "ttydrv" files.                     * preset table for baudrates at each port                     *                     * baudrate latch backup bytes, for 2 acia's each                     *                     * CB B2 B1 B0 CA A2 A1 A0       C=/CTS override, 0 = active                     * X2 X1 X0 are baudrate select bits 38K4/19K2/9K6/4K8/2K4/1K2/0K6/0K3                     * 111 is highest baudrate, 000 is lowest.                     *  EF17 77            brbupr    fcb    $77       acia 0 and 1 board 1  EF18 77                      fcb    $77       acia 2 and 3 ,, ,,  EF19 77                      fcb    $77       acia 4 and 5 board 2  EF1A 77                      fcb    $77       acia 6 and 7 ,, ,,  EF1B 77                      fcb    $77       acia 8 and 9 board3  EF1C 77                      fcb    $77       acia 10 and 11 ,, ,,               0006  BRTBSIZ   equ    *-brbupr                                          *                     * Check for and process an ACIA interrupt                     *  D - Device #                     *  X - Device address                     *  EF1D 34   76       SR4_IRQ   pshs   d,x,y,u   save registers just in case  EF1F A6   84                 lda    csr,x     check for interrupt  EF21 85   80                 bita   #AS_IRQ  EF23 27   0E                 beq    10f       jump if no interrupt                     *  EF25 5F                      clrb  EF26 34   06                 pshs   d                     *  EF28 EC   62                 ldd    2,s       restore device #  EF2A BD   E88E               jsr    tintr     go process interrupt  EF2D 32   62                 leas   2,s       remove device status  EF2F 1A   01                 sec              --         interrupt processed  EF31 20   02                 bra    99f                     *  EF33 1C   FE       10        clc              --         no interrupt processed                     *  EF35 35   F6       99        puls   d,x,y,u,pc                                          *                     * Initialize ACIA port                     *   B - Device #                     *   X - Device address                     *  EF37 34   76       SR4_init  pshs   d,x,y,u  EF39 6F   02                 clr    2,x       init baudrate latch  EF3B 86   43                 lda    #AC_DRTS+AC_MRES set up reset code  EF3D A7   84                 sta    0,x       reset acia  EF3F 34   06                 pshs   d         delayCPU09IOP   Intelligent I/O Proce     16:36:09  Jan 23, 2026   Page   82ACIA       interface routines                         EF41 35   06                 puls   d  EF43 35   F6                 puls   d,x,y,u,pc                                          *                     * Determine if CPU09SR4 ACIA board is present                     *  D - ACIA port address                     *  Y - Device table address                     *  <CS> if present & ACIA                     *  EF45 34   56       SR4_test  pshs   d,x,u  EF47 1F   03                 tfr    d,u  EF49 86   43                 lda    #AC_DRTS+AC_MRES set up reset code  EF4B A7   C4                 sta    0,u       reset acia  EF4D 34   06                 pshs   d         delay  EF4F 35   06                 puls   d  EF51 A6   C4                 lda    0,u       check response  EF53 27   08                 beq    00f                     *  EF55 84   F3                 anda   #%11110011 todo: bit names  EF57 27   04                 beq    00f                     *  EF59 1C   FE                 clc              --         not an 6350  EF5B 20   5F                 bra    99f                     *                     * found an ACIA, fill in the port info                     *  EF5D               00  EF5D 96   E2                 lda    NUM_TRM   Compute device table address  EF5F C6   06                 ldb    #DEV_SIZE  EF61 3D                      mul  EF62 108E 027E               ldy    #dev_tab  EF66 31   AB                 leay   d,y  EF68 96   E2                 lda    NUM_TRM  EF6A 46                      rora             2 ports for each baudrate backup  EF6B CE   02D0               ldu    #brbutb   address of table  EF6E 33   C6                 leau   a,u                     * account for 4 ports CPU09SR4  EF70 D6   E2                 ldb    NUM_TRM  EF72 CB   04                 addb   #4  EF74 D7   E2                 stb    NUM_TRM                     *  EF76 EC   E4                 ldd    0,s       port address  EF78 8E   EEC9               ldx    #DEV_6850  EF7B ED   A4                 std    dev_addr,y device address  EF7D AF   22                 stx    dev_type,y handler dispatch table  EF7F EF   24                 stu    dev_brbu,y baudrate latch backup  EF81 34   02                 pshs   a  EF83 A6   C9 EC47            lda    (brbupr-brbutb),u get rom preset  EF87 A7   C4                 sta    0,u  EF89 35   02                 puls   a  EF8B 31   26                 leay   DEV_SIZE,y  EF8D C3   0004               addd   #4        offset to next ACIACPU09IOP   Intelligent I/O Proce     16:36:09  Jan 23, 2026   Page   83ACIA       interface routines                         EF90 ED   A4                 std    dev_addr,y  EF92 AF   22                 stx    dev_type,y  EF94 EF   24                 stu    dev_brbu,y  EF96 31   26                 leay   DEV_SIZE,y  EF98 C3   0004               addd   #4  EF9B 33   41                 leau   1,u       next backup location  EF9D ED   A4                 std    dev_addr,y  EF9F AF   22                 stx    dev_type,y  EFA1 EF   24                 stu    dev_brbu,y  EFA3 34   02                 pshs   a  EFA5 A6   C9 EC47            lda    (brbupr-brbutb),u get rom preset  EFA9 A7   C4                 sta    0,u  EFAB 35   02                 puls   a  EFAD 31   26                 leay   DEV_SIZE,y  EFAF C3   0004               addd   #4  EFB2 ED   A4                 std    dev_addr,y  EFB4 AF   22                 stx    dev_type,y  EFB6 EF   24                 stu    dev_brbu,y  EFB8 31   26                 leay   DEV_SIZE,y  EFBA 1A   01                 sec  EFBC 35   D6       99        puls   d,x,u,pc                                                               *                     * ttconf                     *                     * Configure the port pointed at by the Y register.  The X                     * register is pointing to the terminal table.  All registers                     * except D should be preserved.                     *                       EFBE 86   03       SR4ttconf lda    #AC_MRES  reset the acia  EFC0 A7   A4                 sta    csr,y  EFC2 34   06                 pshs   d         delay some here  EFC4 35   06                 puls   d  EFC6 A6   A4                 lda    csr,y     get status - see if acia is really here  EFC8 27   04                 beq    2f        if 0 status - then ok                     *  EFCA 85   F3                 bita   #$f3      see if funny status is ok  todo: bit names  EFCC 26   21                 bne    4f                     *  EFCE A6   88 12    2         lda    tbaud,x   get configuration word from table                       EFD1 8A   01                 ora    #AC_DV16  set up full configuration  EFD3 A7   A4                 sta    csr,y     (no ints enabled & RTS brought high)                     *  EFD5 34   16                 pshs   d,x  EFD7 A6   0B                 lda    tdevic+1,x get terminal id  EFD9 C6   06                 ldb    #DEV_SIZE  EFDB 3D                      mul  EFDC 8E   027E               ldx    #dev_tab  EFDF 30   8B                 leax   d,xCPU09IOP   Intelligent I/O Proce     16:36:09  Jan 23, 2026   Page   84ACIA       interface routines                         EFE1 AE   04                 ldx    dev_brbu,x set baudrate latch  EFE3 A6   84                 lda    0,x  EFE5 A7   22                 sta    brr,y  EFE7 35   16                 puls   d,x                       EFE9 A6   A4                 lda    csr,y     get new status  EFEB 85   08                 bita   #AS_NCTS  is CTS ok?  EFED 27   05                 beq    6f                     *  EFEF 1A   04       4         sez              set        false status  EFF1 1C   FE                 clc              show       wait for CTS  EFF3 39                      rts              return                     *  EFF4 1C   FB       6         clz              set        true status  EFF6 39                      rts              return                                          *                     * ttputc                     *                     * Send the character in the B register to the ACIA.  All                     * registers should be preserved.  Y points to the device.                     *                       EFF7 E7   21       SR4ttputc stb    dbuf,y    send character  EFF9 39                      rts              return                                                               *                     * ttgetc                     *                     * Get the character from the device and return in the B                     * register.  Y points to the device and all registers                     * should be preserved.                     *                       EFFA E6   21       SR4ttgetc ldb    dbuf,y    get the character  EFFC 39                      rts              return                                                               *                     * ttenxr                     *                     * Enable the transmit interrupts and leave the receive                     * interrupt enabled (it is enabled upon routine entry).                     * Y points to the device and X points to to the terminal                     * table entry.  Preserve all registers but D.                     *                     *                       EFFD A6   88 12    SR4ttnxr  lda    tbaud,x   get configuration  F000 8A   A1                 ora    #AC_TEIN+AC_REIN+AC_DV16 enable int bits  F002 A7   A4                 sta    csr,y     send to aciaCPU09IOP   Intelligent I/O Proce     16:36:10  Jan 23, 2026   Page   85ACIA       interface routines                         F004 39                      rts              return                                                               *                     * ttdisx                     *                     * Disable the transmit interrupt and leave the receive                     * interrupt enabled.  Y points to the device and X points                     * to the terminal table entry.  Preserve all but D.                     *                       F005 A6   88 12    SR4ttdisx lda    tbaud,x   get configuration word  F008 8A   81                 ora    #AC_REIN+AC_DV16 set bits  F00A A7   A4                 sta    csr,y     send to acia  F00C 39                      rts              return                                                               *                     * ttenr                     *                     * Enable the receive interrupts only.  The transmit                     * interrupts should be turned off.  Y points to the device                     * and X point to the terminal table entry.  Preserve all                     * but the D register.                     *                       F00D A6   88 12    SR4ttnr   lda    tbaud,x   get configuration word  F010 8A   81                 ora    #AC_REIN+AC_DV16 set bits  F012 A7   A4                 sta    csr,y     send to acia  F014 39                      rts              return                                                               *                     * ttenx                     *                     * Enable the transmit interrupts only.  The receive                     * interrupts should be left disabled.  Y points to the                     * device and X points to the terminal table entry.                     * All registers but D shoud be preserved.                     *                       F015 A6   88 12    SR4ttnx   lda    tbaud,x   get configuration word  F018 8A   21                 ora    #AC_TEIN+AC_DV16 set bits  F01A A7   A4                 sta    csr,y     send to acia  F01C 39                      rts              return                                                               *                     * ttenno                     *                     * Disable all interrupts from device and drop the RTS                     * line.  Y points to the device and X points to theCPU09IOP   Intelligent I/O Proce     16:36:10  Jan 23, 2026   Page   86ACIA       interface routines                                            * terminal table entry.  Preserve all but D register.                     *                       F01D A6   88 12    SR4ttnno  lda    tbaud,x   get configuration word  F020 8A   41                 ora    #AC_DRTS+AC_DV16 set bits  F022 A7   A4                 sta    csr,y     send to acia  F024 39                      rts              return                                                               *                     * ttxbsy                     *                     * Test if the transmit buffer is empty.  Return TRUE if                     * it is empty (N.E. status). Y points to the device and                     * all but A needs preserved.                     *                       F025 A6   A4       SR4ttxbsy lda    csr,y     get status  F027 85   02                 bita   #AS_TDRE  is it busy?  F029 39                      rts              return                                                               *                     * tttstx                     *                     * Test device pointed at by Y for a transmit interrupt.                     * Return TRUE if interrupt present.  Preserve all but                     * the A register.                     *                       F02A A6   A4       SR4ttstx  lda    csr,y     get status  F02C 85   02                 bita   #AS_TDRE  F02E 26   06                 bne    SR4true  F030 20   07                 bra    SR4false                                                               *                     * ttiscts                     *                     * Test device pointed at by X for "Clear to Send"                     * -- Return TRUE (not equal) if yes                     *  F032               SR4ttiscts  F032 85   08                 bita   #AS_NCTS  is CTS down?  F034 26   03                 bne    SR4false  F036 1C   FB       SR4true   clz              no         - return TRUE  F038 39                      rts  F039 1A   04       SR4false  sez              yes        - return FALSE  F03B 39                      rts                                                               *CPU09IOP   Intelligent I/O Proce     16:36:10  Jan 23, 2026   Page   87ACIA       interface routines                                            * tttstr                     *                     * Test device pointed at by Y for a receive interrupt.                     * Return TRUE if interrupt present.  Preserve all but                     * the A register.                     *                       F03C A6   A4       SR4ttstr  lda    csr,y  F03E 85   01                 bita   #AS_RDRF  F040 26   F4                 bne    SR4true  F042 20   F5                 bra    SR4false                                                               *                     * tttstb                     *                     * Test device pointed at by Y for a "break" condition.                     * Return TRUE if found.  Preserve all registers but A                     * and return NULL in B (for break character).                     *                       F044 85   30       SR4ttstb  bita   #AS_OVRN+AS_FRME check for break condition  F046 27   0A                 beq    2f        ZERO = false                     *  F048 E6   21                 ldb    dbuf,y    get character from acia  F04A 34   76                 pshs   d,x,y,u   delay some here  F04C 35   76                 puls   d,x,y,u  F04E A6   21                 lda    dbuf,y    get next garbage char if any  F050 1C   FB                 clz              set        TRUE                     *  F052 39            2         rts              return                                                               *                     * tttsts                     *                     * Test device for "CTS" interrupt.                     *                       F053 20   E4       SR4ttsts  bra    SR4false  not currently implemented                                                               *                     * tttstc                     *                     * Test device pointed at by Y for drop "Carrier Detect"                     * type interrupt.  Return TRUE if so.  Preserve all registers                     * but A.                     *                       F055 85   04       SR4ttstc  bita   #AS_NDCD  check for carrier drop  F057 27   04                 beq    1f        jump if no errorCPU09IOP   Intelligent I/O Proce     16:36:11  Jan 23, 2026   Page   88ACIA       interface routines                                            *  F059 E6   21                 ldb    dbuf,y    read reg to reset status  F05B 1C   FB                 clz              return     true                     *  F05D 39            1         rts              return                                                               *                     * tttste                     *                     * Test device pointed at by Y for error conditions.                     * Handle all errors local to this routine - no status                     * returned.  Preserve all but A.                     *                       F05E A6   21       SR4ttste  lda    dbuf,y    read data register to clear any interrupt conditions  F060 1A   04                 sez              return false clz     return     true  F062 39                      rts              return                                          *                     * tttstd - Test for drop in DTR                     *  F063 1A   04       SR4ttstd  sez              --         not supported by hardware  F065 39                      rts                                                               *                     * ttend                     *                     * Terminate i/o operation for device pointed at by Y.                     * Preserve all but D.                     *                       F066 39            SR4ttnd   rts              return     (nothing for acia)                                                               *                     * ttwcts                     *                     * Wait for CTS to go high (sleep on it).                     *                       F067 8D   AC       SR4ttwcts bsr    SR4ttnx   enable xmit ints only  F069 C6   EC                 ldb    #TTYOPR   set priority  F06B 10AE 04                 ldy    tqout,x   point to output q  F06E 7E   E6AD               jmp    sleep     sleep on CTS                                                               *                     * ttwdcd                     *                     * Wait for DCD to go high (sleep on it).CPU09IOP   Intelligent I/O Proce     16:36:11  Jan 23, 2026   Page   89ACIA       interface routines                                            *                       F071 39            SR4ttwdcd rts              currently  not implementedCPU09IOP   Intelligent I/O Proce     16:36:11  Jan 23, 2026   Page   90Debug Interface Routines                                                   F072               DB_main  F072 8D   4F                 bsr    DB_test   see if debug routines present  F074 6E   9F C002            jmp    [DEBUGROM+2]  F078               DB_pdata  F078 8D   49                 bsr    DB_test   see if debug routines present  F07A 6E   9F C004            jmp    [DEBUGROM+4]  F07E               DB_phex  F07E 8D   43                 bsr    DB_test   see if debug routines present  F080 6E   9F C006            jmp    [DEBUGROM+6]  F084               DB_phex2  F084 8D   3D                 bsr    DB_test   see if debug routines present  F086 6E   9F C008            jmp    [DEBUGROM+8]  F08A               DB_pcrlf  F08A 8D   37                 bsr    DB_test   see if debug routines present  F08C 6E   9F C00A            jmp    [DEBUGROM+10]  F090               DB_check  F090 8D   31                 bsr    DB_test   see if debug routines present  F092 6E   9F C00C            jmp    [DEBUGROM+12]  F096               DB_config  F096 8D   2B                 bsr    DB_test   see if debug routines present  F098 6E   9F C00E            jmp    [DEBUGROM+14]  F09C 34   17       DB_msg    pshs   cc,d,x  F09E AE   65                 ldx    1+2+2,s   get return address  F0A0 EC   81                 ldd    ,x++      get mask word  F0A2 B4   010D               anda   DB_cntrl  F0A5 F4   010E               andb   DB_cntrl+1  F0A8 34   04                 pshs   b  F0AA AA   E0                 ora    ,s+  F0AC 27   04                 beq    10f       jump if flag not set  F0AE 30   02                 leax   2,x       skip over false address & fall through  F0B0 20   02                 bra    20f  F0B2 AE   84       10        ldx    ,x        get false branch label  F0B4 AF   65       20        stx    1+2+2,s   fix up return address  F0B6 35   97                 puls   cc,d,x,pc return                     *  F0B8               DB_pspace  F0B8               DB_outsp  F0B8 34   16                 pshs   d,x  F0BA 8E   F0C1               ldx    #00f  F0BD 8D   B9                 bsr    DB_pdata  F0BF 35   96                 puls   d,x,pc  F0C1 20 00         00        fcc    ' ',0                       F0C3 34   07       DB_test   pshs   cc,d  F0C5 FC   C000               ldd    DEBUGROM  Debug rom present?  F0C8 1083 1234               cmpd   #$1234    special marker  F0CC 27   05                 beq    99f       yes - exit  F0CE 35   07                 puls   cc,d      no - abort DB_xx function  F0D0 32   62                 leas   2,s  F0D2 39                      rts  F0D3 35   87       99        puls   cc,d,pc   returnCPU09IOP   Intelligent I/O Proce     16:36:11  Jan 23, 2026   Page   91Debug Interface Routines                                                                                                     end    rom_initCPU09IOP   Intelligent I/O Proce     16:36:11  Jan 23, 2026   Page   92Debug Interface Routines                            Symbol Table:Absolute Symbols:A        0008   AC_8N1   0014   AC_DIV0  0001   AC_DIV1  0002   AC_DRTS  0040   AC_DV16  0001   AC_MRES  0003   AC_REIN  0080   AC_SET   0015   AC_TEIN  0020   AC_WS0   0004   AC_WS1   0008   AC_WS2   0010   AS_FRME  0010   AS_IRQ   0080   AS_NCTS  0008   AS_NDCD  0004   AS_OVRN  0020   AS_PERR  0040   AS_RDRF  0001   AS_TDRE  0002   B        0009   BASE_SLO 8000   BRTBSIZ  0006   BSECH    0020   BSPCH    007F   CBSIZE   0020   CC       000A   CFGDAT   00E0   CHRLIM   00FE   CLISTS   026E   CLOCK    8070   CLOCKI   8071   CLOCKPR  FFC4   CNCLC    0018   CNTRL    0080   CPU2DEV  0022   CPU_down E045   CPUtraps FFF0   CR       000D   CRMOD    0010   D        0000   DBG_8274 0002   DBG_CMD  0100   DBG_HAN  0020   DBG_INIT 0400   DBG_INT  0004   DBG_IO   0010   DBG_MSG  0200   DBG_OPEN 0800   DBG_SLP  0040   DBG_SYS  0001   DBG_TASK 0080   DBG_TRMI 0008   DB_check F090   DB_cntrl 010D   DB_confi F096   DB_iflg  010C   DB_main  F072   DB_msg   F09C   DB_outsp F0B8   DB_pcrlf F08A   DB_pdata F078   DB_phex  F07E   DB_phex2 F084   DB_pspac F0B8   DB_test  F0C3   DBmsg00  E000   DBmsg01  E011   DBmsg02  E031   DEBUG    0D04   DEBUGROM C000   DEBUG_CO 0000   DEV2CPU  0021   DEV_6850 EEC9   DEV_SIZE 0006   DLE      0010   DLE_GOT  0040   DLE_SENT 0020   DO_HISTO 0000   DO_IXON  0000   DP       000B   DSR_OK   0001   D_CLOSE  0004   D_END    0026   D_GETD   0014   D_INTRPT 000E   D_OPEN   0002   D_RQRD   000A   D_RQWR   0006   D_SEND   000C   D_SETD   0016   D_TTYG   001C   D_TTYS   001A   D_WRC    001E   D_WRITE  0008   D_init   0022   D_inthan 0020   D_test   0024   D_ttconf 0026   D_ttdisx 002E   D_ttend  0048   D_ttenno 0034   D_ttenr  0030   D_ttenx  0032   D_ttenxr 002C   D_ttgetc 002A   D_ttisct 003A   D_ttputc 0028   D_tttstb 003E   D_tttstc 0042   D_tttstd 0044   D_tttste 0046   D_tttstr 003C   D_tttsts 0040   D_tttstx 0038   D_ttwcts 004A   D_ttwdcd 004C   D_ttxbsy 0036   E        000E   ECHO     0002   EOTCH    0004   ESCOFF   0080   E_ABORT  00BF   E_BADCMD 0081   E_BADDEV 0084   E_DEVBSY 0085   E_INTRPT 00BE   E_IOERR  0086   E_NTOPEN 0083   E_SOCKET 00C0   E_SYSBSY 0082   F        000F   FF       0040   FIFO_get E3CD   FIFO_put E3F2   FIFOgeta E3C4   FIFOputa E3EA   FIOPRI   000F   FIO_get  E3A2   FIO_lock 015C   FIO_rel  E3B7   HANGS    0001   HOLD     0002   HOLDC    001B   IF       0010   INTRC    0003   INTS     0002   IOPTDMIN 0009   IO_end   E4E8   IO_han   E47E   IRQ_han  E506   IS       0003   IU       0002   IX       0000   IXONXOF  0010   IY       0001   LCASE    0008   MAX_CL   007C   MAX_DEV  000D   MAX_FCMD 0010   MAX_NEC  0000   MAX_OB   0400   MAX_PPR  0000   MAX_TI   000A   MAX_TSK  0028   MAX_TTY  000C   MIN_OB   0120   MIN_TSK  0020   MOD_SIZE 0004   NECADR   02CE   NEC_IQ   02CC   NECstr   027C   NEXT_SLO 0010   NL       000A   NUM_CL   00E1   NUM_NEC  00E4   NUM_PPR  00E3   NUM_TRM  00E2   NUM_TSK  00E0   OBUFRS   0274   OBUF_SIZ 0100   OQHI     0102   OQH_SIZE 000A   OQLO     0104   O_CLOSE  0010   O_INTRPT 0038   O_OPEN   0008   O_PGETD  0058   O_PSETD  0060   O_READ   0030   O_RQRD   0028   O_RQWR   0018   O_TTYG   0050   O_TTYS   0048   O_WR1C   0040   O_WRITE  0020   PC       0005   PPstr    027A   PRCSIZ   0100   PROTOCOL 00F8   QH_SIZE  0005   QUITC    001C   QUITS    0003   RAMend   6FFF   RAMorg   0100   RAMscrat 7000   RAMscren 7F00   RAW      0001   REJECT   0080   ROMLOorg E000   ROM_ERR  E0CF   ROM_VERS 0020   ROMstack 7FFF   RUNPRI   0046   R_CLOCK  000E   R_CLOSE  0002   R_INTRPT 0007   R_OPEN   0001   R_PDATA  000B   R_RD1C   0009   R_RDOK   0005   R_READ   0006   R_READM  000C   R_REQOK  0003   CPU09IOP   Intelligent I/O Proce     16:36:12  Jan 23, 2026   Page   93Debug Interface Routines                            R_RESET  000F   R_TTY    000D   R_WR1C   0008   R_WRITE  0004   S        0004   SCHR     0040   SEND_DLE 0008   SEND_XOF 0004   SEND_XON 0002   SIQPRI   FFD8   SI_HAN   E562   SI_Q     011E   SI_Q_ptr 015A   SPACE    0020   SR4_IRQ  EF1D   SR4_SLOT 0003   SR4_init EF37   SR4_name E339   SR4_test EF45   SR4false F039   SR4true  F036   SR4ttcon EFBE   SR4ttdis F005   SR4ttget EFFA   SR4ttisc F032   SR4ttnd  F066   SR4ttnno F01D   SR4ttnr  F00D   SR4ttnx  F015   SR4ttnxr EFFD   SR4ttput EFF7   SR4ttstb F044   SR4ttstc F055   SR4ttstd F063   SR4ttste F05E   SR4ttstr F03C   SR4ttsts F053   SR4ttstx F02A   SR4ttwct F067   SR4ttwdc F071   SR4ttxbs F025   SYS_ACIA 8000   SYS_TABS 02D6   TABCH    0009   TFREE    0004   TIMOUT   0001   TOPEN    0004   TOPWOC   0010   TRANSPNT 0008   TRUN     0001   TSKSIZ   00A2   TSLEEP   0002   TSYS     0005   TTYIPR   FFF6   TTYLOCK  FFDD   TTYOPR   FFEC   TTYQS    0272   TTYSIZ   0022   TTYSPR   FFE2   TTYTABS  0270   TWAIT    0003   U        0003   USTSIZ   008A   V        0007   W        0006   X        0001   XANY     0020   XOFFC    0013   XOF_SENT 0010   XONC     0011   XONXOF   0040   XTABS    0004   Y        0002   Z0       000C   Z1       000D   bad_cmd  E503   brbupr   EF17   brbutb   02D0   brr      0002   cbchrs   0002   cbstrt   0000   cbufct   011B   cfreel   0119   change   E5C7   chproc   0118   clcnt    0000   clfst    0001   clini2   E272   clinit   E26A   cllst    0003   clock_ti 016D   close_tt EDD7   cpu_fio  0000   cpu_fio1 0001   cpu_fio2 0003   cpu_fio3 0004   cpu_fio4 0006   cpu_fio5 0008   cpu_fioF 0024   csr      0000   dbuf     0001   dev_addr 0000   dev_brbu 0004   dev_tab  027E   dev_type 0002   end_vars 6FFF   fifo     0020   fifo_cnt 0012   fifo_get 0014   fifo_put 0016   fifo_us0 0018   fifo_us1 001A   fifo_us2 001C   fifo_us3 001E   fio_cpu  0009   fio_cpu1 000A   fio_cpu2 000C   fio_cpu3 000D   fio_cpu4 000F   fio_cpu5 0011   fio_cpuF 0023   fio_dsz  E064   fio_fsz  E062   fio_irq  E40D   fio_msg  E36A   fio_rese E342   fio_resp E386   fio_star E097   fio_wait E356   fiointe  E47D   flushi   EC71   flusho   EC46   flusht   EC1E   fluso0   EC4D   fluso1   EC55   get_oq   E79A   get_pdat E9C5   getc     E6FC   getc1    E717   getc2    E725   getc3    E739   getc4    E73E   getjo1   E60F   getjo2   E61E   getjo4   E625   getjo6   E62E   getjo8   E630   getjob   E609   idle     011D   int_all  E532   int_buf  015D   int_ptr  016B   intret   E06C   irq_han  E069   jobpri   0117   lcbuf    011C   lcht     EB17   makrd6   E688   makrdy   E673   max_trn  E066   mod_name 0002   mod_tbl  E333   mod_type 0000   no_dev   E255   open_tty EDCF   oq_buf   0002   oq_count 0000   oq_end   0008   oq_get   0006   oq_put   0004   prcbuf   016E   put_oq   E7BE   putc     E744   putc1    E762   putc2    E785   putc3    E792   putc4    E794   putru1   E647   putru2   E64E   putru4   E65C   putru5   E66B   putru6   E66F   putrun   E63A   read_dat ED8A   req_read ED60   req_writ EDDF   rom_bad  E0CD   rom_firq E0A0   rom_init E075   rom_int  E0C2   rom_nmi  E09A   rom_swi  E0A7   rom_swi2 E0AD   rom_swi3 E0B4   rom_trap E0BB   rsche2   E5DE   rsche3   E5F2   rsched   E5CD   runlst   010F   sdev_sig EEA6   send_SI  E5A4   send_int EEA8   set_pdat E9E4   set_tabl E10B   sleep    E6AD   sleep7   E6D5   slot_tbl 0106   slplst   0111   stbinit  E0DC   sto_chk  E25C   swtchu   E5FE   sys_vars 0100   taddr    0006   tbaud    0012   tbaud2   0013   tbksp    0010   tcncl    0011   tcolm    000F   tdel     000E   tdelay   0009   tdevic   000A   tflags   0008   tintr    E88E   tintr2   E8BC   tintr3   E8C4   tintr4   E8D2   tintr5   E8DA   tintr6   E8E2   tintr7   E8EA   tintr8   E8F1   tintr9   E90A   tlock    0017   tqin     0000   tqout    0004   tqproc   0002   tregs    001A   tsagin   0010   tscmd    0009   tsdev    000D   tsdtix   000F   tsevnt   0006   tskend   0278   tskinit  E2DC   tsktab   0276   tslink   0000   tsold    0018   tsprir   0005   tsseq    000A   tssgnl   0008   tsslnk   0002   tsstat   0004   tstate   0014   tstate2  0015   tstate3  0016   tstval   000C   ttask    000C   ttcls    E83E   ttdop5   E817   ttdop6   E822   ttdopn   E7F4   CPU09IOP   Intelligent I/O Proce     16:36:12  Jan 23, 2026   Page   94Debug Interface Routines                            tterxt   EDDE   ttftab   E868   ttftb2   E86E   ttopn    E7D7   ttopn8   E7E7   ttyget   E981   ttyi25   EB3B   ttyi27   EB3E   ttyi33   EB50   ttyi34   EB58   ttyi35   EB67   ttyi36   EB6B   ttyi44   EB79   ttyi46   EB84   ttyi65   EBD3   ttyi67   EBDD   ttyi85   EC17   ttyin    EB22   ttyin0   EB2A   ttyin2   EB2E   ttyin3   EB41   ttyin4   EB73   ttyin5   EBAF   ttyin6   EBBD   ttyin7   EBDF   ttyin8   EBFC   ttyin9   EC1D   ttyinit  E28C   ttyo12   EA82   ttyo14   EA92   ttyo22   EAAF   ttyo23   EAB3   ttyo24   EAC4   ttyo75   EAE7   ttyo77   EAF5   ttyoe1   EB16   ttyou2   EA9D   ttyou4   EAC8   ttyou6   EAD9   ttyou8   EB03   ttyoue   EB09   ttyout   EA6B   ttyren   EA06   ttys45   E9AC   ttys55   EA51   ttyset   E90F   ttysg5   E9AE   ttyst    EA1E   ttyst1   EA31   ttyst15  EA3A   ttyst2   EA4B   ttyst6   EA52   ttyst65  EA5D   ttyst9   EA65   ttywrt   EDB2   umark0   0014   umark1   0016   usp      0012   utask    0115   wakeu2   E694   wakeu3   E69B   wakeu4   E69F   wakeu5   E6A1   wakeup   E689   write_da EE29   wrt_sc   EE6B   xmtint   E6E2   xtca32   ED03   xtca33   ED15   xtp315   ECFC   xtpr21   ECB9   xtpr22   ECC1   xtpr25   ECD9   xtpr31   ECE5   xtpr45   ED36   xtprc0   EC9C   xtprc1   ECA6   xtprc2   ECAD   xtprc3   ECDB   xtprc4   ED22   xtprc5   ED46   xtprc6   ED50   xtprc7   ED5B   xtprcq   EC84   