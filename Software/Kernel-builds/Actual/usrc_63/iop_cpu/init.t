          sttl    Table      Initialization          pag          if      DBG_INIT&DEBUG_CONTROL00        fcc     $d,'Init CLISTs',001        fcc     $d,'Init TTYs',002        fcc     $d,'Init Tasks',003        fcc     $d,'STBinit done',0          endif** stbinit - Initialize System Memory Tables*stbinit   ldx     #sys_vars  clear all variables          ldd     #010        std     ,x++          cmpx    #end_vars  done yet?          blo     10b          ldd     #DEBUG          std     DB_cntrl*          lbsr    set_tables go figure out configuration, tables, etc* Initialize Terminal Interrupt Queue15        ldx     #TI_Q      set queue empty          stx     TI_Q_ptr          ldx     #int_buf   reset message in pointer          stx     int_ptr          lbsr    clinit     initialize Clists16        lbsr    ttyinit    initialize TTY tables17        lbsr    tskinit    initialize tasks18        lbsr    DB_config  display configuration          rts          if      DBG_INIT&DEBUG_CONTROL00        fcc     $d,'Compute configuration',001        fcc     $d,'Size memory',002        fcc     $d,'Initialize devices',0          endif** Set up system tables*set_tables* -- Force in the on-board PIA*09        ldd     #PIA_SLOT*          jsr     [D_test+DEV_L2]* -- Force in the TOD interface*          ldy     #dev_tab+((MAX_DEV-1)*DEV_SIZE)*          ldx     #DEV_TOD*          stx     dev_type,y* Compute configuration          lda     #SR4_SLOTS          pshs    a          ldd     #BASE_SLOT set port address          ldx     #slot_tbl          pshs    x10        ldu     #no_dev          stu     0,x          ldu     #mod_tbl      tables with module refs12        ldx     mod_type,u          beq     20f        jump if end of module table          jsr     [D_test,x] check for device          bcs     15f        jump if found          leau    MOD_SIZE,u          bra     12b15        ldx     mod_name,u          stx     [0,s]20        addd    #NEXT_SLOT advance address          ldx     0,s        update slot table pointer          leax    2,x          stx     0,s          dec     2,s        any more slots          bne     10b          puls    a,x* -- All done setting up configuration* Set up constants based on configuration22        lda     #MAX_CL          pshs    x          ldx     #CFGDAT          stx     fifo_us0      initialize config data pointer          sta     NUM_CL,x          puls    x**         lda     #MAX_TSK          lda     max_trn             reserve for system tasks          adda    #4          pshs    x          ldx     fifo_us0          sta     NUM_TSK,x          puls    x*          ldd     #MAX_OB          std     OBUF_SIZE* Now figure out where system tables go, based on configuration30        ldd     OBUF_SIZE          subd    #10          std     OQHI          subd    fio_fsz          subd    #5          std     OQLO          ldd     #SYS_TABS  start of system tables* -- Round up to CBSIZE boundary          addd    #CBSIZE-1          andb    #!(CBSIZE-1)          tfr     d,u* -- CLISTS          lda     #CBSIZE          pshs    x          ldx     fifo_us0      pointer          ldb     NUM_CL,x          puls    x          mul          stu     CLISTS          lbsr    sto_chk    check for system table space overflow          lbcs    40f        jump if it happens* -- TTY Control tables          lda     #TTYSIZ          pshs    x          ldx     fifo_us0      pointer          ldb     NUM_TRM,x          puls    x          mul          stu     TTYTABS    point to tty table          lbsr    sto_chk    check for system table space overflow          bcs     40f        jump if it happens* -- TTY Queue headers          lda     #2*QH_SIZE          pshs    x          ldx     fifo_us0      pointer          ldb     NUM_TRM,x          puls    x          mul          stu     TTYQS          lbsr    sto_chk    check for system table space overflow          bcs     40f        jump if it happens          lda     #OQH_SIZE          pshs    x          ldx     fifo_us0      pointer          ldb     NUM_TRM,x          puls    x          mul          lbsr    sto_chk    check for system table space overflow          bcs     40f        jump if it happens* -- TTY Output Queues          clra          pshs    x          ldx     fifo_us0      pointer          ldb     NUM_TRM,x          puls    x          tfr     d,x          ldd     #010        addd    OBUF_SIZE          leax    -1,x          bne     10b          stu     OBUFRS          lbsr    sto_chk    check for system table space overflow          bcs     40f        jump if it happens* -- Task table          lda     #TSKSIZ          pshs    x          ldx     fifo_us0      pointer          ldb     NUM_TSK,x          puls    x          mul          stu     tsktab          lbsr    sto_chk    check for system table space overflow          bcs     40f        jump if it happens          stu     tskend*          bra     60f* -- System table space has overflowed!* -- Try adjusting some parameters to get it under control40        ldd     OBUF_SIZE  first step, reduce output buffer size          subd    #32          std     OBUF_SIZE          cmpd    #MIN_OB          bge     50f        jump if still something left          ldd     #MAX_OB    start over & try something else          std     OBUF_SIZE          pshs    x          ldx     fifo_us0      pointer          lda     NUM_TSK,x  try reducing # tasks          suba    #1          sta     NUM_TSK,x          ldb     NUM_TRM,x          addb    NUM_PPR,x          addb    NUM_NEC,x          puls    x          addb    #3          pshs    b          cmpa    ,s+          bge     50f          lda     #MAX_TSK          pshs    x          ldx     fifo_us0      pointer          sta     NUM_TSK,x          lda     NUM_CL,x   crank back on # clists          suba    #1          sta     NUM_CL,x          cmpa    NUM_TRM,x          puls    x          bge     50f          ldb     #MAX_CL          pshs    x          ldx     fifo_us0      pointer          stb     NUM_CL,x          puls    x          ldx     #00f          jsr     DB_pdata          jsr     DB_config          jsr     DB_main          jmp     rom_init   ... what else can I do???50        lbra    30b        go try it all again*-- Initialize devices60        ldu     #dev_tab62        clrb70        pshs    b          ldx     dev_addr,u get device address          beq     75f        jump if none there          ldy     dev_type,u get device kind          jsr     [D_init,y] go initialize device75        leau    DEV_SIZE,u          puls    b          incb          cmpb    #MAX_DEV-1          bne     70b* -- All done90        rts*00        fcc     $d,"...Can't size tables!",0*no_dev    fcc     '..None',0** Allocate some system table space*   D - Space being consumed*   U - Current end of table space*   jsr sto_chk (System Table Overflow check)*   <CS> if overflow*sto_chk   leau    d,u        compute new end pointer          cmpu    #end_vars  overflow?          bhi     10f        yes - return error          clc     no         - return OK          rts10        sec     ..         bad owies          rts** clinit** Initialize character buffer lists.  This routine* is only called once at startup time.*clinit    ldx     CLISTS     point to clist          pshs    x          ldx     fifo_us0          ldb     NUM_CL,x   set count          puls    x          stx     cfreel     set head pointerclini2    leay    CBSIZE,x          sty     0,x        set fwd link          tfr     y,x        advance to next          decb          bne     clini2          pshs    x          ldx     fifo_us0          lda     NUM_CL,x   get buffer count          puls    x          suba    #2          sta     lcbuf      set max count          clra    make       d=0          std     -CBSIZE,x  clear last link          clr     cbufct          rts     all        done!** ttyinit** Init the tty tables and queues.*ttyinit   ldy     TTYQS      point to q tables          clr     ,-s        terminal # counter          pshs    x          ldx     fifo_us0          ldb     NUM_TRM,x  get terminal count          puls    x          pshs    b          ldu     OBUFRS     output buffer          ldx     TTYTABS    point to TTY Tables10        sty     tqin,x     set input q          leay    QH_SIZE,y  get next q          sty     tqproc,x   set pr q          leay    QH_SIZE,y  set next q          sty     tqout,x    set output q          stu     oq_buf,y   ** Init output Q **          stu     oq_get,y          stu     oq_put,y          ldd     OBUF_SIZE          leau    d,u          stu     oq_end,y          leay    OQH_SIZE,y get next q          lda     #AC_SET    #%101<<2   8 bits, no parity, 1 stop bit          sta     tbaud,x    set conf word          lda     1,s        get terminal #          sta     tdevic+1,x   set in table          pshs    d,u          ldb     #DEV_SIZE          mul          ldu     #dev_tab          leau    d,u          ldd     dev_addr,u -- device address          std     taddr,x          puls    d,u          inc     1,s        bump terminal #          leax    TTYSIZ,x   next tty entry          dec     0,s        dec the count          bne     10b        repeat?          puls    d,pc       clean up stack & return** tskinit - Initialize all tasks*tskinit   ldx     #tsktab          stx     utask          pshs    x          ldx     fifo_us0   get pointer          ldb     NUM_TSK,x  # tasks in system          puls    x          pshs    b          ldy     tsktab     task 1          leay    TSKSIZ,y1011        lda     #TFREE     mark all tasks free          cmpx    tsktab     is this the system task?          bne     15f          lda     #TSYS       the system task is never free15        sta     tsstat,x          lda     #$FF       not associated with a terminal          sta     tsdev,x          sta     tsdev+1,x          leau    TSKSIZ,x   initialize stack          ldd     #IO_han          pshs    y          cmpx    ,s++       task 1?          bne     20f        no - normal I/O handling task          ldd     #TI_HAN    yes - special terminal interrupt handling task20        pshu    d          stu     usp,x          stu     umark0,x          leax    TSKSIZ,x          dec     0,s        done?          bne     10b          leas    1,s        clean up stack          ldd     #0         nothing running or sleeping          std     runlst          std     slplst          std     slplst+tsslnk          leax    0,y        start interrupt handling task          jsr     makrdy          rts