          sttl    FIO        Simulation Routines          pag** Reset CPU-IOP Interface* it is assumed that the FIO (DPR) sits at $0000* it sets the offsets to the sock array and to the device info*fio_reset* when here, all storage locations have been erased already*          ldx     #0          stx     fifo_get   set Q pointers          stx     fifo_put          ldx     #WZNETOF          stx     fifo_us1          ldx     #WZSKOFF          stx     fifo_us0   so that kernel CPU can see it* init the 8 SOCK structs          lda     #801        sta     wzenum,x          leax    WZSIZE,x      to next          deca          bne    01b*          ldx     fio_dsz          leax    -2,x       one from top          ldu     #1024      -- Reset Time-Out value*fio_wait  ldb     #255       Spin counter*00          tst     0,x        fio_cpuF          beq     10f*          decb          bne     00b        jump back if not ready*          leau    -1,u          cmpu    #0          bne     fio_wait          ldx     #CPU_down          lbsr    DB_pdata          lbsr    DB_main          bra     fio_reset* reset OK10        rts** FIO interrupt handler, called when IRQ was set (interrupt context)* for regular NWP and IOP purpose*fio_irq   ldx     int_ptr    input message pointer          lda     cpu_fio    move REQUEST          sta     ,x+          ldd     cpu_fio1   sequence # TASK ID          std     ,x++          lda     cpu_fio2   specific DATA          sta     ,x+          ldd     cpu_fio3   device major/minor          std     ,x++** X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device*          ldu     fio_dsz          leau    -1,u          clr     0,u        cpu_fioF indicate message consumed*          stx     int_ptr    update pointer          ldy     #int_buf   get message from buffer          lda     0,y        -- Send interrupt command?          cmpa    #S_INTRPT          bne     30f** special case OOB signal*          sty     int_ptr    reset pointer          ldb     3,y        signal          ldx     4,y        SOCK reference*          jsr     sdev_sig   send device signal          bra     fiointe    exit** normal command* acquire free task slot*30        ldx     #tsktab     search for an available task          ldb     NUM_TSK    Number of tasks in system*32        lda     tsstat,x          cmpa    #TFREE     looking for a "free" task          beq     40f*          leax    TSKSIZ,x          decb          bne     32b*          ldb     #E_SYSBSY  can't process - IOP saturated!          jsr     fio_msg          bra     fiointe    exit** X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device* move data over into task struct*40        ldy     #int_buf   get message from buffer          sty     int_ptr    reset pointer          ldb     ,y+        command byte  REQUEST          stb     tscmd,x    save for task          ldd     ,y++       sequence #    task ID          std     tsseq,x          ldb     ,y+        command specific DATA          stb     tstval,x          ldd     ,y++       associate with terminal major/minor          std     tsdev,x          jsr     makrdy     make task ready to run*fiointe   rts                exit** fio_msg - Send a message via the FIO Mailbox* it is assumed that the FIO (DPR) sits at $0000*   B - Message code to send (one byte)*   fio_cpu1..3 already set up** used for netblock/IOP and NWP purpose*fio_msg   pshs    cc,b,x,u      save register          seti          ldu     fio_dsz          leau    -2,u       one off top          stb     fio_cpu    set up mailbox value* interrupt location5         stb     0,u        fio_cpuF, tell the message type*05        ldx     #0         time-out counter*10        lda     0,u        fio_cpuF   wait till value consumed          beq     20f        jump if consumed*          leax    -1,x       time-out yet?          bne     10b*          bra     05b        try again*20        puls    cc,b,x,u,pc*** this is the normal way the IOP sends data to the host CPU* fio_response - Return a response code/sequence #* it is assumed that the FIO (DPR) sits at $0000*    X = utask,*    B - Response code*    A - Transaction specific value*fio_response pshs    d,x          bsr     FIO_get    access FIO          ldx     utask      task ID          ldd     tsseq,x          std     fio_cpu1          ldd     tsdev,x    device info          std     fio_cpu3          lda     0,s        get transaction specific value (i.e. error code)          sta     fio_cpu2          ldb     1,s        is RESPONSE code          jsr     fio_msg          bsr     FIO_rel    release FIO          puls    d,x,pc     return** FIO_get - Get access to FIO device* -- Sleep till available*FIO_get   pshs    d,x,y,u    save registers10        ldy     #FIO_lock  is the device locked          tst     0,y          beq     20f        no - go get it*          ldb     #FIOPRI    waiting for the FIO          jsr     sleep          bra     10b        try again*20        inc     0,y        mark in use          puls    d,x,y,u,pc return** FIO_rel - Release access to FIO*FIO_rel   pshs    d,x,y,u          ldy     #FIO_lock          clr     0,y          jsr     wakeup          puls    d,x,y,u,pc return** FIFO_get - Fetch character from FIFO*   B - Character fetched*FIFOgeta  pshs    b          bsr     FIFO_get          puls    a          exg     a,b          rts*FIFO_get  pshs    a,x          ldd     fifo_cnt   any data?          beq     99f        no - exit*          decd    yes        - adjust count          std     fifo_cnt          ldx     fifo_get   get consumer pointer          ldb     fifo,x     fetch byte          leax    1,x        bump pointer          cmpx    fio_fsz    end of fifo?          bne     10f*          ldx     #0         reset pointer*10        stx     fifo_get*99        puls    a,x,pc** FIFO_put - Place character into FIFO*   B - Character fetched*FIFOputa  pshs    b          tfr     a,b          bsr     FIFO_put          puls    b,pc*FIFO_put  pshs    d,x          ldx     fifo_put   get consumer pointer          stb     fifo,x     store byte          leax    1,x        bump pointer          cmpx    fio_fsz    end of FIFO?          bne     10f*          ldx     #0         reset pointer10        stx     fifo_put*          ldd     fifo_cnt          incd          std     fifo_cnt99        puls    d,x,pc