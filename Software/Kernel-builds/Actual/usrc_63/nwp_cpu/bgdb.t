           sttl    bgdb** BGDB, Back ground debugger** is added to ROM image and is activated by NMI***** DEBUG IO via DPR kernel debug interface**SPI0TUF equ $03fc       I/O via DPR**SPI0FUF equ $03fd*** DEBUG via 09MON ACIAACIAC   equ     $82FEACIAD   equ     ACIAC+1        org     $7ff0   top of RAMbdbsta  rmb     1       echo flag        org     $fc00bgdben  equ     *        tfr     s,u        leas    -32,u***** nextcmd *****nextcmd ldx     #msg3   point to msg ">"        lbsr    pstrng  print msg        lbsr    dbinch    get one char. from terminal        anda    #$7f    strip parity from char.        cmpa    #$0d    is it carriage return ?        beq     nextcmd if cr then get another char.        tfr     a,b     put char. in "b" accum.        cmpa    #$20    is it control or data char ?        bge     prtcmd  if cmd char is data, prnt it        lda     #'^     else cntrl char cmd so...        lbsr    dboutch   print "^"        tfr     b,a     recall cntrl cmd char        adda    #$40    convert it to ascii letterprtcmd  lbsr    dboutch   prnt cmd char        lbsr    out1s   prnt space        cmpb    #$60        ble     nxtch0        subb    #$20***** do table lookup ******   for command functionsnxtch0  ldx     #jmptab point to jump tablenxtchr  cmpb    ,x+     does command match table entry ?        beq     jmpcmd  branch if match found        leax    2,x     point to next entry in table        cmpx    #tabend reached end of table yet ?        bne     nxtchr  if not end, check next entry        ldx     #msg4   point to msg "what?"        lbsr    pdata   print msg        bra     nextcmd if no match, prmpt for new cmdjmpcmd  jsr     [,x]    jump to command routine        bra     nextcmd prompt for new command** "g" go or continuego      tfr     u,srti     rti* "r" display registersregstr  ldx     #msg5   point to msg " - "        lbsr    pstrng  print msg        lbsr    prtsp        lbsr    prtus        lbsr    prtdp        lbsr    prtix        lbsr    prtiy        ldx     #msg5   point to msg " - "        lbsr    pstrng  print msg        lbsr    prtcc        lbsr    prta        lbsr    prtb        lbsr    prte        lbsr    prtf        lbra    prtpc* alter "pc" program counteraltrpc  lbsr    prtpc   print msg " pc = "        lbsr    out1s   output space        lbsr    in1adr  get new contents for "pc"        bvs     altpcd  exit if invalid hex        stx     12,u    poke in new contentsaltpcd  rts* alter "u" user stack pointeraltru   lbsr    prtus   print msg " us = "        lbsr    out1s   output space        lbsr    in1adr        bvs     altud        stx     10,ualtud   rts* alter "y" index registeraltry   lbsr    prtiy   print msg " iy = "        lbsr    out1s   output space        lbsr    in1adr        bvs     altyd        stx     8,ualtyd   rts* alter "x" index registeraltrx   lbsr    prtix   print msg " ix = "        lbsr    out1s   output space        lbsr    in1adr        bvs     altxd        stx     6,ualtxd   rts* alter "dp" direct page registeraltrdp  lbsr    prtdp   print msg " dp = "        lbsr    out1s   output space        lbsr    byte    input byte (2 hex char)        bvs     altdpd        sta     5,ualtdpd  rtsaltre   lbsr    prte        lbsr    out1s        lbsr    byte        bvs     alted        sta     3,ualted   rtsaltrf   lbsr    prtf        lbsr    out1s        lbsr    byte        bvs     altfd        sta     4,ualtfd   rts* alter "b" accumulatoraltrb   lbsr    prtb    print msg " b = "        lbsr    out1s   output space        lbsr    byte    input byte (2 hex char)        bvs     altbd        sta     2,ualtbd   rts* alter "a" accumulatoraltra   lbsr    prta    print msg " a = "        lbsr    out1s   output space        lbsr    byte    input byte (2 hex char)        bvs     altad        sta     1,ualtad   rts* alter "cc" registeraltrcc  lbsr    prtcc   print msg " cc: "        lbsr    out1s   output space        lbsr    byte    input byte (2 hex char)        bvs     altccd        ora     #$80    sets "e" flag in print list        sta     ,ualtccd  rts***** "m" memory examine and change *****memchg  lbsr    in1adr  input address        bvs     chrtn   if not hex, return        tfr     x,y     save addr in "y"memc2   ldx     #msg5   point to msg " - "        lbsr    pstrng  print msg        tfr     y,x     fetch address        lbsr    out4h   print addr in hex        lbsr    out1s   output space        lda     ,y      get contents of current addr.        lbsr    dbout2h   output contents in ascii        lbsr    out1s   output space        lbsr    byte    loop waiting for operator input        bvc     dbchange  if valid hex go change mem. loc.        anda    #%11011111 undo 'toupper'        cmpa    #8      is it a backspace (cntrl h)?        beq     memc2   prompt operator again        cmpa    #$18    is it a cancel (cntrl x)?        beq     memc2   prompt operator again        cmpa    #'^     is it an up arrow?        beq     back    display previous byte        cmpa    #$d     is it a cr?        bne     forwrd  display next bytechrtn   rts             exit routinedbchange  sta     ,y      change byte in memory        cmpa    ,y      did memory byte change?        beq     forwrd        lbsr    out1s   output space        lda     #'?     load question mark        lbsr    dboutch   print itforwrd  leay    1,y     point to next higher mem location        bra     memc2   print location & contentsback    leay    -1,y    point to last mem location        bra     memc2   print location & contents* "s" display stack* hex-ascii display of current stack contents from* current stack pointer to internal stack limit.disstk  lbsr    prtsp   print current stack pointer        tfr     u,y     U = user stack        tfr     u,x        leax    64,x    point to current stack        bra     mdump1  enter memory dump of stack contents* "e" dump memory for examine in hex and ascii* after calling 'in2adr' lower address in y-reg.*                        upper address in x-reg.* if hex addresses are invalid (v)=1.memdump lbsr    in2adr  input address boundries        bvs     edprtn  new command if illegal hexmdump1  pshs    y       compare lower to upper bounds        cmpx    ,s++    lower bounds > upper bounds?        bcc     ajdump  if not, dump hex and asciiedprtn  rts* adjust lower and upper address limits* to even 16 byte boundries.* if lower addr = $4532* lower bounds will be adjusted to = $4530.* if upper addr = $4567* upper bounds will be adjusted to = $4570.* enter with lower address in x-reg.*           -upper address on top of stack.ajdump  tfr     x,d     get upper addr in d-reg        addd    #$10    add 16 to upper address        andb    #$f0    mask to even 16 byte boundry        pshs    a,b     save on stack as upper dump limit        tfr     y,d     get lower address in d-reg        andb    #$f0    mask to even 16 byte boundry        tfr     d,x     put in x-reg as lower dump limitnxtlin  cmpx    ,s      compare lower to upper limit        beq     skpdmp  if equal skip hex-ascii dump        lbsr    dbinchk  check for input from keyboard        beq     edump   if none, continue with dumpskpdmp  leas    2,s     readjust stack if not dumping        rts* print 16 hex bytes followed by 16 ascii characters* for each line throughout address limits.edump   pshs    x       push lower addr limit on stack        ldx     #msg5   point to msg " - "        lbsr    pstrng  print msg        ldx     ,s      load lower addr from top of stack        lbsr    out4h   print the address        lbsr    out2s   print 2 spaces        ldb     #$10    load count of 16 bytes to dumpeloop   lda     ,x+     get from memory hex byte to print        lbsr    dbout2h   output hex byte as ascii        lbsr    out1s   output space        decb            decrement byte count        bne     eloop   continue til 16 hex bytes printed* print 16 ascii characters* if not printable or not valid* ascii print a period (.)        lbsr    out2s   2 spaces        ldx     ,s++    get low limit frm stack - adj stack        ldb     #$10    set ascii char to print = 16edpasc  lda     ,x+     get character from memory        cmpa    #$20    if less than $20, non-printable?        bcs     period  if so, print period instead        cmpa    #$7e    is it valid ascii?        bls     prasc   if so print itperiod  lda     #'.     load a period (.)prasc   lbsr    dboutch   print ascii character        decb            decrement count        bne     edpasc        bra     nxtlinprtsp ldx  #msg10 point to msg "sp=" lbsr pdata  print msg tfr  u,x lbra out4hprtus ldx  #msg12 point to msg "us=" lbsr pdata  print msg ldx  10,u lbra out4hprtdp ldx  #msg15 point to msg "dp=" lbsr pdata  print msg lda  5,u lbra dbout2h output hex byte as asciiprtix ldx  #msg14 point to msg "ix=" lbsr pdata  print msg ldx  6,u      $fce6 lbra out4hprtiy ldx  #msg13 point to msg "iy=" lbsr pdata  print msg ldx  8,u lbra  out4hprtpc ldx  #msg11 point to msg "pc=" lbsr pdata  print msg ldx  12,u lbra  out4hprta ldx  #msg16 point to msg "a=" lbsr pdata  print msg lda  1,u lbra dbout2h output hex byte as asciiprtb ldx  #msg17 point to msg "b=" lbsr pdata  print msg lda  2,u bra dbout2h output hex byte as asciiprte ldx #msg21 lbsr pdata lda 3,u bra dbout2hprtf ldx #msg22 lbsr pdata lda 4,u bra dbout2hprtcc ldx  #msg18 point to msg "cc:" lbsr pdata  print msg lda  ,u ldx  #msg19 point to msg "efhinzvc" bra biasci output in binary/ascii format* the following routine loops waiting for the* operator to input two valid hex addresses.* the first address input is returned in "iy".* the second is returned in "ix". the "v" bit* in the c-code reg. is set if an invalid hex* address is input.in2adr bsr in1adr get first address bvs nothex exit if not valid hex tfr  x,y save first addr. in "iy" lda #'- lbsr dboutch print " - "* the following routine loops waiting for the* operator to input one valid hex address. the* address is returned in the "x" register.in1adr bsr byte input byte (2 hex char) bvs nothex exit if not valid hex tfr  d,x bsr byte input byte (2 hex char) bvs nothex pshs x sta  1,s puls x rts***** input byte (2 hex char.) *****byte bsr dbinhex get hex left bvs nothex exit if not valid hex asla asla asla shift into left nibble asla tfr  a,b put hexl in "b" bsr dbinhex get hex right bvs nothex exit if not valid hex pshs b push hexl on stack adda ,s+ add hexl to hexr and adj. stk rts return with hex l&r in "a"dbinhex bsr echon input ascii char. cmpa #'0 is it > or = "0" ? bcs nothex if less it ain't hex cmpa #'9 is it < or = "9" ? bhi dbinhexa if > maybe it's alpha suba #$30 ascii adj. numeric rtsdbinhexa ora #$20 make it lower cmpa #'a is it > or = "a" bcs nothex if less it ain't hex cmpa #'f is it < or = "f" ? bhi nothex suba #$57 ascii adj. alpha rtsnothex orcc #2 set (v) flag in c-codes register rtsout4h pshs x push x-reg. on the stack puls a pop ms byte of x-reg into a-acc. bsr dbouthl output hex left puls a pop ls byte of x-reg into a-acc.dbouthl equ *dbout2h pshs a save it back on stack lsra convert upper hex nibble to ascii lsra lsra lsra bsr xascii print hex nibble as asciidbouthr puls a convert lower hex nibble to ascii anda #$0f strip left nibblexascii adda #$30 ascii adj cmpa #$39 is it < or = "9" ? ble  outc if less, output it adda #7 if > make ascii letteroutc jmp  dboutch output char* binary / ascii --- this routine* outputs a byte in enhanced* binary format. the enhancement* is done by substituting ascii* letters for the ones in the byte.* the ascii enhancement letters* are obtained from the string* pointed to by the index reg. "x".biasci pshs a save "a" on stack ldb  #8 preset loop# to bits per byteoutba lda ,x+ get letter from string asl  ,s test byte for "1" in b7 bcs prtba if one print letter lda #'- if zero print "-"prtba bsr dboutch print it bsr out1s print space decb sub 1 from #bits yet to print bne outba puls a rts* print string preceeded by a cr & lf.pstrng bsr pcrlf print cr/lf bra  pdata  print string pointed to by ix* pcrlfpcrlf pshs x save ix ldx  #msg2+1  point to msg cr/lf + 3 nuls bsr pdata  print msg puls x restore ix rtsdbprint   bsr     dboutch* pdatapdata   lda     ,x+     get 1st char. to print        cmpa    #4      is it eot?        bne     dbprint   if not eot print it        rtsout2s bsr out1s output 2 spacesout1s lda  #$20  output 1 space* use the DPR debug interface*dboutch   PSHB             SAVE B*00      LDB    SPI0TUF   To UniFLEX*        BNE     00b      wait until taken*        STAA   SPI0TUF       debugIO*        PULB   RESTORE B*        RTSdboutch PSHS    B00      ldb     ACIAC        bitb    #2        beq     00b        sta     ACIAD        PULS    B        rtsechon   tst    bdbsta        bmi    dbinchdbinche PSHS    B        bsr     dbinch        bra     00bdbinch  bsr     dbinchk        beq     dbinch        ldaa    ACIAD        anda    #$7f        cmpa    #$7f        beq     dbinch        rtsdbinchk ldb     ACIAC        bitb    #1        rts* use the DPR debug interface*dbinche   PSHB             SAVE B*        BSR    dbinch*        BRA    00b       ECHO* pure input, no echo*dbinch    BSR     dbinchk*        BEQ     dbinch*        LDAA    SPI0FUF*        CLR     SPI0FUF**        ANDA    #$7F*        CMPA    #$7F      SKIP RUBOUT*        BEQ     dbinch*        RTS*dbinchk  LDAB    SPI0FUF*        RTS* monitor keyboard command jump tablejmptab equ * fcb 1 " ^a " fdb altra fcb 2 " ^b " fdb altrb fcb 3 " ^c " fdb altrcc fcb 4 " ^d " fdb altrdp fcb 5 " ^e " fdb altre fcb 6 " ^f " fdb altrf fcb $10 " ^p " fdb altrpc fcb $15 " ^u " fdb altru fcb $18 " ^x " fdb altrx fcb $19 " ^y " fdb altry fcc 'E' fdb memdump *$f990 fcc 'G' fdb go *$f89f fcc 'M' fdb memchg *$f93b fcc 'R' fdb regstr *$f8a2tabend equ *msg2 fcb 'k,$d,$a,$0,$0,$0,4 k, * cr/lf + 3 nulsmsg3 fcc '>' fcb 4msg4 fcc 'what?' fcb 4msg5 fcc ' - ' fcb 4msg19 fcc 'efhinzvc'msg9 fcc '76543210'msg10 fcc '  sp=' fcb 4msg11 fcc '  pc=' fcb 4msg12 fcc '  us=' fcb 4msg13 fcc '  iy=' fcb 4msg14 fcc '  ix=' fcb 4msg15 fcc '  dp=' fcb 4msg16 fcc '  a=' fcb 4msg17 fcc '  b=' fcb 4msg21 fcc '  e=' fcb 4msg22 fcc '  f=' fcb 4msg18 fcc '  cc: ' fcb 4*       org     $fffc   NMI*       fdb     bgdben