NET     set     1          ttl     SWTPc      IOP Debug ROM          sttl    Hardware   Definitions          abs          pag          lib     environment.h          lib     sys_acia.h          sttl    System     Debug Code          pagTEST_PORT set     0TEST_ONLY set     0TEST_ROM  set     0          if      TEST_ROM          org     $FFF0          fdb     DB_main          fdb     DB_main          fdb     DB_main          fdb     DB_main          fdb     DB_main          fdb     DB_main          fdb     DB_main          fdb     DB_main          org     ROMorg          else          org     DEBUGROM          endif** Vector of entry points*          fdb     $1234      -- ROM present flag          fdb     DB_main    Interractive debug monitor          fdb     DB_pdata          fdb     DB_phex          fdb     DB_phex2          fdb     DB_pcrlf          fdb     DB_check          fdb     DB_config          sttl    Debug      Routines          pag** Debug driver*DB_main          if      TEST_ROM          seti    turn       off interrupts          if      TEST_PORT*-- Brute force characters          ldx     #SYS_ACIA  -- Initialize ACIA          lda     #$03          sta     csr,x          mul          mul          lda     #$15          sta     csr,x10        ldb     #$2020        lda     csr,x          bita    #ACTBSY          beq     20b          stb     dbuf,x          incb          cmpb    #$7E          bne     20b          if      TEST_ONLY          bra     10b          endif          endif          lds     #ROMstack          clr     DB_iflg          endif          pshs    cc,d,x,y,u save all registers          ldx     #00f          lbsr    DB_pdata10        ldx     #01f       print prompt          lbsr    DB_pdata          lbsr    DB_inch    get character          pshs    a          save character          lda     #'         let the guy know I saw it          lbsr    DB_putch          puls    a          restore character          ldy     #DB_cmds   process command20        tst     0,y        end of table?          beq     30f        yes - error          cmpa    0,y        command match?          bne     25f        no - try next one          jsr     [1,y]      yes - go process it          bra     10b        next command25        leay    3,y        next command entry          bra     20b30        ldx     #02f       illegal command          bsr     DB_pdata          bra     10b*00        fcc     $d,'IOP Debug',001        fcc     $d,'>>',002        fcc     ' ??',0** Debug command table*DB_cmds          fcb     'Q         Quit - return to normal operation          fdb     quit          fcb     'E         Examine system memory          fdb     examine          fcb     'M         Modify system memory          fdb     modify          fcb     'S         Dump Task tables          fdb     dmp_task          fcb     'R         Print registers at time of entry to IOP DEBUG          fdb     dmp_regs          fcb     'D         Change display parameters          fdb     display          fcb     'C         Display configuration          fdb     DB_config*          fcb     'T         Dump TTY Tables          fdb     dmp_tty          fcb     'H         Print transaction history          fdb     prt_hist          fcb     0          end of table* -- Quit debug modequit      puls    x          return address from command processor          puls    cc,d,x,y,u,pc return to interrupt context** This file contains routines for debug purposes.*DB_init   pshs    d,x        save registers          tst     DB_iflg    terminal initialized?          bne     99f        yes - exit          lda     #1          sta     DB_iflg          ldx     #SYS_ACIA          lda     #$03       reset code          sta     csr,x          lda     #$15+ENBRIN config byte          sta     csr,x99        puls    d,x,pc* Print character in (A) on debug portDB_putch  pshs    d,x          bsr     DB_init    initialize terminal if necessary          ldx     #SYS_ACIA10        ldb     csr,x      get acia status          bitb    #ACTBSY    xmit busY?          beq     10b          sta     dbuf,x     output char          puls    d,x,pc* Print string (pointed to by X) on debug portDB_pdata  pshs    d,x10        lda     ,x+        get next character          beq     99f        exit at end of string          cmpa    #CR        map carriage returns to CR/LF          bne     15f          bsr     DB_putch          lda     #NL        send LF15        bsr     DB_putch          bra     10b99        puls    d,x,pc     return* Print character in (A) in HexDB_phex   pshs    d,x          ldx     #00f       string of nibbles          lsra          lsra          lsra          lsra          lda     a,x          bsr     DB_putch   print character          lda     0,s          anda    #$0F          lda     a,x          bsr     DB_putch   print character          puls    d,x,pc*00        fcc     '0123456789ABCDEF'* Print the value in (D) in HexDB_phex2  pshs    d          bsr     DB_phex print (A)          lda     1,s          bsr     DB_phex    print (B)          puls    d,pc       return* Print a spaceDB_outsp  lda     #'          bra     DB_putch** Read & Echo one character*   DB_inch - Character in A*DB_inch   pshs    x          save registers          ldx     #SYS_ACIA  get port address10        lda     csr,x      wait for character present          bita    #ACRBSY          beq     10b          lda     dbuf,x     get character          anda    #$7F       strip parity          cmpa    #'a        map lower case -> upper case          blo     20f          anda    #!$2020        puls    x          restore register          bra     DB_putch   print character** DB_check - Check for special conditions*   jsr DB_check*   CS if ^C*   Also handles escape for hold mode*DB_check  pshs    a,x          ldx     #SYS_ACIA  get port address10        lda     csr,x      wait for character present          bita    #ACRBSY          beq     95f          lda     dbuf,x     get character          cmpa    #$03       Control-C?          beq     90f          cmpa    #$1B       escape = HOLD output          bne     95f        no - ingore it* -- wait for another escape          ldx     #SYS_ACIA  get port address20        lda     csr,x      wait for character present          bita    #ACRBSY          beq     20b          lda     dbuf,x     get character          cmpa    #$1B       wait for escape          bne     20b          bra     95f        exit - no ^C90        sec     --         Control-C exit          bra     99f95        clc99        puls    a,x,pc** Dump a range of memory (X..Y)*DB_dump   pshs    d,x,y,u** Print one line (16 bytes) of data*10        lbsr    DB_pcrlf   start a new print line          ldd     2,s        print address          lbsr    DB_phex2          ldb     #2          lbsr    spaces          ldx     2,s          ldb     #16        print 16 bytes          pshs    b20        lda     ,x+        get next byte to print          lbsr    DB_phex          lbsr    DB_outsp          dec     0,s        done?          bne     20b        no - go back          ldx     1+2,s      now print characters          ldb     #2          lbsr    spaces          ldb     #16          stb     0,s30        lda     ,x+        get next byte          cmpa    #$20       printable?          blo     35f        no          cmpa    #$7F          blo     40f        go print character35        lda     #'.        print period for unprintable40        lbsr    DB_putch   print character          dec     0,s        done?          bne     30b          leas    1,s        clean up stack          lbsr    DB_check   see if abort          bcs     99f        exit if so          stx     2,s        update address          cmpx    4,s        any more?          bls     10b        yes - go to it99        lbsr    DB_pcrlf          puls    d,x,y,u,pc return** DB_pcrlf - print carriage return/line feed*DB_pcrlf  pshs    d,x        save registers          ldx     #CRLF          lbsr    DB_pdata          puls    d,x,pc     returnCRLF      fcc     $d,0          sttl    DEBUG - Memory Modify Command          pag** Modify system memory*modify          leas    -2,s       reserve temp space          lbsr    DB_getadr  get starting address          bcs     mod99      exit if error          std     0,s        save address*mod10     ldx     #modm00          lbsr    DB_pdata          ldd     0,s        print address          lbsr    DB_phex2          lbsr    DB_outsp          ldx     0,s        get byte address          lda     0,x        get value          pshs    a          save current value          lbsr    DB_phex    output it          lbsr    DB_outsp   print a space          lbsr    DB_gethex  get a hex digit          bcs     mod30      jump if error          asla          asla          asla          asla          sta     0,s        update value          lbsr    DB_gethex  get second hex digit          bcs     mod40      exit if error          ora     ,s+        compute total valuemod20     ldx     0,s        get memory address          sta     ,x+        update memory          stx     0,s        update address          bra     mod10      continue with next byte*mod30     cmpa    #'.        is it "go on" char?          bne     mod40      no - exit          puls    a          restore original value          bra     mod20      yes - move to next address*mod40     leas    1,s        clean up stackmod99     puls    x,pc       return*modm00    fcc     $d,' - ',0          sttl    Memory     Examine Command          pag** Examine memory (system)*examine          leas    -4,s       reserve temp space          lbsr    DB_getadr  get low address          bcs     99f          std     0,s        save low limit          lda     #'-          lbsr    DB_putch          lbsr    DB_getadr  get high address          bcs     99f          std     2,s        save high limit          puls    x,y        get limit registers          lbsr    DB_dump    go dump memory          rts     exit99        puls    x,y,pc     return - error** get 4 hex digit address*   return value in D*DB_getadr ldb     #4         number of digits          pshs    b          ldd     #0         starting value          pshs    d10        lbsr    DB_gethex  get a hex digit (in B)          bcs     90f        jump if error          pshs    a          ldd     1,s        fix up value          aslb          rola          aslb          rola          aslb          rola          aslb          rola          orb     ,s+          std     ,s          dec     2,s        done?          bne     10b          clc90        puls    d          get value          leas    1,s        clean up stack          rts     return** DB_gethex - get one hex digit*DB_gethex lbsr    DB_inch    read character          cmpa    #'0        check for legal digit          blo     90f          cmpa    #'9          bls     10f          cmpa    #'A        legal digit?          blo     90f        no - error          cmpa    #'F          bhi     90f          adda    #9         add bias10        anda    #$0F       strip ASCII stuff          clc          rts     all        done - no error90        sec     illegal          rts     exit          sttl    Dump       TTY Tables          pag** dmp_tty - dump TTY table       !!!!!!!*dmp_tty   pshs    d,x,y,u99        puls    d,x,y,u,pc*00        fcc     $d,'TTY In Q Out Q Flag State Sold',004        fcc     '/',0          sttl    Dump Task Tables          pag** dmp_tasks - Print task tables*dmp_tasks pshs    d,x,y,u          ldx     #00f          lbsr    DB_pdata          lbsr    DB_pcrlf          lda     #1         1=Busy, 0=Free          pshs    a05        ldy     tsktab10        lda     tsstat,y   get task state          tst     0,s        free or busy tasks?          beq     11f        jump for free          cmpa    #TFREE     skip free tasks this time          beq     20f          bra     12f        go print info11        cmpa    #TFREE     skip non-free tasks this time          bne     20f12        tfr     y,d          lbsr    DB_phex2          lbsr    spc_2          ldd     tsstat,y          lbsr    DB_phex2          bsr     spc_2          ldu     umark0,y          lda     tsstat,y   task sleeping?          cmpa    #TSLEEP          bne     13f        no          ldd     0+7,u      PC - in sleep          bra     15f13        ldd     0,u        PC - from interrupt15        lbsr    DB_phex2          bsr     spc_2          ldd     tsevnt,y          lbsr    DB_phex2   event          bsr     spc_2          lda     tsdev,y          lbsr    DB_phex          bsr     spc_2          lda     tscmd,y          lbsr    DB_phex          bsr     spc_2          lda     tsseq,y          lbsr    DB_phex          bsr     spc_4          lda     tstval,y          lbsr    DB_phex          lbsr    DB_pcrlf20        leay    TSKSIZ,y          lbsr    DB_check          bcs     25f          cmpy    tskend          bne     10b          dec     0,s        next pass          bpl     05b25        puls    a          clean stack99        puls    d,x,y,u,pc00        fcc     $d,'Task State PC Event TTY CMD SEQ# VAL',001        fcc     ' ',0spc_2     ldx     #01b          lbra    DB_pdata*spc_4     bsr     spc_2          bra     spc_2          sttl    Dump       IOP Registers          pagdmp_regs          ldx     #00f          jsr     DB_pdata          leay    2,s        point to stacked regs          lda     ,y+        CC          jsr     DB_phex          ldx     #01f          jsr     DB_pdata          ldd     ,y++       D          jsr     DB_phex2          ldx     #97f          jsr     DB_pdata   W          ldd     0,y++          jsr     DB_phex2          ldx     #98f          jsr     DB_pdata   DP          ldd     0,y++          jsr     DB_phex          ldx     #02f          jsr     DB_pdata          ldd     ,y++       X          jsr     DB_phex2          ldx     #03f          jsr     DB_pdata          ldd     ,y++       Y          jsr     DB_phex2          ldx     #04f          jsr     DB_pdata          ldd     ,y++       U          jsr     DB_phex2          ldx     #05f          jsr     DB_pdata          tfr     y,d          jsr     DB_phex2          ldx     #06f          jsr     DB_pdata          ldd     ,y++       D          jsr     DB_phex2          rts*00        fcc     $d,'CC = ',001        fcc     ', D = ',097        fcc     ', W = ',098        fcc     ', DP = ',002        fcc     ', X = ',003        fcc     ', Y = ',004        fcc     ', U = ',005        fcc     ', S = ',006        fcc     ', PC = ',0          sttl    Set/Change Display Parameters          pag** Set/Change Display parameters*display          ldy     #DEBUG_tbl cycle through all flags00        ldx     2,y        get string          jsr     DB_pcrlf          jsr     DB_pdata          ldd     0,y        get flag byte          bsr     disp_YN    get/set yes/no answer          bcs     00b        retry if error          leay    4,y        next entry          cmpy    #DEBUG_end          bne     00b          rts*disp_YN   pshs    d,x,y,u          anda    DB_cntrl   see if flag is set          andb    DB_cntrl+1          pshs    b          ora     ,s+          bne     10f          ldx     #00f       'N'          bra     20f10        ldx     #01f       'Y'20        jsr     DB_pdata          jsr     DB_inch    get response          cmpa    #CR        -- leave alone          beq     90f          cmpa    #'Y        -- set flag          beq     30f          cmpa    #'N        -- reset flag          beq     40f          sec     --         illegal character          bra     99f30        ldd     0,s        set flag          ldx     #DB_cntrl          ora     ,x          sta     ,x+          orb     ,x          stb     ,x+          bra     90f40        ldd     0,s        reset flag          coma          comb          ldx     #DB_cntrl          anda    ,x          sta     ,x+          andb    ,x          stb     ,x+90        clc     -          valid input99        puls    d,x,y,u,pc*00        fcc     ' (N)? ',001        fcc     ' (Y)? ',0*DEBUG_tbl          fdb     DBG_SYS,00f*          fdb     DBG_8274,01f          fdb     DBG_INT,02f          fdb     DBG_TRMI,03f          fdb     DBG_IO,04f          fdb     DBG_HAN,05f          fdb     DBG_SLP,06f          fdb     DBG_TASK,07f          fdb     DBG_CMD,08f          fdb     DBG_MSG,09f          fdb     DBG_INIT,10f          fdb     DBG_OPEN,11fDEBUG_end*00        fcc     'Debug system (scheduler, etc)',0* 01        fcc     'Debug PORT drivers',002        fcc     'Debug Interrupt routine',003        fcc     'Debug terminal interrupts',004        fcc     'Debug I/O Main routine',005        fcc     'Debug terminal handler',006        fcc     'Debug Sleep/Wakeup',007        fcc     'Debug tasking',008        fcc     'Debug I/O tasks',009        fcc     'Debug high level messages',010        fcc     'Print initialization messages',011        fcc     'Debug Open actions',0          sttl    Display    System Configuration          pag*** !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!DB_config          ldx     #00f          lbsr    DB_pdata          ldx     #01f          lbsr    DB_pdata          lda     NUM_TSK          lbsr    DB_phex**         ldx     #02f*         lbsr    DB_pdata*         lda     NUM_TRM*         lbsr    DB_phex**         ldx     #06f*         lbsr    DB_pdata*         lda     NUM_PPR*         lbsr    DB_phex**         ldx     #03f*         lbsr    DB_pdata*         lda     NUM_CL*         lbsr    DB_phex**         ldx     #04f*         lbsr    DB_pdata*         ldd     OBUF_SIZE*         lbsr    DB_phex2*          ldx     #05f          lbsr    DB_pdata          ldd     #RAMend+1          subd    tskend          lbsr    DB_phex2**         ldx     #10f*         jsr     DB_pdata*         ldy     #slot_tbl*         ldu     #BASE_SLOT*         lda     #NUM_SLOTS*         pshs    a*50        lbsr    DB_pcrlf*         lbsr    spc_2*         lda     #NUM_SLOTS*         suba    0,s*         lbsr    DB_phex*         lbsr    spc_2*         tfr     u,d*         lbsr    DB_phex2*         lbsr    spc_2*         ldx     0,y++*         lbsr    DB_pdata*         leau    NEXT_SLOT,u*         dec     0,s*         bne     50b*         puls    a          rts*00        fcc     $d,'IOP Configuration:',001        fcc     $d,' Number of tasks = $',002        fcc     $d,' Number of terminals = $',006        fcc     $d,' Number of printers = $',003        fcc     $d,' Number of CLISTs = $',004        fcc     $d,' Output buffer size = $',005        fcc     $d,' Unused memory = $',010        fcc     $d,' Slot Address Type',0          sttl    History    Transaction Queue Output          pagprt_hist          ldx     #00f          jsr     DB_pdata          ldy     hstptr10        jsr     DB_pcrlf          ldb     #7          bsr     spaces          lda     hst_cmd,y          jsr     DB_phex          ldb     #8          bsr     spaces          lda     hst_seq,y          jsr     DB_phex          ldb     #6          bsr     spaces          lda     hst_tty,y          jsr     DB_phex          ldb     #7          bsr     spaces          lda     hst_val,y          jsr     DB_phex          leay    HRECSIZ,y          cmpy    #hstptr          blo     20f          ldy     #hstbuf20        cmpy    hstptr     all Queue printed?          bne     10b          rts*00        fcc     $d,'Transaction History:'          fcc     $d,' Cmd/Resp Seq # TTY # Value',0** Print (B) spaces*spaces          lbsr    DB_outsp          decb          bne     spaces          rts