               0001  NET       set    1                               opt    exp  0000                         absSWTPc      Intelligent I/O Proce     16:33:39  Jan 23, 2026   Page    1Hardware   Definitions                                                                                                                  *       lib ../include/sysdefs.h                     *                     * Various useful constants                     *                                          * Include Debug info                                    0001  DBG_SYS   equ    %0000000000000001 Debug system (scheduler, etc)               0002  DBG_8274  equ    %0000000000000010 Debug ACIA drivers               0004  DBG_INT   equ    %0000000000000100 Debug Interrupt routine               0008  DBG_TRMI  equ    %0000000000001000 Debug terminal interrupts               0010  DBG_IO    equ    %0000000000010000 Debug I/O Main routine               0020  DBG_HAN   equ    %0000000000100000 Debug terminal handler               0040  DBG_SLP   equ    %0000000001000000 Debug Sleep/Wakeup               0080  DBG_TASK  equ    %0000000010000000 Debug tasking               0100  DBG_CMD   equ    %0000000100000000 Debug I/O tasks               0200  DBG_MSG   equ    %0000001000000000 Debug high level messages               0400  DBG_INIT  equ    %0000010000000000 Print initialization messages               0800  DBG_OPEN  equ    %0000100000000000 Debug Open actions                     *               0D04  DEBUG     equ    %0000110100000100                     *EBUG_CONTROL set     %0000111100111111               0000  DEBUG_CONTROL set %0000000000000000                                    0000  DO_HISTORY set   0         Include transaction history mechanism                                          * Process Priorities                                    0046  RUNPRI    equ    70        Must run NOW               FFD8  SIQPRI    equ    -40       Waiting for a terminal interrupt to process               FFCE  FIOPRI    equ    -50       Waiting for the FIO               FFC4  SKPRI     equ    -60       Waiting for socket interrupt               FFBA  POLPRI    equ    -70       poliing priority                                          * UniFLEX signals                                    0001  HANGS     equ    1         Device hangup               0002  INTS      equ    2         Program quit (Control-C)               0003  QUITS     equ    3         Program abort (Control-backslash)               0006  PIPES     equ    6         Broken pipe                                          * -- Configuration constants                                    0009  MAX_TI    equ    9         # Queued terminal interrupts                     *               0001  MAX_DEV   equ    1                     *                                          * constants for PROT_XLTEOLSWTPc      Intelligent I/O Proce     16:33:40  Jan 23, 2026   Page    2Hardware   Definitions                                             000A  LF        equ    $0a       line feed               000D  CR        equ    $0d       carriage return                                          * NETBLOCK constants               0004  NBRQLN    equ    4         4 bytes for request               0204  NBSIZE    equ    512+NBRQLN                                          * CC bits               0001  CFLAG     equ    %00000001 carry               0002  VFLAG     equ    %00000010 overflow               0004  ZFLAG     equ    %00000100 zero bit               0008  NFLAG     equ    %00001000 negative                     SWTPc      Intelligent I/O Proce     16:33:40  Jan 23, 2026   Page    3Macro Definitions                                                                             *                     * This file contains all the standard macro definitions                     * used in the system.                     *                                    0040  FF        equ    %01000000 FIRQ interrupt mask               0010  IF        equ    %00010000 IRQ interrupt mask                                          * register references               0000  D         equ    0               0001  X         equ    1               0002  Y         equ    2               0003  U         equ    3               0004  S         equ    4               0005  PC        equ    5               0006  W         equ    6               0007  V         equ    7               0008  A         equ    8               0009  B         equ    9               000A  CC        equ    10               000B  DP        equ    11               000C  Z0        equ    12        0               000D  Z1        equ    13        0               000E  E         equ    14               000F  F         equ    15                                          * indexed addressing in macro's               0000  IX        equ    0               0001  IY        equ    1               0002  IU        equ    2               0003  IS        equ    3                                                               *                     * Set interrupt flags (I and F)                     *                                          seti      macro                               orcc   #FF|IF                               endm                                          *                     * Clear interrupt flags (I and F)                     *                                          clri      macro                               andcc  #!(FF|IF)                               endm                     SWTPc      Intelligent I/O Proce     16:33:40  Jan 23, 2026   Page    4Macro Definitions                                                                                                  *                     * debug macro                     *                                          *dbugm macro output_character                     * lda #'&1                     * lbsr syspch                     * endm                                          *                     * HD6309 MACRO's                     *                                          ldmd      macro                               fdb    $113d                               fcb    &1                               endm                                          * load W immediate                     ldwi      macro                               fdb    $1086                               fdb    &1                               endm                                          * load W direct                     *ldwd    macro                     *        fdb     $1096                     *        fcb     &1&0xff                     *        endm                                          * load W indexed                     ldwx      macro                               fdb    $10A6                               doindx &1,&2                               endm                                          * load W extended                     *ldwe    macro                     *        fdb     $10b6                     *        fdb     &1                     *        endm                                          * load E indexed                     ldex      macro                               fdb    $11a6                               doindx &1                               endm                                          ordx      macro                               fdb    $10aaSWTPc      Intelligent I/O Proce     16:33:40  Jan 23, 2026   Page    5Macro Definitions                                                                  doindx &1,&2                               endm                                          doindx    macro                               if     (&1=0)                               fcb    $84+(&2<<5)                               else                               if     (&1<16)                               fcb    (&2<<5)+(&1&$0f)                               else                               if     (&1>-16)                               fcb    (&2<<5)+($10)+(&1&$0f)                               else                               if     (&1<128)                               fcb    $88+(&2<<5),(&1&$7f)                               endif                               endif                               endif                               endif                               endm                                          * push W on system stack                     pshsw     macro                               fdb    $1038                               endm                                          * pull W from sytemstack                     pulsw     macro                               fdb    $1039                               endm                                          * memory move ++,++                     tfm1      macro                               fdb    $1138                               fcb    &1<<4|&2                               endm                                          * move memory++ to location                     tfm3      macro                               fdb    $113a                               fcb    &1<<4|&2                               endm                                          * move location to memory++                     tfm4      macro                               fdb    $113b                               fcb    &1<<4|&2                               endm                                          * logical shift left D                     lsld      macro                               fdb    $1048SWTPc      Intelligent I/O Proce     16:33:40  Jan 23, 2026   Page    6Macro Definitions                                                                  endm                                          * logical shift right D                     lsrd      macro                               fdb    $1044                               endm                                          * arithmetic shift right D                     *asrd    macro                     *        fdb     $1047                     *        endm                                          * negate D                     negd      macro                               fdb    $1040                               endm                                          * ex-or registers                     eorr      macro                               fdb    $1036                               fcb    &1<<4|&2                               endm                                          * add with carry D immediate                     adcdi     macro                               fdb    $1089                               fdb    &1                               endm                                          * increment D                     incd      macro                               fdb    $104c                               endm                                          * decrement D                     decd      macro                               fdb    $104a                               endm                                          * clear D                     clrd      macro                               fdb    $104f                               endm                                          * complement D                     comd      macro                               fdb    $1043                               endm                                          * and D immediate                     anddi     macro                               fdb    $1084SWTPc      Intelligent I/O Proce     16:33:41  Jan 23, 2026   Page    7Macro Definitions                                                                  fdb    &1                               endm                                          * bit D immediate                     bitdi     macro                               fdb    $1085                               fdb    &1                               endm                                          *                     * trfr, transfer registers, allow ALL registers                     *                     trfr      macro                               fcb    $1f                               fcb    &1<<4|&2                               endm                                          * exchange, allow ALL registers                     excg      macro                               fcb    $1e                               fcb    &1<<4|&2                               endm                                          * add registers                     *                     * addr, add reg0 + reg1 => reg1                     *                     addr      macro                               fdb    $1030                               fcb    &1<<4|&2                               endm                                          * subtract registers                     subr      macro                               fdb    $1032                               fcb    &1<<4|&2                               endm                                          * extended addressing mode                     aime      macro                               fcb    $72                               fcb    &1                               fdb    &2                               endm                                          * extended addressing mode                     oime      macro                               fcb    $71                               fcb    &1                               fdb    &2                               endm                     SWTPc      Intelligent I/O Proce     16:33:41  Jan 23, 2026   Page    8Macro Definitions                                                        * extended addressing mode                     eime      macro                               fcb    $75                               fcb    &1                               fdb    &2                               endm                                          * test immediate memory                     *timex   macro                     *        fcb     $7b                     *        fcb     &1                     *        fdb     &2                     *        endm                                          * put a LED in LIGHTS on                     LEDON     macro                               fcb    $71                               fcb    &1                               fdb    LIGHTS                               endm                                          * put a LED in LIGHTS off                     LEDOFF    macro                               fcb    $72                               fcb    255-&1                               fdb    LIGHTS                               endmSWTPc      Intelligent I/O Proce     16:33:41  Jan 23, 2026   Page    9Device     Table Structure                                                                    *                     * Possible module types table                     *                       0000                         org    $0  0000               mod_type  rmb    2         device control table address  0002               mod_name  rmb    2         pointer to module name                     *  0004               MOD_SIZE  rmb    0                                                               *                     * Device table structure                     *                       0000                         org    0  0000               dev_addr  rmb    2         Device base address  0002               dev_type  rmb    2         Device type table  0004               dev_brbu  rmb    2         baudrate backup loc                     *  0006               DEV_SIZE  rmb    0         Size of device entry                                          *                     * Control structure for a device, indexed by fifo cmnd >>3                     * MUST match nwp_codes.h  and MAX_S_NUM !!!!                     *     ==>  wzsockdev.t   <==                     *  0000                         org    $0000  0000               D_func0   rmb    2         0  Bad Command  0002               D_func1   rmb    2         1  S_OPEN  0004               D_func2   rmb    2         2  S_CLOSE  0006               D_func3   rmb    2         3  S_RQWR  0008               D_func4   rmb    2         4  S_SEND  000A               D_func5   rmb    2         5  S_RQRD  000C               D_func6   rmb    2         6  S_RECV  000E               D_func7   rmb    2         7  S_INTRPT  0010               D_func8   rmb    2         8  S_CONNECT  0012               D_func9   rmb    2         9  S_BIND  0014               D_funcA   rmb    2         10  S_LISTEN  0016               D_funcB   rmb    2         11  S_ACCEPT  0018               D_funcC   rmb    2         12  S_DISCON  001A               D_funcD   rmb    2         13  S_SNDMAC  001C               D_funcE   rmb    2         14  S_SNDKEP  001E               D_funcF   rmb    2         15  S_SPCL                     *  0020               D_func10  rmb    2         16 S_RRDFRM  0022               D_func11  rmb    2         17 S_RREAD  0024               D_func12  rmb    2         18 S_WRQSTO  0026               D_func13  rmb    2         19 S_WSNDO  0028               D_func14  rmb    2         20 S_WSNDTM  002A               D_func15  rmb    2SWTPc      Intelligent I/O Proce     16:33:41  Jan 23, 2026   Page   10Device     Table Structure                            002C               D_func16  rmb    2  002E               D_func17  rmb    2                       0030               D_func18  rmb    2         24 S_RQSBLK  0032               D_func19  rmb    2         25 S_SNDBLK  0034               D_func1A  rmb    2         26 S_RQRBLK  0036               D_func1B  rmb    2         27 S_RDRBLK                       0038               D_func1C  rmb    2         28  003A               D_func1D  rmb    2         29  003C               D_func1E  rmb    2         30  003E               D_func1F  rmb    2         31                     *  0040               D_inthan  rmb    2         14 Interrupt poller/handler  0042               D_init    rmb    2         15 Device initialization  0044               D_test    rmb    2         16 Test for device present                     *  0046               D_END     rmb    0         End of common handlers                                          SWTPc      Intelligent I/O Proce     16:33:42  Jan 23, 2026   Page   11IOP        Memory Layout                                                 *                     * Basic Memory Layout                     *               0400  RAMorg    equ    $0400     28K of RAM - Thru $6FFF               3EFF  RAMend    equ    $3EFF     $6FFF               7000  RAMscratch equ   $7000     4K of scratchpad RAM               7E00  RAMscrend equ    $7E00               7FE0  ROMstack  equ    $7FE0     High end of ROM Stack                     * BGDB uses 7FF0               E000  ROMLOorg  equ    $E000     8K of ROM - $E000-$FFFF               C000  DEBUGROM  equ    $C000     8K of Debug ROM $C000-$DFFF               FFF0  CPUtraps  equ    $FFF0     CPU Trap Vectors                                          *                     * layout of hardware, w5500 socket device                     *Task       Structure                 16:33:42  Jan 23, 2026   Page   12IOP        Memory Layout                                                 *                     * Task Table                     *                       0000                         org    0                                          * struct task                                    00C0  USTSIZ    equ    192       User Stack Size (big enough??)                     *  0000               tslink    rmb    2         list link of running tasks  0002               tsslnk    rmb    2         list link of sleeping tasks  0004               tsstat    rmb    1         * see below *  0005               tsprir    rmb    1         priority - negative is low  0006               tsevnt    rmb    2         event task is waiting on  0008               tssgnl    rmb    1         Signal waiting for task                     *  0009               tscmd     rmb    1         Saved mailbox command  000A               tsseq     rmb    2         Saved message sequence #  000C               tstval    rmb    1         Saved transaction value  000D               tsdev     rmb    2         Device for task is servicing  000F               tsdtix    rmb    1         device table index  0010               tsagin    rmb    2         return pointer                     *  0012               usp       rmb    2         Saved User Stack Pointer  0014               umark0    rmb    2         Stack Frame Markers  0016               umark1    rmb    2  0018                         rmb    USTSIZ    space for per/process stack                                    00D8  TSKSIZ    equ    *         task structure size                     * stat codes                                    0001  TRUN      equ    1         running               0002  TSLEEP    equ    2         sleep with high priority               0003  TWAIT     equ    3         sleep with low priority               0004  TFREE     equ    4         task is free (uncommitted)               0005  TSYS      equ    5         system task                     *                     * definition of wz5500 variables                     *                     * [*] items are initialized by the IO CPU                     * others are zeroed out                     *                                          * [*] are setup by GPP CPU                                          *                     * wzfsta bits                     *               0001  WZSLCK    equ    %00000001 sock is locked (equal to fdn)Task       Structure                 16:33:42  Jan 23, 2026   Page   13IOP        Memory Layout                                                 *WZSKIO  equ     %00000010       io mode                     *WZSKIS  equ     %00000100       sock is sending               0010  WZWLCK    equ    %00010000 sock task is waiting lock (equal to fdn)               0040  WZWBND    equ    %01000000 sock waiting for bind               0080  WZBUSY    equ    %10000000 sock is busy                                          *                     * protocol values                     *               0001  SP_ICMP   equ    1         Internet Control Message Protocol               0002  SP_GMP    equ    2         Internet Group Management Protocol               0006  SP_TCP    equ    6         Transmission Control Protocol               0008  SP_EGP    equ    8         Exterior Gateway Protocol               0011  SP_UDP    equ    17        User Datagram Protocol                                          *                     * wzcmd values (w5500), private for IOP                     *               0001  WCOPEN    equ    1         open command               0002  WCLIST    equ    2         list command               0004  WCCONN    equ    4         connect command               0008  WCDISC    equ    8         disconnect               0010  WCCLOS    equ    16        close               0020  WCSEND    equ    32        send               0021  WCSNAC    equ    33        send mac               0022  WCSKEP    equ    34        send keep               0040  WCRECV    equ    64        receive               0080  WCSPEC    equ    128       special, combined commands               0081  WCRRQD    equ    128+1     read request data               0082  WCXMDR    equ    128+2     write data in fifo                                    0085  WCBIND    equ    128+5     bind  CPU<=>GPP               0086  WCACCP    equ    128+6     accpet CPU<=>GPP                     *                     * wzstat values                     *               0000  WSCLSD    equ    $00       sock closed               0013  WSINIT    equ    $13       sock init               0014  WSLIST    equ    $14       sock listen               0017  WSESTB    equ    $17       sock established               001C  WSCLWT    equ    $1c       sock close wait               0022  WSUDP     equ    $22       sock UDP               0042  WSMRAW    equ    $42       sock mac raw               0032  WSIRAW    equ    $32       sock IP raw               0015  WSSYNS    equ    $15       sock syn sent               0016  WSSYNR    equ    $16       sock syn received               0018  WSFWAI    equ    $18       sock fin wiat               001A  WSCLSG    equ    $1a       sock closing               001B  WSTIMW    equ    $1b       sock time wait               001D  WSLACK    equ    $1d       sock last ack               001E  WSRNBL    equ    $1e       sock read non block               001F  WSWNBL    equ    $1f       sock write non blockTask       Structure                 16:33:42  Jan 23, 2026   Page   14IOP        Memory Layout                                           0080  WSSPEC    equ    $80       special combined commands               0081  WSRRQF    equ    $80+1     read request data in fifo               0082  WSXMDD    equ    $80+2     xmit data taken from fifo                                          *                     * miscellaneous                     *               0080  PACK_FIRST equ   $80       in non TCP packet start to receive               0001  PACK_REMAI equ   $01       in non TCP packet received               0000  PACK_COMPL equ   $00       in non TCP complete toe receive                                          * is SOCK_NONBLOCK               0001  WFNBLK    equ    $01       in socket() call(wztype << 8)                     * is SOCK_SIGPIPECLS               0002  WFSPOC    equ    $02       in socket() call(wztype << 8)                     * is SOCK_SIGHANGCLS               0004  WFSHNGC   equ    $04       in socket() call(wztype << 8)                       0000                         org    $0                     *                     * per wzsocket process and socket data                     *  0000               wzenum    rmb    1         [*] (pre=enum)  0001               wzdctr    rmb    1         [*] (pre= $00)  delay counter  0002               wzfsta    rmb    1         (pre= $00) status bits (SAME POS!! as in fdn)  0003               wzflg     rmb    1         [*] flasgs, swap busy                     *  0004               wzcmnd    rmb    1         command byte copy  0005               wzstat    rmb    1         status byte copy  0006               wzprio    rmb    1         priority helper  0007               wzerr     rmb    1         error code passing                     *  0008               wzxfer    rmb    2         transfer size  000A               wzrqln    rmb    2         requested size                     *  000C               wzdma1    rmb    2         if split xfer, first part  000E               wzdma2    rmb    2         task id, (if split xfer, second part)                     *                     * unix socket call info                     *  0010               wzsprt    rmb    2         source port  0012               wzdprt    rmb    2         destination port  0014               wzipad    rmb    4         dest IP address  0018               wzsflg    rmb    2         flags                     *                     * udp header info                     *  001A               wzuipa    rmb    4         ip address from UDP header  001E               wzuprt    rmb    2         port number from UDP header               0020  wzswap    equ    *         use this with TCP for swap  0020               wzurms    rmb    2         socket remained size                     * UDP write pointerTask       Structure                 16:33:43  Jan 23, 2026   Page   15IOP        Memory Layout                              0022               wzuwrp    rmb    2         write pointer save                     *                     * open parameters                     *  0024               wzfaml    rmb    2         family            for check AF_  0026               wztype    rmb    2         type              for check SOCK_  0028               wzprot    rmb    2         protocol          for check IPPROTO_                                    002A  WZSIZE    equ    *-wzenum                       0000                         org    $0                     *                     * holds the local IP info, wzdev  net0                     * ipad, mask, gwad, macad                     *  0000               wzmyip    rmb    4         Device IP address  0004               wzsbnm    rmb    4         Subnet mask bits  0008               wzgwad    rmb    4         Gateway IP address  000C               wzhwad    rmb    6         Device Hardware address                     *  0012               wzdsta    rmb    1         up/down status  0013                         rmb    3                                    0016  WZLCSZ    equ    *-wzmyip                     *                     * this is (an attempt) to implement the Berkely                     * socket interface into the UniFLEX 6309 kernel (no 6809)                     *  0000                         org    0                                          * struct sockaddr  0000               sa_fam    rmb    2         address family  0002               sa_dat    rmb    14        protocol address               0010  SKADLN    equ    *                                          * struct sockaddr_in  0010               sin_fam   rmb    2         AF_INET  0012               sin_port  rmb    2         16 bit port  0014               sin_addr  rmb    4         32 bit netid/hostid                                          * address families               0000  AF_UNSP   equ    0         AF_UNSPEC               0001  AF_UNIX   equ    1         AF_UNIX               0002  AF_INET   equ    2         AF_INET                                          * socket types               0001  SK_STRM   equ    1         socket stream               0002  SK_DGRM   equ    2         datagram, conn less               0003  SK_MRAW   equ    3         mac raw socket               0004  SK_IRAW   equ    4         IP raw socket                     *               0100  SK_NONBLK equ    $0100     non blockingTask       Structure                 16:33:43  Jan 23, 2026   Page   16IOP        Memory Layout                                           0200  SK_SPONCL equ    $0200     SIGPIPE on close                                          * protocol families               0001  PF_UNIX   equ    AF_UNIX   same as address families               0002  PF_INET   equ    AF_INET                                    8000  PROT_XLTEOL equ  $8000     xlate CR<=>LF (stream only)               0001  PROT_ICMP equ    1               0002  PROT_IGMP equ    2               0008  PROT_EGP  equ    8                                          *               05C0  MAX_UDP   equ    1472      max size of UDP packet                                          Task       Structure                 16:33:43  Jan 23, 2026   Page   17FIO in Dual Port RAM                                                                          *                     * is now performed by CY7C130 dual port RAM where (1024 * 8)                     * the RAM size is limited to the (upper) 256 bytes, which                     * contains the Interrupt handshake locations                     *                     *                       0000                         org    $0000     absolute addressed                                          ************************************************************                     * the first 32 bytes of a fifo/DPR area are the same                     * for ALL applications                     ************************************************************  0000               cpu_fio   rmb    1         Command code  0001               cpu_fio1  rmb    2         Task ID/sequence  0003               cpu_fio2  rmb    1         Message specific data  0004               cpu_fio3  rmb    2         Device designator  0006               cpu_fio4  rmb    2         UIO  0008               cpu_fio5  rmb    1         Device table index                     ************************************************************  0009               fio_cpu   rmb    1         Response code  000A               fio_cpu1  rmb    2         Task ID /sequence  000C               fio_cpu2  rmb    1         Transaction specific value  000D               fio_cpu3  rmb    2         --  000F               fio_cpu4  rmb    2         UIO  0011               fio_cpu5  rmb    1         --                     ************************************************************                     *  0012               fifo_cnt  rmb    2         Count of data in FIFO  0014               fifo_get  rmb    2         retrieval ponter  0016               fifo_put  rmb    2         storage pointer                     *                     * these values are initialized by the IO CPU                     *  0018               fifo_us0  rmb    2         FIFO offset to application data                     *  001A               fifo_us1  rmb    2         FIFO offset to user specific area2  001C               fifo_us2  rmb    2         FIFO offset to user specific area2  001E               fifo_us3  rmb    2         FIFO offset to user specific area3                     *  0020                         rmb    32-(*-cpu_fio) ** Filler **                     * end of defined area                                          ************************************************************  0020               fifo      rmb    1                     * the size of the fifo is defined in the parameter block                     ************************************************************                                          ************************************************************                     * the top 4 locations are also fixed and shared on all applications                     ************************************************************Task       Structure                 16:33:43  Jan 23, 2026   Page   18FIO in Dual Port RAM                                  0021               DEV2CPU   rmb    1         debug data from IOP/GPP  0022               CPU2DEV   rmb    1         debug data to IOP/GPP                     * should end up at the two top locations in the DUALPORT RAM  0023               fio_cpuF  rmb    1         INT + non-zero   contains info AND set CPU IRQ when written  0024               cpu_fioF  rmb    1         INT + non-zero   contains info AND set FIO IRQ when written                     **************************************************************Task       Structure                 16:33:43  Jan 23, 2026   Page   19Dual_Port RAM Structure                                                                                            *                     * this is an OVERLAY on a 1Kx8 FIFO in DPR                     *                     * the primary fifo definitions are not touched                     *                     * some locations may be re-used for this purpose                     *               0000  DPR_BASE  equ    $0000     GPP DPR at this address (GPP)  0000                         org    DPR_BASE  -- Dual port RAM address                                          *               0000  nwp_strt  equ    *         first address  of DPR RAM                     *                     ******************************************************  0000                         rmb    32        defined in fio.h                       0020                         rmb    512       fifo space                     ******************************************************               0220  WZSKOFF   equ    *                     ******************************************************  0220               wzsk8     rmb    WZSIZE    sock structure  024A               wzsk7     rmb    WZSIZE    sock  0274               wzsk6     rmb    WZSIZE    sock  029E               wzsk5     rmb    WZSIZE    sock  02C8               wzsk4     rmb    WZSIZE    sock  02F2               wzsk3     rmb    WZSIZE    sock  031C               wzsk2     rmb    WZSIZE    sock  0346               wzsk1     rmb    WZSIZE    sock                     ******************************************************               0370  WZNETOF   equ    *  0370               wlocip    rmb    WZLCSZ    network device                                    03B0  wnboot    equ    wlocip+64 see netblock.h                                          ******************************************************                     *                     * fifo top                     * specified in fio.h                     *                     ******************************************************                     *                     * IOP ROM Version #                     *               0020  ROM_VERSION equ  $20       Major/Minor Version of IOP ROM                                          *                     * generic and specific transaction codes for use with fio_han                     * these are for IOP                     *                     Task       Structure                 16:33:44  Jan 23, 2026   Page   20Dual_Port RAM Structure                                                  *                     * Error codes                     *               0080  REJECT    equ    %10000000 Error/Reject bit in command response               0081  E_BADCMD  equ    REJECT+$01 Illegal command               0082  E_SYSBSY  equ    REJECT+$02 IOP saturated               0083  E_NTOPEN  equ    REJECT+$03 Selected device not open               0084  E_BADDEV  equ    REJECT+$04 Illegal device # (=3)               0085  E_DEVBSY  equ    REJECT+$05 Device is already open (exclusieve)               0086  E_IOERR   equ    REJECT+$06 Some sort of IO error               00BE  E_INTRPT  equ    REJECT+$3E Terminal interrupt (send by IOP to UniFLEX)               00BF  E_ABORT   set    REJECT+$3F Transaction aborted by UniFLEX (not sent by IOP)               00C0  E_SOCKET  equ    REJECT+$40 Socket error,                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     *               0008  O_OPEN    equ    $08       Open device               0010  O_CLOSE   equ    $10       Close device               0018  O_RQWR    equ    $18       Request write               0020  O_WRITE   equ    $20       Write data via fifo to IOP               0028  O_RQRD    equ    $28       Request read data               0030  O_READ    equ    $30       Read data for via fifo from IOP               0038  O_INTRPT  set    $38       Interrupt all tasks on a terminal               0040  O_WR1C    equ    $40       Write single character               0048  O_TTYS    equ    $48       TTY Set               0050  O_TTYG    equ    $50       TTY Get                                    0058  O_PGETD   equ    $58       Read baudrate settings               0060  O_PSETD   equ    $60       Write baudrate settings                                          *                     * Normal responses                     * error is with bit 7 set, A contains error code                     *               000F  R_RESET   equ    $0F       System reset & functioning               0001  R_OPEN    equ    $01       Device open successful               0002  R_CLOSE   equ    $02       Device close successful               0003  R_REQOK   equ    $03       Write request now granted               0004  R_WRITE   equ    $04       Write data complete               0005  R_RDOK    equ    $05       Read data now available               0006  R_READ    equ    $06       Read data in FIFO & no more data is available               0007  R_INTRPT  set    $07       Interrupt complete               0008  R_WR1C    equ    $08       Write single character               0009  R_RD1C    equ    $09       Single character available               000B  R_PDATA   equ    $0B       port data transaction succes               000C  R_READM   equ    $0C       Read data in fifo, more data waiting               000D  R_TTY     equ    $0D       TTYSET/GET complete               000E  R_CLOCK   equ    $0E       Interval Timer Tick                     *                     *                     * fio_codes.h is the leading file, here areTask       Structure                 16:33:44  Jan 23, 2026   Page   21Dual_Port RAM Structure                                                  * ammendments                     *                     *               0003  R_RQWR    set    $03       [S]  Request for write               0005  R_RQRD    set    $05       [S]  Request for read               0007  R_INTRPT  set    $07       [S]  Interrupt complete               0008  R_CONNECT equ    $08       [S]  connect ok               0009  R_BIND    equ    $09       [S]  bind call ok               000A  R_LISTEN  equ    $0A       [S]  listen call ok               000B  R_ACCEPT  equ    $0B       [S]  accept call ok               000C  R_DISCON  equ    $0C       [S]  disconnect happened               000D  R_SNDMAC  equ    $0D       [S]  send mac done               000E  R_SNDKEP  equ    $0E       [S]  send keep alive done               000F  R_SPCL    equ    $0F       [S]  special call ok               0015  R_RQRDNB  equ    $15       [S]  non block return read               0013  R_RQWRNB  equ    $13       [S]  non block return write                     *               0021  R_RDFRM   equ    $21       [S]  request for data readfrom               0022  R_RRDFD   equ    $22       [S]  read data readfrom next packet               0023  R_RSNDTO  equ    $23       [S]  request write sendto               0024  R_WSNDTO  equ    $24       [S]  write data sendto               0025  R_SNDTOM  equ    $25       [S]  write data, request more               0026  R_POLLRD  equ    $26       [S]  response poll read data                     *                     * netblock uses a specific interrupt routine                     *               0080  R_RQSBLK  equ    $80               0081  R_SNDBLK  equ    $81               0082  R_RQRBLK  equ    $82               0083  R_RDRBLK  equ    $83               0084  R_ERRBLK  equ    $84       error repsonse                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     * Socket functions                     *               0008  S_OPEN    equ    O_OPEN    Open socket               0010  S_CLOSE   equ    O_CLOSE   Close socket               0018  S_RQWR    equ    O_RQWR    request write to socket               0020  S_WRITE   equ    O_WRITE   Write data to socket               0028  S_RQRD    equ    O_RQRD    Request read data from socket               0030  S_READ    equ    O_READ    Read data from socket               0038  S_INTRPT  equ    O_INTRPT  Interrupt socket               0040  S_CONNECT equ    $40       Connect socket               0048  S_BIND    equ    $48       Bind socket               0050  S_LISTEN  equ    $50       Listen on socket               0058  S_ACCEPT  equ    $58       Accept connection on socket               0060  S_DISCON  equ    $60       Disconnect socket               0068  S_SNDMAC  equ    $68       Send to mac               0070  S_SNDKEP  equ    $70       Send keep alive               0078  S_SPCL    equ    $78       Special. i.e set network device                     *Task       Structure                 16:33:44  Jan 23, 2026   Page   22Dual_Port RAM Structure                                            0080  S_RRDFRM  equ    $80       request read readfrom               0088  S_RREAD   equ    $88       read data readfrom               0090  S_WRQSTO  equ    $90       request send ssendto               0098  S_WSNDTO  equ    $98       send data sendto               00A0  S_WSNDTM  equ    $a0       send to more data                     *               00A8  S_POLLRD  equ    $a8       poll socket for read data present                     * b0                     * b8                     *               00C0  S_RQSBLK  equ    $c0       request send extended block               00C8  S_SNDBLK  equ    $c8       send extended block               00D0  S_RQRBLK  equ    $d0       request read extended block               00D8  S_RDRBLK  equ    $d8       read extended block                     *                     * e0                     * e8               00F0  S_NETBOOT equ    $f0       network boot               00F8  S_PG2FIFO equ    $f8       copy memory page to fifo               0020  MAX_S_NUM equ    32        # of supported functions (incl 0)                                          *                     * specific SOCKET errors in high byte (with E_SOCKET as error)                     *               0001  ESDNOTI   equ    1         device not initialized               0002  ESTYPER   equ    2         type error               000F  ESIMPRO   equ    15        improperly setup               000E  ESDSTPN   equ    14        destination port not set               000A  ESDNOI    equ    10        **               000B  ESIPAIN   equ    11        IP address invalid               0082  ESSKSTE   equ    130       read socket status error               00A1  ESRSPCE   equ    161       SPCL read error               00FF  ESNOIMP   equ    255       not implemented                     *                     * definition of all interrupts in the W5500                     *                                          *                     * interrupts per socket (Socket registers)                     *               0001  SI_CON    equ    %00000001 Sn_IR(CON)               0002  SI_DIS    equ    %00000010 Sn_IR(DISCON)               0004  SI_RCV    equ    %00000100 Sn_IR(RECV)               0008  SI_TIM    equ    %00001000 Sn_IR(TIMEOUT)               0010  SI_SOK    equ    %00010000 Sn_IR(SEND_OK)                                          *                     * common interrupts  (Common registers)                     *               0010  CI_MP     equ    %00010000 Magic Packet               0020  CI_POC    equ    %00100000 PPoE Close               0040  CI_UNR    equ    %01000000 UNREACHTask       Structure                 16:33:45  Jan 23, 2026   Page   23Dual_Port RAM Structure                                            0080  CI_CFL    equ    %10000000 IP ConflictTask       Structure                 16:33:45  Jan 23, 2026   Page   24Variable   Space                                                           0400                         org    RAMorg                       0400               sys_vars  rmb    0         -- start of system variables                                          * Configuration "constants"                       0400               DB_iflg   rmb    1         Debug terminal initialized  0401               DB_cntrl  rmb    2         Debug control flags                     *  0403               slplst    rmb    4         Pointer to waiting tasks  0407               utask     rmb    2         Currently executing task  0409               jobpri    rmb    1         Current job priority (for scheduling)  040A               chproc    rmb    1         Set if must switch users of CPU (reschedule)  040B               tskindx   rmb    1         index in task list  040C               NUM_TSK   rmb    1         max tasks                     *  040D               idle      rmb    1         idle loop flag for scheduler  040E               SI_Q      rmb    6*MAX_TI  Max Terminal Interrupts  0444               SI_Q_ptr  rmb    2         current Q pointer  0446               FIO_lock  rmb    1         FIO in use lock                       0447               int_buf   rmb    2*7       Current Message in (1+2+1+2+1)  0455               int_ptr   rmb    2         Message in pointer  0457               clock_tick rmb   1         Clock tick counter  0458               spiint    rmb    1         Interrupt flag from w5500  0459               wzanyp    rmb    2         Source Port                                            045B               dev_tab   rmb    DEV_SIZE*MAX_DEV system configuration table                     *  0461                         rmb    32                       0481               tsktab    rmb    TSKSIZ*15 Start of dynamic system tables                                    1129  lstram    equ    *               3EFF  end_vars  equ    RAMend    End of System Variables                                          Task       Structure                 16:33:45  Jan 23, 2026   Page   25CPU        Vectors                                                         FFF0                         org    CPUtraps                       FFF0 E0CD                    fdb    rom_trap  Unused  FFF2 E0C6                    fdb    rom_swi3  SWI3  FFF4 E0BF                    fdb    rom_swi2  SWI2  FFF6 E0B2                    fdb    rom_firq  FIRQ  FFF8 E3C2                    fdb    IRQ_han   IRQ  FFFA E0B9                    fdb    rom_swi   SWI  FFFC E0AC                    fdb    rom_nmi   Background debug  FFFE E07B                    fdb    rom_init  Reset                     *                               info   UniFLEX Networking ROM                               info   for CPU09GPP+09NET                               info   At the start of ROM the locations for preset                               info   the network setting are reserved                               info   0000...0005  MAC ADDRESS                               info   0006...0009  IP address                               info   000A...000D  NETMASK                               info   000E...0011  GATEWAY IP address                               info   avoid any duplicate settings!                                          Task       Structure                 16:33:46  Jan 23, 2026   Page   26System     RESET Code                                                      E000                         org    ROMLOorg                                          * start of ROM                     ***************************************************************                     *                     * contains the MAC ADDRESS to be used, make sure that is unique                     *                     * contains the IP address for the interface                     *                     * contains the NETMASK for the interface                     *                     * contains the IP address of the GATEWAY                     *                     **************************************************************                     *                     * REPLACE the defaults with your specific values                     *                     * this is for the local network device setup                     *                     * mac address 6 bytes                            (Ex00...Ex05)                     *  E000 FF FF FF FF   wzifma    fcb    $FF,$FF,$FF,$FF,$FF,$FF                     *                     * Note! HERE  IP addresses are written COMMA SEPARATED!                     *                     * IP addres for THIS interface (avoid duplicates!!!)  E006 FF FF FF FF   wzifip    fcb    255,255,255,255 (Ex06...Ex09)                     * NETMASK  E00A FF FF FF FF   wzifnm    fcb    255,255,255,255 (Ex0A...Ex0D)                     * GATEWAY IP address  E00E FF FF FF FF   wzifga    fcb    255,255,255,255 (Ex0E...E011)                     *                     **************************************************************                                          **************************************************************                       E012 0D 4E 57 50   DBmsg00   fcc    $d,'NWP ROM :250121',0                                          **************************************************************                     *  E023 0D 53 79 73   DBmsg01   fcc    $d,'System Initialization Complete',0  E043 0D 43 50 55   DBmsg02   fcc    $d,'CPU RESET Complete',0  E057 0D 0D 53 79   CPU_down  fcc    $d,$d,'System CPU not functioning',0                                          *                     * share settings with kernel driver code                     *               E074  fio_fsz   equ    *         device fifo size               E076  fio_dsz   equ    *+2       device RAM size               E078  max_trn   equ    *+4       max transactions                     *Task       Structure                 16:33:46  Jan 23, 2026   Page   27System     RESET Code                                                    * share specific DUAL PORT RAM device initialization                     * between UniFLEX kernel and NWP CPU                     *  E074 0200                    fdb    512       fio_fsz FIFO SIZE  E076 0400                    fdb    1024      fio_dsz DEVICE SIZE  E078 08                      fcb    8         fio_mxtrn MAX_TRANSACTIONS  E079 0000                    fdb    0                     *                     * declaration of offsets and settings                     *               0008  MAX_WZ    equ    8         # of sockets in w5500                                                               *                     * System RESET code                     *  E07B 10CE 7FE0     rom_init  lds    #ROMstack initialize stack pointer  E07F                         ldmd   3  E07F 113D                    fdb    $113d  E081 03                      fcb    3                               endm                      >E082 BD   E0EE     20        jsr    stbinit   go initialize system memory                       E085 10CE 0481     30        lds    #tsktab   Task 0 Stack  E089 32   E9 00D8            leas   TSKSIZ,s  E08D 17   015E               lbsr   fio_reset  E090 BD   E59C               jsr    skdvini   set the device itself  E093 17   0135               lbsr   timerin                       E096 34   30                 pshs   x,y  E098 108E E013               ldy    #DBmsg00+1 skip initial EOL  E09C 8E   03E0               ldx    #$03e0    top of FIFO  E09F A6   A0       02        lda    0,y+  E0A1 27   04                 beq    01f  E0A3 A7   80                 sta    0,x+      copy ROM info  E0A5 20   F8                 bra    02b  E0A7 35   30       01        puls   x,y                                          *                     * Initialization complete - Start executing commands                     *  E0A9               fio_start  E0A9 7E   E47D     10        jmp    rsched                                          Task       Structure                 16:33:46  Jan 23, 2026   Page   28ROM        Interrupt Fielders                                              E0AC 8D   26       rom_nmi   bsr    rom_int  E0AE 4E 4D 49 00             fcc    'NMI',0  E0B2 8D   20       rom_firq  bsr    rom_int  E0B4 46 49 52 51             fcc    'FIRQ',0  E0B9 8D   19       rom_swi   bsr    rom_int  E0BB 53 57 49 00             fcc    'SWI',0  E0BF 8D   13       rom_swi2  bsr    rom_int  E0C1 53 57 49 32             fcc    'SWI2',0  E0C6 8D   0C       rom_swi3  bsr    rom_int  E0C8 53 57 49 33             fcc    'SWI3',0  E0CD 8D   05       rom_trap  bsr    rom_int  E0CF 54 52 41 50             fcc    'TRAP',0                       E0D4 8E   E0E1     rom_int   ldx    #ROM_ERR  E0D7 BD   F395               jsr    DB_pdata  E0DA 35   10                 puls   x  E0DC BD   F395               jsr    DB_pdata  E0DF 20   FE       rom_bad   bra    *                     *  E0E1 0D 52 4F 4D   ROM_ERR   fcc    $d,'ROM Error: ',0                                          *Task       Structure                 16:33:46  Jan 23, 2026   Page   29Table      Initialization                                                                                                               *                     * stbinit - Initialize System Memory Tables                     *  E0EE 8E   0000     stbinit   ldx    #0        s  clear all variables  E0F1 CC   0000               ldd    #0  E0F4 ED   81       10        std    ,x++  E0F6 8C   3EFF               cmpx   #end_vars done yet?  E0F9 25   F9                 blo    10b                       E0FB CC   0D04               ldd    #DEBUG  E0FE FD   0401               std    DB_cntrl                                            E101 B6   E078               lda    max_trn   shared with main CPU  E104 8B   04                 adda   #4        fixed system tasks  E106 B7   040C               sta    NUM_TSK                     * >E109 17   0013               lbsr   set_tables go figure out configuration, tables, etc                                          * Initialize Socket Interrupt Queue  E10C 8E   040E     15        ldx    #SI_Q     set queue empty  E10F BF   0444               stx    SI_Q_ptr  E112 8E   0447               ldx    #int_buf  reset message in pointer  E115 BF   0455               stx    int_ptr                      >E118 17   005B     17        lbsr   tskinit   initialize tasks                       E11B 17   1295     18        lbsr   DB_config display configuration  E11E 39                      rts                                          *                     * Set up system tables                     *  E11F               set_tables  E11F 108E 045B               ldy    #dev_tab  E123 8E   E539               ldx    #DEV_SOCK  E126 AF   22                 stx    dev_type,y  E128 AD   98 42              jsr    [D_init,x] (skinit)                                          * Compute configuration  E12B CE   E1DD               ldu    #mod_tbl  tables with module refs  E12E AE   C4       12        ldx    mod_type,u  E130 27   09                 beq    20f       jump if end of module table  E132 AD   98 44              jsr    [D_test,x] check for device  E135 25   04                 bcs    15f       jump if found  E137 33   44                 leau   MOD_SIZE,u  E139 20   F3                 bra    12b                     *  E13B               15Task       Structure                 16:33:47  Jan 23, 2026   Page   30Table      Initialization                             E13B               20                     * -- All done setting up configuration                       E13B CC   0481               ldd    #tsktab   start of system tables  E13E 1F   03                 tfr    d,u                     * -- Task table  E140 86   D8                 lda    #TSKSIZ  E142 F6   040C               ldb    NUM_TSK  E145 3D                      mul >E146 17   001F               lbsr   sto_chk   check for system table space overflow                     *                     * -- All done  E149 39            90        rts                     *  E14A 0D 2E 2E 2E   00        fcc    $d,"...Can't size tables!",0                     *  E161 2E 2E 4E 6F   no_dev    fcc    '..None',0                                                                                    *                     * Allocate some system table space                     *   D - Space being consumed                     *   U - Current end of table space                     *   jsr sto_chk (System Table Overflow check)                     *   <CS> if overflow                     *  E168 33   CB       sto_chk   leau   d,u       compute new end pointer  E16A 1183 3EFF               cmpu   #end_vars overflow?  E16E 22   03                 bhi    10f       yes - return error  E170 1C   FE                 clc              no         - return OK  E172 39                      rts  E173 1A   01       10        sec              ..         bad owies  E175 39                      rts                                          *                     * tskinit - Initialize all tasks                     *  E176 8E   0481     tskinit   ldx    #tsktab  E179 BF   0407               stx    utask  E17C F6   040C               ldb    NUM_TSK   # tasks in system  E17F 34   04                 pshs   b  E181 108E 0481               ldy    #tsktab   task 1  E185 31   A9 00D8            leay   TSKSIZ,y                       E189 86   04       10        lda    #TFREE    mark all tasks free  E18B 8C   0481               cmpx   #tsktab   is this the system task?  E18E 26   02                 bne    15f  E190 86   05                 lda    #TSYS     the system task is never free  E192 A7   04       15        sta    tsstat,x  E194 86   FF                 lda    #$FF      not associated with a terminal  E196 A7   0D                 sta    tsdev,xTask       Structure                 16:33:47  Jan 23, 2026   Page   31Table      Initialization                             E198 A7   0E                 sta    tsdev+1,x  E19A 33   89 00D8            leau   TSKSIZ,x  initialize stack  E19E CC   E33A               ldd    #IO_han  E1A1 34   20                 pshs   y  E1A3 AC   E1                 cmpx   ,s++      task 1?  E1A5 26   03                 bne    20f       no - normal I/O handling task  E1A7 CC   E418               ldd    #SI_HAN   yes - special terminal interrupt handling task  E1AA 36   06       20        pshu   d  E1AC EF   88 12              stu    usp,x  E1AF EF   88 14              stu    umark0,x  E1B2 30   89 00D8            leax   TSKSIZ,x  E1B6 6A   E4                 dec    0,s       done?  E1B8 26   CF                 bne    10b                       E1BA 32   61                 leas   1,s       clean up stack  E1BC CC   0000               ldd    #0        nothing running or sleeping  E1BF FD   0403               std    slplst  E1C2 FD   0405               std    slplst+tsslnk  E1C5 30   A4                 leax   0,y       start interrupt handling task  E1C7 BD   E4BC               jsr    makrdy  E1CA 39                      rts                                                               *                     * GPP interrupt timer                     *               8400  tim_base  equ    $8400               8401  tim_rest  equ    $8401                       E1CB 86   00       timerin   lda    #%00000000 D0      (OFF!)  E1CD B7   8400               sta    tim_base  interrupt enable  E1D0 39                      rts                                                         E1D1  timerack  equ    *  E1D1 86   01                 lda    #1  E1D3 B7   8401               sta    tim_rest  reset interrupt  E1D6 39                      rts                       E1D7 B6   8400     timerchk  lda    tim_base  E1DA 84   80                 anda   #%10000000 interrupt flag  E1DC 39                      rtsTask       Structure                 16:33:47  Jan 23, 2026   Page   32IOP        Configuration                                                                      *                     * define which type of boards are present                     *               E1DD  mod_tbl   equ    *  E1DD E539 E1E3               fdb    DEV_SOCK,WZ5_name  E1E1 0000                    fdb    0                     *  E1E3 57 35 35 30   WZ5_name  fcc    'W5500_SOCK',0Task       Structure                 16:33:47  Jan 23, 2026   Page   33FIO        Simulation Routines                                                                *                     * Reset CPU-IOP Interface                     * it is assumed that the FIO (DPR) sits at $0000                     * it sets the offsets to the sock array and to the device info                     *  E1EE               fio_reset                     * when here, all storage locations have been erased already                     *  E1EE 8E   0000               ldx    #0  E1F1 9F   14                 stx    fifo_get  set Q pointers  E1F3 9F   16                 stx    fifo_put  E1F5 8E   0370               ldx    #WZNETOF  E1F8 9F   1A                 stx    fifo_us1  E1FA 8E   0220               ldx    #WZSKOFF  E1FD 9F   18                 stx    fifo_us0  so that kernel CPU can see it                     * init the 8 SOCK structs  E1FF 86   08                 lda    #8  E201 A7   84       01        sta    wzenum,x  E203 30   88 2A              leax   WZSIZE,x  to next  E206 4A                      deca  E207 26   F8                 bne    01b                     *  E209 BE   E076               ldx    fio_dsz  E20C 30   1E                 leax   -2,x      one from top  E20E CE   0400               ldu    #1024     -- Reset Time-Out value                     *  E211 C6   FF       fio_wait  ldb    #255      Spin counter                     *  E213               00  E213 6D   84                 tst    0,x       fio_cpuF  E215 27   0D                 beq    10f                     *  E217 5A                      decb  E218 26   F9                 bne    00b       jump back if not ready                     *  E21A 33   5F                 leau   -1,u  E21C 1183 0000               cmpu   #0  E220 26   EF                 bne    fio_wait  E222 20   CA                 bra    fio_reset                     * reset OK  E224 39            10        rtsTask       Structure                 16:33:48  Jan 23, 2026   Page   34FIO        Simulation Routines                                                                *                     * fio_msg - Send a message via the FIO Mailbox                     * it is assumed that the FIO (DPR) sits at $0000                     *   B - Message code to send (one byte)                     *   fio_cpu1..3 already set up                     *  E225 34   54       fio_msg   pshs   b,x,u     save register  E227 FE   E076               ldu    fio_dsz  E22A 33   5E                 leau   -2,u      one off top  E22C D7   09                 stb    fio_cpu   set up mailbox value                       E22E 86   FF       5         lda    #$FF      tell CPU mailbox full  E230 A7   C4                 sta    0,u       fio_cpuF  E232 8E   FFFF     05        ldx    #$FFFF    time-out counter                     *  E235 A6   C4       10        lda    0,u       fio_cpuF   wait till value consumed  E237 27   06                 beq    20f       jump if consumed                     *  E239 30   1F                 leax   -1,x      time-out yet?  E23B 26   F8                 bne    10b                     *  E23D 20   F3                 bra    05b       try again                     *  E23F 35   D4       20        puls   b,x,u,pc                     *                                          *                     * fio_response - Return a response code/sequence #                     * it is assumed that the FIO (DPR) sits at $0000                     *    X = utask,                     *    B - Response code                     *    A - Transaction specific value                     *  E241 34   16       fio_response pshs d,x  E243 8D   18                 bsr    FIO_get   access FIO  E245 BE   0407               ldx    utask     task ID  E248 EC   0A                 ldd    tsseq,x  E24A DD   0A                 std    fio_cpu1  E24C EC   0D                 ldd    tsdev,x   device info  E24E DD   0D                 std    fio_cpu3  E250 A6   E4                 lda    0,s       get transaction specific value  E252 97   0C                 sta    fio_cpu2  E254 E6   61                 ldb    1,s       is RESPONSE code >E256 BD   E225               jsr    fio_msg  E259 8D   17                 bsr    FIO_rel   release FIO  E25B 35   96                 puls   d,x,pc    return                                          *                     * FIO_get - Get access to FIO device                     * -- Sleep till available                     *Task       Structure                 16:33:48  Jan 23, 2026   Page   35FIO        Simulation Routines                        E25D 34   76       FIO_get   pshs   d,x,y,u   save registers  E25F 108E 0446     10        ldy    #FIO_lock is the device locked  E263 6D   A4                 tst    0,y  E265 27   07                 beq    20f       no - go get it                     *  E267 C6   CE                 ldb    #FIOPRI   waiting for the FIO  E269 BD   E4EA               jsr    sleep  E26C 20   F1                 bra    10b       try again                     *  E26E 6C   A4       20        inc    0,y       mark in use  E270 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIO_rel - Release access to FIO                     *  E272 34   76       FIO_rel   pshs   d,x,y,u  E274 108E 0446               ldy    #FIO_lock  E278 6F   A4                 clr    0,y  E27A BD   E4C6               jsr    wakeup  E27D 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIFO_get - Fetch character from FIFO                     *   B - Character fetched                     *  E27F 34   04       FIFOgeta  pshs   b  E281 8D   05                 bsr    FIFO_get  E283 35   02                 puls   a  E285 1E   89                 exg    a,b  E287 39                      rts                     *  E288 34   12       FIFO_get  pshs   a,x  E28A DC   12                 ldd    fifo_cnt  any data?  E28C 27   15                 beq    99f       no - exit                     *  E28E                         decd   yes       - adjust count  E28E 104A                    fdb    $104a                               endm  E290 DD   12                 std    fifo_cnt  E292 9E   14                 ldx    fifo_get  get consumer pointer  E294 E6   88 20              ldb    fifo,x    fetch byte  E297 30   01                 leax   1,x       bump pointer  E299 BC   E074               cmpx   fio_fsz   end of fifo?  E29C 26   03                 bne    10f                     *  E29E 8E   0000               ldx    #0        reset pointer                     *  E2A1 9F   14       10        stx    fifo_get                     *  E2A3 35   92       99        puls   a,x,pc                                          *Task       Structure                 16:33:48  Jan 23, 2026   Page   36FIO        Simulation Routines                                           * FIFO_put - Place character into FIFO                     *   B - Character fetched                     *  E2A5 34   04       FIFOputa  pshs   b  E2A7 1F   89                 tfr    a,b  E2A9 8D   02                 bsr    FIFO_put  E2AB 35   84                 puls   b,pc                     *  E2AD 34   16       FIFO_put  pshs   d,x  E2AF 9E   16                 ldx    fifo_put  get consumer pointer  E2B1 E7   88 20              stb    fifo,x    store byte  E2B4 30   01                 leax   1,x       bump pointer  E2B6 BC   E074               cmpx   fio_fsz   end of FIFO?  E2B9 26   03                 bne    10f                     *  E2BB 8E   0000               ldx    #0        reset pointer  E2BE 9F   16       10        stx    fifo_put                     *  E2C0 DC   12                 ldd    fifo_cnt  E2C2                         incd  E2C2 104C                    fdb    $104c                               endm  E2C4 DD   12                 std    fifo_cnt  E2C6 35   96       99        puls   d,x,pcTask       Structure                 16:33:49  Jan 23, 2026   Page   37FIO        FIO IRQ code                                                                       *                     * FIO interrupt handler, called when IRQ was set (interrupt context)                     * for regular NWP and IOP purpose                     *  E2C8 BE   0455     fio_irq   ldx    int_ptr   input message pointer  E2CB 96   00                 lda    cpu_fio   move REQUEST  E2CD A7   80                 sta    ,x+  E2CF DC   01                 ldd    cpu_fio1  sequence # TASK ID  E2D1 ED   81                 std    ,x++  E2D3 96   03                 lda    cpu_fio2  specific DATA  E2D5 A7   80                 sta    ,x+  E2D7 DC   04                 ldd    cpu_fio3  device major/minor  E2D9 ED   81                 std    ,x++  E2DB 96   08                 lda    cpu_fio5  E2DD A7   80                 sta    0,x+                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device, X[6]=devtab                     *  E2DF FE   E076               ldu    fio_dsz  E2E2 33   5F                 leau   -1,u  E2E4 6F   C4                 clr    0,u       cpu_fioF indicate message consumed                     *  E2E6 BF   0455               stx    int_ptr   update pointer  E2E9 108E 0447               ldy    #int_buf  get message from buffer  E2ED A6   A4                 lda    0,y       -- Send interrupt command?  E2EF 81   38                 cmpa   #O_INTRPT  E2F1 26   0D                 bne    30f                     *                     * special case OOB signal                     *  E2F3 10BF 0455               sty    int_ptr   reset pointer  E2F7 E6   23                 ldb    3,y       signal  E2F9 AE   24                 ldx    4,y       DEVICE/SOCK reference                     *  E2FB BD   E5F4               jsr    sdev_sig  send device signal  E2FE 20   39                 bra    fiointe   exit                     *                     * normal command                     * acquire free task slot                     *  E300 8E   0481     30        ldx    #tsktab   search for an available task  E303 F6   040C               ldb    NUM_TSK   Number of tasks in system                     *  E306 A6   04       32        lda    tsstat,x  E308 81   04                 cmpa   #TFREE    looking for a "free" task  E30A 27   0E                 beq    40f                     *  E30C 30   89 00D8            leax   TSKSIZ,x  E310 5A                      decb  E311 26   F3                 bne    32b                     *Task       Structure                 16:33:49  Jan 23, 2026   Page   38FIO        FIO IRQ code                               E313 C6   82                 ldb    #E_SYSBSY can't process - IOP saturated!  E315 BD   E225               jsr    fio_msg  E318 20   1F                 bra    fiointe   exit                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device, X[6]=device table                     * move data over into task struct                     *  E31A 108E 0447     40        ldy    #int_buf  get message from buffer  E31E 10BF 0455               sty    int_ptr   reset pointer  E322 E6   A0                 ldb    ,y+       command byte  REQUEST  E324 E7   09                 stb    tscmd,x   save for task  E326 EC   A1                 ldd    ,y++      sequence #    task ID  E328 ED   0A                 std    tsseq,x  E32A E6   A0                 ldb    ,y+       command specific DATA  E32C E7   0C                 stb    tstval,x  E32E EC   A1                 ldd    ,y++      associate with terminal major/minor  E330 ED   0D                 std    tsdev,x  E332 A6   A0                 lda    ,y+  E334 A7   0F                 sta    tsdtix,x  device table index  E336 BD   E4BC               jsr    makrdy    make task ready to run                     *  E339 39            fiointe   rts              exitTask       Structure                 16:33:49  Jan 23, 2026   Page   39IO         Command Handler                                               *                     *                     * IO_han - I/O Command Handler                     *                     *   This routine comprises the main processing loop                     * for each task in the system.  Whenever an I/O command                     * is detected (via the message interrupt), a task will                     * be scheduled to process it.  This is that task.                     *   The command is saved in the "tscmd" field of the                     * task control block.                     *  E33A               IO_han                     *                     * we execute the task belonging to the transaction                     *  E33A                         clri  E33A 1C   AF                 andcc  #!(FF|IF)                               endm  E33C BE   0407               ldx    utask     get task control block address  E33F A6   09                 lda    tscmd,x   get I/O command  E341 E6   0F                 ldb    tsdtix,x  get device table selector                     *                     * The command byte is shifted and used as an index                     * in a DEV_XXXX tab, max 32 commands allowed                     *  E343 44                      lsra             isolate    command  E344 44                      lsra  E345 44                      lsra                     *  E346 C1   01                 cmpb   #MAX_DEV  invalid device?  E348 25   04                 blo    00f  E34A C6   84                 ldb    #E_BADDEV  E34C 20   53                 bra    20f                     *  E34E 81   20       00        cmpa   #MAX_FCMD max. fifo commands  E350 25   04                 blo    01f  E352 C6   81                 ldb    #E_BADCMD  E354 20   4B                 bra    20f                     *                     * build 16 bit index in table                     *  E356 48            01        lsla             --   word index on command  E357 34   10                 pshs   x         TASK info  E359 34   02                 pshs   a  E35B 8E   045B               ldx    #dev_tab  E35E 86   06                 lda    #DEV_SIZE  E360 3D                      mul  E361 30   8B                 leax   d,x       right table selected  E363 AE   02                 ldx    dev_type,x get handler table address  E365 35   02                 puls   a  E367 10AE 86                 ldy    a,x       get processor address  E36A 35   10                 puls   xTask       Structure                 16:33:49  Jan 23, 2026   Page   40IO         Command Handler                            E36C 34   20                 pshs   y         can be changed on stack..                     *                     * Y=function code address, X = task                     *  E36E 10AE 88 10              ldy    tsagin,x  if 0, d nothing  E372 27   0B                 beq    05f       else it is target ponter  E374 10AF E4                 sty    0,s       code asks for rerun, overwrite  E377 108E 0000               ldy    #0  E37B 10AF 88 10              sty    tsagin,x  reset pointer                     *                     * TOS now holds correct execution address                     *  E37F 35   20       05        puls   y         change address  E381 4F                      clra                     *  E382 8E   E3A4               ldx    #IO_end   interrupt handler address  E385 34   10                 pshs   x  E387 BE   0407               ldx    utask     task pointer  E38A 10EF 88 16              sts    umark1,x  E38E EE   0D                 ldu    tsdev,x   get sock reference                     *                     * CALL HANDLER: X=utask, Y=handler address, U=device reference                     * can be maj/min or wzsock address                     *  E390 AD   A4                 jsr    0,y       perform operation & return status  E392 32   62                 leas   2,s       clean up stack                     *                     * on return, Y= flag. -1 is resched, else end task                     * B = status , A = danta, X,U are lost                     *  E394 BE   0407               ldx    utask     restore task pointer  E397 108C FFFF               cmpy   #$ffff  E39B 26   04                 bne    20f                     * task is NOT done yet, don't stop it! re-schedule  E39D                         seti   set       interrupt mask  E39D 1A   50                 orcc   #FF|IF                               endm  E39F 20   18                 bra    91f       just escape (and come back)                     *                     * A=transaction value, B=response code, U=device reference                     * X = task pointer                     * in fio_response the task ID is added as sequence reference                     * SEND the response to the host CPU                     *                     *  E3A1 BD   E241     20        jsr    fio_response                     *                     * task is done                     *  E3A4               IO_end    seti   mask      interrupts  E3A4 1A   50                 orcc   #FF|IF                               endmTask       Structure                 16:33:50  Jan 23, 2026   Page   41IO         Command Handler                            E3A6 BE   0407               ldx    utask     restore task control block address  E3A9 A7   0C                 sta    tstval,x  remember transaction value sent  E3AB E7   09                 stb    tscmd,x   and command response  E3AD 86   04                 lda    #TFREE    mark task "terminated & free"  E3AF A7   04                 sta    tsstat,x  E3B1 86   FF                 lda    #$FF      disassociate from any terminal  E3B3 A7   0D                 sta    tsdev,x  E3B5 A7   0E                 sta    tsdev+1,x  E3B7 6F   08                 clr    tssgnl,x  no waiting signals                     *                     * exit here to rescheduling                     *  E3B9 BD   E47D     91        jsr    rsched    run other tasks  E3BC 16   FF7B               lbra   IO_han                                          *                     * not implemented                     *  E3BF C6   81       bad_cmd   ldb    #E_BADCMD error code  E3C1 39                      rtsTask       Structure                 16:33:50  Jan 23, 2026   Page   42Interrupt  Processing                                                                         *                     * This routine handles all IRQ interrupts                     *                     *               E3C2  IRQ_han   equ    *                     *                     * Check for FIO Mailbox interrupt                     *  E3C2 BE   E076     10        ldx    fio_dsz  E3C5 30   1F                 leax   -1,x  E3C7 A6   84                 lda    0,x       cpu_fioF   see if mailbox interrupt  E3C9 27   03                 beq    99f       no - move on  E3CB BD   E2C8               jsr    fio_irq   call fio interrupt handler                     *                     *         lbsr    DB_main                     *  E3CE 3B            99        rti              return from interrupt                     *  E3CF 0D 49 4F 50   IRQmsg10  fcc    $d,'IOP Got: ',0  E3DA 2D 2D 20 4E   00        fcc    '-- No tasks!',0Task       Structure                 16:33:50  Jan 23, 2026   Page   43Interrupt  All Tasks                                                                          *                     * Interrupt all tasks associated with a given device                     *   D - Device #, XL = SIG                     *   jsr int_all                     * Note: The current task is skipped, along with                     * the system and the interrupt handler task (1).                     *  E3E7 34   36       int_all   pshs   d,x,y  E3E9 F6   040C               ldb    NUM_TSK  E3EC C0   02                 subb   #2  E3EE 34   04                 pshs   b  E3F0 BE   0481               ldx    tsktab  E3F3 30   89 01B0            leax   2*TSKSIZ,x                     *  E3F7 EC   61       10        ldd    1,s  E3F9 10A3 0D                 cmpd   tsdev,x   is this guy associated with the device?  E3FC 26   0E                 bne    20f                     *  E3FE BC   0407               cmpx   utask     make sure I don't get blown away  E401 27   09                 beq    20f                     *  E403 34   16                 pshs   d,x                     * B = signal #  E405 E6   64                 ldb    4,s       XL  E407 BD   E51F               jsr    xmtint    interrupt task  E40A 35   16                 puls   d,x                     *  E40C 30   89 00D8  20        leax   TSKSIZ,x  next task  E410 6A   E4                 dec    0,s       more tasks?  E412 26   E3                 bne    10b  E414 32   61                 leas   1,s                     *  E416 35   B6                 puls   d,x,y,pc  returnTask       Structure                 16:33:50  Jan 23, 2026   Page   44Generic Signal Handling Task                                                                  *                     * SI_HAN Signal interrupt handler                     *  E418 108E 040E     SI_HAN    ldy    #SI_Q     Terminal Interrupt Queue  E41C                         seti  E41C 1A   50                 orcc   #FF|IF                               endm  E41E FE   0444               ldu    SI_Q_ptr  get current Q ptr  E421 1183 040E               cmpu   #SI_Q     anything in Q?  E425 26   07                 bne    20f       yes - go process it                     *  E427 C6   D8                 ldb    #SIQPRI   wait for something to do  E429 BD   E4EA               jsr    sleep  E42C 20   EA                 bra    SI_HAN                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *  E42E E6   C2       20        ldb    0,-u      B = Interrupt #  E430 34   04                 pshs   b  E432 EC   C3                 ldd    0,--u     A = Device #  E434 34   06                 pshs   d  E436 EC   C3                 ldd    0,--u     task ID  E438 34   06                 pshs   d         save registers  E43A FF   0444               stu    SI_Q_ptr  update pointer                     *                     * S[0][1]=task,U[2][3]=dev,U[4]=response                     *  E43D E6   63                 ldb    3,s       set up to flush all input for this terminal  E43F                         clri   allow     interrupts  E43F 1C   AF                 andcc  #!(FF|IF)                               endm                     *  E441 BD   E25D               jsr    FIO_get   get access to FIO  E444 EC   E1                 ldd    0,s++     task ID  E446 DD   0A                 std    fio_cpu1  E448 EC   E1                 ldd    ,s++      terminal #  E44A DD   0D                 std    fio_cpu3  terminal  E44C E6   E0                 ldb    ,s+       interrupt #  E44E D7   0C                 stb    fio_cpu2  signal  E450 C6   07                 ldb    #R_INTRPT  E452 BD   E225               jsr    fio_msg   send interrupt message  E455 BD   E272               jsr    FIO_rel   release access to FIO  E458 20   BE                 bra    SI_HAN    process more if needed                                          *                     * Send_SI - Send a Signal interrupt                     *   B = Interrupt #                     *   X = task struct                     *   jsr send_SI                     *  E45A 34   76       send_SI   pshs   d,x,y,u   save registersTask       Structure                 16:33:51  Jan 23, 2026   Page   45Generic Signal Handling Task                          E45C FE   0444               ldu    SI_Q_ptr  get Q head  E45F 1183 0444               cmpu   #SI_Q_ptr check for overflow  E463 24   0F                 bhs    90f       exit if so - sorry                     *  E465 EC   0A                 ldd    tsseq,x   task ID @ master side  E467 ED   C1                 std    0,u++  E469 EC   0D                 ldd    tsdev,x   device #  E46B ED   C1                 std    0,u++     place value in Queue  E46D E6   61                 ldb    1,s       old B  E46F E7   C0                 stb    0,u+  E471 FF   0444               stu    SI_Q_ptr  update pointer                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *                     *  E474 108E 040E     90        ldy    #SI_Q     wake up Queue server >E478 BD   E4C6               jsr    wakeup  E47B 35   F6       99        puls   d,x,y,u,pc returnTask       Structure                 16:33:51  Jan 23, 2026   Page   46Scheduler  routines                                                                           *                     * All routines in this file pertain to scheduling                     * operations.                     *                                          *                     * this is a very specilaized version of rsched. It will                     * in a round robin fashion, all runable tasks make                     * one run. This way there will be no priority clash                     * between the active sockets                     *                                          *                     * rsched                     *                     * Rsched will reschedule the cpu giving control to                     * another ready task.  If no tasks are ready,                     * looping is done until one becomes ready.  Rsched                     * does not put the current task back on the ready list!                     * This routine returns one to the caller.  All registers                     * are destroyed.                     *                       E47D               rsched    seti   mask      interrupts  E47D 1A   50                 orcc   #FF|IF                               endm                     *  E47F               rsched2   clri  E47F 1C   AF                 andcc  #!(FF|IF)                               endm  E481 12                      nop  E482                         seti  E482 1A   50                 orcc   #FF|IF                               endm  E484 8D   1A                 bsr    stptsk    select next task in chain  E486 8D   09                 bsr    gtsktb    get it's details                     *                     * is it runnable?                     *  E488 A6   04                 lda    tsstat,x  ready?  E48A 81   01                 cmpa   #TRUN  E48C 26   F1                 bne    rsched2   no?, try the next one                     *  E48E 8D   21                 bsr    swtchu    switch users top page  E490 39                      rts              return                                          *                     * select next task                     *  E491 34   06       gtsktb    pshs   d         current index  E493 8E   0481               ldx    #tsktab   task tableTask       Structure                 16:33:51  Jan 23, 2026   Page   47Scheduler  routines                                   E496 F6   040B               ldb    tskindx  E499 86   D8                 lda    #TSKSIZ  E49B 3D                      mul  E49C 30   8B                 leax   d,x       select task  E49E 35   86                 puls   d,pc                                          *                     * step index in tasks list                     *  E4A0 34   02       stptsk    pshs   a  E4A2 B6   040B               lda    tskindx   step index  E4A5 4C                      inca  E4A6 B1   040C               cmpa   NUM_TSK  E4A9 25   01                 blo    01f       against max  E4AB 4F                      clra  E4AC B7   040B     01        sta    tskindx  E4AF 35   82                 puls   a,pc                                          *                     * Switch users                     *   X - Task entry for new task                     *  E4B1 35   20       swtchu    puls   y         get return address  E4B3 BF   0407               stx    utask     set up new running task  E4B6 10EE 88 14              lds    umark0,x  reset stack  E4BA 6E   A4                 jmp    0,y       return to caller                     Task       Structure                 16:33:51  Jan 23, 2026   Page   48Scheduler  routines                                                                           *                     * makrdy                     *                     * Make a task ready to run.  Enter with x                     * pointing to task table entry.  If new tasks                     * priority is higher than current, set the                     * 'chproc' flag so the system can change tasks.                     *                       E4BC 86   01       makrdy    lda    #TRUN     set status  E4BE A7   04                 sta    tsstat,x  E4C0 CC   0000               ldd    #0        clear events flag  E4C3 ED   06                 std    tsevnt,x                     *  E4C5 39            makrd6    rts              returnTask       Structure                 16:33:52  Jan 23, 2026   Page   49Sleep      and Wakeup routines                                                                *                     * wakeup                     *                     * Wakeup all tasks waiting the event designated                     * in the y register.  The x reg is preserved.                     *                       E4C6 34   57       wakeup    pshs   cc,d,x,u  save registers  E4C8                         seti   mask      interupts  E4C8 1A   50                 orcc   #FF|IF                               endm  E4CA CE   0403               ldu    #slplst  E4CD AE   42                 ldx    tsslnk,u  point to sleep list  E4CF 27   0B                 beq    wakeu4                     *  E4D1 10AC 06       wakeu2    cmpy   tsevnt,x  check event  E4D4 27   08                 beq    wakeu5  E4D6 33   84                 leau   0,x       mark this entry                     *  E4D8 AE   02       wakeu3    ldx    tsslnk,x  follow chain  E4DA 26   F5                 bne    wakeu2    end of list?                     *  E4DC 35   D7       wakeu4    puls   cc,d,x,u,pc return                     *  E4DE 34   70       wakeu5    pshs   x,y,u     save registers  E4E0 EC   02                 ldd    tsslnk,x  remove from list  E4E2 ED   42                 std    tsslnk,u  E4E4 8D   D6                 bsr    makrdy    put on ready list  E4E6 35   70                 puls   u,x,y  E4E8 20   EE                 bra    wakeu3    repeat                     Task       Structure                 16:33:52  Jan 23, 2026   Page   50Sleep      and Wakeup routines                                                                *                     * sleep                     *                     * Sleep will put this task to sleep with priority                     * specified in the b register.  On entry, y is pointing                     * to the event which will be awakened.                     *  E4EA 34   51       sleep     pshs   cc,x,u    save registers  E4EC BE   0407               ldx    utask     point to task  E4EF 6D   08                 tst    tssgnl,x  any signals waiting?  E4F1 26   1F                 bne    sleep7                     *  E4F3                         seti   mask      ints  E4F3 1A   50                 orcc   #FF|IF                               endm  E4F5 E7   05                 stb    tsprir,x  set priority  E4F7 10AF 06                 sty    tsevnt,x  set event  E4FA 86   02                 lda    #TSLEEP   set status  E4FC A7   04                 sta    tsstat,x  E4FE FC   0405               ldd    slplst+tsslnk get head of list  E501 ED   02                 std    tsslnk,x  set new link  E503 BF   0405               stx    slplst+tsslnk set new head  E506 17   FF74               lbsr   rsched    reschedule cpu                       E509 BE   0407     20        ldx    utask     get task entry  E50C 6D   08                 tst    tssgnl,x  any signals waiting?  E50E 26   02                 bne    sleep7                     *  E510 35   D1                 puls   cc,x,u,pc return                     *  E512 BE   0407     sleep7    ldx    utask     reset signal  E515 6F   08                 clr    tssgnl,x  E517 EC   88 16              ldd    umark1,x  stack reset point  E51A 35   51                 puls   cc,x,u    reset cc and registers  E51C 1F   04                 tfr    d,s       change stacks  E51E 39                      rts              returnTask       Structure                 16:33:52  Jan 23, 2026   Page   51Sleep      and Wakeup routines                                                                *                     * xmtint - Send an interrupt to a task                     *  X - Task entry                     *  B - signal#                     *  jsr xmtint                     *  E51F 34   76       xmtint    pshs   d,x,y,u   save registers  E521 A6   04                 lda    tsstat,x  get task state  E523 81   01                 cmpa   #TRUN     running?  E525 26   04                 bne    10f       no - try something else                     *  E527 E7   08                 stb    tssgnl,x  set signal  E529 20   0C                 bra    99f       exit                     *  E52B 81   02       10        cmpa   #TSLEEP   task sleeping?  E52D 26   08                 bne    99f       no - can't send interrupt                     *  E52F E7   08                 stb    tssgnl,x  set signal  E531 10AE 06                 ldy    tsevnt,x  wake task up >E534 17   FF8F               lbsr   wakeup                     *  E537 35   F6       99        puls   d,x,y,u,pc returnTask       Structure                 16:33:52  Jan 23, 2026   Page   52Sleep      and Wakeup routines                                                                *                     * the routines in this file are specific                     * for the W5500 socket device                     * they are called from "wskhan" and "wskdrv" files                     *                     * wzsocket device table                     *  E539               DEV_SOCK  E539 E3BF                    fdb    bad_cmd   0  E53B E641                    fdb    skopen    S_OPEN    1 open socket  E53D E6E6                    fdb    skclos    S_CLOSE   2 close socket  E53F E939                    fdb    skreqwr   S_RQWR    3 request write to socket  E541 E99C                    fdb    sksend    S_SEND    4 write data to socket  E543 E890                    fdb    skreqrd   S_RQRD    5 request read data from socket  E545 E8F6                    fdb    skrecv    S_RECV    6 read data from socket  E547 E6E6                    fdb    skintrp   S_INTRPT  7 interrupt socket  E549 E733                    fdb    skconn    S_CONNECT 8 connect socket  E54B E7C3                    fdb    skbind    S_BIND    9 bind socket  E54D E814                    fdb    sklist    S_LISTEN  10 listen on socket  E54F E84F                    fdb    skacpt    S_ACCEPT  11 accept connection  E551 ED1B                    fdb    skdisc    S_DISCON  12 disconnect socket  E553 ED1B                    fdb    sksmac    S_SNDMAC  13 send mac  E555 ED1B                    fdb    skskep    S_SNDKEP  14 send keep alive  E557 EC54                    fdb    skspcl    S_SPCL    15 special command  E559 E9DE                    fdb    skurrdf   S_RRDFRM  16 request read readfrom  E55B EA63                    fdb    skurrd    S_RREAD   17 read data readfrom  E55D EA91                    fdb    skurwt    S_WRQSTO  18 request write sendto  E55F EB1C                    fdb    skusnt    S_WSNDTO  19 write data sendto  E561 EAD5                    fdb    skusnm    S_WSNDTM  20 write data send more  E563 E599                    fdb    sknone    21  E565 E599                    fdb    sknone    22  E567 E599                    fdb    sknone    23  E569 EBEA                    fdb    sknbsr    S_RQSBLK  24 netblock req send ext block  E56B EC24                    fdb    sknbsd    S_SNDBLK  25 netblock send ext block  E56D EB56                    fdb    sknbrr    S_RQRBLK  26 netblock req read ext block  E56F EBBB                    fdb    sknbrd    S_RDRBLK  27 netblock read ext block  E571 E599                    fdb    sknone    28  E573 E599                    fdb    sknone    29  E575 F40A                    fdb    netboot   30 network boot  E577 F3F2                    fdb    memp2ff   31 copy memory page to fifo                     *                     *                     *               0020  MAX_FCMD  equ    (*-DEV_SOCK)/2 max commands supported                     * should match the number of D_funcXX in nwp_devtab.h                     *  E579 E5F3                    fdb    skinthan  16 socket interrupt handler  E57B E57F                    fdb    skinit    17 socket initialization  E57D E5F0                    fdb    sktest    18 test device present                     *                     *Task       Structure                 16:33:53  Jan 23, 2026   Page   53wz socket interface routines                                             * this file contains all socket handlers                     *                     * when a wzsocket is opened, all locations are effectively                     * cleared to zero, with exception of the enumeration byte                     *                                    0200  BUFSIZ    equ    512       fifo and system buffer size                                          *                     * do everything to init the system                     *               E57F  skinit    equ    *  E57F BD   ED22               jsr    spinit    set SPI  E582 C6   82                 ldb    #%10000010 software reset + force ARP  E584 BD   EDF3               jsr    PCRMR  E587 BD   EDE4     01        jsr    GCRMR  E58A 5D                      tstb  E58B 2B   FA                 bmi    01b                     *  E58D C6   78                 ldb    #%01111000 power up  E58F BD   EFD1               jsr    PCRPHY    set the PHY part  E592 CC   8000               ldd    #32768  E595 FD   0459               std    wzanyp    set value for Source port  E598 39                      rts                                          *                     * sknone, return error, not implemented                     *  E599 C6   81       sknone    ldb    #E_BADCMD  E59B 39                      rts                                          *                     * check if ROM locations are preset, if not skip this here                     * else setup device with provided values                     *  E59C 108E E000     skdvini   ldy    #wzifma   where mac address is to be found  E5A0 EC   A1       03        ldd    0,y++  E5A2 1083 FFFF               cmpd   #$ffff    not set  E5A6 26   07                 bne    02f  E5A8 108C E012               cmpy   #wzifga+4 past area  E5AC 25   F2                 blo    03b                     * ROM not initialized, do nothing  E5AE 39                      rts                                          *                     * values present, setup device                     *  E5AF 34   66       02        pshs   d,y,u  E5B1 DE   1A                 ldu    fifo_us1  E5B3 108E E006               ldy    #wzifip   source IP  E5B7 EC   A1                 ldd    0,y++  E5B9 ED   C1                 std    0,u++Task       Structure                 16:33:53  Jan 23, 2026   Page   54wz socket interface routines                          E5BB EC   A1                 ldd    0,y++  E5BD ED   C1                 std    0,u++  E5BF 108E E00A               ldy    #wzifnm   netmask  E5C3 EC   A1                 ldd    0,y++  E5C5 ED   C1                 std    0,u++  E5C7 EC   A1                 ldd    0,y++  E5C9 ED   C1                 std    0,u++  E5CB 108E E00E               ldy    #wzifga   gateway ip  E5CF EC   A1                 ldd    0,y++  E5D1 ED   C1                 std    0,u++  E5D3 EC   A1                 ldd    0,y++  E5D5 ED   C1                 std    0,u++  E5D7 108E E000               ldy    #wzifma   mac address  E5DB EC   A1                 ldd    0,y++  E5DD ED   C1                 std    0,u++  E5DF EC   A1                 ldd    0,y++  E5E1 ED   C1                 std    0,u++  E5E3 EC   A1                 ldd    0,y++  E5E5 ED   C1                 std    0,u++                     *  E5E7 C6   FF                 ldb    #$ff      set active  E5E9 E7   C4                 stb    0,u  E5EB BD   EC86               jsr    wzwdev    init device with settings  E5EE 35   E6                 puls   d,y,u,pc                                          *                     * test if device is present                     *  E5F0 1A   01       sktest    sec              yes  E5F2 39                      rts                                          *                     * skinthan, fromddevice table                     *               E5F3  skinthan  equ    *  E5F3 39                      rts                                          *                     * device signal handle, from master                     *               E5F4  sdev_sig  equ    *  E5F4 C6   07                 ldb    #R_INTRPT we saw it  E5F6 39                      rts                                          *                     * get a new source port                     *  E5F7 FC   0459     sknewp    ldd    wzanyp    else create one  E5FA                         incd  E5FA 104C                    fdb    $104c                               endm  E5FC 1083 FFF0               cmpd   #$FFF0Task       Structure                 16:33:53  Jan 23, 2026   Page   55wz socket interface routines                          E600 25   03                 blo    03f  E602 CC   8000               ldd    #$8000  E605 FD   0459     03        std    wzanyp  E608 39                      rts                                                               *                     * check if W5500 is active                     * wzdevt, device test, return Z if running, NZ if not                     *  E609 34   22       wzdevt    pshs   a,y  E60B 109E 1A                 ldy    fifo_us1  device info  E60E A6   A8 12              lda    wzdsta,y  E611 81   FF                 cmpa   #$ff      open  E613 35   A2                 puls   a,y,pc                                          *                     * U=wzsock, originally in OS address range                     * convert it to Network CPU range                     * skfres, socket restore info, set E register                     *  E615 1E   30       skfres    exg    u,d  E617 84   03                 anda   #%00000011 i.e EA20 -> 0220  E619 1E   03                 exg    d,u  E61B A6   C4                 lda    wzenum,u  socket #, is remembered  E61D                         trfr   A,E  E61D 1F                      fcb    $1f  E61E 8E                      fcb    A<<4|E                               endm  E61F 6F   47                 clr    wzerr,u   init result  E621 39                      rts                                          *                     * skctcp, check if in TCP mode                     * return zero if in TCP mode, non-zero if not                     * U = wzsock                     *  E622 34   06       skctcp    pshs   d  E624 EC   C8 26              ldd    wztype,u  SOCK_STREAM  E627 C1   01                 cmpb   #SK_STRM  is TCP  E629 35   86                 puls   d,pc                                          *                     * skcudp, check if in UDP  mode                     * return zero if in UDP mode, non-zero if not                     * U = wzsock                     *  E62B 34   06       skcudp    pshs   d  E62D EC   C8 26              ldd    wztype,u  SOCK_DGRAM  E630 C1   02                 cmpb   #SK_DGRM  is UDP  E632 27   02                 beq    01f  E634 C1   04                 cmpb   #SK_IRAW  also allowedTask       Structure                 16:33:54  Jan 23, 2026   Page   56wz socket interface routines                          E636 35   86       01        puls   d,pc                                          *                     * skraw, check if in RAW mode                     * return zero if in RAW mode, non-zero if not                     * U = wzsock                     *  E638 34   06       skcraw    pshs   d  E63A EC   C8 26              ldd    wztype,u  SOCK_DGRAM  E63D C1   03                 cmpb   #SK_MRAW  is RAW socket  E63F 35   86                 puls   d,pc                                          ****************************************************************                     *                     * here the socket is opened                     * X hold the TASK table                     * U holds the sock address                     *               E641  skopen    equ    * >E641 BD   E615               jsr    skfres                     *                     * check if DEVICE is active                     * >E644 BD   E609               jsr    wzdevt  E647 27   06                 beq    11f  E649 BD   E701               jsr    skclin    NO, close internal and don't start >E64C 16   0069     04        lbra   skoper1                     *                     * retry, we do all things                     *  E64F A6   42       11        lda    wzfsta,u  check if allocated by OS  E651 2A   F9                 bpl    04b       error, do nothing                     *                     * check socket() call arguments                     *  E653 6F   43                 clr    wzflg,u   erase flags  E655 6F   41                 clr    wzdctr,u  init counter  E657 EC   C8 24              ldd    wzfaml,u  E65A C1   02                 cmpb   #AF_INET  E65C 26   EE                 bne    04b       not supported                     * wztype holds socket type AND socket flags (hibyte)  E65E EC   C8 26              ldd    wztype,u  E661 C1   01                 cmpb   #SK_STRM  SOCK_STREAM  E663 27   22                 beq    01f  E665 C1   02                 cmpb   #SK_DGRM  SOCK_DGRAM  E667 27   1A                 beq    21f                     *        cmpb    #SK_MRAW        SOCK_RAW                     *        beq     41f  E669 C1   04                 cmpb   #SK_IRAW  IP_RAW  E66B 26   4F                 bne    skoper2                     *                     * raw IP socket, set protocol register firstTask       Structure                 16:33:54  Jan 23, 2026   Page   57wz socket interface routines                                             * UDP and TCP are handled in a different way                     *  E66D EC   C8 28              ldd    wzprot,u  what is the protocol option?  E670 C1   06                 cmpb   #SP_TCP   not allowed  E672 27   48                 beq    skoper2  E674 C1   11                 cmpb   #SP_UDP   not allowed  E676 27   44                 beq    skoper2  E678 BD   F134               jsr    PSRPROT   set protocol register                     *  E67B C6   03                 ldb    #%00000011 IPRAW  E67D 20   0A                 bra    07f                     * nacraw  E67F C6   04       41        ldb    #%00000100 MACRAW  E681 20   06                 bra    07f                     * dgram  E683 C6   02       21        ldb    #%00000010 UDP  E685 20   02                 bra    07f                     * TCP socket  E687 C6   01       01        ldb    #%00000001 TCP set source port in connect                     *                     * set socket mode register                     *  E689 BD   EFFE     07        jsr    PSRMR     set socket mode register                     *                     * here do the real OPEN,                     *  E68C C6   01                 ldb    #WCOPEN   open the device  E68E E7   44                 stb    wzcmnd,u  copy command  E690 BD   F01C               jsr    PSRCR  E693 108E 0000               ldy    #0        nopoll                     *                     * interrupts not expected                     *               E697  skowfo    equ    *  E697 BD   E615               jsr    skfres    reset important info  E69A BD   F050     21        jsr    GSRSR     get status  E69D E7   45                 stb    wzstat,u  E69F C1   00                 cmpb   #WSCLSD   not closed?  E6A1 26   0B                 bne    22f                     *  E6A3 6A   41                 dec    wzdctr,u  delay counter  E6A5 27   15                 beq    skoper2  E6A7 108E E697               ldy    #skowfo  E6AB 7E   E7A4               jmp    polext    switch tasks                     *  E6AE A6   42       22        lda    wzfsta,u  mark bind is needed  E6B0 8A   40                 ora    #WZWBND  E6B2 A7   42                 sta    wzfsta,u  E6B4 4F                      clra  E6B5 C6   01                 ldb    #R_OPEN   response  E6B7 39            99        rts                     *Task       Structure                 16:33:54  Jan 23, 2026   Page   58wz socket interface routines                          E6B8 86   01       skoper1   lda    #1        device not initialized  E6BA 20   02                 bra    12f  E6BC 86   02       skoper2   lda    #2        type error  E6BE C6   C0       12        ldb    #E_SOCKET  E6C0 20   F5                 bra    99b                                          *                     * convert number in bit position                     * B = enum, B=bit                     *  E6C2 34   10       num2bt    pshs   x  E6C4 8E   E6DD               ldx    #bittab  E6C7 3A                      abx  E6C8 E6   84                 ldb    0,x  E6CA 35   90                 puls   x,pc                                          *                     * bit to nummer, offset byt one, entry should NOT be 0                     *  E6CC 34   10       bt2num    pshs   x  E6CE 8E   E6DD               ldx    #bittab  E6D1 6F   E2                 clr    0,-s  E6D3 E1   80       02        cmpb   0,x+  E6D5 27   04                 beq    01f  E6D7 6C   E4                 inc    0,s  E6D9 20   F8                 bra    02b  E6DB 35   94       01        puls   b,x,pc                                          * table  E6DD 00            bittab    fcb    0  E6DE 01 02 04 08             fcb    %00000001,%00000010,%00000100,%00001000  E6E2 10 20 40 80             fcb    %00010000,%00100000,%01000000,%10000000                                                               ***************************************************************                     *                     * close the socket and clean up                     * X hold the task table                     * U holds the sock address                     *               E6E6  skclos    equ    *               E6E6  skintrp   equ    *         interrupt!  E6E6 BD   E615               jsr    skfres  E6E9 C6   08                 ldb    #WCDISC  E6EB E7   44                 stb    wzcmnd,u  E6ED BD   F01C               jsr    PSRCR     send disconnect                     *  E6F0 8D   0F                 bsr    skclin    internal close  E6F2                         clrd  E6F2 104F                    fdb    $104f                               endm  E6F4 ED   C8 24              std    wzfaml,uTask       Structure                 16:33:55  Jan 23, 2026   Page   59wz socket interface routines                          E6F7 ED   C8 26              std    wztype,u  E6FA ED   C8 28              std    wzprot,u                     *  E6FD 4F                      clra  E6FE C6   02                 ldb    #R_CLOSE  response  E700 39                      rts                                          *                     * wzclin, close interal                     *  E701 34   06       skclin    pshs   d  E703 C6   10                 ldb    #WCCLOS   do close  E705 E7   44                 stb    wzcmnd,u  E707 BD   F01C               jsr    PSRCR                     *                     * erase registers in device                     *  E70A CC   0000               ldd    #0  E70D BD   F06E               jsr    PSRPORT   source port                     *  E710 A6   42                 lda    wzfsta,u  E712 84   00                 anda   #0        mask (?)  E714 A7   42                 sta    wzfsta,u  E716 CC   0000               ldd    #0  E719 ED   48                 std    wzxfer,u  clear remaining size                     *  E71B BD   F050     91        jsr    GSRSR  E71E E7   45                 stb    wzstat,u  stat = 0 (closed)                     *  E720 CC   0000               ldd    #0  E723 ED   C8 10              std    wzsprt,u  erase old info  E726 ED   C8 14              std    wzipad,u  E729 ED   C8 16              std    wzipad+2,u  E72C ED   C8 12              std    wzdprt,u  E72F E7   43                 stb    wzflg,u   clear flags                     *  E731 35   86                 puls   d,pc                                          ***************************************************************                     *                     * connect socket                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E733  skconn    equ    *  E733 BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E736 BD   E609               jsr    wzdevt  E739 27   06                 beq    01fTask       Structure                 16:33:55  Jan 23, 2026   Page   60wz socket interface routines                         >E73B BD   E6E6               jsr    skclos    NO, don't start >E73E 16   007C     02        lbra   skcner4  E741 BD   E622     01        jsr    skctcp    not in tcp, illegal  E744 26   F8                 bne    02b                     *                     * check if socket has been set up                     *  E746 BD   F050     11        jsr    GSRSR     status  E749 E7   45                 stb    wzstat,u  check if properly setup  E74B C1   13                 cmpb   #WSINIT   SHOULD BE >E74D 1026 0060               lbne   skcner6                     *                     * check the info from the connect call                     *  E751 EC   C8 14              ldd    wzipad,u  check if dest IP == null  E754                         ordx   wzipad+2,IU  E754 10AA                    fdb    $10aa  E756                         doindx wzipad+2,IU  E756 C8 16                   fcb    $88+(IU<<5),(wzipad+2&$7f)                               endm                               endm  E758 27   5F                 beq    skcner1   IP address == NULL                     * IP address = 0000  E75A EC   C8 14              ldd    wzipad,u  or FFFFFFFF  E75D                         incd  E75D 104C                    fdb    $104c                               endm  E75F 26   07                 bne    01f  E761 EC   C8 16              ldd    wzipad+2,u  E764                         incd  E764 104C                    fdb    $104c                               endm  E766 27   51                 beq    skcner1   IP address = FFFFFFFF                     *                     * valid IP                     *  E768 EC   C8 12    01        ldd    wzdprt,u  check destination port  E76B 27   48                 beq    skcner5   is not set, error                     *  E76D BD   F0F8               jsr    PSRDPOR   set destination port  E770 31   C8 14              leay   wzipad,u  load socket  E773 BD   F0D2               jsr    PSRDIP    set destination IP                     *                     * source port, create one, always unique                     *  E776 BD   E5F7               jsr    sknewp    get new  E779 ED   C8 10              std    wzsprt,u  tell us what you took  E77C BD   F06E               jsr    PSRPORT   source port                     *                     * do the CONNECT here                     *  E77F C6   04                 ldb    #WCCONNTask       Structure                 16:33:55  Jan 23, 2026   Page   61wz socket interface routines                          E781 E7   44                 stb    wzcmnd,u  E783 BD   F01C               jsr    PSRCR     do connect                     *                     *                     *  E786 BD   E615     conlb1    jsr    skfres  E789 BD   F050               jsr    GSRSR     update status  E78C E7   45                 stb    wzstat,u  E78E C1   17                 cmpb   #WSESTB  E790 27   0E                 beq    90f  E792 C1   00                 cmpb   #WSCLSD   is closed?  E794 27   17                 beq    skcner2  E796 C1   1C                 cmpb   #WSCLWT   close wait?  E798 27   13                 beq    skcner2  E79A 108E E786               ldy    #conlb1  E79E 20   04                 bra    polext                     *  E7A0 4F            90        clra  E7A1 C6   08                 ldb    #R_CONNECT  E7A3 39            99        rts                                          *                     * polexit, Y=where to return                     *  E7A4 10AF 88 10    polext    sty    tsagin,x  here to restart  E7A8 108E FFFF               ldy    #$ffFF  E7AC 39                      rts                       E7AD C6   0C       skcner2   ldb    #R_DISCON  E7AF 20   F2                 bra    99b                       E7B1               skcner6  E7B1 86   0F                 lda    #15       not properly setup  E7B3 20   0A                 bra    09f  E7B5 86   0E       skcner5   lda    #14       destination port not set  E7B7 20   06                 bra    09f  E7B9 86   0B       skcner1   lda    #11       IP address invalid  E7BB 20   02                 bra    09f  E7BD 86   01       skcner4   lda    #1        device not initialized  E7BF C6   C0       09        ldb    #E_SOCKET  E7C1 20   E0                 bra    99b                                          ***************************************************************                     *                     * bind request                     * X hold the task table                     * U holds the sock address                     * bindt() call fills in info in the sock structure                     *               E7C3  skbind    equ    *  E7C3 BD   E615               jsr    skfres                     *Task       Structure                 16:33:56  Jan 23, 2026   Page   62wz socket interface routines                                             * is the DEVICE (still) active                     *  E7C6 BD   E609               jsr    wzdevt  E7C9 1026 0124               lbne   rdrqer1  E7CD BD   E622               jsr    skctcp    check TCP  E7D0 27   07                 beq    01f  E7D2 BD   E62B               jsr    skcudp    check UDP >E7D5 1026 FFD8               lbne   skcner6  E7D9               01                     *                     * go on , the bind() call sets wzipad and wzsprt, this is for                     * a server, for a client it needs to set wzdprt                     * for as server IP is local, for a client IP is remote                     *                     *  E7D9 BD   F050               jsr    GSRSR     status  E7DC E7   45                 stb    wzstat,u  E7DE C1   22                 cmpb   #WSUDP    check  E7E0 27   25                 beq    03f  E7E2 C1   13                 cmpb   #WSINIT   should be >E7E4 1026 FFC9     04        lbne   skcner6                     *                     * set the network connection data                     *  E7E8 BD   E5F7               jsr    sknewp  E7EB ED   C8 12              std    wzdprt,u  E7EE BD   F0F8               jsr    PSRDPOR   destination port  E7F1 EC   C8 10              ldd    wzsprt,u  E7F4 BD   F06E     04        jsr    PSRPORT   source port                     *  E7F7 31   C8 14              leay   wzipad,u  E7FA BD   F0D2               jsr    PSRDIP    source IP                     *  E7FD A6   42                 lda    wzfsta,u  we did BIND  E7FF 84   BF                 anda   #255-WZWBND  E801 A7   42                 sta    wzfsta,u  E803 4F                      clra  E804 C6   09                 ldb    #R_BIND  E806 39                      rts                     *  E807 EC   C8 10    03        ldd    wzsprt,u  if set, keep it  E80A 26   E8                 bne    04b  E80C BD   E5F7               jsr    sknewp    make new  E80F ED   C8 10              std    wzsprt,u  E812 20   E0                 bra    04b                                                               ***************************************************************                     *                     * listen request                     * X hold the task table                     * U holds the sock addressTask       Structure                 16:33:56  Jan 23, 2026   Page   63wz socket interface routines                                             * listen() call waits for peer to connect                     *               E814  sklist    equ    *  E814 BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E817 BD   E609               jsr    wzdevt  E81A 1026 00D3     02        lbne   rdrqer1  E81E BD   E622               jsr    skctcp  E821 26   F7                 bne    02b                     *                     * go on                     *                     *  E823 BD   F050               jsr    GSRSR     status  E826 E7   45                 stb    wzstat,u                     *  E828 C1   00                 cmpb   #WSCLSD   closed?  E82A 27   19                 beq    80f  E82C C1   1C                 cmpb   #WSCLWT   close wait?  E82E 27   15                 beq    80f  E830 C1   13                 cmpb   #WSINIT   opened  E832 26   14                 bne    90f                     *  E834 A6   42                 lda    wzfsta,u  did we BIND  E836 85   40                 bita   #WZWBND  E838 26   0B                 bne    80f       no, error                     *  E83A C6   02                 ldb    #WCLIST  E83C E7   44                 stb    wzcmnd,u  E83E BD   F01C               jsr    PSRCR                     *  E841 4F                      clra  E842 C6   0A                 ldb    #R_LISTEN  E844 39                      rts                                          * Go close and tidy up  E845 7E   E6E6     80        jmp    skclos                     *  E848 108E E814     90        ldy    #sklist  E84C 7E   E7A4               jmp    polext                                          ***************************************************************                     *                     * accept request                     * X hold the task table                     * U holds the sock address                     * listen() call waits for peer to connect                     *               E84F  skacpt    equ    *  E84F BD   E615               jsr    skfresTask       Structure                 16:33:56  Jan 23, 2026   Page   64wz socket interface routines                                             *                     * is the DEVICE (still) active                     *  E852 BD   E609               jsr    wzdevt  E855 1026 0098     02        lbne   rdrqer1  E859 BD   E622               jsr    skctcp  E85C 26   F7                 bne    02b       wrong mode                     *                     * go on                     *  E85E BD   F050               jsr    GSRSR     status  E861 E7   45                 stb    wzstat,u  E863 C1   17                 cmpb   #WSESTB   connected  E865 26   16                 bne    01f                     *  E867 A6   42                 lda    wzfsta,u  did we BIND  E869 85   40                 bita   #WZWBND  E86B 26   18                 bne    03f       no, error                     *  E86D BD   F0E9               jsr    GSRDPOR   fill in peer port  E870 ED   C8 12              std    wzdprt,u  E873 31   C8 14              leay   wzipad,u  E876 BD   F0BB               jsr    GSRDIP                     *  E879 4F                      clra  E87A C6   0B                 ldb    #R_ACCEPT  E87C 39                      rts                     *  E87D C1   00       01        cmpb   #WSCLSD  E87F 27   04                 beq    03f  E881 C1   1C                 cmpb   #WSCLWT  E883 26   04                 bne    02f  E885 4F            03        clra                     * go close and tidy up  E886 7E   E6E6               jmp    skclos                     *  E889 108E E84F     02        ldy    #skacpt  E88D 7E   E7A4               jmp    polext                                                               ***************************************************************                     *                     * read request  TCP only !!                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E890  skreqrd   equ    *  E890 BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *Task       Structure                 16:33:57  Jan 23, 2026   Page   65wz socket interface routines                          E893 BD   E609               jsr    wzdevt >E896 1026 0057     02        lbne   rdrqer1  E89A BD   E622               jsr    skctcp    check TCP  E89D 26   F7                 bne    02b                     *                     * go on                     *  E89F BD   F050               jsr    GSRSR  E8A2 E7   45                 stb    wzstat,u  update status  E8A4 C1   17                 cmpb   #WSESTB   connection active?  E8A6 26   0B                 bne    82f                     * check data available  E8A8 BD   F207               jsr    GSRRXRS   data available?  E8AB ED   48                 std    wzxfer,u  E8AD 27   21                 beq    85f                     * data present  E8AF 4F            87        clra  E8B0 C6   05                 ldb    #R_RQRD  E8B2 39                      rts                     * not established  E8B3 E6   45       82        ldb    wzstat,u  E8B5 C1   00                 cmpb   #WSCLSD   closed?  E8B7 26   22                 bne    84f       (85f)241128                     * close socket and return  E8B9 EC   C8 26    81        ldd    wztype,u  E8BC 85   04                 bita   #WFSHNGC  E8BE 27   04                 beq    71f  E8C0 C6   01                 ldb    #HANGS  E8C2 20   06                 bra    72f  E8C4 85   02       71        bita   #WFSPOC  E8C6 27   05                 beq    70f       no signal  E8C8 C6   06                 ldb    #PIPES  E8CA BD   E45A     72        jsr    send_SI   send to main CPU                     * close and tidy up  E8CD 7E   E6E6     70        jmp    skclos    !!##                     * established but no data yet || not established and not closed  E8D0 EC   C8 26    85        ldd    wztype,u  check flags  E8D3 85   01                 bita   #WFNBLK   non block  E8D5 27   04                 beq    84f                     * non block ************************  E8D7 4F                      clra  E8D8 C6   15                 ldb    #R_RQRDNB tell no data  E8DA 39                      rts                     *  E8DB E6   45       84        ldb    wzstat,u  E8DD C1   1C                 cmpb   #WSCLWT   last attempt  E8DF 26   09                 bne    86f       go poll                     * close wait active  E8E1 BD   F207               jsr    GSRRXRS  E8E4 ED   48                 std    wzxfer,u  E8E6 26   C7                 bne    87b       last data  E8E8 20   CF                 bra    81b       closeTask       Structure                 16:33:57  Jan 23, 2026   Page   66wz socket interface routines                                             *  E8EA 108E E890     86        ldy    #skreqrd  E8EE 7E   E7A4               jmp    polext                                          *                     * error in socket status  E8F1 86   82       rdrqer1   lda    #130  E8F3 C6   C0                 ldb    #E_SOCKET  E8F5 39                      rts                                          ***************************************************************                     *                     * get the data  U=wzsock, X=task struct                     *               E8F6  skrecv    equ    *  E8F6 BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E8F9 BD   E609               jsr    wzdevt >E8FC 1026 FFF1               lbne   rdrqer1  E900 BD   E622     02        jsr    skctcp  E903 26   FB                 bne    02b                     *                     * we got info that data is present, get it                     * if here the main CPU already locked the fifo for us                     * on return D= xfreed count                     *  E905 BD   F207               jsr    GSRRXRS   received size                     * D total aviable data  E908 108E 0020               ldy    #fifo     target  E90C BD   F2D7               jsr    RDSK2FB   transfer datat to fifo  E90F ED   48                 std    wzxfer,u  save it                     *                     * here check if PROT_XLTEOF is set                     *  E911 6D   C8 28              tst    wzprot,u  PROT_XLTEOL is $8000  E914 2A   18                 bpl    01f                     *                     * do EOL conversion in fifo buffer                     *  E916 34   36                 pshs   d,x,y  E918 1F   01                 tfr    d,x       count  E91A 108E 0020               ldy    #fifo  E91E A6   A4       03        lda    0,y  E920 81   0A                 cmpa   #LF       is line feed  E922 26   02                 bne    02f  E924 86   0D                 lda    #CR       make it Return  E926 A7   A0       02        sta    0,y+  E928 30   1F                 leax   -1,x      count  E92A 26   F2                 bne    03b  E92C 35   36                 puls   d,x,yTask       Structure                 16:33:57  Jan 23, 2026   Page   67wz socket interface routines                                             *                     *                     *  E92E C6   40       01        ldb    #WCRECV  E930 E7   44                 stb    wzcmnd,u  E932 BD   F01C               jsr    PSRCR     tell sender we took it                       E935 C6   06                 ldb    #R_READ   tell data in fifo  E937 4F                      clra  E938 39                      rts                                          ***************************************************************                     *                     * write request                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E939  skreqwr   equ    *  E939 BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E93C BD   E609               jsr    wzdevt >E93F 1026 FFAE     02        lbne   rdrqer1  E943 BD   E622               jsr    skctcp  E946 26   F7                 bne    02b                     *                     * go on                     *  E948 BD   F050               jsr    GSRSR  E94B E7   45                 stb    wzstat,u  update status  E94D C1   17                 cmpb   #WSESTB  E94F 26   0C                 bne    82f                     * connection active  E951 BD   F1BB     83        jsr    GSRTXFR   free size (remaining)  E954 10A3 4A                 cmpd   wzrqln,u  would it fit  E957 25   21                 blo    85f                     * data space is enough  E959 4F            88        clra  E95A C6   03                 ldb    #R_RQWR  E95C 39                      rts                     * not established  E95D E6   45       82        ldb    wzstat,u  E95F C1   00                 cmpb   #WSCLSD  E961 26   17                 bne    85f                     * close socket and return  E963 EC   C8 26    89        ldd    wztype,u  E966 85   04                 bita   #WFSHNGC  E968 27   04                 beq    71f  E96A C6   01                 ldb    #HANGS  E96C 20   06                 bra    72fTask       Structure                 16:33:58  Jan 23, 2026   Page   68wz socket interface routines                          E96E 85   02       71        bita   #WFSPOC  E970 27   05                 beq    70f       no signal  E972 C6   06                 ldb    #PIPES  E974 BD   E45A     72        jsr    send_SI   send to main CPU                     * close and tidy up  E977 7E   E6E6     70        jmp    skclos    !!##                     *  E97A EC   C8 26    85        ldd    wztype,u  E97D 85   01                 bita   #WFNBLK  E97F 27   04                 beq    86f                     * data space exhausted, would block  E981 4F                      clra  E982 C6   13                 ldb    #R_RQWRNB  E984 39                      rts                     * not closed  E985 E6   45       86        ldb    wzstat,u  E987 C1   1C                 cmpb   #WSCLWT   try data  E989 26   0A                 bne    87f                     *  E98B BD   F1BB               jsr    GSRTXFR   free size (remaining)  E98E 10A3 4A                 cmpd   wzrqln,u  would it fit  E991 24   C6                 bhs    88b  E993 20   CE                 bra    89b                     *  E995 108E E939     87        ldy    #skreqwr  E999 7E   E7A4               jmp    polext                                          ***************************************************************                     *                     * write request                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E99C  sksend    equ    *  E99C BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E99F BD   E609               jsr    wzdevt  E9A2 1026 FF4B     02        lbne   rdrqer1  E9A6 BD   E622               jsr    skctcp  E9A9 26   F7                 bne    02b                     *                     * we got info that data is present, get it                     * if here the main CPU already locked the fifo for us                     * on return D= xfreed count                     *  E9AB EC   4A                 ldd    wzrqln,u  data to xfer                     * D = total available space  E9AD 6D   C8 28              tst    wzprot,u  check if PROT_XLTEOL is set  E9B0 2A   18                 bpl    01fTask       Structure                 16:33:58  Jan 23, 2026   Page   69wz socket interface routines                                             *                     *  do EOL conversion in fifo buffer                     *  E9B2 34   36                 pshs   d,x,y  E9B4 1F   01                 tfr    d,x       count  E9B6 108E 0020               ldy    #fifo  E9BA A6   A4       03        lda    0,y  E9BC 81   0D                 cmpa   #CR       Return?  E9BE 26   02                 bne    02f  E9C0 86   0A                 lda    #LF       make it Line feed  E9C2 A7   A0       02        sta    0,y+  E9C4 30   1F                 leax   -1,x      count  E9C6 26   F2                 bne    03b  E9C8 35   36                 puls   d,x,y                     *                     *                     *  E9CA 108E 0020     01        ldy    #fifo     target  E9CE BD   F325               jsr    WRFB2SK   transfer from fifo to socket  E9D1 ED   48                 std    wzxfer,u  save it  E9D3 C6   20                 ldb    #WCSEND  E9D5 E7   44                 stb    wzcmnd,u  E9D7 BD   F01C               jsr    PSRCR     tell sender it is coming                       E9DA C6   04                 ldb    #R_WRITE  tell data in fifo  E9DC 4F                      clra  E9DD 39                      rts                                          ***************************************************************                     * skurrdf, request readfrom                     *                     *                     * X hold the task table                     * U holds the sock address                     *                     * UDP type transfers have diffent W5500 buffer layouts for receive                     *                     * pure UDP  (WSUDP) returns                     *                     *  [sender-IP][sender-Port][data-len][data.............]                     *                     * IPRAW (WSIRAW) returns                     *                     *  [senser-IP][data-len][data.................]                     *                     *               E9DE  skurrdf   equ    *  E9DE BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E9E1 BD   E609               jsr    wzdevtTask       Structure                 16:33:58  Jan 23, 2026   Page   70wz socket interface routines                          E9E4 1026 FF09     02        lbne   rdrqer1  E9E8 BD   E62B               jsr    skcudp  E9EB 26   F7                 bne    02b                     *                     * no  packet data present, wait for it                     *  E9ED BD   F050               jsr    GSRSR  E9F0 E7   45                 stb    wzstat,u  update status  E9F2 C1   22                 cmpb   #WSUDP  E9F4 27   21                 beq    81f                     *  E9F6 C1   32                 cmpb   #WSIRAW   W55 state  E9F8 26   54                 bne    82f                     * IPRAW handling  E9FA EC   C8 20              ldd    wzurms,u  new data  E9FD 26   45                 bne    83f       no                     * yes, read data details  E9FF BD   F207               jsr    GSRRXRS   now full UDP size  EA02 ED   7E                 std    -2,s      test D  EA04 27   48                 beq    82f                     * read [sender-IP][data-len]  EA06 31   C8 1A              leay   wzuipa,u  EA09 CC   0006               ldd    #6  EA0C BD   ED7A               jsr    bmread                     * read data size  EA0F EC   C8 1E              ldd    wzuprt,u  here lands size  EA12 ED   C8 20              std    wzurms,u  EA15 20   23                 bra    87f                     * pure UDP handling, check if BIND has been called before  EA17 A6   42       81        lda    wzfsta,u  EA19 85   40                 bita   #WZWBND   did we? BIND erases flag  EA1B 1026 00FA               lbne   skuer1    we need for datagram server                     *  EA1F EC   C8 20              ldd    wzurms,u  new data?  EA22 26   20                 bne    83f       no                     * check data available  EA24 BD   F207               jsr    GSRRXRS   data available?  EA27 ED   7E                 std    -2,s      test D  EA29 27   23                 beq    82f       keep waiting                     *                     * first data present, set [wzuipa(4), wzuprt(2), wzurms(2)]                     *                     * get header info from data  EA2B CC   0008               ldd    #8        size of header  EA2E 31   C8 1A              leay   wzuipa,u  read 8 bytes from socketbuffer  EA31 BD   ED7A               jsr    bmread    copy data and update PSRRXRP!  EA34 EC   C8 1E              ldd    wzuprt,u  who sent it  EA37 ED   C8 12              std    wzdprt,u  EA3A C6   40       87        ldb    #WCRECV  EA3C E7   44                 stb    wzcmnd,u  process move pointer  EA3E BD   F01C               jsr    PSRCR                     *Task       Structure                 16:33:59  Jan 23, 2026   Page   71wz socket interface routines                                             * wzurms is fetched from socket buffer with bmread                     *  EA41 EC   C8 20    84        ldd    wzurms,u  EA44 1083 05C0     83        cmpd   #MAX_UDP  max size  EA48 22   16                 bhi    89f                     *  EA4A 4F                      clra  EA4B C6   21                 ldb    #R_RDFRM  tell caller  EA4D 39                      rts                                          * no data yet  EA4E EC   C8 26    82        ldd    wztype,u  check non-block  EA51 85   01                 bita   #WFNBLK  EA53 26   07                 bne    90f                     *  EA55 108E E9DE               ldy    #skurrdf  EA59 7E   E7A4               jmp    polext                     *  EA5C 4F            90        clra  EA5D C6   15                 ldb    #R_RQRDNB  EA5F 39                      rts                     *  EA60               89  EA60 C6   C0                 ldb    #E_SOCKET  EA62 39                      rts                                          ***************************************************************                     * skurrd,  data readfrom                     *                     *                     * X hold the task table                     * U holds the sock address                     *               EA63  skurrd    equ    *  EA63 BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EA66 BD   E609               jsr    wzdevt  EA69 1026 FE84     02        lbne   rdrqer1  EA6D BD   E62B               jsr    skcudp  EA70 26   F7                 bne    02b                     *                     * go on                     *                     *                     * transfer at most fio_fsz bytes  EA72 EC   C8 20              ldd    wzurms,u  this is leading count                     * D = total available data  EA75 108E 0020               ldy    #fifo     target  EA79 BD   F2D7               jsr    RDSK2FB   transfer data, update wzxfer  EA7C 34   06                 pshs   d         xferred countTask       Structure                 16:33:59  Jan 23, 2026   Page   72wz socket interface routines                          EA7E EC   C8 20              ldd    wzurms,u  update  EA81 A3   E1                 subd   0,s++  EA83 ED   C8 20              std    wzurms,u  new remaining                     *  EA86 C6   40       01        ldb    #WCRECV  EA88 E7   44                 stb    wzcmnd,u  set processed pointer  EA8A BD   F01C               jsr    PSRCR                     *  EA8D 4F                      clra  EA8E C6   22                 ldb    #R_RRDFD  EA90 39                      rts                                          ***************************************************************                     * skurwt,  request sendto                     *                     *                     * X hold the task table                     * U holds the sock address                     *               EA91  skurwt    equ    *  EA91 BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EA94 BD   E609               jsr    wzdevt  EA97 1026 FE56     02        lbne   rdrqer1  EA9B BD   E62B               jsr    skcudp  EA9E 26   F7                 bne    02b                     *                     * go on                     *  EAA0 EC   C8 14              ldd    wzipad,u  EAA3                         ordx   wzipad+2,IU  EAA3 10AA                    fdb    $10aa  EAA5                         doindx wzipad+2,IU  EAA5 C8 16                   fcb    $88+(IU<<5),(wzipad+2&$7f)                               endm                               endm >EAA7 1027 006E               lbeq   skuer1                     * set network registers  EAAB 31   C8 14              leay   wzipad,u  EAAE BD   F0D2               jsr    PSRDIP                     *  EAB1 EC   C8 12              ldd    wzdprt,u  check illegal port >EAB4 1027 0061               lbeq   skuer1                     *  EAB8 EC   C8 12              ldd    wzdprt,u  EABB BD   F0F8               jsr    PSRDPOR                     * for IPRAW set only destination IP and port  EABE E6   45                 ldb    wzstat,u  EAC0 C1   32                 cmpb   #WSIRAW  EAC2 27   11                 beq    skusnm    specialTask       Structure                 16:33:59  Jan 23, 2026   Page   73wz socket interface routines                                             *                     * regulare UDP, set source port if not yet assigned  EAC4 EC   C8 10              ldd    wzsprt,u  already set?  EAC7 26   09                 bne    16f  EAC9 BD   E5F7               jsr    sknewp    get new source port  EACC ED   C8 10              std    wzsprt,u  EACF ED   C8 1E              std    wzuprt,u  set also return port  EAD2 BD   F06E     16        jsr    PSRPORT                     *                     * wait for data to go out loop                     *               EAD5  skusnm    equ    *  EAD5 BD   E615     skuwr2    jsr    skfres    set socket base  EAD8 BD   E609               jsr    wzdevt    devie active >EADB 1026 FFB8               lbne   02b       no  EADF BD   E62B               jsr    skcudp    check open method  EAE2 26   B3                 bne    02b                     *  EAE4 BD   F050               jsr    GSRSR  EAE7 E7   45                 stb    wzstat,u  update status  EAE9 C1   22                 cmpb   #WSUDP  EAEB 27   04                 beq    20f  EAED C1   32                 cmpb   #WSIRAW   IPRAW  EAEF 26   28                 bne    skuer1  EAF1 BD   F1BB     20        jsr    GSRTXFR   free size  EAF4 10A3 C8 20              cmpd   wzurms,u  set by driver  EAF8 24   12                 bhs    10f                     * no space yet                       EAFA EC   C8 26              ldd    wztype,u  EAFD 85   01                 bita   #WFNBLK  EAFF 26   07                 bne    21f                     *  EB01 108E EAD5               ldy    #skuwr2  EB05 7E   E7A4               jmp    polext    keep polling                     *  EB08 4F            21        clra  EB09 C6   13                 ldb    #R_RQWRNB non block write  EB0B 39                      rts                     *  EB0C EC   C8 20    10        ldd    wzurms,u  EB0F 1083 05C0               cmpd   #MAX_UDP  too big  EB13 22   04                 bhi    skuer1                     *  EB15 4F                      clra  EB16 C6   23                 ldb    #R_RSNDTO  EB18 39                      rts                       EB19               skuer1  EB19 C6   C0                 ldb    #E_SOCKET  EB1B 39                      rts                     Task       Structure                 16:34:00  Jan 23, 2026   Page   74wz socket interface routines                                                                  ***************************************************************                     * skusnt,  data sendto                     *                     *                     * X hold the task table                     * U holds the sock address                     *               EB1C  skusnt    equ    *  EB1C BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EB1F BD   E609               jsr    wzdevt  EB22 1026 FDCB     02        lbne   rdrqer1  EB26 BD   E62B               jsr    skcudp  EB29 26   F7                 bne    02b                     *                     * go on                     *                     * transfer fifo to socket data register  EB2B EC   C8 20              ldd    wzurms,u  total data                     *  EB2E 108E 0020               ldy    #fifo     target  EB32 BD   F325               jsr    WRFB2SK   fifo to socket  EB35 34   06                 pshs   d  EB37 EC   C8 20              ldd    wzurms,u  all loaded  EB3A A3   E1                 subd   0,s++  EB3C ED   C8 20              std    wzurms,u  EB3F 26   11                 bne    01f                       EB41 EC   C8 22              ldd    wzuwrp,u  is it used  EB44 BD   F1F8               jsr    PSRTXWP   set write pointer                       EB47 C6   20                 ldb    #WCSEND  EB49 E7   44                 stb    wzcmnd,u  EB4B BD   F01C               jsr    PSRCR  EB4E 4F                      clra  EB4F C6   24                 ldb    #R_WSNDTO data taken  EB51 39                      rts                       EB52 4F            01        clra  EB53 C6   25                 ldb    #R_SNDTOM ask for more  EB55 39                      rts                                          ***************************************************************                     *                     * netblock, read block                     * the method is special, we need to send a request                     * over the net first (send) before new data can be returned                     * request sits at fido_us2/fifo_us3                     * X=task struct, U=wzsockTask       Structure                 16:34:00  Jan 23, 2026   Page   75wz socket interface routines                                             *                     * requires exclusive and permanent access to fifo and                     * therefore a CPU09GPP/09NET combo where for this device                     * the socket drivers are not active                     *                     ***************************************************************                                    EB56  sknbrr    equ    *  EB56 BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EB59 BD   E609               jsr    wzdevt  EB5C 1026 FD91     02        lbne   rdrqer1  EB60 BD   E622               jsr    skctcp  EB63 26   F7                 bne    02b                     *                     *                     *  EB65 BD   F050               jsr    GSRSR     get status  EB68 E7   45                 stb    wzstat,u  update sock  EB6A C1   17                 cmpb   #WSESTB   established  EB6C 26   46                 bne    sknbe1    error                     *  EB6E BD   F1BB               jsr    GSRTXFR   get free space  EB71 1083 0004               cmpd   #NBRQLN  EB75 25   37                 blo    sknbrp1   go poll                     *                     * read, send command info to server                     *  EB77 CC   0004               ldd    #NBRQLN   actual size of request  EB7A 108E 001C               ldy    #fifo_us2 where request is present  EB7E BD   F325               jsr    WRFB2SK  EB81 C6   20                 ldb    #WCSEND   tell socket we put it  EB83 E7   44                 stb    wzcmnd,u  EB85 BD   F01C               jsr    PSRCR                     *                     * read is 2 phase, receive response from server                     *  EB88 BD   E615     sknbrp2   jsr    skfres    reset important info  EB8B BD   F207               jsr    GSRRXRS   check response  EB8E 34   06                 pshs   d  EB90 EC   4A                 ldd    wzrqln,u  requested data  EB92 C3   0004               addd   #NBRQLN  EB95 10A3 E1                 cmpd   0,s++     allows for other data packet sizes  EB98 23   1D                 bls    01f  EB9A BD   F050               jsr    GSRSR  EB9D E7   45                 stb    wzstat,u  EB9F C1   17                 cmpb   #WSESTB   check socket state  EBA1 26   11                 bne    sknbe1  EBA3 C1   1C                 cmpb   #WSCLWT  EBA5 27   0D                 beq    sknbe1    bail outTask       Structure                 16:34:00  Jan 23, 2026   Page   76wz socket interface routines                          EBA7 108E EB88               ldy    #sknbrp2  wait until                     *                     * poll loop                     *  EBAB 7E   E7A4     02        jmp    polext                     *  EBAE 108E EB56     sknbrp1   ldy    #sknbrr  EBB2 20   F7                 bra    02b                     *  EBB4 C6   C0       sknbe1    ldb    #E_SOCKET  EBB6 39                      rts                     * we have data in socket  EBB7 C6   82       01        ldb    #R_RQRBLK  EBB9 4F                      clra  EBBA 39                      rts                                          ***************************************************************                     * here data is moved from the socket to the fifo                     * write 4 bytes back to fifo_us2/fifo_us3                     ***************************************************************               EBBB  sknbrd    equ    *  EBBB BD   E615               jsr    skfres  EBBE BD   E609               jsr    wzdevt  EBC1 1026 FD2C     02        lbne   rdrqer1  EBC5 BD   E622               jsr    skctcp  EBC8 26   F7                 bne    02b                     *                     * when we arrive here, the data has arrived                     *  EBCA EC   4A       01        ldd    wzrqln,u  request sets the buffer size  EBCC 34   06                 pshs   d  EBCE C3   0004               addd   #NBRQLN  EBD1 ED   4A                 std    wzrqln,u  fool RDSK2FB  EBD3 108E 001C               ldy    #fifo_us2 data contains cmd info  EBD7 BD   F2D7               jsr    RDSK2FB  EBDA C6   40                 ldb    #WCRECV   tell socket we took it  EBDC E7   44                 stb    wzcmnd,u  EBDE BD   F01C               jsr    PSRCR                     * transfer only data part  EBE1 35   06                 puls   d  EBE3 ED   48                 std    wzxfer,u  EBE5 ED   4A                 std    wzrqln,u                     *  EBE7 C6   83                 ldb    #R_RDRBLK tell caller, data in fifo_us2 and fifo  EBE9 39                      rts                                          ***************************************************************                     *                     * netblock, write block                     *                     ***************************************************************               EBEA  sknbsr    equ    *Task       Structure                 16:34:01  Jan 23, 2026   Page   77wz socket interface routines                          EBEA BD   E615               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EBED BD   E609               jsr    wzdevt  EBF0 1026 FCFD     02        lbne   rdrqer1  EBF4 BD   E622               jsr    skctcp  EBF7 26   F7                 bne    02b                     *  EBF9 BD   F050               jsr    GSRSR     status  EBFC E7   45                 stb    wzstat,u  EBFE C1   17                 cmpb   #WSESTB   still there?  EC00 26   16                 bne    sknbe10                     *  EC02 BD   F1BB               jsr    GSRTXFR   get free space  EC05 34   06                 pshs   d  EC07 CC   0004               ldd    #NBRQLN  EC0A E3   4A                 addd   wzrqln,u  EC0C 10A3 E1                 cmpd   0,s++  EC0F 23   0F                 bls    70f                     *  EC11 108E EBEA               ldy    #sknbsr  EC15 7E   E7A4               jmp    polext                     *  EC18 CC   0000     sknbe10   ldd    #0  EC1B ED   48                 std    wzxfer,u  EC1D C6   C0                 ldb    #E_SOCKET  EC1F 39                      rts                       EC20 4F            70        clra  EC21 C6   80                 ldb    #R_RQSBLK  EC23 39                      rts                                          ***************************************************************                     *                     *                     ***************************************************************               EC24  sknbsd    equ    *  EC24 BD   E615               jsr    skfres  EC27 BD   E609               jsr    wzdevt  EC2A 1026 FCC3     02        lbne   rdrqer1  EC2E BD   E622               jsr    skctcp  EC31 26   F7                 bne    02b                                          *                     * data to write, cnd +data                     *  EC33 EC   4A       70        ldd    wzrqln,u  EC35 34   06                 pshs   d  EC37 C3   0004               addd   #NBRQLN  EC3A ED   4A                 std    wzrqln,u  fool WFB2SK  EC3C 108E 001C               ldy    #fifo_us2 where cmd sitsTask       Structure                 16:34:01  Jan 23, 2026   Page   78wz socket interface routines                          EC40 BD   F325               jsr    WRFB2SK  EC43 C6   20                 ldb    #WCSEND   send it now  EC45 E7   44                 stb    wzcmnd,u  EC47 BD   F01C               jsr    PSRCR  EC4A 35   06                 puls   d  EC4C ED   48                 std    wzxfer,u  make it correct  EC4E ED   4A                 std    wzrqln,u  EC50 4F                      clra  EC51 C6   81                 ldb    #R_SNDBLK tell host we did  EC53 39                      rts                                          ***************************************************************                     *                     * special function, tstval,x is indicator                     * X holds the task table                     * U holds the  sock address (wz....  access!)                     *               EC54  skspcl    equ    *                     *  EC54 BD   E615               jsr    skfres    set U to internal address  EC57 34   10                 pshs   x  EC59 E6   0C                 ldb    tstval,x  get index  EC5B C1   03                 cmpb   #MAXTBL  EC5D 22   18                 bhi    01f       illegal                     *  EC5F 58                      aslb  EC60 8E   EC7E               ldx    #functb  EC63 10AE 85                 ldy    b,x       get special function  EC66 27   0F                 beq    01f       not valid  EC68 35   10                 puls   x                     *  EC6A AD   A4                 jsr    0,y       do function  EC6C 26   05                 bne    90f                     * done, tell OS  EC6E 4F                      clra  EC6F C6   0F                 ldb    #R_SPCL  EC71 20   0A                 bra    99f                     *  EC73 86   A2       90        lda    #162  EC75 20   04                 bra    02f                     *  EC77 35   10       01        puls   x  EC79 86   A1                 lda    #161  EC7B               02  EC7B C6   C0                 ldb    #E_SOCKET set socket error                     *  EC7D 39            99        rts                                          * dispatch table  EC7E EC86          functb    fdb    wzwdev    write device settings  EC80 EC86                    fdb    wzwdev  EC82 ECB0                    fdb    wzrdev    read device settingsTask       Structure                 16:34:01  Jan 23, 2026   Page   79wz socket interface routines                          EC84 ECCC                    fdb    showrg               0003  MAXTBL    equ    ((*-functb)/2)-1                                          *                     * write W5500 device settings!                     *                     * X hold the task table                     * U holds the special sock address                     *  EC86               wzwdev  EC86 C6   08                 ldb    #8  EC88                         trfr   B,E  EC88 1F                      fcb    $1f  EC89 9E                      fcb    B<<4|E                               endm  EC8A DE   1A                 ldu    fifo_us1  device info area  EC8C 31   C4                 leay   0,u       myip  EC8E BD   EEB3               jsr    PCRSIP    source IP  EC91 31   44                 leay   4,u  EC93 BD   EE47               jsr    PCRSNM    subnet mask  EC96 31   48                 leay   8,u  EC98 BD   EE19               jsr    PCRGA     gateway IP  EC9B 31   4C                 leay   12,u  EC9D BD   EE7D               jsr    PCRSHA    hardware address                     *  ECA0 A6   C8 12              lda    18,u      ON/OFF  ECA3 27   04                 beq    01f  ECA5 C6   F8                 ldb    #%11111000 all on  ECA7 20   02                 bra    02f  ECA9 C6   78       01        ldb    #%01111000 all off  ECAB BD   EFD1     02        jsr    PCRPHY  ECAE 4F                      clra             no error return status  ECAF 39                      rts                                          *                     * read W5500 device settings                     *  ECB0               wzrdev  ECB0 C6   08                 ldb    #8  ECB2                         trfr   B,E       select first socket  ECB2 1F                      fcb    $1f  ECB3 9E                      fcb    B<<4|E                               endm  ECB4 DE   1A                 ldu    fifo_us1  ECB6 31   C4                 leay   0,u       overwrite what was set  ECB8 BD   EE9C               jsr    GCRSIP    source IP  ECBB 31   44                 leay   4,u  ECBD BD   EE30               jsr    GCRSNM    network mask  ECC0 31   48                 leay   8,u  ECC2 BD   EE02               jsr    GCRGA     gateway address  ECC5 31   4C                 leay   12,u  ECC7 BD   EE5E               jsr    GCRSHA    hardware addressTask       Structure                 16:34:02  Jan 23, 2026   Page   80wz socket interface routines                          ECCA 4F                      clra             no error return status  ECCB 39                      rts                                          *                     * DEBUG service, read selected registers                     *  ECCC               showrg  ECCC C6   08                 ldb    #8  ECCE                         trfr   B,E       select first socket  ECCE 1F                      fcb    $1f  ECCF 9E                      fcb    B<<4|E                               endm  ECD0 DE   1A                 ldu    fifo_us1  ECD2 33   C8 20              leau   32,u      skip network data area                     *  ECD5 BD   EFEF               jsr    GSRMR     socket mask  ECD8 E7   C0                 stb    0,u+  ECDA BD   F050               jsr    GSRSR     socket status  ECDD E7   C0                 stb    0,u+  ECDF BD   F17F               jsr    GSRRBFS   socket  ECE2 E7   C0                 stb    0,u+                       ECE4 C6   3D                 ldb    #'=  ECE6 E7   C0                 stb    0,u+                       ECE8 31   C4                 leay   0,u  ECEA BD   EE9C               jsr    GCRSIP    control source IP  ECED 33   44                 leau   4,u  ECEF 31   C4                 leay   0,u  ECF1 BD   EE02               jsr    GCRGA     control gateway address  ECF4 33   44                 leau   4,u                       ECF6 C6   23                 ldb    #'#  ECF8 E7   C0                 stb    0,u+                       ECFA 31   C4                 leay   0,u  ECFC BD   EE5E               jsr    GCRSHA    control hardware address  ECFF 33   46                 leau   6,u                       ED01 C6   23                 ldb    #'#  ED03 E7   C0                 stb    0,u+                       ED05 31   C4                 leay   0,u  ED07 BD   EE30               jsr    GCRSNM    control net mask  ED0A 33   44                 leau   4,u                       ED0C C6   3D                 ldb    #'=  ED0E E7   C0                 stb    0,u+                       ED10 BD   EFE0               jsr    GCRVERS   control version  ED13 ED   C1                 std    0,u++                     Task       Structure                 16:34:02  Jan 23, 2026   Page   81wz socket interface routines                          ED15 C6   23                 ldb    #'#  ED17 E7   C4                 stb    0,u  ED19 4F                      clra                       ED1A 39                      rts                                          * not implemented functions                     *                     * X hold the task table                     * U holds the wzsock address                     *   skintrp  ED1B               skdisc  ED1B               sksmac  ED1B               skskep  ED1B 86   FF                 lda    #255  ED1D A7   47                 sta    wzerr,u  ED1F C6   C0                 ldb    #E_SOCKET                                            ED21 39                      rts                                    ED22  oldorg    set    *                     *                     * hardware register orgaization                     *               8080  SPIBASE   equ    $8080     hardware base address                       0000                         org    0                     *  0000               spicmd    rmb    1         HW control register               0000  spista    equ    spicmd    HW status register  0001               spicon    rmb    1         [W]   HW aux control register  0002                         rmb    2         dummy not used                     * shift register access  0004               hibyta    rmb    1         [R/W] hibyte auto 8 clock pulses for SR  0005               lobyta    rmb    1         [R/W] lobyte auto 8 clock pulses for SR  0006               hibyts    rmb    1         [R/W] hibyte static (no clock)  0007               lobyts    rmb    1         [R/W] lobyte static (no clock)                     *               0080  QFF1      equ    %10000000 [R]                          X               0040  SPI_CS_   equ    %01000000 [R/W] spi chip CS_           1               0020  SPI_RST   equ    %00100000 [R/W] spi chip RST_          1               0010  SPI_IEN   equ    %00010000 [R/W] spi chip INT enabled   0               0008  SPI_AUT   equ    %00001000 [R/W] auto advance           0               0004  SPI_SR_   equ    %00000100 [R/W] shift register MR_     1               0002  SPI_HLD   equ    %00000010 [R/W] HOLD                   0               0001  SPI_CR_   equ    %00000001 [W]   HC163 MR_              1               0001  SPI_IRQ   equ    %00000001 [R]   /IRQ bit               1                     *               0003  RSVREG    equ    %00000011 reserved register address                       ED22                         org    oldorgTask       Structure                 16:34:03  Jan 23, 2026   Page   82wzspi, basic spi routines                                                                     *                     * spinit, init the SPI hardware                     *               ED22  spinit    equ    *  ED22 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_ set idle  ED24 B7   8080               sta    SPIBASE+spicmd  ED27 39                      rts                                          *                     * setup inital port for SPI access                     *                     * A,B are lost A=rwflag, F=register, X=offset                     * F=corrected register bits [7...3]                     * A= R/W flag 1=write/ 0= read                     * X,Y untouched                     *               ED28  spistr2   equ    *  ED28 CE   8080               ldu    #SPIBASE  SPI base TODO  ED2B                         trfr   F,B  ED2B 1F                      fcb    $1f  ED2C F9                      fcb    F<<4|B                               endm  ED2D 5D                      tstb             register pointer  ED2E 27   09                 beq    01f       OK, valid  ED30 34   04                 pshs   b  ED32 C4   03                 andb   #RSVREG   reserved loctation  ED34 5D                      tstb             xxx10xxx  is invalid!  ED35 35   04                 puls   b  ED37 27   1A                 beq    09f       invalid access                     * adjust READ/WRITE bit  ED39 4D            01        tsta             cmd flag  ED3A 27   04                 beq    04f  ED3C 1A   01                 sec              write   100  ED3E 20   02                 bra    05f  ED40 1C   FE       04        clc              read    000                     *  ED42 59            05        rolb             set READ/WRITE bit  [2...0]  ED43 58                      lslb             set variable length data [00]  ED44 58                      lslb                     *                     * here the actual SPI action starts                     *  ED45                         seti   disable   interrupts  ED45 1A   50                 orcc   #FF|IF                               endm  ED47 12                      nop                     *       lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT+SPI_IEN low  ED48 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT low  ED4A A7   C4                 sta    spicmd,u  ED4C AF   44                 stx    hibyta,u  and shift out  ED4E E7   44                 stb    hibyta,u  and shift outTask       Structure                 16:34:03  Jan 23, 2026   Page   83wzspi, basic spi routines                             ED50 1A   04                 sez  ED52 39                      rts  ED53 1C   FB       09        clz  ED55 39                      rts                                          *                     * X = offset, unchanged                     * F = register#                     * read BYTE from SPI                     * return B=value, D,X,Y,U preserved                     *               ED56  byterd    equ    *  ED56 34   47                 pshs   cc,d,u  ED58 4F                      clra  ED59 8D   CD                 bsr    spistr2 >ED5B 1026 007F               lbne   09f  ED5F E6   44                 ldb    hibyta,u  extra clocks for first data                     *  ED61 E6   45                 ldb    lobyta,u  read byte  ED63 4F                      clra  ED64 ED   61                 std    1,s  ED66 20   6A                 bra    sprend                                          *                     * X = offset                     * F = register#                     * read WORD from SPI                     * return D=value,  D,X,Y,U preserved                     *               ED68  wordrd    equ    *  ED68 34   47                 pshs   cc,d,u  ED6A 4F                      clra >ED6B BD   ED28               jsr    spistr2  ED6E 26   6E                 bne    09f  ED70 E6   44                 ldb    hibyta,u  extra clocks for first data                     *  ED72 A6   45                 lda    lobyta,u  read byte  ED74 E6   45                 ldb    lobyta,u  read byte  ED76 ED   61                 std    1,s  ED78 20   58                 bra    sprend                                          *                     * bmread, spi to memory read xfer                     * Y=mem pointer, D=count (bytes)                     * F = register#                     * read bytes from SPI into memory location                     * return D,X,Y,U preserved                     *               ED7A  bmread    equ    *  ED7A 34   77                 pshs   cc,d,x,y,u  ED7C                         pshsw  save      E:F  ED7C 1038                    fdb    $1038Task       Structure                 16:34:03  Jan 23, 2026   Page   84wzspi, basic spi routines                                                          endm  ED7E BD   F21E               jsr    GSRRXRP   'read' pointer  ED81 1F   01                 tfr    d,x       keep  ED83 CE   8080               ldu    #SPIBASE  ED86 34   40                 pshs   u         remember  ED88 1A   50                 orcc   #$50  ED8A 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT  ED8C A7   C4                 sta    spicmd,u  start SPI  ED8E AF   44                 stx    hibyta,u  start address  ED90 BD   F2C8               jsr    tsk2rx    E => B  ED93 E7   44                 stb    hibyta,u  socket register  ED95 EC   65                 ldd    5,s       old D  ED97                         trfr   D,W       transaction count  ED97 1F                      fcb    $1f  ED98 06                      fcb    D<<4|W                               endm  ED99 E7   44                 stb    hibyta,u  dummy, shift out  ED9B 10AE 69                 ldy    9,s       old Y, mem pointer  ED9E 33   45                 leau   lobyta,u  point to data register  EDA0                         tfm4   U,Y       U => Y++  EDA0 113B                    fdb    $113b  EDA2 32                      fcb    U<<4|Y                               endm  EDA3 35   40                 puls   u         restore SPIBASE  EDA5 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  EDA7 A7   C4                 sta    spicmd,u  end SPI                     * X = old read pointer, 0,s byte wount  EDA9 1F   10                 tfr    x,d       start pointer  EDAB E3   63                 addd   3,s       move pointer with # bytes  EDAD                         pulsw  restore   E:F  EDAD 1039                    fdb    $1039                               endm  EDAF BD   F22D               jsr    PSRRXRP   update pointer  EDB2 35   F7                 puls   cc,d,x,y,u,pc                                          *                     * X = offset                     * F = register#                     * write BYTE to SPI, D,X,Y,U preserved                     *               EDB4  bytewr    equ    *  EDB4 34   47                 pshs   cc,d,u  EDB6 86   01                 lda    #1  EDB8 BD   ED28               jsr    spistr2  EDBB 26   21                 bne    09f                     *  EDBD A6   62                 lda    2,s  EDBF A7   44                 sta    hibyta,u  EDC1 20   0F                 bra    sprend                                          *                     * X = offsetTask       Structure                 16:34:03  Jan 23, 2026   Page   85wzspi, basic spi routines                                                * F = register#                     * write WORD to SPI, D,X,Y,U preserved                     *               EDC3  wordwr    equ    *  EDC3 34   47                 pshs   cc,d,u  EDC5 86   01                 lda    #1  EDC7 BD   ED28               jsr    spistr2  EDCA 26   12                 bne    09f                     *  EDCC EC   61                 ldd    1,s  EDCE A7   44                 sta    hibyta,u  EDD0 E7   44                 stb    hibyta,u                     *                     * common exit from SPI action                     *  EDD2 86   65       sprend    lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_                     *sprend  lda     #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_+SPI_IEN  EDD4 A7   C4                 sta    spicmd,u  EDD6 A6   E4                 lda    0,s       sez  EDD8 8A   04                 ora    #4  EDDA A7   E4       02        sta    0,s  EDDC 35   C7                 puls   cc,d,u,pc                     *  EDDE A6   E4       09        lda    0,s       clz  EDE0 84   FB                 anda   #255-4  EDE2 20   F6                 bra    02b                     Task       Structure                 16:34:04  Jan 23, 2026   Page   86wzspi, basic spi routines                                                                     * register names and offset               0000  WZMR      equ    0               0001  WZGAR0    equ    1               0002  WZGAR1    equ    2               0003  WZGAR2    equ    3               0004  WZGAR3    equ    4               0005  WZSUBR0   equ    5               0006  WZSUBR1   equ    6               0007  WZSUBR2   equ    7               0008  WZSUBR3   equ    8               0009  WZSHAR0   equ    9               000A  WZSHAR1   equ    10               000B  WZSHAR2   equ    11               000C  WZSHAR3   equ    12               000D  WZSHAR4   equ    13               000E  WZSHAR5   equ    14               000F  WZSIPR0   equ    15               0010  WZSIPR1   equ    16               0011  WZSIPR2   equ    17               0012  WZSIPR3   equ    18               0013  WZILLT0   equ    19               0014  WZILLT1   equ    20               0015  WZIR      equ    21               0016  WZIMR     equ    22               0017  WZSIR     equ    23               0018  WZSIMR    equ    24               0019  WZRTR0    equ    25               001A  WZRTR1    equ    26               001B  WZRCR     equ    27               0028  WZUIPR0   equ    40               0029  WZUIPR1   equ    41               002A  WZUIPR2   equ    42               002B  WZUIPR3   equ    43               002C  WZUPRT0   equ    44               002D  WZUPRT1   equ    45               002E  WZPHY     equ    46               0039  WZVERS    equ    57                                          *                     * all commands to access common register set                     *                                          *                     * GCRMR, get byte from common registers mode register                     * return byte in B                     *  EDE4 34   56       GCRMR     pshs   d,x,u  EDE6 5F                      clrb  EDE7                         trfr   B,F  EDE7 1F                      fcb    $1f  EDE8 9F                      fcb    B<<4|FTask       Structure                 16:34:04  Jan 23, 2026   Page   87wzspi, basic spi routines                                                          endm  EDE9 8E   0000               ldx    #WZMR  EDEC BD   ED56               jsr    byterd  EDEF ED   E4                 std    0,s  EDF1 35   D6                 puls   d,x,u,pc                                          *                     * PCRMR, put byte B into common registers mode register                     *  EDF3 34   16       PCRMR     pshs   d,x  EDF5 5F                      clrb  EDF6                         trfr   B,F  EDF6 1F                      fcb    $1f  EDF7 9F                      fcb    B<<4|F                               endm  EDF8 8E   0000               ldx    #WZMR  EDFB EC   E4                 ldd    0,s >EDFD BD   EDB4               jsr    bytewr  EE00 35   96                 puls   d,x,pc                                          *                     * GCRGA, get gateway address from common regsiters                     * Y=destination address (4 bytes)                     *  EE02 34   16       GCRGA     pshs   d,x  EE04 5F                      clrb  EE05                         trfr   B,F  EE05 1F                      fcb    $1f  EE06 9F                      fcb    B<<4|F                               endm  EE07 8E   0001               ldx    #WZGAR0  EE0A BD   ED68               jsr    wordrd  EE0D ED   A4                 std    0,y  EE0F 8E   0003               ldx    #WZGAR2  EE12 BD   ED68               jsr    wordrd  EE15 ED   22                 std    2,y  EE17 35   96                 puls   d,x,pc                                          *                     * PCRGW, put gateway address                     * Y=source address (4 bytes)                     *  EE19 34   16       PCRGA     pshs   d,x  EE1B 5F                      clrb  EE1C                         trfr   B,F  EE1C 1F                      fcb    $1f  EE1D 9F                      fcb    B<<4|F                               endm  EE1E 8E   0001               ldx    #WZGAR0  EE21 EC   A4                 ldd    0,y >EE23 BD   EDC3               jsr    wordwr  EE26 8E   0003               ldx    #WZGAR2Task       Structure                 16:34:04  Jan 23, 2026   Page   88wzspi, basic spi routines                             EE29 EC   22                 ldd    2,y >EE2B BD   EDC3               jsr    wordwr  EE2E 35   96                 puls   d,x,pc                                          *                     * GCRSNM, get subnet mask  from common regsiters                     * Y=destination address (4 bytes)                     *  EE30 34   16       GCRSNM    pshs   d,x  EE32 5F                      clrb  EE33                         trfr   B,F  EE33 1F                      fcb    $1f  EE34 9F                      fcb    B<<4|F                               endm  EE35 8E   0005               ldx    #WZSUBR0  EE38 BD   ED68               jsr    wordrd  EE3B ED   A4                 std    0,y  EE3D 8E   0007               ldx    #WZSUBR2  EE40 BD   ED68               jsr    wordrd  EE43 ED   22                 std    2,y  EE45 35   96                 puls   d,x,pc                                          *                     * PCRSNM, put subnet mask address                     * Y=source address (4 bytes)                     *  EE47 34   16       PCRSNM    pshs   d,x  EE49 5F                      clrb  EE4A                         trfr   B,F  EE4A 1F                      fcb    $1f  EE4B 9F                      fcb    B<<4|F                               endm  EE4C 8E   0005               ldx    #WZSUBR0  EE4F EC   A4                 ldd    0,y  EE51 BD   EDC3               jsr    wordwr  EE54 8E   0007               ldx    #WZSUBR2  EE57 EC   22                 ldd    2,y  EE59 BD   EDC3               jsr    wordwr  EE5C 35   96                 puls   d,x,pc                                          *                     * GCRSHA, get gateway hardware address from common regsiters                     * Y=destination address (6 bytes)                     *  EE5E 34   16       GCRSHA    pshs   d,x  EE60 5F                      clrb  EE61                         trfr   B,F  EE61 1F                      fcb    $1f  EE62 9F                      fcb    B<<4|F                               endm  EE63 8E   0009               ldx    #WZSHAR0  EE66 BD   ED68               jsr    wordrdTask       Structure                 16:34:05  Jan 23, 2026   Page   89wzspi, basic spi routines                             EE69 ED   A4                 std    0,y  EE6B 8E   000B               ldx    #WZSHAR2  EE6E BD   ED68               jsr    wordrd  EE71 ED   22                 std    2,y  EE73 8E   000D               ldx    #WZSHAR4  EE76 BD   ED68               jsr    wordrd  EE79 ED   24                 std    4,y  EE7B 35   96                 puls   d,x,pc                                          *                     * PCRSHA, put gateway hardware address                     * Y=source address (6 bytes)                     *  EE7D 34   16       PCRSHA    pshs   d,x  EE7F 5F                      clrb  EE80                         trfr   B,F  EE80 1F                      fcb    $1f  EE81 9F                      fcb    B<<4|F                               endm  EE82 8E   0009               ldx    #WZSHAR0  EE85 EC   A4                 ldd    0,y  EE87 BD   EDC3               jsr    wordwr  EE8A 8E   000B               ldx    #WZSHAR2  EE8D EC   22                 ldd    2,y  EE8F BD   EDC3               jsr    wordwr  EE92 8E   000D               ldx    #WZSHAR4  EE95 EC   24                 ldd    4,y  EE97 BD   EDC3               jsr    wordwr  EE9A 35   96                 puls   d,x,pc                                          *                     * GCRSIP, get source IP address from common regsiters                     * Y=destination address (4 bytes)                     *  EE9C 34   16       GCRSIP    pshs   d,x  EE9E 5F                      clrb  EE9F                         trfr   B,F  EE9F 1F                      fcb    $1f  EEA0 9F                      fcb    B<<4|F                               endm  EEA1 8E   000F               ldx    #WZSIPR0  EEA4 BD   ED68               jsr    wordrd  EEA7 ED   A4                 std    0,y  EEA9 8E   0011               ldx    #WZSIPR2  EEAC BD   ED68               jsr    wordrd  EEAF ED   22                 std    2,y  EEB1 35   96                 puls   d,x,pc                                          *                     * PCRSIP, put gateway address                     * Y=source address (4 bytes)                     *Task       Structure                 16:34:05  Jan 23, 2026   Page   90wzspi, basic spi routines                             EEB3 34   16       PCRSIP    pshs   d,x  EEB5 5F                      clrb  EEB6                         trfr   B,F  EEB6 1F                      fcb    $1f  EEB7 9F                      fcb    B<<4|F                               endm  EEB8 8E   000F               ldx    #WZSIPR0  EEBB EC   A4                 ldd    0,y  EEBD BD   EDC3               jsr    wordwr  EEC0 8E   0011               ldx    #WZSIPR2  EEC3 EC   22                 ldd    2,y  EEC5 BD   EDC3               jsr    wordwr  EEC8 35   96                 puls   d,x,pc                                          *                     * GCRILLT, get byte from interrup low level timer register                     * return word in D                     *  EECA 34   16       GCRILLT   pshs   d,x  EECC 5F                      clrb  EECD                         trfr   B,F  EECD 1F                      fcb    $1f  EECE 9F                      fcb    B<<4|F                               endm  EECF 8E   0013               ldx    #WZILLT0  EED2 BD   ED68               jsr    wordrd  EED5 ED   E4                 std    0,s  EED7 35   96                 puls   d,x,pc                                          *                     * PCRILLT, put word D into common registers mode register                     *  EED9 34   16       PCRILLT   pshs   d,x  EEDB 5F                      clrb  EEDC                         trfr   B,F  EEDC 1F                      fcb    $1f  EEDD 9F                      fcb    B<<4|F                               endm  EEDE 8E   0013               ldx    #WZILLT0  EEE1 EC   E4                 ldd    0,s  EEE3 BD   EDC3               jsr    wordwr  EEE6 35   96                 puls   d,x,pc                                          *                     * GCRIR, get byte from common registers interrupt register                     * return byte in B                     *  EEE8 34   16       GCRIR     pshs   d,x  EEEA 5F                      clrb  EEEB                         trfr   B,F  EEEB 1F                      fcb    $1f  EEEC 9F                      fcb    B<<4|FTask       Structure                 16:34:05  Jan 23, 2026   Page   91wzspi, basic spi routines                                                          endm  EEED 8E   0015               ldx    #WZIR  EEF0 BD   ED56               jsr    byterd  EEF3 ED   E4                 std    0,s  EEF5 35   96                 puls   d,x,pc                                          *                     * PCRIR, put byte B into common registers interrupt register                     *  EEF7 34   16       PCRIR     pshs   d,x  EEF9 5F                      clrb  EEFA                         trfr   B,F  EEFA 1F                      fcb    $1f  EEFB 9F                      fcb    B<<4|F                               endm  EEFC 8E   0015               ldx    #WZIR  EEFF EC   E4                 ldd    0,s  EF01 BD   EDB4               jsr    bytewr  EF04 35   96                 puls   d,x,pc                                          *                     * GCRIMR, get byte from common registers interrupt mask register                     * return byte in B                     *  EF06 34   16       GCRIMR    pshs   d,x  EF08 5F                      clrb  EF09                         trfr   B,F  EF09 1F                      fcb    $1f  EF0A 9F                      fcb    B<<4|F                               endm  EF0B 8E   0016               ldx    #WZIMR  EF0E BD   ED56               jsr    byterd  EF11 ED   E4                 std    0,s  EF13 35   96                 puls   d,x,pc                                          *                     * PCRIMR, put byte B into common registers interrupt mask register                     *  EF15 34   16       PCRIMR    pshs   d,x  EF17 5F                      clrb  EF18                         trfr   B,F  EF18 1F                      fcb    $1f  EF19 9F                      fcb    B<<4|F                               endm  EF1A 8E   0016               ldx    #WZIMR  EF1D EC   E4                 ldd    0,s  EF1F BD   EDB4               jsr    bytewr  EF22 35   96                 puls   d,x,pc                                          *                     * GCRSIR, get byte from common registers socket interrupt register                     * return byte in BTask       Structure                 16:34:06  Jan 23, 2026   Page   92wzspi, basic spi routines                                                *  EF24 34   16       GCRSIR    pshs   d,x  EF26 5F                      clrb  EF27                         trfr   B,F  EF27 1F                      fcb    $1f  EF28 9F                      fcb    B<<4|F                               endm  EF29 8E   0017               ldx    #WZSIR  EF2C BD   ED56               jsr    byterd  EF2F ED   E4                 std    0,s  EF31 35   96                 puls   d,x,pc                                          *                     * PCRSIR, put byte B into common registers socket interrupt register                     *  EF33 34   16       PCRSIR    pshs   d,x  EF35 5F                      clrb  EF36                         trfr   B,F  EF36 1F                      fcb    $1f  EF37 9F                      fcb    B<<4|F                               endm  EF38 8E   0017               ldx    #WZSIR  EF3B EC   E4                 ldd    0,s  EF3D BD   EDB4               jsr    bytewr  EF40 35   96                 puls   d,x,pc                                          *                     * GCSIMR, get byte from common registers socket interrupt mask register                     * return byte in B                     *  EF42 34   16       GCRSIMR   pshs   d,x  EF44 5F                      clrb  EF45                         trfr   B,F  EF45 1F                      fcb    $1f  EF46 9F                      fcb    B<<4|F                               endm  EF47 8E   0018               ldx    #WZSIMR  EF4A BD   ED56               jsr    byterd  EF4D ED   E4                 std    0,s  EF4F 35   96                 puls   d,x,pc                                          *                     * PCRSIMR, put byte B into common registers socket interrupt mask register                     *  EF51 34   16       PCRSIMR   pshs   d,x  EF53 5F                      clrb  EF54                         trfr   B,F  EF54 1F                      fcb    $1f  EF55 9F                      fcb    B<<4|F                               endm  EF56 8E   0018               ldx    #WZSIMR  EF59 EC   E4                 ldd    0,sTask       Structure                 16:34:06  Jan 23, 2026   Page   93wzspi, basic spi routines                             EF5B BD   EDB4               jsr    bytewr  EF5E 35   96                 puls   d,x,pc                                          *                     * GCRRTR, get word from common registers retry register                     * return word in D                     *  EF60 34   16       GCRRTR    pshs   d,x  EF62 5F                      clrb  EF63                         trfr   B,F  EF63 1F                      fcb    $1f  EF64 9F                      fcb    B<<4|F                               endm  EF65 8E   0019               ldx    #WZRTR0  EF68 BD   ED68               jsr    wordrd  EF6B ED   E4                 std    0,s  EF6D 35   96                 puls   d,x,pc                                          *                     * PCRRTR, put word D into common registers retry register                     *  EF6F 34   16       PCRRTR    pshs   d,x  EF71 5F                      clrb  EF72                         trfr   B,F  EF72 1F                      fcb    $1f  EF73 9F                      fcb    B<<4|F                               endm  EF74 8E   0019               ldx    #WZRTR0  EF77 EC   E4                 ldd    0,s  EF79 BD   EDC3               jsr    wordwr  EF7C 35   96                 puls   d,x,pc                                          *                     * GCRRCR, get byte from common registers retry count register                     * return byte in B                     *  EF7E 34   16       GCRRCR    pshs   d,x  EF80 5F                      clrb  EF81                         trfr   B,F  EF81 1F                      fcb    $1f  EF82 9F                      fcb    B<<4|F                               endm  EF83 8E   001B               ldx    #WZRCR  EF86 BD   ED56               jsr    byterd  EF89 ED   E4                 std    0,s  EF8B 35   96                 puls   d,x,pc                                          *                     * PCRRCR, put byte B into common registers retry count register                     *  EF8D 34   16       PCRRCR    pshs   d,x  EF8F 5F                      clrbTask       Structure                 16:34:06  Jan 23, 2026   Page   94wzspi, basic spi routines                             EF90                         trfr   B,F  EF90 1F                      fcb    $1f  EF91 9F                      fcb    B<<4|F                               endm  EF92 8E   001B               ldx    #WZRCR  EF95 EC   E4                 ldd    0,s  EF97 BD   EDB4               jsr    bytewr  EF9A 35   96                 puls   d,x,pc                                          *                     * GCRURP, get word from common registers unreachable port register                     * return word in D                     *  EF9C 34   16       GCRURP    pshs   d,x  EF9E 5F                      clrb  EF9F                         trfr   B,F  EF9F 1F                      fcb    $1f  EFA0 9F                      fcb    B<<4|F                               endm  EFA1 8E   002C               ldx    #WZUPRT0  EFA4 BD   ED68               jsr    wordrd  EFA7 ED   E4                 std    0,s  EFA9 35   96                 puls   d,x,pc                                          *                     * GCRUIP, get unreachable IP address from common registers                     * Y=destination address (4 bytes)                     *  EFAB 34   16       GCRUIP    pshs   d,x  EFAD 5F                      clrb  EFAE                         trfr   B,F  EFAE 1F                      fcb    $1f  EFAF 9F                      fcb    B<<4|F                               endm  EFB0 8E   0028               ldx    #WZUIPR0  EFB3 BD   ED68               jsr    wordrd  EFB6 ED   A4                 std    0,y  EFB8 8E   002A               ldx    #WZUIPR2  EFBB BD   ED68               jsr    wordrd  EFBE ED   22                 std    2,y  EFC0 35   96                 puls   d,x,pc                                          *                     * GCRPHY, get byte from common registers PHY config register                     * return byte in B                     *  EFC2 34   56       GCRPHY    pshs   d,x,u  EFC4 8E   002E               ldx    #WZPHY  EFC7 5F                      clrb  EFC8                         trfr   B,F  EFC8 1F                      fcb    $1f  EFC9 9F                      fcb    B<<4|FTask       Structure                 16:34:07  Jan 23, 2026   Page   95wzspi, basic spi routines                                                          endm  EFCA BD   ED56               jsr    byterd  EFCD ED   E4                 std    0,s  EFCF 35   D6                 puls   d,x,u,pc                                          *                     * PCRPHY, put byte B into common registers PHY config register                     *  EFD1 34   56       PCRPHY    pshs   d,x,u  EFD3 8E   002E               ldx    #WZPHY  EFD6 5F                      clrb  EFD7                         trfr   B,F  EFD7 1F                      fcb    $1f  EFD8 9F                      fcb    B<<4|F                               endm  EFD9 EC   E4                 ldd    0,s  EFDB BD   EDB4               jsr    bytewr  EFDE 35   D6                 puls   d,x,u,pc                                          *                     * GCRVERS, get byte from common registers socket version register                     * return byte in B                     *  EFE0 34   56       GCRVERS   pshs   d,x,u  EFE2 8E   0039               ldx    #WZVERS  EFE5 5F                      clrb  EFE6                         trfr   B,F  EFE6 1F                      fcb    $1f  EFE7 9F                      fcb    B<<4|F                               endm  EFE8 BD   ED56               jsr    byterd  EFEB ED   E4                 std    0,s  EFED 35   D6                 puls   d,x,u,pc                     *                     * all functions to access socket registers                     *                                          * socket register names and offsets               0000  SNMR      equ    0               0001  SNCR      equ    1               0002  SNIR      equ    2               0003  SNSR      equ    3               0004  SNPORT0   equ    4               0005  SNPORT1   equ    5               0006  SNDHAR0   equ    6               0007  SNDHAR1   equ    7               0008  SNDHAR2   equ    8               0009  SNDHAR3   equ    9               000A  SNDHAR4   equ    10               000B  SNDHAR5   equ    11               000C  SNDIPR0   equ    12               000D  SNDIPR1   equ    13Task       Structure                 16:34:07  Jan 23, 2026   Page   96wzspi, basic spi routines                                          000E  SNDIPR2   equ    14               000F  SNDIPR3   equ    15               0010  SNDPOR0   equ    16               0011  SNDPOR1   equ    17               0012  SNMSSR0   equ    18               0013  SNMSSR1   equ    19               0014  SNPROTO   equ    20               0015  SNTOS     equ    21               0016  SNTTL     equ    22               001E  SNRBFSZ   equ    30               001F  SNTBFSZ   equ    31               0020  SNTXFR0   equ    32               0021  SNTXFR1   equ    33               0022  SNTXRP0   equ    34               0023  SNTXRP1   equ    35               0024  SNTXWP0   equ    36               0025  SNTXWP1   equ    37               0026  SNRXRZ0   equ    38               0027  SNRXRZ1   equ    39               0028  SNRXRP0   equ    40               0029  SNRXRP1   equ    41               002A  SNRXWP0   equ    42               002B  SNRXWP1   equ    43               002C  SNIMR     equ    44               002D  SNFRAG0   equ    45               002E  SNFRAG1   equ    46               002F  SNKATIM   equ    47                                                               *                     * all commands to access socket register set                     *                                                               *                     * GSRMR, get byte from socket registers mode register                     * E=socket#                     * return byte in B                     *  EFEF 34   16       GSRMR     psh    d,x  EFF1 BD   F2AD               jsr    tsk2rg  EFF4 8E   0000               ldx    #SNMR  EFF7 BD   ED56               jsr    byterd  EFFA ED   E4                 std    0,s  EFFC 35   96                 puls   d,x,pc                                          *                     * PSRMR, put byte B  to socket registers mode register                     * E=socket#                     *  EFFE 34   16       PSRMR     pshs   d,x  F000 BD   F2AD               jsr    tsk2rgTask       Structure                 16:34:07  Jan 23, 2026   Page   97wzspi, basic spi routines                             F003 8E   0000               ldx    #SNMR  F006 EC   E4                 ldd    0,s  F008 BD   EDB4               jsr    bytewr  F00B 35   96                 puls   d,x,pc                                          *                     * GSRCR, get bytefrom socket registers command register                     * E=socket#                     * return byte in B                     *  F00D 34   16       GSRCR     pshs   d,x  F00F BD   F2AD               jsr    tsk2rg  F012 8E   0001               ldx    #SNCR  F015 BD   ED56               jsr    byterd  F018 ED   E4                 std    0,s  F01A 35   96                 puls   d,x,pc                                          *                     * PSRCR, put byte B in socket registers command register                     * E=socket#                     *  F01C 34   16       PSRCR     pshs   d,x  F01E BD   F2AD               jsr    tsk2rg  F021 8E   0001               ldx    #SNCR  F024 EC   E4                 ldd    0,s  F026 BD   EDB4               jsr    bytewr  F029 8D   E2       01        bsr    GSRCR  F02B 5D                      tstb  F02C 26   FB                 bne    01b       wait command to be consumed  F02E E7   61                 stb    1,s       set return  F030 35   96                 puls   d,x,pc                                          *                     * GSRIR, get bytefrom socket registers interrupt register                     * E=socket#                     * return byte in B                     *  F032 34   16       GSRIR     pshs   d,x  F034 BD   F2AD               jsr    tsk2rg  F037 8E   0002               ldx    #SNIR  F03A BD   ED56               jsr    byterd  F03D ED   E4                 std    0,s  F03F 35   96                 puls   d,x,pc                                          *                     * PSRIR, put byte B in socket registers interrupt register                     * E=socket#                     *  F041 34   16       PSRIR     pshs   d,x  F043 BD   F2AD               jsr    tsk2rg  F046 8E   0002               ldx    #SNIR  F049 EC   E4                 ldd    0,sTask       Structure                 16:34:08  Jan 23, 2026   Page   98wzspi, basic spi routines                             F04B BD   EDB4               jsr    bytewr  F04E 35   96                 puls   d,x,pc                                          *                     * GSRSR, get bytefrom socket registers status register                     * E=socket#                     * return byte in B                     *  F050 34   16       GSRSR     pshs   d,x  F052 BD   F2AD               jsr    tsk2rg  F055 8E   0003               ldx    #SNSR  F058 BD   ED56               jsr    byterd  F05B ED   E4                 std    0,s  F05D 35   96                 puls   d,x,pc                                          *                     * GSRPORT, get word from socket registers source port                     * E=socket#                     * return word in D                     *  F05F 34   16       GSRPORT   pshs   d,x  F061 BD   F2AD               jsr    tsk2rg  F064 8E   0004               ldx    #SNPORT0  F067 BD   ED68               jsr    wordrd  F06A ED   E4                 std    0,s  F06C 35   96                 pul    d,x,pc                                          *                     * PSRPORT, put word D into socket registers source port                     * E=socket#                     *  F06E 34   16       PSRPORT   pshs   d,x  F070 BD   F2AD               jsr    tsk2rg  F073 8E   0004               ldx    #SNPORT0  F076 EC   E4                 ldd    0,s  F078 BD   EDC3               jsr    wordwr  F07B 35   96                 puls   d,x,pc                                          *                     * GSRDHAR, get destination hardware address into [Y]                     * F=sockt#, Y=destination                     *  F07D 34   16       GSRDHAR   pshs   d,x  F07F BD   F2AD               jsr    tsk2rg  F082 8E   0006               ldx    #SNDHAR0  F085 BD   ED68               jsr    wordrd  F088 ED   A4                 std    0,y  F08A 8E   0008               ldx    #SNDHAR2  F08D BD   ED68               jsr    wordrd  F090 ED   22                 std    2,y  F092 8E   000A               ldx    #SNDHAR4  F095 BD   ED68               jsr    wordrdTask       Structure                 16:34:08  Jan 23, 2026   Page   99wzspi, basic spi routines                             F098 ED   24                 std    4,y  F09A 35   96                 puls   d,x,pc                                          *                     * PSRDHAR, put [Y] into destination hardware address                     * F=sockt#, Y=destination                     *  F09C 34   16       PSRDHAR   pshs   d,x  F09E BD   F2AD               jsr    tsk2rg  F0A1 8E   0006               ldx    #SNDHAR0  F0A4 EC   A4                 ldd    0,y  F0A6 BD   EDC3               jsr    wordwr  F0A9 8E   0008               ldx    #SNDHAR2  F0AC EC   22                 ldd    2,y  F0AE BD   EDC3               jsr    wordwr  F0B1 8E   000A               ldx    #SNDHAR4  F0B4 EC   24                 ldd    4,y  F0B6 BD   EDC3               jsr    wordwr  F0B9 35   96                 puls   d,x,pc                                          *                     * GSRDIP. get destination IP address into [Y]                     * E=socket#                     *  F0BB 34   16       GSRDIP    pshs   d,x  F0BD BD   F2AD               jsr    tsk2rg  F0C0 8E   000C               ldx    #SNDIPR0  F0C3 BD   ED68               jsr    wordrd  F0C6 ED   A4                 std    0,y  F0C8 8E   000E               ldx    #SNDIPR2  F0CB BD   ED68               jsr    wordrd  F0CE ED   22                 std    2,y  F0D0 35   96                 puls   d,x,pc                                          *                     * PSRDIP. put destination IP address into [Y]                     * E=socket#                     *  F0D2 34   16       PSRDIP    pshs   d,x  F0D4 BD   F2AD               jsr    tsk2rg  F0D7 8E   000C               ldx    #SNDIPR0  F0DA EC   A4                 ldd    0,y  F0DC BD   EDC3               jsr    wordwr  F0DF 8E   000E               ldx    #SNDIPR2  F0E2 EC   22                 ldd    2,y  F0E4 BD   EDC3               jsr    wordwr  F0E7 35   96                 puls   d,x,pc                                          *                     * GSRDPOR, get word from socket registers destination port                     * E=socket#                     * return word in DTask       Structure                 16:34:08  Jan 23, 2026   Page  100wzspi, basic spi routines                                                *  F0E9 34   16       GSRDPOR   pshs   d,x  F0EB BD   F2AD               jsr    tsk2rg  F0EE 8E   0010               ldx    #SNDPOR0  F0F1 BD   ED68               jsr    wordrd  F0F4 ED   E4                 std    0,s  F0F6 35   96                 pul    d,x,pc                                          *                     * PSRDPOR, put word D into socket registers destination port                     * E=socket#                     *  F0F8 34   16       PSRDPOR   pshs   d,x  F0FA BD   F2AD               jsr    tsk2rg  F0FD 8E   0010               ldx    #SNDPOR0  F100 EC   E4                 ldd    0,s  F102 BD   EDC3               jsr    wordwr  F105 35   96                 puls   d,x,pc                                          *                     * GSRMSS, get word from socket registers max segment size                     * E=socket#                     * return word in D                     *  F107 34   16       GSRMSS    pshs   d,x  F109 BD   F2AD               jsr    tsk2rg  F10C 8E   0012               ldx    #SNMSSR0  F10F BD   ED68               jsr    wordrd  F112 ED   E4                 std    0,s  F114 35   96                 pul    d,x,pc                                          *                     * PSRMSS, put word D into socket registers maximum segment size                     * E=socket#                     *  F116 34   16       PSRMSS    pshs   d,x  F118 BD   F2AD               jsr    tsk2rg  F11B 8E   0012               ldx    #SNMSSR0  F11E EC   E4                 ldd    0,s  F120 BD   EDC3               jsr    wordwr  F123 35   96                 puls   d,x,pc                                          *                     * GSRPROT, get byte from socket registers PROTOCOL                     * E=socket#                     * return byte in B                     *  F125 34   16       GSRPROT   pshs   d,x  F127 BD   F2AD               jsr    tsk2rg  F12A 8E   0014               ldx    #SNPROTO  F12D BD   ED56               jsr    byterd  F130 ED   E4                 std    0,sTask       Structure                 16:34:08  Jan 23, 2026   Page  101wzspi, basic spi routines                             F132 35   96                 pul    d,x,pc                                          *                     * PSRPROT, put byte B into socket registers PROTOCOL                     * E=socket#                     *  F134 34   16       PSRPROT   pshs   d,x  F136 BD   F2AD               jsr    tsk2rg  F139 8E   0014               ldx    #SNPROTO  F13C EC   E4                 ldd    0,s  F13E BD   EDB4               jsr    bytewr  F141 35   96                 puls   d,x,pc                                          *                     * GSRTOS, get byte from socket registers TOS                     * E=socket#                     * return byte in B                     *  F143 34   16       GSRTOS    pshs   d,x  F145 BD   F2AD               jsr    tsk2rg  F148 8E   0015               ldx    #SNTOS  F14B BD   ED56               jsr    byterd  F14E ED   E4                 std    0,s  F150 35   96                 pul    d,x,pc                                          *                     * PSRTOS, put byte B into socket registers TOS                     * E=socket#                     *  F152 34   16       PSRTOS    pshs   d,x  F154 BD   F2AD               jsr    tsk2rg  F157 8E   0015               ldx    #SNTOS  F15A EC   E4                 ldd    0,s  F15C BD   EDB4               jsr    bytewr  F15F 35   96                 puls   d,x,pc                                          *                     * GSRTTL, get byte from socket registers TTL                     * E=socket#                     * return byte in B                     *  F161 34   16       GSRTTL    pshs   d,x  F163 BD   F2AD               jsr    tsk2rg  F166 8E   0016               ldx    #SNTTL  F169 BD   ED56               jsr    byterd  F16C ED   E4                 std    0,s  F16E 35   96                 pul    d,x,pc                                          *                     * PSRTTL, put byte B into socket registers TTL                     * E=socket#                     *Task       Structure                 16:34:09  Jan 23, 2026   Page  102wzspi, basic spi routines                             F170 34   16       PSRTTL    pshs   d,x  F172 BD   F2AD               jsr    tsk2rg  F175 8E   0016               ldx    #SNTTL  F178 EC   E4                 ldd    0,s  F17A BD   EDB4               jsr    bytewr  F17D 35   96                 puls   d,x,pc                                          *                     * GSRRBFS, get byte from socket registers rec buf size                     * E=socket#                     * return byte in B                     *  F17F 34   16       GSRRBFS   pshs   d,x  F181 BD   F2AD               jsr    tsk2rg  F184 8E   001E               ldx    #SNRBFSZ  F187 BD   ED56               jsr    byterd  F18A ED   E4                 std    0,s  F18C 35   96                 pul    d,x,pc                                          *                     * PSRTBFS, put byte B into socket registers rec buf size                     * E=socket#                     *  F18E 34   16       PSRRBFS   pshs   d,x  F190 BD   F2AD               jsr    tsk2rg  F193 8E   001E               ldx    #SNRBFSZ  F196 EC   E4                 ldd    0,s  F198 BD   EDB4               jsr    bytewr  F19B 35   96                 puls   d,x,pc                                          *                     * GSRTBFS, get byte from socket registers tx buf size                     * E=socket#                     * return byte in B                     *  F19D 34   16       GSRTBFS   pshs   d,x  F19F BD   F2AD               jsr    tsk2rg  F1A2 8E   001F               ldx    #SNTBFSZ  F1A5 BD   ED56               jsr    byterd  F1A8 ED   E4                 std    0,s  F1AA 35   96                 puls   d,x,pc                                          *                     * PSRTBFS, put byte B into socket registers tx buf size                     * E=socket#                     *  F1AC 34   16       PSRTBFS   pshs   d,x  F1AE BD   F2AD               jsr    tsk2rg  F1B1 8E   001F               ldx    #SNTBFSZ  F1B4 EC   E4                 ldd    0,s  F1B6 BD   EDB4               jsr    bytewr  F1B9 35   96                 puls   d,x,pcTask       Structure                 16:34:09  Jan 23, 2026   Page  103wzspi, basic spi routines                                                                     *                     * GSRTXFR, get word from socket registers TX free size                     * E=socket#                     * return word in D                     *  F1BB 34   16       GSRTXFR   pshs   d,x  F1BD BD   F2AD               jsr    tsk2rg  F1C0 8E   0020               ldx    #SNTXFR0  [R]  F1C3 BD   ED68               jsr    wordrd  F1C6 ED   E4       01        std    0,s  F1C8 BD   ED68               jsr    wordrd  F1CB 10A3 E4                 cmpd   0,s       read more times and exit  F1CE 26   F6                 bne    01b       when 2 reads are equal  F1D0 35   96                 puls   d,x,pc                                          *                     * GSRTXRP, get word from socket registers TX read pointer                     * E=socket#                     * return word in D                     *  F1D2 34   16       GSRTXRP   pshs   d,x  F1D4 BD   F2AD               jsr    tsk2rg  F1D7 8E   0022               ldx    #SNTXRP0  [R]  F1DA BD   ED68               jsr    wordrd  F1DD ED   E4       01        std    0,s  F1DF BD   ED68               jsr    wordrd  F1E2 10A3 E4                 cmpd   0,s       read more times and exit  F1E5 26   F6                 bne    01b       when 2 reads are equal  F1E7 35   96                 puls   d,x,pc                                          *                     * GSRTXWP, get word from socket registers TX write pointer                     * E=socket#                     * return word in D                     *  F1E9 34   16       GSRTXWP   pshs   d,x  F1EB BD   F2AD               jsr    tsk2rg  F1EE 8E   0024               ldx    #SNTXWP0  [RW]  F1F1 BD   ED68               jsr    wordrd  F1F4 ED   E4                 std    0,s  F1F6 35   96                 puls   d,x,pc                                          *                     * PSRTXWP, put word D into socket registers TX write pointer                     * E=socket#                     *  F1F8 34   16       PSRTXWP   pshs   d,x  F1FA BD   F2AD               jsr    tsk2rg  F1FD 8E   0024               ldx    #SNTXWP0  F200 EC   E4                 ldd    0,s  F202 BD   EDC3               jsr    wordwrTask       Structure                 16:34:09  Jan 23, 2026   Page  104wzspi, basic spi routines                             F205 35   96                 puls   d,x,pc                                          *                     * GSRRXRS, get word from socket registers RX received size                     * E=socket#                     * return word in D                     *  F207 34   16       GSRRXRS   pshs   d,x  F209 BD   F2AD               jsr    tsk2rg  F20C 8E   0026               ldx    #SNRXRZ0  [R]  F20F BD   ED68               jsr    wordrd  F212 ED   E4       01        std    0,s  F214 BD   ED68               jsr    wordrd  F217 10A3 E4                 cmpd   0,s       read more times and exit  F21A 26   F6                 bne    01b       when 2 reads are equal  F21C 35   96                 puls   d,x,pc                                          *                     * GSRRXRP, get word from socket registers RX read pointer                     * E=socket#                     * return word in D                     *  F21E 34   16       GSRRXRP   pshs   d,x  F220 BD   F2AD               jsr    tsk2rg  F223 8E   0028               ldx    #SNRXRP0  [RW]  F226 BD   ED68               jsr    wordrd  F229 ED   E4                 std    0,s  F22B 35   96                 puls   d,x,pc                                          *                     * PSRRXRP, put word D into socket registers RX read pointer                     * E=socket#                     *  F22D 34   16       PSRRXRP   pshs   d,x >F22F BD   F2AD               jsr    tsk2rg  F232 8E   0028               ldx    #SNRXRP0  F235 EC   E4                 ldd    0,s  F237 BD   EDC3               jsr    wordwr  F23A 35   96                 puls   d,x,pc                                          *                     * GSRRXWP, get word from socket registers RX write pointer                     * E=socket#                     * return word in D                     *  F23C 34   16       GSRRXWP   pshs   d,x >F23E BD   F2AD               jsr    tsk2rg  F241 8E   002A               ldx    #SNRXWP0  [R]  F244 BD   ED68               jsr    wordrd  F247 ED   E4       01        std    0,s  F249 BD   ED68               jsr    wordrd  F24C 10A3 E4                 cmpd   0,s       read more times and exitTask       Structure                 16:34:10  Jan 23, 2026   Page  105wzspi, basic spi routines                             F24F 26   F6                 bne    01b       when 2 reads are equal  F251 35   96                 puls   d,x,pc                                          *                     * GSRIMR, get byte from socket registers interrupt mask                     * E=socket#                     * return byte in B                     *  F253 34   16       GSRIMR    pshs   d,x >F255 BD   F2AD               jsr    tsk2rg  F258 8E   002C               ldx    #SNIMR  F25B BD   ED56               jsr    byterd  F25E ED   E4                 std    0,s  F260 35   96                 puls   d,x,pc                                          *                     * PSRIMS, put byte B into socket registers interrupt mask                     * E=socket#                     *  F262 34   16       PSRIMR    pshs   d,x >F264 BD   F2AD               jsr    tsk2rg  F267 8E   002C               ldx    #SNIMR  F26A EC   E4                 ldd    0,s  F26C BD   EDB4               jsr    bytewr  F26F 35   96                 puls   d,x,pc                                          *                     * GSRFRAG, get word from socket registers FRAG                     * E=socket#                     * return word in D                     *  F271 34   16       GSRFRAG   pshs   d,x >F273 BD   F2AD               jsr    tsk2rg  F276 8E   002D               ldx    #SNFRAG0  F279 BD   ED68               jsr    wordrd  F27C ED   E4                 std    0,s  F27E 35   96                 puls   d,x,pc                                          *                     * PSRGRAG, put word D into socket registers FRAG                     * E=socket#                     *  F280 34   16       PSRFRAG   pshs   d,x >F282 BD   F2AD               jsr    tsk2rg  F285 8E   002D               ldx    #SNFRAG0  F288 EC   E4                 ldd    0,s  F28A BD   EDC3               jsr    wordwr  F28D 35   96                 puls   d,x,pc                                          *                     * GSRKATM, get byte from socket registers keep alive timer                     * E=socket#Task       Structure                 16:34:10  Jan 23, 2026   Page  106wzspi, basic spi routines                                                * return byte in B                     *  F28F 34   16       GSKATM    pshs   d,x >F291 BD   F2AD               jsr    tsk2rg  F294 8E   002F               ldx    #SNKATIM  F297 BD   ED56               jsr    byterd  F29A ED   E4                 std    0,s  F29C 35   96                 puls   d,x,pc                                          *                     * PSRKATM, put byte B into socket registers keep alive timer                     * E=socket#                     *  F29E 34   16       PSRKATM   pshs   d,x >F2A0 BD   F2AD               jsr    tsk2rg  F2A3 8E   002F               ldx    #SNKATIM  F2A6 EC   E4                 ldd    0,s  F2A8 BD   EDB4               jsr    bytewr  F2AB 35   96                 puls   d,x,pc                     *                     * data handling routines                     *                                          * translate socket register in partial address                     * prepares bits [7...5][4...3]                     * E=socket#, F=lost, B=lost               F2AD  tsk2rg    equ    *  F2AD                         trfr   E,B  F2AD 1F                      fcb    $1f  F2AE E9                      fcb    E<<4|B                               endm  F2AF 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F2B0 1C   FE                 clc              make reg bits + '01'  F2B2 59                      rolb             socket register  F2B3 1A   01                 sec  F2B5 59                      rolb             xxx 01 ...                     *  F2B6                         trfr   B,F  F2B6 1F                      fcb    $1f  F2B7 9F                      fcb    B<<4|F                               endm  F2B8 39                      rts                                          *                     * translate socket register in final address (data xfer)                     * prepares bit [7...0]                     *               F2B9  tsk2tx    equ    *  F2B9                         trfr   E,B  F2B9 1F                      fcb    $1f  F2BA E9                      fcb    E<<4|BTask       Structure                 16:34:10  Jan 23, 2026   Page  107wzspi, basic spi routines                                                          endm  F2BB 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F2BC 1A   01                 sec              make reg bits + '10'  F2BE 59                      rolb             sock TX buffer  F2BF 1C   FE                 clc  F2C1 59                      rolb                     *  F2C2 1A   01                 sec  F2C4 59                      rolb             write bit     '1'                     *  F2C5 58                      lslb             variable size '00'  F2C6 58                      lslb             xxx 10 100                     *  F2C7 39                      rts                                          *                     * translate socket register in rx buffer address (data xfer)                     * prepares bit [7...0]                     *               F2C8  tsk2rx    equ    *  F2C8                         trfr   E,B  F2C8 1F                      fcb    $1f  F2C9 E9                      fcb    E<<4|B                               endm  F2CA 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F2CB 1A   01                 sec              make reg bits + '11'  F2CD 59                      rolb             sock RX buffer  F2CE 1A   01                 sec              make reg bits + '11'  F2D0 59                      rolb                     *  F2D1 1C   FE                 clc  F2D3 59                      rolb             read bit     '0'                     *  F2D4 58                      lslb             variable size '00'  F2D5 58                      lslb             xxx 11 000  F2D6 39                      rts                                          *                     * rdsk2fb, read socket data in fifo buffer                     * Y=target, U=sock info                     * E=socket#                     * entry D= available count                     * return, D=xferred count                     *  F2D7 34   76       RDSK2FB   pshs   d,x,y,u                     *  F2D9 10A3 4A                 cmpd   wzrqln,u  has fio max size incorporated  F2DC 23   02                 bls    01f  F2DE EC   4A                 ldd    wzrqln,u  mandatory size  F2E0 1F   01       01        tfr    D,X       save for laterTask       Structure                 16:34:11  Jan 23, 2026   Page  108wzspi, basic spi routines                             F2E2 ED   E4                 std    0,s       save xfrerred old  D  F2E4 ED   48                 std    wzxfer,u  F2E6 27   3B                 beq    15f       no data                     *  F2E8 BD   F21E               jsr    GSRRXRP  F2EB 34   06                 pshs   d         save socket read pointer [5,6]  F2ED 1F   02                 tfr    D,Y                     *  F2EF CE   8080               ldu    #SPIBASE  F2F2 34   01                 pshs   cc        [4]  F2F4                         pshsw  [2,3]  F2F4 1038                    fdb    $1038                               endm  F2F6 34   40                 pshs   u         [0,1]  F2F8 1A   50                 orcc   #$50      disable interrupts  F2FA 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT set CS low  F2FC A7   C4                 sta    spicmd,u  F2FE 10AF 44                 sty    hibyta,u  start address                      >F301 BD   F2C8               jsr    tsk2rx    SOCK# to buffer address                       F304 E7   44                 stb    hibyta,u  F306 10AE 6B                 ldy    11,s      target  F309 E7   44                 stb    hibyta,u  shift out first data byte  F30B 33   45                 leau   lobyta,u  lobyte is the first byte shifted in  F30D                         trfr   X,W  F30D 1F                      fcb    $1f  F30E 16                      fcb    X<<4|W                               endm  F30F                         tfm4   U,Y  F30F 113B                    fdb    $113b  F311 32                      fcb    U<<4|Y                               endm  F312 35   40                 puls   u         [0,1]  F314 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  F316 A7   C4                 sta    spicmd,u  F318                         pulsw  restore   E:F              [2,3]  F318 1039                    fdb    $1039                               endm  F31A 35   01                 puls   cc        [4]                     *  F31C 35   06                 puls   d         old read pointer         [5,6]  F31E E3   E4                 addd   0,s       adjust transferred  F320 BD   F22D               jsr    PSRRXRP   update pointer                     *  F323 35   F6       15        puls   d,x,y,u,pc                                                               *                     * wrfb2sk,write fifo buffer to socket buffer                     * Y=target                     * E=socket#Task       Structure                 16:34:11  Jan 23, 2026   Page  109wzspi, basic spi routines                                                * on entry D= total amount to xfer                     * on return D= xferred count                     *  F325 34   76       WRFB2SK   pshs   d,x,y,u  F327 10A3 4A                 cmpd   wzrqln,u  has fio max size incorporated  F32A 23   02                 bls    01f  F32C EC   4A                 ldd    wzrqln,u  F32E 1F   01       01        tfr    d,x  F330 ED   E4                 std    0,s  F332 ED   48                 std    wzxfer,u  report size  F334 27   57                 beq    15f                     *  F336 10AE C8 22              ldy    wzuwrp,u  0 if not UDP or never written  F33A 26   05                 bne    24f  F33C BD   F1E9               jsr    GSRTXWP   get write pointer  F33F 20   02                 bra    25f  F341 1F   20       24        tfr    y,d                     *  F343 34   06       25        pshs   d  F345 1F   02                 tfr    D,Y                     *  F347 CE   8080               ldu    #SPIBASE  F34A 34   01                 pshs   cc  F34C                         pshsw  save      E:F  F34C 1038                    fdb    $1038                               endm  F34E 34   40                 pshs   u  F350 1A   50                 orcc   #$50  F352 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT set CS low  F354 A7   C4                 sta    spicmd,u  F356 10AF 44                 sty    hibyta,u  start address                       F359 BD   F2B9               jsr    tsk2tx                       F35C E7   44                 stb    hibyta,u  F35E 10AE 6B                 ldy    11,s      target  F361 33   44                 leau   hibyta,u  the first to shift out  F363                         trfr   X,W  F363 1F                      fcb    $1f  F364 16                      fcb    X<<4|W                               endm  F365                         tfm3   Y,U  F365 113A                    fdb    $113a  F367 23                      fcb    Y<<4|U                               endm  F368 35   40                 puls   u  F36A 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  F36C A7   C4                 sta    spicmd,u  F36E                         pulsw  restore   E:F!!  F36E 1039                    fdb    $1039                               endm  F370 35   01                 puls   ccTask       Structure                 16:34:11  Jan 23, 2026   Page  110wzspi, basic spi routines                                                *  F372 35   06                 puls   d         old write pointer  F374 E3   E4                 addd   0,s  F376 EE   66                 ldu    6,s       restore U  F378 AE   C8 26              ldx    wztype,u  F37B 8C   0002               cmpx   #SK_DGRM  F37E 27   0A                 beq    10f  F380 8C   0004               cmpx   #SK_IRAW  F383 27   05                 beq    10f  F385 BD   F1F8     11        jsr    PSRTXWP   update pointer  F388 20   03                 bra    15f                       F38A ED   C8 22    10        std    wzuwrp,u  set RAM pointer                     *                     *  F38D 35   F6       15        puls   d,x,y,u,pcTask       Structure                 16:34:12  Jan 23, 2026   Page  111Debug Interface Routines                                                   F38F               DB_main  F38F 8D   4F                 bsr    DB_test   see if debug routines present  F391 6E   9F C002            jmp    [DEBUGROM+2]  F395               DB_pdata  F395 8D   49                 bsr    DB_test   see if debug routines present  F397 6E   9F C004            jmp    [DEBUGROM+4]  F39B               DB_phex  F39B 8D   43                 bsr    DB_test   see if debug routines present  F39D 6E   9F C006            jmp    [DEBUGROM+6]  F3A1               DB_phex2  F3A1 8D   3D                 bsr    DB_test   see if debug routines present  F3A3 6E   9F C008            jmp    [DEBUGROM+8]  F3A7               DB_pcrlf  F3A7 8D   37                 bsr    DB_test   see if debug routines present  F3A9 6E   9F C00A            jmp    [DEBUGROM+10]  F3AD               DB_check  F3AD 8D   31                 bsr    DB_test   see if debug routines present  F3AF 6E   9F C00C            jmp    [DEBUGROM+12]  F3B3               DB_config  F3B3 8D   2B                 bsr    DB_test   see if debug routines present  F3B5 6E   9F C00E            jmp    [DEBUGROM+14]  F3B9 34   17       DB_msg    pshs   cc,d,x  F3BB AE   65                 ldx    1+2+2,s   get return address  F3BD EC   81                 ldd    ,x++      get mask word  F3BF B4   0401               anda   DB_cntrl  F3C2 F4   0402               andb   DB_cntrl+1  F3C5 34   04                 pshs   b  F3C7 AA   E0                 ora    ,s+  F3C9 27   04                 beq    10f       jump if flag not set  F3CB 30   02                 leax   2,x       skip over false address & fall through  F3CD 20   02                 bra    20f  F3CF AE   84       10        ldx    ,x        get false branch label  F3D1 AF   65       20        stx    1+2+2,s   fix up return address  F3D3 35   97                 puls   cc,d,x,pc return                     *  F3D5               DB_pspace  F3D5               DB_outsp  F3D5 34   16                 pshs   d,x  F3D7 8E   F3DE               ldx    #00f  F3DA 8D   B9                 bsr    DB_pdata  F3DC 35   96                 puls   d,x,pc  F3DE 20 00         00        fcc    ' ',0                       F3E0 34   07       DB_test   pshs   cc,d  F3E2 FC   C000               ldd    DEBUGROM  Debug rom present?  F3E5 1083 1234               cmpd   #$1234    special marker  F3E9 27   05                 beq    99f       yes - exit  F3EB 35   07                 puls   cc,d      no - abort DB_xx function  F3ED 32   62                 leas   2,s  F3EF 39                      rts  F3F0 35   87       99        puls   cc,d,pc   returnTask       Structure                 16:34:12  Jan 23, 2026   Page  112Debug Interface Routines                                                 *                     * nwpspecial, routines that communicate a bit differently                     *                                                                                                                              *********************************************************************                     *                     * memp2ff, mem pointer to fifo                     * copy 512 bytes addressed by fifo_us3 to fifo                     *                     * X=taskstruct                     * U=wzsock address                     *                     *                     *********************************************************************               F3F2  memp2ff   equ    *  F3F2 DC   1E                 ldd    fifo_us3  get address  F3F4 1F   98                 tfr    b,a  F3F6 5F                      clrb  F3F7 48                      lsla             512 byte chunks  F3F8 1F   01                 tfr    d,x  F3FA FC   E074               ldd    fio_fsz  F3FD                         trfr   D,W  F3FD 1F                      fcb    $1f  F3FE 06                      fcb    D<<4|W                               endm  F3FF 108E 0020               ldy    #fifo  F403                         tfm1   X,Y  F403 1138                    fdb    $1138  F405 12                      fcb    X<<4|Y                               endm  F406 4F                      clra  F407 C6   05                 ldb    #R_RDOK  F409 39                      rts                                                         F40A  netboot   equ    *  F40A 39                      rts                                          ****************************************************************                     *                     * placeholder                     *                     ****************************************************************  FC00                         org    $fc00     command F8 only works with 512 boundaries! >FC00 16   0015     nboot     lbra   nboot1  FC03 0D            names     fcb    $0d  FC04 75 6E 69 66             fcc    "uniflexn"  FC0C 0000 0000               fdb    0,0,0,0,0,0Task       Structure                 16:34:12  Jan 23, 2026   Page  113Debug Interface Routines                                                   FC18 30   8C E8    nboot1    leax   names,pcr  FC1B AD   9F F80A            jsr    [$f80a]  FC1F 3F                      swi                                                               ****************************************************************                                                                         end    rom_initTask       Structure                 16:34:13  Jan 23, 2026   Page  114Debug Interface Routines                            Symbol Table:Absolute Symbols:A        0008   AF_INET  0002   AF_UNIX  0001   AF_UNSP  0000   B        0009   BUFSIZ   0200   CC       000A   CFLAG    0001   CI_CFL   0080   CI_MP    0010   CI_POC   0020   CI_UNR   0040   CPU2DEV  0022   CPU_down E057   CPUtraps FFF0   CR       000D   D        0000   DBG_8274 0002   DBG_CMD  0100   DBG_HAN  0020   DBG_INIT 0400   DBG_INT  0004   DBG_IO   0010   DBG_MSG  0200   DBG_OPEN 0800   DBG_SLP  0040   DBG_SYS  0001   DBG_TASK 0080   DBG_TRMI 0008   DB_check F3AD   DB_cntrl 0401   DB_confi F3B3   DB_iflg  0400   DB_main  F38F   DB_msg   F3B9   DB_outsp F3D5   DB_pcrlf F3A7   DB_pdata F395   DB_phex  F39B   DB_phex2 F3A1   DB_pspac F3D5   DB_test  F3E0   DBmsg00  E012   DBmsg01  E023   DBmsg02  E043   DEBUG    0D04   DEBUGROM C000   DEBUG_CO 0000   DEV2CPU  0021   DEV_SIZE 0006   DEV_SOCK E539   DO_HISTO 0000   DP       000B   DPR_BASE 0000   D_END    0046   D_func0  0000   D_func1  0002   D_func10 0020   D_func11 0022   D_func12 0024   D_func13 0026   D_func14 0028   D_func15 002A   D_func16 002C   D_func17 002E   D_func18 0030   D_func19 0032   D_func1A 0034   D_func1B 0036   D_func1C 0038   D_func1D 003A   D_func1E 003C   D_func1F 003E   D_func2  0004   D_func3  0006   D_func4  0008   D_func5  000A   D_func6  000C   D_func7  000E   D_func8  0010   D_func9  0012   D_funcA  0014   D_funcB  0016   D_funcC  0018   D_funcD  001A   D_funcE  001C   D_funcF  001E   D_init   0042   D_inthan 0040   D_test   0044   E        000E   ESDNOI   000A   ESDNOTI  0001   ESDSTPN  000E   ESIMPRO  000F   ESIPAIN  000B   ESNOIMP  00FF   ESRSPCE  00A1   ESSKSTE  0082   ESTYPER  0002   E_ABORT  00BF   E_BADCMD 0081   E_BADDEV 0084   E_DEVBSY 0085   E_INTRPT 00BE   E_IOERR  0086   E_NTOPEN 0083   E_SOCKET 00C0   E_SYSBSY 0082   F        000F   FF       0040   FIFO_get E288   FIFO_put E2AD   FIFOgeta E27F   FIFOputa E2A5   FIOPRI   FFCE   FIO_get  E25D   FIO_lock 0446   FIO_rel  E272   GCRGA    EE02   GCRILLT  EECA   GCRIMR   EF06   GCRIR    EEE8   GCRMR    EDE4   GCRPHY   EFC2   GCRRCR   EF7E   GCRRTR   EF60   GCRSHA   EE5E   GCRSIMR  EF42   GCRSIP   EE9C   GCRSIR   EF24   GCRSNM   EE30   GCRUIP   EFAB   GCRURP   EF9C   GCRVERS  EFE0   GSKATM   F28F   GSRCR    F00D   GSRDHAR  F07D   GSRDIP   F0BB   GSRDPOR  F0E9   GSRFRAG  F271   GSRIMR   F253   GSRIR    F032   GSRMR    EFEF   GSRMSS   F107   GSRPORT  F05F   GSRPROT  F125   GSRRBFS  F17F   GSRRXRP  F21E   GSRRXRS  F207   GSRRXWP  F23C   GSRSR    F050   GSRTBFS  F19D   GSRTOS   F143   GSRTTL   F161   GSRTXFR  F1BB   GSRTXRP  F1D2   GSRTXWP  F1E9   HANGS    0001   IF       0010   INTS     0002   IO_end   E3A4   IO_han   E33A   IRQ_han  E3C2   IRQmsg10 E3CF   IS       0003   IU       0002   IX       0000   IY       0001   LF       000A   MAXTBL   0003   MAX_DEV  0001   MAX_FCMD 0020   MAX_S_NU 0020   MAX_TI   0009   MAX_UDP  05C0   MAX_WZ   0008   MOD_SIZE 0004   NBRQLN   0004   NBSIZE   0204   NET      0001   NFLAG    0008   NUM_TSK  040C   O_CLOSE  0010   O_INTRPT 0038   O_OPEN   0008   O_PGETD  0058   O_PSETD  0060   O_READ   0030   O_RQRD   0028   O_RQWR   0018   O_TTYG   0050   O_TTYS   0048   O_WR1C   0040   O_WRITE  0020   PACK_COM 0000   PACK_FIR 0080   PACK_REM 0001   PC       0005   PCRGA    EE19   PCRILLT  EED9   PCRIMR   EF15   PCRIR    EEF7   PCRMR    EDF3   PCRPHY   EFD1   PCRRCR   EF8D   PCRRTR   EF6F   PCRSHA   EE7D   PCRSIMR  EF51   PCRSIP   EEB3   PCRSIR   EF33   PCRSNM   EE47   PF_INET  0002   PF_UNIX  0001   PIPES    0006   POLPRI   FFBA   PROT_EGP 0008   PROT_ICM 0001   PROT_IGM 0002   PROT_XLT 8000   PSRCR    F01C   PSRDHAR  F09C   PSRDIP   F0D2   PSRDPOR  F0F8   PSRFRAG  F280   Task       Structure                 16:34:13  Jan 23, 2026   Page  115Debug Interface Routines                            PSRIMR   F262   PSRIR    F041   PSRKATM  F29E   PSRMR    EFFE   PSRMSS   F116   PSRPORT  F06E   PSRPROT  F134   PSRRBFS  F18E   PSRRXRP  F22D   PSRTBFS  F1AC   PSRTOS   F152   PSRTTL   F170   PSRTXWP  F1F8   QFF1     0080   QUITS    0003   RAMend   3EFF   RAMorg   0400   RAMscrat 7000   RAMscren 7E00   RDSK2FB  F2D7   REJECT   0080   ROMLOorg E000   ROM_ERR  E0E1   ROM_VERS 0020   ROMstack 7FE0   RSVREG   0003   RUNPRI   0046   R_ACCEPT 000B   R_BIND   0009   R_CLOCK  000E   R_CLOSE  0002   R_CONNEC 0008   R_DISCON 000C   R_ERRBLK 0084   R_INTRPT 0007   R_LISTEN 000A   R_OPEN   0001   R_PDATA  000B   R_POLLRD 0026   R_RD1C   0009   R_RDFRM  0021   R_RDOK   0005   R_RDRBLK 0083   R_READ   0006   R_READM  000C   R_REQOK  0003   R_RESET  000F   R_RQRBLK 0082   R_RQRD   0005   R_RQRDNB 0015   R_RQSBLK 0080   R_RQWR   0003   R_RQWRNB 0013   R_RRDFD  0022   R_RSNDTO 0023   R_SNDBLK 0081   R_SNDKEP 000E   R_SNDMAC 000D   R_SNDTOM 0025   R_SPCL   000F   R_TTY    000D   R_WR1C   0008   R_WRITE  0004   R_WSNDTO 0024   S        0004   SIQPRI   FFD8   SI_CON   0001   SI_DIS   0002   SI_HAN   E418   SI_Q     040E   SI_Q_ptr 0444   SI_RCV   0004   SI_SOK   0010   SI_TIM   0008   SKADLN   0010   SKPRI    FFC4   SK_DGRM  0002   SK_IRAW  0004   SK_MRAW  0003   SK_NONBL 0100   SK_SPONC 0200   SK_STRM  0001   SNCR     0001   SNDHAR0  0006   SNDHAR1  0007   SNDHAR2  0008   SNDHAR3  0009   SNDHAR4  000A   SNDHAR5  000B   SNDIPR0  000C   SNDIPR1  000D   SNDIPR2  000E   SNDIPR3  000F   SNDPOR0  0010   SNDPOR1  0011   SNFRAG0  002D   SNFRAG1  002E   SNIMR    002C   SNIR     0002   SNKATIM  002F   SNMR     0000   SNMSSR0  0012   SNMSSR1  0013   SNPORT0  0004   SNPORT1  0005   SNPROTO  0014   SNRBFSZ  001E   SNRXRP0  0028   SNRXRP1  0029   SNRXRZ0  0026   SNRXRZ1  0027   SNRXWP0  002A   SNRXWP1  002B   SNSR     0003   SNTBFSZ  001F   SNTOS    0015   SNTTL    0016   SNTXFR0  0020   SNTXFR1  0021   SNTXRP0  0022   SNTXRP1  0023   SNTXWP0  0024   SNTXWP1  0025   SPIBASE  8080   SPI_AUT  0008   SPI_CR_  0001   SPI_CS_  0040   SPI_HLD  0002   SPI_IEN  0010   SPI_IRQ  0001   SPI_RST  0020   SPI_SR_  0004   SP_EGP   0008   SP_GMP   0002   SP_ICMP  0001   SP_TCP   0006   SP_UDP   0011   S_ACCEPT 0058   S_BIND   0048   S_CLOSE  0010   S_CONNEC 0040   S_DISCON 0060   S_INTRPT 0038   S_LISTEN 0050   S_NETBOO 00F0   S_OPEN   0008   S_PG2FIF 00F8   S_POLLRD 00A8   S_RDRBLK 00D8   S_READ   0030   S_RQRBLK 00D0   S_RQRD   0028   S_RQSBLK 00C0   S_RQWR   0018   S_RRDFRM 0080   S_RREAD  0088   S_SNDBLK 00C8   S_SNDKEP 0070   S_SNDMAC 0068   S_SPCL   0078   S_WRITE  0020   S_WRQSTO 0090   S_WSNDTM 00A0   S_WSNDTO 0098   TFREE    0004   TRUN     0001   TSKSIZ   00D8   TSLEEP   0002   TSYS     0005   TWAIT    0003   U        0003   USTSIZ   00C0   V        0007   VFLAG    0002   W        0006   WCACCP   0086   WCBIND   0085   WCCLOS   0010   WCCONN   0004   WCDISC   0008   WCLIST   0002   WCOPEN   0001   WCRECV   0040   WCRRQD   0081   WCSEND   0020   WCSKEP   0022   WCSNAC   0021   WCSPEC   0080   WCXMDR   0082   WFNBLK   0001   WFSHNGC  0004   WFSPOC   0002   WRFB2SK  F325   WSCLSD   0000   WSCLSG   001A   WSCLWT   001C   WSESTB   0017   WSFWAI   0018   WSINIT   0013   WSIRAW   0032   WSLACK   001D   WSLIST   0014   WSMRAW   0042   WSRNBL   001E   WSRRQF   0081   WSSPEC   0080   WSSYNR   0016   WSSYNS   0015   WSTIMW   001B   WSUDP    0022   WSWNBL   001F   WSXMDD   0082   WZ5_name E1E3   WZBUSY   0080   WZGAR0   0001   WZGAR1   0002   WZGAR2   0003   WZGAR3   0004   WZILLT0  0013   WZILLT1  0014   WZIMR    0016   WZIR     0015   WZLCSZ   0016   WZMR     0000   WZNETOF  0370   WZPHY    002E   WZRCR    001B   WZRTR0   0019   WZRTR1   001A   WZSHAR0  0009   WZSHAR1  000A   WZSHAR2  000B   WZSHAR3  000C   WZSHAR4  000D   WZSHAR5  000E   WZSIMR   0018   WZSIPR0  000F   WZSIPR1  0010   WZSIPR2  0011   WZSIPR3  0012   WZSIR    0017   WZSIZE   002A   WZSKOFF  0220   WZSLCK   0001   WZSUBR0  0005   WZSUBR1  0006   WZSUBR2  0007   WZSUBR3  0008   WZUIPR0  0028   WZUIPR1  0029   WZUIPR2  002A   WZUIPR3  002B   WZUPRT0  002C   WZUPRT1  002D   WZVERS   0039   WZWBND   0040   WZWLCK   0010   X        0001   Y        0002   Z0       000C   Task       Structure                 16:34:14  Jan 23, 2026   Page  116Debug Interface Routines                            Z1       000D   ZFLAG    0004   bad_cmd  E3BF   bittab   E6DD   bmread   ED7A   bt2num   E6CC   byterd   ED56   bytewr   EDB4   chproc   040A   clock_ti 0457   conlb1   E786   cpu_fio  0000   cpu_fio1 0001   cpu_fio2 0003   cpu_fio3 0004   cpu_fio4 0006   cpu_fio5 0008   cpu_fioF 0024   dev_addr 0000   dev_brbu 0004   dev_tab  045B   dev_type 0002   end_vars 3EFF   fifo     0020   fifo_cnt 0012   fifo_get 0014   fifo_put 0016   fifo_us0 0018   fifo_us1 001A   fifo_us2 001C   fifo_us3 001E   fio_cpu  0009   fio_cpu1 000A   fio_cpu2 000C   fio_cpu3 000D   fio_cpu4 000F   fio_cpu5 0011   fio_cpuF 0023   fio_dsz  E076   fio_fsz  E074   fio_irq  E2C8   fio_msg  E225   fio_rese E1EE   fio_resp E241   fio_star E0A9   fio_wait E211   fiointe  E339   functb   EC7E   gtsktb   E491   hibyta   0004   hibyts   0006   idle     040D   int_all  E3E7   int_buf  0447   int_ptr  0455   jobpri   0409   lobyta   0005   lobyts   0007   lstram   1129   makrd6   E4C5   makrdy   E4BC   max_trn  E078   memp2ff  F3F2   mod_name 0002   mod_tbl  E1DD   mod_type 0000   names    FC03   nboot    FC00   nboot1   FC18   netboot  F40A   no_dev   E161   num2bt   E6C2   nwp_strt 0000   oldorg   ED22   polext   E7A4   rdrqer1  E8F1   rom_bad  E0DF   rom_firq E0B2   rom_init E07B   rom_int  E0D4   rom_nmi  E0AC   rom_swi  E0B9   rom_swi2 E0BF   rom_swi3 E0C6   rom_trap E0CD   rsched   E47D   rsched2  E47F   sa_dat   0002   sa_fam   0000   sdev_sig E5F4   send_SI  E45A   set_tabl E11F   showrg   ECCC   sin_addr 0014   sin_fam  0010   sin_port 0012   skacpt   E84F   skbind   E7C3   skclin   E701   skclos   E6E6   skcner1  E7B9   skcner2  E7AD   skcner4  E7BD   skcner5  E7B5   skcner6  E7B1   skconn   E733   skcraw   E638   skctcp   E622   skcudp   E62B   skdisc   ED1B   skdvini  E59C   skfres   E615   skinit   E57F   skinthan E5F3   skintrp  E6E6   sklist   E814   sknbe1   EBB4   sknbe10  EC18   sknbrd   EBBB   sknbrp1  EBAE   sknbrp2  EB88   sknbrr   EB56   sknbsd   EC24   sknbsr   EBEA   sknewp   E5F7   sknone   E599   skopen   E641   skoper1  E6B8   skoper2  E6BC   skowfo   E697   skrecv   E8F6   skreqrd  E890   skreqwr  E939   sksend   E99C   skskep   ED1B   sksmac   ED1B   skspcl   EC54   sktest   E5F0   skuer1   EB19   skurrd   EA63   skurrdf  E9DE   skurwt   EA91   skusnm   EAD5   skusnt   EB1C   skuwr2   EAD5   sleep    E4EA   sleep7   E512   slplst   0403   spicmd   0000   spicon   0001   spiint   0458   spinit   ED22   spista   0000   spistr2  ED28   sprend   EDD2   stbinit  E0EE   sto_chk  E168   stptsk   E4A0   swtchu   E4B1   sys_vars 0400   tim_base 8400   tim_rest 8401   timerack E1D1   timerchk E1D7   timerin  E1CB   tsagin   0010   tscmd    0009   tsdev    000D   tsdtix   000F   tsevnt   0006   tsk2rg   F2AD   tsk2rx   F2C8   tsk2tx   F2B9   tskindx  040B   tskinit  E176   tsktab   0481   tslink   0000   tsprir   0005   tsseq    000A   tssgnl   0008   tsslnk   0002   tsstat   0004   tstval   000C   umark0   0014   umark1   0016   usp      0012   utask    0407   wakeu2   E4D1   wakeu3   E4D8   wakeu4   E4DC   wakeu5   E4DE   wakeup   E4C6   wlocip   0370   wnboot   03B0   wordrd   ED68   wordwr   EDC3   wzanyp   0459   wzcmnd   0004   wzdctr   0001   wzdevt   E609   wzdma1   000C   wzdma2   000E   wzdprt   0012   wzdsta   0012   wzenum   0000   wzerr    0007   wzfaml   0024   wzflg    0003   wzfsta   0002   wzgwad   0008   wzhwad   000C   wzifga   E00E   wzifip   E006   wzifma   E000   wzifnm   E00A   wzipad   0014   wzmyip   0000   wzprio   0006   wzprot   0028   wzrdev   ECB0   wzrqln   000A   wzsbnm   0004   wzsflg   0018   wzsk1    0346   wzsk2    031C   wzsk3    02F2   wzsk4    02C8   wzsk5    029E   wzsk6    0274   wzsk7    024A   wzsk8    0220   wzsprt   0010   wzstat   0005   wzswap   0020   wztype   0026   wzuipa   001A   wzuprt   001E   wzurms   0020   wzuwrp   0022   wzwdev   EC86   wzxfer   0008   xmtint   E51F   