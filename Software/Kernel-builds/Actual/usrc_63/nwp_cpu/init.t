          sttl    Table      Initialization          pag          if      DBG_INIT&DEBUG_CONTROL00        fcc     $d,'Init CLISTs',001        fcc     $d,'Init TTYs',002        fcc     $d,'Init Tasks',003        fcc     $d,'STBinit done',0          endif** stbinit - Initialize System Memory Tables*stbinit   ldx     #0      s  clear all variables          ldd     #010        std     ,x++          cmpx    #end_vars  done yet?          blo     10b          ldd     #DEBUG          std     DB_cntrl          lda     max_trn       shared with main CPU          adda    #4            fixed system tasks          sta     NUM_TSK*          lbsr    set_tables go figure out configuration, tables, etc* Initialize Socket Interrupt Queue15        ldx     #SI_Q      set queue empty          stx     SI_Q_ptr          ldx     #int_buf   reset message in pointer          stx     int_ptr17        lbsr    tskinit    initialize tasks18        lbsr    DB_config  display configuration          rts** Set up system tables*set_tables         ldy      #dev_tab         ldx      #DEV_SOCK         stx      dev_type,y         jsr      [D_init,x]    (skinit)* Compute configuration          ldu     #mod_tbl      tables with module refs12        ldx     mod_type,u          beq     20f        jump if end of module table          jsr     [D_test,x] check for device          bcs     15f        jump if found          leau    MOD_SIZE,u          bra     12b*1520* -- All done setting up configuration          ldd     #tsktab  start of system tables          tfr     d,u* -- Task table          lda     #TSKSIZ          ldb     NUM_TSK          mul          lbsr    sto_chk    check for system table space overflow** -- All done90        rts*00        fcc     $d,"...Can't size tables!",0*no_dev    fcc     '..None',0          if      DBG_INIT&DEBUG_CONTROL** init_msg - Print message about to initialize device*   B - Device #*   X - Device address*   Y - Device handler table*init_msg  pshs    d,x,y,u          jsr     DB_msg          fdb     DBG_INIT,99f          ldx     #00f          jsr     DB_pdata          lda     1,s          jsr     DB_phex          ldx     #01f          jsr     DB_pdata          ldd     2,s          jsr     DB_phex2          ldx     #02f          jsr     DB_pdata          ldd     D_init,y          jsr     DB_phex299        puls    d,x,y,u,pc*00        fcc     $d,'...Initialize device $',001        fcc     ', Addr $',002        fcc     ', At $',0          endif** Allocate some system table space*   D - Space being consumed*   U - Current end of table space*   jsr sto_chk (System Table Overflow check)*   <CS> if overflow*sto_chk   leau    d,u        compute new end pointer          cmpu    #end_vars  overflow?          bhi     10f        yes - return error          clc     no         - return OK          rts10        sec     ..         bad owies          rts** tskinit - Initialize all tasks*tskinit   ldx     #tsktab          stx     utask          ldb     NUM_TSK    # tasks in system          pshs    b          ldy     #tsktab     task 1          leay    TSKSIZ,y10        lda     #TFREE     mark all tasks free          cmpx    #tsktab     is this the system task?          bne     15f          lda     #TSYS       the system task is never free15        sta     tsstat,x          lda     #$FF       not associated with a terminal          sta     tsdev,x          sta     tsdev+1,x          leau    TSKSIZ,x   initialize stack          ldd     #IO_han          pshs    y          cmpx    ,s++       task 1?          bne     20f        no - normal I/O handling task          ldd     #SI_HAN    yes - special terminal interrupt handling task20        pshu    d          stu     usp,x          stu     umark0,x          leax    TSKSIZ,x          dec     0,s        done?          bne     10b          leas    1,s        clean up stack          ldd     #0         nothing running or sleeping          std     slplst          std     slplst+tsslnk          leax    0,y        start interrupt handling task          jsr     makrdy          rts          if      DBG_INIT&DEBUG_CONTROL90        fcc     $d,'... Init task $',0          endif** GPP interrupt timer*tim_base  equ     $8400tim_rest  equ     $8401timerin   lda     #%00000000    D0      (OFF!)          sta     tim_base      interrupt enable          rtstimerack  equ     *          lda     #1          sta     tim_rest      reset interrupt          rtstimerchk  lda     tim_base          anda    #%10000000    interrupt flag          rts