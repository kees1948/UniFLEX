               0001  NET       set    1                               opt    exp  0000                         absSWTPc      Intelligent I/O Proce     16:02:35  Nov 28, 2024   Page    1Hardware   Definitions                                                                                                                  *       lib ../include/sysdefs.h                     *                     * Various useful constants                     *                                          * Include Debug info                                    0001  DBG_SYS   equ    %0000000000000001 Debug system (scheduler, etc)               0002  DBG_8274  equ    %0000000000000010 Debug ACIA drivers               0004  DBG_INT   equ    %0000000000000100 Debug Interrupt routine               0008  DBG_TRMI  equ    %0000000000001000 Debug terminal interrupts               0010  DBG_IO    equ    %0000000000010000 Debug I/O Main routine               0020  DBG_HAN   equ    %0000000000100000 Debug terminal handler               0040  DBG_SLP   equ    %0000000001000000 Debug Sleep/Wakeup               0080  DBG_TASK  equ    %0000000010000000 Debug tasking               0100  DBG_CMD   equ    %0000000100000000 Debug I/O tasks               0200  DBG_MSG   equ    %0000001000000000 Debug high level messages               0400  DBG_INIT  equ    %0000010000000000 Print initialization messages               0800  DBG_OPEN  equ    %0000100000000000 Debug Open actions                     *               0D04  DEBUG     equ    %0000110100000100                     *EBUG_CONTROL set     %0000111100111111               0000  DEBUG_CONTROL set %0000000000000000                                    0001  DO_HISTORY set   1         Include transaction history mechanism                                          * Process Priorities                                    0046  RUNPRI    equ    70        Must run NOW               FFD8  SIQPRI    equ    -40       Waiting for a terminal interrupt to process               FFCE  FIOPRI    equ    -50       Waiting for the FIO               FFC4  SKPRI     equ    -60       Waiting for socket interrupt               FFBA  POLPRI    equ    -70       poliing priority                                          * UniFLEX signals                                    0001  HANGS     equ    1         Device hangup               0002  INTS      equ    2         Program quit (Control-C)               0003  QUITS     equ    3         Program abort (Control-backslash)               0006  PIPES     equ    6         Broken pipe                                          * -- Configuration constants                                    0009  MAX_TI    equ    9         # Queued terminal interrupts                     *               0001  MAX_DEV   equ    1                     *                                          * constants for PROT_XLTEOLSWTPc      Intelligent I/O Proce     16:02:36  Nov 28, 2024   Page    2Hardware   Definitions                                             000A  LF        equ    $0a       line feed               000D  CR        equ    $0d       carriage return                                          * NETBLOCK constants               0004  NBRQLN    equ    4         4 bytes for request               0204  NBSIZE    equ    512+NBRQLN                     SWTPc      Intelligent I/O Proce     16:02:36  Nov 28, 2024   Page    3Macro Definitions                                                                             *                     * This file contains all the standard macro definitions                     * used in the system.                     *                                    0040  FF        equ    %01000000 FIRQ interrupt mask               0010  IF        equ    %00010000 IRQ interrupt mask                                          * register references               0000  D         equ    0               0001  X         equ    1               0002  Y         equ    2               0003  U         equ    3               0004  S         equ    4               0005  PC        equ    5               0006  W         equ    6               0007  V         equ    7               0008  A         equ    8               0009  B         equ    9               000A  CC        equ    10               000B  DP        equ    11               000E  E         equ    14               000F  F         equ    15                                          * indexed addressing in macro's               0000  IX        equ    0               0001  IY        equ    1               0002  IU        equ    2               0003  IS        equ    3                                                               *                     * Set interrupt flags (I and F)                     *                                          seti      macro                               orcc   #FF|IF                               endm                                          *                     * Clear interrupt flags (I and F)                     *                                          clri      macro                               andcc  #!(FF|IF)                               endm                     SWTPc      Intelligent I/O Proce     16:02:36  Nov 28, 2024   Page    4Macro Definitions                                                                                                  *                     * debug macro                     *                                          *dbugm macro output_character                     * lda #'&1                     * lbsr syspch                     * endm                                          *                     * HD6309 MACRO's                     *                                          ldmd      macro                               fdb    $113d                               fcb    &1                               endm                                          * load W immediate                     ldwi      macro                               fdb    $1086                               fdb    &1                               endm                                          * load W direct                     *ldwd    macro                     *        fdb     $1096                     *        fcb     &1&0xff                     *        endm                                          * load W indexed                     ldwx      macro                               fdb    $10A6                               doindx &1,&2                               endm                                          * load W extended                     *ldwe    macro                     *        fdb     $10b6                     *        fdb     &1                     *        endm                                          * load E indexed                     ldex      macro                               fdb    $11a6                               doindx &1                               endm                                          ordx      macro                               fdb    $10aaSWTPc      Intelligent I/O Proce     16:02:36  Nov 28, 2024   Page    5Macro Definitions                                                                  doindx &1,&2                               endm                                          doindx    macro                               if     (&1=0)                               fcb    $84+(&2<<5)                               else                               if     (&1<16)                               fcb    (&2<<5)+(&1&$0f)                               else                               if     (&1>-16)                               fcb    (&2<<5)+($10)+(&1&$0f)                               else                               if     (&1<128)                               fcb    $88+(&2<<5),(&1&$7f)                               endif                               endif                               endif                               endif                               endm                                          * push W on system stack                     pshsw     macro                               fdb    $1038                               endm                                          * pull W from sytemstack                     pulsw     macro                               fdb    $1039                               endm                                          * memory move ++,++                     tfm1      macro                               fdb    $1138                               fcb    &1<<4|&2                               endm                                          * move memory++ to location                     tfm3      macro                               fdb    $113a                               fcb    &1<<4|&2                               endm                                          * move location to memory++                     tfm4      macro                               fdb    $113b                               fcb    &1<<4|&2                               endm                                          * logical shift left D                     lsld      macro                               fdb    $1048SWTPc      Intelligent I/O Proce     16:02:37  Nov 28, 2024   Page    6Macro Definitions                                                                  endm                                          * logical shift right D                     lsrd      macro                               fdb    $1044                               endm                                          * arithmetic shift right D                     *asrd    macro                     *        fdb     $1047                     *        endm                                          * negate D                     negd      macro                               fdb    $1040                               endm                                          * ex-or registers                     eorr      macro                               fdb    $1036                               fcb    &1<<4|&2                               endm                                          * add with carry D immediate                     adcdi     macro                               fdb    $1089                               fdb    &1                               endm                                          * increment D                     incd      macro                               fdb    $104c                               endm                                          * decrement D                     decd      macro                               fdb    $104a                               endm                                          * clear D                     clrd      macro                               fdb    $104f                               endm                                          * complement D                     comd      macro                               fdb    $1043                               endm                                          * and D immediate                     anddi     macro                               fdb    $1084SWTPc      Intelligent I/O Proce     16:02:37  Nov 28, 2024   Page    7Macro Definitions                                                                  fdb    &1                               endm                                          * bit D immediate                     bitdi     macro                               fdb    $1085                               fdb    &1                               endm                                          *                     * trfr, transfer registers, allow ALL registers                     *                     trfr      macro                               fcb    $1f                               fcb    &1<<4|&2                               endm                                          * exchange, allow ALL registers                     excg      macro                               fcb    $1e                               fcb    &1<<4|&2                               endm                                          * add registers                     *                     * addr, add reg0 + reg1 => reg1                     *                     addr      macro                               fdb    $1030                               fcb    &1<<4|&2                               endm                                          * subtract registers                     subr      macro                               fdb    $1032                               fcb    &1<<4|&2                               endm                                          * extended addressing mode                     aime      macro                               fcb    $72                               fcb    &1                               fdb    &2                               endm                                          * extended addressing mode                     oime      macro                               fcb    $71                               fcb    &1                               fdb    &2                               endm                     SWTPc      Intelligent I/O Proce     16:02:37  Nov 28, 2024   Page    8Macro Definitions                                                        * extended addressing mode                     eime      macro                               fcb    $75                               fcb    &1                               fdb    &2                               endm                                          * test immediate memory                     *timex   macro                     *        fcb     $7b                     *        fcb     &1                     *        fdb     &2                     *        endm                                          * put a LED in LIGHTS on                     LEDON     macro                               fcb    $71                               fcb    &1                               fdb    LIGHTS                               endm                                          * put a LED in LIGHTS off                     LEDOFF    macro                               fcb    $72                               fcb    255-&1                               fdb    LIGHTS                               endmSWTPc      Intelligent I/O Proce     16:02:37  Nov 28, 2024   Page    9Device     Table Structure                                                                    *                     * Possible module types table                     *                       0000                         org    $0  0000               mod_type  rmb    2         device control table address  0002               mod_name  rmb    2         pointer to module name                     *  0004               MOD_SIZE  rmb    0                                                               *                     * Device table structure                     *                       0000                         org    0  0000               dev_addr  rmb    2         Device base address  0002               dev_type  rmb    2         Device type table  0004               dev_brbu  rmb    2         baudrate backup loc                     *  0006               DEV_SIZE  rmb    0         Size of device entry                                          *                     * Control structure for a device, indexed by fifo cmnd >>3                     * MUST match nwp_codes.h  and MAX_S_NUM !!!!                     *     ==>  wzsockdev.t   <==                     *  0000                         org    $0000  0000               D_func0   rmb    2         0  Bad Command  0002               D_func1   rmb    2         1  S_OPEN  0004               D_func2   rmb    2         2  S_CLOSE  0006               D_func3   rmb    2         3  S_RQWR  0008               D_func4   rmb    2         4  S_SEND  000A               D_func5   rmb    2         5  S_RQRD  000C               D_func6   rmb    2         6  S_RECV  000E               D_func7   rmb    2         7  S_INTRPT  0010               D_func8   rmb    2         8  S_CONNECT  0012               D_func9   rmb    2         9  S_BIND  0014               D_funcA   rmb    2         10  S_LISTEN  0016               D_funcB   rmb    2         11  S_ACCEPT  0018               D_funcC   rmb    2         12  S_DISCON  001A               D_funcD   rmb    2         13  S_SNDMAC  001C               D_funcE   rmb    2         14  S_SNDKEP  001E               D_funcF   rmb    2         15  S_SPCL                     *  0020               D_func10  rmb    2         16 S_RRDFRM  0022               D_func11  rmb    2         17 S_RREAD  0024               D_func12  rmb    2         18 S_WRQSTO  0026               D_func13  rmb    2         19 S_WSNDO  0028               D_func14  rmb    2         20 S_WSNDTM  002A               D_func15  rmb    2SWTPc      Intelligent I/O Proce     16:02:38  Nov 28, 2024   Page   10Device     Table Structure                            002C               D_func16  rmb    2  002E               D_func17  rmb    2                       0030               D_func18  rmb    2         24 S_RQSBLK  0032               D_func19  rmb    2         25 S_SNDBLK  0034               D_func1A  rmb    2         26 S_RQRBLK  0036               D_func1B  rmb    2         27 S_RDRBLK                       0038               D_func1C  rmb    2         28  003A               D_func1D  rmb    2         29  003C               D_func1E  rmb    2         30  003E               D_func1F  rmb    2         31                     *  0040               D_inthan  rmb    2         14 Interrupt poller/handler  0042               D_init    rmb    2         15 Device initialization  0044               D_test    rmb    2         16 Test for device present                     *  0046               D_END     rmb    0         End of common handlers                     SWTPc      Intelligent I/O Proce     16:02:38  Nov 28, 2024   Page   11History Queue Record Structure                                             0000                         org    0  0000               hst_cmd   rmb    1         Command  0001               hst_seq   rmb    1         Sequence #  0002               hst_tty   rmb    1         TTY #  0003               hst_val   rmb    1         Message dependent data                     *  0004               HRECSIZ   rmb    0                                          *                     * Number of history records supported                     *               0010  MAXHIST   equ    16                     SWTPc      Intelligent I/O Proce     16:02:38  Nov 28, 2024   Page   12IOP        Memory Layout                                                 *                     * Basic Memory Layout                     *               0400  RAMorg    equ    $0400     28K of RAM - Thru $6FFF               3EFF  RAMend    equ    $3EFF     $6FFF               7000  RAMscratch equ   $7000     4K of scratchpad RAM               7E00  RAMscrend equ    $7E00               7FE0  ROMstack  equ    $7FE0     High end of ROM Stack                     * BGDB uses 7FF0               E000  ROMLOorg  equ    $E000     8K of ROM - $E000-$FFFF               C000  DEBUGROM  equ    $C000     8K of Debug ROM $C000-$DFFF               FFF0  CPUtraps  equ    $FFF0     CPU Trap Vectors                                          *                     * layout of hardware, w5500 socket device                     *Task       Structure                 16:02:38  Nov 28, 2024   Page   13IOP        Memory Layout                                                 *                     * Task Table                     *                       0000                         org    0                                          * struct task                                    00C0  USTSIZ    equ    192       User Stack Size (big enough??)                     *  0000               tslink    rmb    2         list link of running tasks  0002               tsslnk    rmb    2         list link of sleeping tasks  0004               tsstat    rmb    1         * see below *  0005               tsprir    rmb    1         priority - negative is low  0006               tsevnt    rmb    2         event task is waiting on  0008               tssgnl    rmb    1         Signal waiting for task                     *  0009               tscmd     rmb    1         Saved mailbox command  000A               tsseq     rmb    2         Saved message sequence #  000C               tstval    rmb    1         Saved transaction value  000D               tsdev     rmb    2         Device for task is servicing  000F               tsagin    rmb    2         return pointer                     *  0011               usp       rmb    2         Saved User Stack Pointer  0013               umark0    rmb    2         Stack Frame Markers  0015               umark1    rmb    2  0017                         rmb    USTSIZ    space for per/process stack                                    00D7  TSKSIZ    equ    *         task structure size                     * stat codes                                    0001  TRUN      equ    1         running               0002  TSLEEP    equ    2         sleep with high priority               0003  TWAIT     equ    3         sleep with low priority               0004  TFREE     equ    4         task is free (uncommitted)               0005  TSYS      equ    5         system task                     *                     * definition of wz5500 variables                     *                     * [*] items are initialized by the IO CPU                     * others are zeroed out                     *                                          * [*] are setup by GPP CPU                                          *                     * wzfsta bits                     *               0001  WZSLCK    equ    %00000001 sock is locked (equal to fdn)                     *WZSKIO  equ     %00000010       io modeTask       Structure                 16:02:39  Nov 28, 2024   Page   14IOP        Memory Layout                                                 *WZSKIS  equ     %00000100       sock is sending               0010  WZWLCK    equ    %00010000 sock task is waiting lock (equal to fdn)               0040  WZWBND    equ    %01000000 sock waiting for bind               0080  WZBUSY    equ    %10000000 sock is busy                                          *                     * protocol values                     *               0001  SP_ICMP   equ    1         Internet Control Message Protocol               0002  SP_GMP    equ    2         Internet Group Management Protocol               0006  SP_TCP    equ    6         Transmission Control Protocol               0008  SP_EGP    equ    8         Exterior Gateway Protocol               0011  SP_UDP    equ    17        User Datagram Protocol                                          *                     * wzcmd values (w5500), private for IOP                     *               0001  WCOPEN    equ    1         open command               0002  WCLIST    equ    2         list command               0004  WCCONN    equ    4         connect command               0008  WCDISC    equ    8         disconnect               0010  WCCLOS    equ    16        close               0020  WCSEND    equ    32        send               0021  WCSNAC    equ    33        send mac               0022  WCSKEP    equ    34        send keep               0040  WCRECV    equ    64        receive               0080  WCSPEC    equ    128       special, combined commands               0081  WCRRQD    equ    128+1     read request data               0082  WCXMDR    equ    128+2     write data in fifo                                    0085  WCBIND    equ    128+5     bind  CPU<=>GPP               0086  WCACCP    equ    128+6     accpet CPU<=>GPP                     *                     * wzstat values                     *               0000  WSCLSD    equ    $00       sock closed               0013  WSINIT    equ    $13       sock init               0014  WSLIST    equ    $14       sock listen               0017  WSESTB    equ    $17       sock established               001C  WSCLWT    equ    $1c       sock close wait               0022  WSUDP     equ    $22       sock UDP               0042  WSMRAW    equ    $42       sock mac raw               0032  WSIRAW    equ    $32       sock IP raw               0015  WSSYNS    equ    $15       sock syn sent               0016  WSSYNR    equ    $16       sock syn received               0018  WSFWAI    equ    $18       sock fin wiat               001A  WSCLSG    equ    $1a       sock closing               001B  WSTIMW    equ    $1b       sock time wait               001D  WSLACK    equ    $1d       sock last ack               001E  WSRNBL    equ    $1e       sock read non block               001F  WSWNBL    equ    $1f       sock write non block               0080  WSSPEC    equ    $80       special combined commandsTask       Structure                 16:02:40  Nov 28, 2024   Page   15IOP        Memory Layout                                           0081  WSRRQF    equ    $80+1     read request data in fifo               0082  WSXMDD    equ    $80+2     xmit data taken from fifo                                          *                     * miscellaneous                     *               0080  PACK_FIRST equ   $80       in non TCP packet start to receive               0001  PACK_REMAI equ   $01       in non TCP packet received               0000  PACK_COMPL equ   $00       in non TCP complete toe receive                                          * is SOCK_NONBLOCK               0001  WFNBLK    equ    $01       in socket() call(wztype << 8)                     * is SOCK_SIGPIPECLS               0002  WFSPOC    equ    $02       in socket() call(wztype << 8)                       0000                         org    $0                     *                     * per wzsocket process and socket data                     *  0000               wzenum    rmb    1         [*] (pre=enum)  0001               wzdctr    rmb    1         [*] (pre= $00)  delay counter  0002               wzfsta    rmb    1         (pre= $00) status bits (SAME POS!! as in fdn)  0003               wzflg     rmb    1         [*] flasgs, swap busy                     *  0004               wzcmnd    rmb    1         command byte copy  0005               wzstat    rmb    1         status byte copy  0006               wzprio    rmb    1         priority helper  0007               wzerr     rmb    1         error code passing                     *  0008               wzxfer    rmb    2         transfer size  000A               wzrqln    rmb    2         requested size                     *  000C               wzdma1    rmb    2         if split xfer, first part  000E               wzdma2    rmb    2         if split xfer, second part                     *                     * unix socket call info                     *  0010               wzsprt    rmb    2         source port  0012               wzdprt    rmb    2         destination port  0014               wzipad    rmb    4         dest IP address  0018               wzsflg    rmb    2         flags                     *                     * udp header info                     *  001A               wzuipa    rmb    4         ip address from UDP header  001E               wzuprt    rmb    2         port number from UDP header               0020  wzswap    equ    *         use this with TCP for swap  0020               wzurms    rmb    2         socket remained size                     * UDP write pointer  0022               wzuwrp    rmb    2         write pointer save                     *                     * open parametersTask       Structure                 16:02:41  Nov 28, 2024   Page   16IOP        Memory Layout                                                 *  0024               wzfaml    rmb    2         family            for check AF_  0026               wztype    rmb    2         type              for check SOCK_  0028               wzprot    rmb    2         protocol          for check IPPROTO_                                    002A  WZSIZE    equ    *-wzenum                       0000                         org    $0                     *                     * holds the local IP info, wzdev  net0                     * ipad, mask, gwad, macad                     *  0000               wzmyip    rmb    4         Device IP address  0004               wzsbnm    rmb    4         Subnet mask bits  0008               wzgwad    rmb    4         Gateway IP address  000C               wzhwad    rmb    6         Device Hardware address                     *  0012               wzdsta    rmb    1         up/down status  0013                         rmb    3                                    0016  WZLCSZ    equ    *-wzmyip                     *                     * this is (an attempt) to implement the Berkely                     * socket interface into the UniFLEX 6309 kernel (no 6809)                     *  0000                         org    0                                          * struct sockaddr  0000               sa_fam    rmb    2         address family  0002               sa_dat    rmb    14        protocol address               0010  SKADLN    equ    *                                          * struct sockaddr_in  0010               sin_fam   rmb    2         AF_INET  0012               sin_port  rmb    2         16 bit port  0014               sin_addr  rmb    4         32 bit netid/hostid                                          * address families               0000  AF_UNSP   equ    0         AF_UNSPEC               0001  AF_UNIX   equ    1         AF_UNIX               0002  AF_INET   equ    2         AF_INET                                          * socket types               0001  SK_STRM   equ    1         socket stream               0002  SK_DGRM   equ    2         datagram, conn less               0003  SK_MRAW   equ    3         mac raw socket               0004  SK_IRAW   equ    4         IP raw socket                     *               0100  SK_NONBLK equ    $0100     non blocking               0200  SK_SPONCL equ    $0200     SIGPIPE on close                                          * protocol familiesTask       Structure                 16:02:42  Nov 28, 2024   Page   17IOP        Memory Layout                                           0001  PF_UNIX   equ    AF_UNIX   same as address families               0002  PF_INET   equ    AF_INET                                    8000  PROT_XLTEOL equ  $8000     xlate CR<=>LF (stream only)               0001  PROT_ICMP equ    1               0002  PROT_IGMP equ    2               0008  PROT_EGP  equ    8                                          *               05C0  MAX_UDP   equ    1472      max size of UDP packet                                          FIO Simulation Structure             16:02:42  Nov 28, 2024   Page   18IOP        Memory Layout                                                                      *                     * is now performed by CY7C130 dual port RAM where (1024 * 8)                     * the RAM size is limited to the (upper) 256 bytes, which                     * contains the Interrupt handshake locations                     *                     *                       0000                         org    $0000     absolute addressed                                          ************************************************************                     * the first 32 bytes of a fifo/DPR area are the same                     * for ALL applications                     ************************************************************  0000               cpu_fio   rmb    1         Command code  0001               cpu_fio1  rmb    2         Task ID/sequence  0003               cpu_fio2  rmb    1         Message specific data  0004               cpu_fio3  rmb    2         Device designator  0006               cpu_fio4  rmb    2         UIO  0008               cpu_fio5  rmb    1         UIO                     ************************************************************  0009               fio_cpu   rmb    1         Response code  000A               fio_cpu1  rmb    2         Task ID /sequence  000C               fio_cpu2  rmb    1         Transaction specific value  000D               fio_cpu3  rmb    2         --  000F               fio_cpu4  rmb    2         UIO  0011               fio_cpu5  rmb    1         UIO                     ************************************************************                     *  0012               fifo_cnt  rmb    2         Count of data in FIFO  0014               fifo_get  rmb    2         retrieval ponter  0016               fifo_put  rmb    2         storage pointer                     *                     * these values are initialized by the IO CPU                     *  0018               fifo_us0  rmb    2         FIFO offset to application data                     *  001A               fifo_us1  rmb    2         FIFO offset to user specific area2  001C               fifo_us2  rmb    2         FIFO offset to user specific area2  001E               fifo_us3  rmb    2         FIFO offset to user specific area3                     *  0020                         rmb    32-(*-cpu_fio) ** Filler **                     * end of defined area                                          ************************************************************  0020               fifo      rmb    1                     * the size of the fifo is defined in the parameter block                     ************************************************************                                          ************************************************************                     * the top 4 locations are also fixed and shared on all applications                     ************************************************************FIO Simulation Structure             16:02:43  Nov 28, 2024   Page   19IOP        Memory Layout                              0021               DEV2CPU   rmb    1         debug data from IOP/GPP  0022               CPU2DEV   rmb    1         debug data to IOP/GPP                     * should end up at the two top locations in the DUALPORT RAM  0023               fio_cpuF  rmb    1         INT + non-zero   contains info AND set CPU IRQ when written  0024               cpu_fioF  rmb    1         INT + non-zero   contains info AND set FIO IRQ when written                     **************************************************************FIO Simulation Structure             16:02:43  Nov 28, 2024   Page   20Dual_Port RAM Structure                                                                                            *                     * this is an OVERLAY on a 1Kx8 FIFO in DPR                     *                     * the primary fifo definitions are not touched                     *                     * some locations may be re-used for this purpose                     *               0000  DPR_BASE  equ    $0000     GPP DPR at this address (GPP)  0000                         org    DPR_BASE  -- Dual port RAM address                                          *               0000  nwp_strt  equ    *         first address  of DPR RAM                     *                     ******************************************************  0000                         rmb    32        defined in fio.h                       0020                         rmb    512       fifo space                     ******************************************************               0220  WZSKOFF   equ    *                     ******************************************************  0220               wzsk8     rmb    WZSIZE    sock structure  024A               wzsk7     rmb    WZSIZE    sock  0274               wzsk6     rmb    WZSIZE    sock  029E               wzsk5     rmb    WZSIZE    sock  02C8               wzsk4     rmb    WZSIZE    sock  02F2               wzsk3     rmb    WZSIZE    sock  031C               wzsk2     rmb    WZSIZE    sock  0346               wzsk1     rmb    WZSIZE    sock                     ******************************************************               0370  WZNETOF   equ    *  0370               wlocip    rmb    WZLCSZ    network device                                    03B0  wnboot    equ    wlocip+64 see netblock.h                                          ******************************************************                     *                     * fifo top                     * specified in fio.h                     *                     ******************************************************                     *                     * IOP ROM Version #                     *               0020  ROM_VERSION equ  $20       Major/Minor Version of IOP ROM                                          *                     * generic and specific transaction codes for use with fio_han                     * these are for IOP                     *                     FIO Simulation Structure             16:02:44  Nov 28, 2024   Page   21Dual_Port RAM Structure                                                  *                     * Error codes                     *               0080  REJECT    equ    %10000000 Error/Reject bit in command response               0081  E_BADCMD  equ    REJECT+$01 Illegal command               0082  E_SYSBSY  equ    REJECT+$02 IOP saturated               0083  E_NTOPEN  equ    REJECT+$03 Selected device not open               0084  E_BADDEV  equ    REJECT+$04 Illegal device # (=3)               0085  E_DEVBSY  equ    REJECT+$05 Device is already open (exclusieve)               0086  E_IOERR   equ    REJECT+$06 Some sort of IO error               00BE  E_INTRPT  equ    REJECT+$3E Terminal interrupt (send by IOP to UniFLEX)               00BF  E_ABORT   set    REJECT+$3F Transaction aborted by UniFLEX (not sent by IOP)               00C0  E_SOCKET  equ    REJECT+$40 Socket error,                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     *               0010  O_OPEN    equ    $10       Open device               0020  O_CLOSE   equ    $20       Close device               0030  O_RQWR    equ    $30       Request write               0040  O_WRITE   equ    $40       Write data via fifo to IOP               0050  O_RQRD    equ    $50       Request read data               0060  O_READ    equ    $60       Read data for via fifo from IOP               0070  O_INTRPT  set    $70       Interrupt all tasks on a terminal               0080  O_WR1C    equ    $80       Write single character               0090  O_TTYS    equ    $90       TTY Set               00A0  O_TTYG    equ    $A0       TTY Get                                    00D0  O_PGETD   equ    $D0       Read baudrate settings               00E0  O_PSETD   equ    $E0       Write baudrate settings                                          *                     * Normal responses                     * error is with bit 7 set, A contains error code                     *               000F  R_RESET   equ    $0F       System reset & functioning               0001  R_OPEN    equ    $01       Device open successful               0002  R_CLOSE   equ    $02       Device close successful               0003  R_REQOK   equ    $03       Write request now granted               0004  R_WRITE   equ    $04       Write data complete               0005  R_RDOK    equ    $05       Read data now available               0006  R_READ    equ    $06       Read data in FIFO & no more data is available               0007  R_INTRPT  set    $07       Interrupt complete               0008  R_WR1C    equ    $08       Write single character               0009  R_RD1C    equ    $09       Single character available               000B  R_PDATA   equ    $0B       port data transaction succes               000C  R_READM   equ    $0C       Read data in fifo, more data waiting               000D  R_TTY     equ    $0D       TTYSET/GET complete               000E  R_CLOCK   equ    $0E       Interval Timer Tick                     *                     *                     * fio_codes.h is the leading file, here areFIO Simulation Structure             16:02:45  Nov 28, 2024   Page   22Dual_Port RAM Structure                                                  * ammendments                     *                     *               0003  R_RQWR    set    $03       [S]  Request for write               0005  R_RQRD    set    $05       [S]  Request for read               0007  R_INTRPT  set    $07       [S]  Interrupt complete               0008  R_CONNECT equ    $08       [S]  connect ok               0009  R_BIND    equ    $09       [S]  bind call ok               000A  R_LISTEN  equ    $0A       [S]  listen call ok               000B  R_ACCEPT  equ    $0B       [S]  accept call ok               000C  R_DISCON  equ    $0C       [S]  disconnect happened               000D  R_SNDMAC  equ    $0D       [S]  send mac done               000E  R_SNDKEP  equ    $0E       [S]  send keep alive done               000F  R_SPCL    equ    $0F       [S]  special call ok               0015  R_RQRDNB  equ    $15       [S]  non block return read               0013  R_RQWRNB  equ    $13       [S]  non block return write                     *               0021  R_RDFRM   equ    $21       [S]  request for data readfrom               0022  R_RRDFD   equ    $22       [S]  read data readfrom next packet               0023  R_RSNDTO  equ    $23       [S]  request write sendto               0024  R_WSNDTO  equ    $24       [S]  write data sendto               0025  R_SNDTOM  equ    $25       [S]  write data, request more                     *                     * netblock uses a specific interrupt routine                     *               0080  R_RQSBLK  equ    $80               0081  R_SNDBLK  equ    $81               0082  R_RQRBLK  equ    $82               0083  R_RDRBLK  equ    $83               0084  R_ERRBLK  equ    $84       error repsonse                                          *                     * Request codes (from Main CPU) is index in DEV_XXXX table at IOP                     * Socket functions                     *               0008  S_OPEN    equ    $08       Open socket               0010  S_CLOSE   equ    $10       Close socket               0018  S_RQWR    equ    $18       request write to socket               0020  S_WRITE   equ    $20       Write data to socket               0028  S_RQRD    equ    $28       Request read data from socket               0030  S_READ    equ    $30       Read data from socket               0038  S_INTRPT  equ    $38       Interrupt socket               0038  O_INTRPT  set    S_INTRPT               0040  S_CONNECT equ    $40       Connect socket               0048  S_BIND    equ    $48       Bind socket               0050  S_LISTEN  equ    $50       Listen on socket               0058  S_ACCEPT  equ    $58       Accept connection on socket               0060  S_DISCON  equ    $60       Disconnect socket               0068  S_SNDMAC  equ    $68       Send to mac               0070  S_SNDKEP  equ    $70       Send keep alive               0078  S_SPCL    equ    $78       Special. i.e set network device                     *FIO Simulation Structure             16:02:46  Nov 28, 2024   Page   23Dual_Port RAM Structure                                            0080  S_RRDFRM  equ    $80       request read readfrom               0088  S_RREAD   equ    $88       read data readfrom               0090  S_WRQSTO  equ    $90       request send ssendto               0098  S_WSNDTO  equ    $98       send data sendto               00A0  S_WSNDTM  equ    $a0       send to more data                     *                     * a8                     * b0                     * b8                     *               00C0  S_RQSBLK  equ    $c0       request send extended block               00C8  S_SNDBLK  equ    $c8       send extended block               00D0  S_RQRBLK  equ    $d0       request read extended block               00D8  S_RDRBLK  equ    $d8       read extended block                     *                     * e0                     * e8               00F0  S_NETBOOT equ    $f0       network boot               00F8  S_PG2FIFO equ    $f8       copy memory page to fifo               0020  MAX_S_NUM equ    32        # of supported functions (incl 0)                     *                     * definition of all interrupts in the W5500                     *                                          *                     * interrupts per socket (Socket registers)                     *               0001  SI_CON    equ    %00000001 Sn_IR(CON)               0002  SI_DIS    equ    %00000010 Sn_IR(DISCON)               0004  SI_RCV    equ    %00000100 Sn_IR(RECV)               0008  SI_TIM    equ    %00001000 Sn_IR(TIMEOUT)               0010  SI_SOK    equ    %00010000 Sn_IR(SEND_OK)                                          *                     * common interrupts  (Common registers)                     *               0010  CI_MP     equ    %00010000 Magic Packet               0020  CI_POC    equ    %00100000 PPoE Close               0040  CI_UNR    equ    %01000000 UNREACH               0080  CI_CFL    equ    %10000000 IP ConflictFIO Simulation Structure             16:02:46  Nov 28, 2024   Page   24Variable   Space                                                           0400                         org    RAMorg                       0400               sys_vars  rmb    0         -- start of system variables                                          * Configuration "constants"                       0400               DB_iflg   rmb    1         Debug terminal initialized  0401               DB_cntrl  rmb    2         Debug control flags                     *  0403               slplst    rmb    4         Pointer to waiting tasks  0407               utask     rmb    2         Currently executing task  0409               jobpri    rmb    1         Current job priority (for scheduling)  040A               chproc    rmb    1         Set if must switch users of CPU (reschedule)  040B               tskindx   rmb    1         index in task list  040C               NUM_TSK   rmb    1         max tasks                     *  040D               idle      rmb    1         idle loop flag for scheduler  040E               SI_Q      rmb    6*MAX_TI  Max Terminal Interrupts  0444               SI_Q_ptr  rmb    2         current Q pointer  0446               FIO_lock  rmb    1         FIO in use lock  0447               int_buf   rmb    12        Current Message in  0453               int_ptr   rmb    2         Message in pointer  0455               clock_tick rmb   1         Clock tick counter  0456               spiint    rmb    1         Interrupt flag from w5500  0457               wzanyp    rmb    2         Source Port                       0459               hstbuf    rmb    HRECSIZ*MAXHIST  0499               hstptr    rmb    2         next "put" pointer in history queue                       049B               dev_tab   rmb    DEV_SIZE*MAX_DEV system configuration table                     *  04A1                         rmb    32                       04C1               tsktab    rmb    TSKSIZ*15 Start of dynamic system tables                                    115A  lstram    equ    *               3EFF  end_vars  equ    RAMend    End of System Variables                                          FIO Simulation Structure             16:02:47  Nov 28, 2024   Page   25CPU        Vectors                                                         FFF0                         org    CPUtraps                       FFF0 E0BF                    fdb    rom_trap  Unused  FFF2 E0B8                    fdb    rom_swi3  SWI3  FFF4 E0B1                    fdb    rom_swi2  SWI2  FFF6 E0A4                    fdb    rom_firq  FIRQ  FFF8 E3A3                    fdb    IRQ_han   IRQ  FFFA E0AB                    fdb    rom_swi   SWI  FFFC E09E                    fdb    rom_nmi   Background debug  FFFE E080                    fdb    rom_init  Reset                     *                               info   UniFLEX Networking ROM                               info   for CPU09GPP+09NET                               info   At the start of ROM the locations for preset                               info   the network setting are reserved                               info   0000...0005  MAC ADDRESS                               info   0006...0009  IP address                               info   000A...000D  NETMASK                               info   000E...0011  GATEWAY IP address                               info   avoid any duplicate settings!                                          FIO Simulation Structure             16:02:48  Nov 28, 2024   Page   26System     RESET Code                                                      E000                         org    ROMLOorg                                          * start of ROM                     ***************************************************************                     *                     * contains the MAC ADDRESS to be used, make sure that is unique                     *                     * contains the IP address for the interface                     *                     * contains the NETMASK for the interface                     *                     * contains the IP address of the GATEWAY                     *                     **************************************************************                     *                     * REPLACE the defaults with your specific values                     *                     * this is for the local network device setup                     *                     * mac address 6 bytes                            (Ex00...Ex05)                     *  E000 FF FF FF FF   wzifma    fcb    $FF,$FF,$FF,$FF,$FF,$FF                     *                     * Note! HERE  IP addresses are written COMMA SEPARATED!                     *                     * IP addres for THIS interface (avoid duplicates!!!)  E006 FF FF FF FF   wzifip    fcb    255,255,255,255 (Ex06...Ex09)                     * NETMASK  E00A FF FF FF FF   wzifnm    fcb    255,255,255,255 (Ex0A...Ex0D)                     * GATEWAY IP address  E00E FF FF FF FF   wzifga    fcb    255,255,255,255 (Ex0E...E011)                     *                     **************************************************************                                          **************************************************************                       E012 0D 4E 57 50   DBmsg00   fcc    $d,'NWP ROM version:241128',0                                          **************************************************************                     *  E02A 0D 53 79 73   DBmsg01   fcc    $d,'System Initialization Complete',0  E04A 0D 43 50 55   DBmsg02   fcc    $d,'CPU RESET Complete',0  E05E 0D 0D 53 79   CPU_down  fcc    $d,$d,'System CPU not functioning',0                                          *                     * share settings with kernel driver code                     *               E07B  fio_fsz   equ    *         device fifo size               E07D  fio_dsz   equ    *+2       device RAM size               E07F  max_trn   equ    *+4       max transactions                     *FIO Simulation Structure             16:02:48  Nov 28, 2024   Page   27System     RESET Code                                                    * share specific DUAL PORT RAM device initialization                     * between UniFLEX kernel and NWP CPU                     *  E07B 0200                    fdb    512       fio_fsz FIFO SIZE  E07D 0400                    fdb    1024      fio_dsz DEVICE SIZE  E07F 08                      fcb    8         fio_mxtrn MAX_TRANSACTIONS                     *                     * declaration of offsets and settings                     *               0008  MAX_WZ    equ    8         # of sockets in w5500                                                               *                     * System RESET code                     *  E080 10CE 7FE0     rom_init  lds    #ROMstack initialize stack pointer  E084                         ldmd   3  E084 113D                    fdb    $113d  E086 03                      fcb    3                               endm                      >E087 BD   E0E0     20        jsr    stbinit   go initialize system memory                       E08A 10CE 04C1     30        lds    #tsktab   Task 0 Stack  E08E 32   E9 00D7            leas   TSKSIZ,s  E092 17   014B               lbsr   fio_reset  E095 BD   E5CE               jsr    skdvini   set the device itself  E098 17   0122               lbsr   timerin                     *                     * Initialization complete - Start executing commands                     *  E09B               fio_start  E09B 7E   E4AB     10        jmp    rsched                                          FIO Simulation Structure             16:02:48  Nov 28, 2024   Page   28ROM        Interrupt Fielders                                              E09E 8D   26       rom_nmi   bsr    rom_int  E0A0 4E 4D 49 00             fcc    'NMI',0  E0A4 8D   20       rom_firq  bsr    rom_int  E0A6 46 49 52 51             fcc    'FIRQ',0  E0AB 8D   19       rom_swi   bsr    rom_int  E0AD 53 57 49 00             fcc    'SWI',0  E0B1 8D   13       rom_swi2  bsr    rom_int  E0B3 53 57 49 32             fcc    'SWI2',0  E0B8 8D   0C       rom_swi3  bsr    rom_int  E0BA 53 57 49 33             fcc    'SWI3',0  E0BF 8D   05       rom_trap  bsr    rom_int  E0C1 54 52 41 50             fcc    'TRAP',0                       E0C6 8E   E0D3     rom_int   ldx    #ROM_ERR  E0C9 BD   F399               jsr    DB_pdata  E0CC 35   10                 puls   x  E0CE BD   F399               jsr    DB_pdata  E0D1 20   FE       rom_bad   bra    *                     *  E0D3 0D 52 4F 4D   ROM_ERR   fcc    $d,'ROM Error: ',0                                          *FIO Simulation Structure             16:02:49  Nov 28, 2024   Page   29Table      Initialization                                                                                                               *                     * stbinit - Initialize System Memory Tables                     *  E0E0 8E   0000     stbinit   ldx    #0        s  clear all variables  E0E3 CC   0000               ldd    #0  E0E6 ED   81       10        std    ,x++  E0E8 8C   3EFF               cmpx   #end_vars done yet?  E0EB 25   F9                 blo    10b                       E0ED CC   0D04               ldd    #DEBUG  E0F0 FD   0401               std    DB_cntrl                                            E0F3 B6   E07F               lda    max_trn   shared with main CPU  E0F6 8B   04                 adda   #4        fixed system tasks  E0F8 B7   040C               sta    NUM_TSK                     * >E0FB 17   0013               lbsr   set_tables go figure out configuration, tables, etc                                          * Initialize Socket Interrupt Queue  E0FE 8E   040E     15        ldx    #SI_Q     set queue empty  E101 BF   0444               stx    SI_Q_ptr  E104 8E   0447               ldx    #int_buf  reset message in pointer  E107 BF   0453               stx    int_ptr                      >E10A 17   005B     17        lbsr   tskinit   initialize tasks                       E10D 17   12A7     18        lbsr   DB_config display configuration  E110 39                      rts                                          *                     * Set up system tables                     *  E111               set_tables  E111 108E 049B               ldy    #dev_tab  E115 8E   E56B               ldx    #DEV_SOCK  E118 AF   22                 stx    dev_type,y  E11A AD   98 42              jsr    [D_init,x] (skinit)                                          * Compute configuration  E11D CE   E1CF               ldu    #mod_tbl  tables with module refs  E120 AE   C4       12        ldx    mod_type,u  E122 27   09                 beq    20f       jump if end of module table  E124 AD   98 44              jsr    [D_test,x] check for device  E127 25   04                 bcs    15f       jump if found  E129 33   44                 leau   MOD_SIZE,u  E12B 20   F3                 bra    12b                     *  E12D               15FIO Simulation Structure             16:02:49  Nov 28, 2024   Page   30Table      Initialization                             E12D               20                     * -- All done setting up configuration                       E12D CC   04C1               ldd    #tsktab   start of system tables  E130 1F   03                 tfr    d,u                     * -- Task table  E132 86   D7                 lda    #TSKSIZ  E134 F6   040C               ldb    NUM_TSK  E137 3D                      mul >E138 17   001F               lbsr   sto_chk   check for system table space overflow                     *                     * -- All done  E13B 39            90        rts                     *  E13C 0D 2E 2E 2E   00        fcc    $d,"...Can't size tables!",0                     *  E153 2E 2E 4E 6F   no_dev    fcc    '..None',0                                                                                    *                     * Allocate some system table space                     *   D - Space being consumed                     *   U - Current end of table space                     *   jsr sto_chk (System Table Overflow check)                     *   <CS> if overflow                     *  E15A 33   CB       sto_chk   leau   d,u       compute new end pointer  E15C 1183 3EFF               cmpu   #end_vars overflow?  E160 22   03                 bhi    10f       yes - return error  E162 1C   FE                 clc              no         - return OK  E164 39                      rts  E165 1A   01       10        sec              ..         bad owies  E167 39                      rts                                          *                     * tskinit - Initialize all tasks                     *  E168 8E   04C1     tskinit   ldx    #tsktab  E16B BF   0407               stx    utask  E16E F6   040C               ldb    NUM_TSK   # tasks in system  E171 34   04                 pshs   b  E173 108E 04C1               ldy    #tsktab   task 1  E177 31   A9 00D7            leay   TSKSIZ,y                       E17B 86   04       10        lda    #TFREE    mark all tasks free  E17D 8C   04C1               cmpx   #tsktab   is this the system task?  E180 26   02                 bne    15f  E182 86   05                 lda    #TSYS     the system task is never free  E184 A7   04       15        sta    tsstat,x  E186 86   FF                 lda    #$FF      not associated with a terminal  E188 A7   0D                 sta    tsdev,xFIO Simulation Structure             16:02:50  Nov 28, 2024   Page   31Table      Initialization                             E18A A7   0E                 sta    tsdev+1,x  E18C 33   89 00D7            leau   TSKSIZ,x  initialize stack  E190 CC   E32D               ldd    #IO_han  E193 34   20                 pshs   y  E195 AC   E1                 cmpx   ,s++      task 1?  E197 26   03                 bne    20f       no - normal I/O handling task  E199 CC   E3F7               ldd    #SI_HAN   yes - special terminal interrupt handling task  E19C 36   06       20        pshu   d  E19E EF   88 11              stu    usp,x  E1A1 EF   88 13              stu    umark0,x  E1A4 30   89 00D7            leax   TSKSIZ,x  E1A8 6A   E4                 dec    0,s       done?  E1AA 26   CF                 bne    10b                       E1AC 32   61                 leas   1,s       clean up stack  E1AE CC   0000               ldd    #0        nothing running or sleeping  E1B1 FD   0403               std    slplst  E1B4 FD   0405               std    slplst+tsslnk  E1B7 30   A4                 leax   0,y       start interrupt handling task  E1B9 BD   E4EA               jsr    makrdy  E1BC 39                      rts                                                               *                     * GPP interrupt timer                     *               8400  tim_base  equ    $8400               8401  tim_rest  equ    $8401                       E1BD 86   00       timerin   lda    #%00000000 D0      (OFF!)  E1BF B7   8400               sta    tim_base  interrupt enable  E1C2 39                      rts                                                         E1C3  timerack  equ    *  E1C3 86   01                 lda    #1  E1C5 B7   8401               sta    tim_rest  reset interrupt  E1C8 39                      rts                       E1C9 B6   8400     timerchk  lda    tim_base  E1CC 84   80                 anda   #%10000000 interrupt flag  E1CE 39                      rtsFIO Simulation Structure             16:02:51  Nov 28, 2024   Page   32IOP        Configuration                                                                      *                     * define which type of boards are present                     *               E1CF  mod_tbl   equ    *  E1CF E56B E1D5               fdb    DEV_SOCK,WZ5_name  E1D3 0000                    fdb    0                     *  E1D5 57 35 35 30   WZ5_name  fcc    'W5500_SOCK',0FIO Simulation Structure             16:02:51  Nov 28, 2024   Page   33FIO        Simulation Routines                                                                *                     * Reset CPU-IOP Interface                     * it is assumed that the FIO (DPR) sits at $0000                     * it sets the offsets to the sock array and to the device info                     *  E1E0               fio_reset                     * when here, all storage locations have been erased already                     *  E1E0 8E   0000               ldx    #0  E1E3 9F   14                 stx    fifo_get  set Q pointers  E1E5 9F   16                 stx    fifo_put  E1E7 8E   0370               ldx    #WZNETOF  E1EA 9F   1A                 stx    fifo_us1  E1EC 8E   0220               ldx    #WZSKOFF  E1EF 9F   18                 stx    fifo_us0  so that kernel CPU can see it                     * init the 8 SOCK structs  E1F1 86   08                 lda    #8  E1F3 A7   84       01        sta    wzenum,x  E1F5 30   88 2A              leax   WZSIZE,x  to next  E1F8 4A                      deca  E1F9 26   F8                 bne    01b                     *  E1FB BE   E07D               ldx    fio_dsz  E1FE 30   1E                 leax   -2,x      one from top  E200 CE   0400               ldu    #1024     -- Reset Time-Out value                     *  E203 C6   FF       fio_wait  ldb    #255      Spin counter                     *  E205               00  E205 6D   84                 tst    0,x       fio_cpuF  E207 27   16                 beq    10f                     *  E209 5A                      decb  E20A 26   F9                 bne    00b       jump back if not ready                     *  E20C 33   5F                 leau   -1,u  E20E 1183 0000               cmpu   #0  E212 26   EF                 bne    fio_wait  E214 8E   E05E               ldx    #CPU_down  E217 17   117F               lbsr   DB_pdata  E21A 17   1176               lbsr   DB_main  E21D 20   C1                 bra    fio_reset                     * reset OK  E21F 39            10        rts                                                               *                     * FIO interrupt handler, called when IRQ was set (interrupt context)                     * for regular NWP and IOP purpose                     *  E220 BE   0453     fio_irq   ldx    int_ptr   input message pointerFIO Simulation Structure             16:02:52  Nov 28, 2024   Page   34FIO        Simulation Routines                        E223 96   00                 lda    cpu_fio   move REQUEST  E225 A7   80                 sta    ,x+  E227 DC   01                 ldd    cpu_fio1  sequence # TASK ID  E229 ED   81                 std    ,x++  E22B 96   03                 lda    cpu_fio2  specific DATA  E22D A7   80                 sta    ,x+  E22F DC   04                 ldd    cpu_fio3  device major/minor  E231 ED   81                 std    ,x++                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device                     *  E233 FE   E07D               ldu    fio_dsz  E236 33   5F                 leau   -1,u  E238 6F   C4                 clr    0,u       cpu_fioF indicate message consumed                     *  E23A BF   0453               stx    int_ptr   update pointer  E23D 108E 0447               ldy    #int_buf  get message from buffer  E241 A6   A4                 lda    0,y       -- Send interrupt command?  E243 81   38                 cmpa   #S_INTRPT  E245 26   0D                 bne    30f                     *                     * special case OOB signal                     *  E247 10BF 0453               sty    int_ptr   reset pointer  E24B E6   23                 ldb    3,y       signal  E24D AE   24                 ldx    4,y       SOCK reference                     *  E24F BD   E626               jsr    sdev_sig  send device signal  E252 20   35                 bra    fiointe   exit                     *                     * normal command                     * acquire free task slot                     *  E254 8E   04C1     30        ldx    #tsktab   search for an available task  E257 F6   040C               ldb    NUM_TSK   Number of tasks in system                     *  E25A A6   04       32        lda    tsstat,x  E25C 81   04                 cmpa   #TFREE    looking for a "free" task  E25E 27   0E                 beq    40f                     *  E260 30   89 00D7            leax   TSKSIZ,x  E264 5A                      decb  E265 26   F3                 bne    32b                     *  E267 C6   82                 ldb    #E_SYSBSY can't process - IOP saturated! >E269 BD   E28A               jsr    fio_msg  E26C 20   1B                 bra    fiointe   exit                     *                     * X[0]=cmd,X[1][2]=task ID,X[3]=data, X[4][5]=device                     * move data over into task struct                     *  E26E 108E 0447     40        ldy    #int_buf  get message from bufferFIO Simulation Structure             16:02:53  Nov 28, 2024   Page   35FIO        Simulation Routines                        E272 10BF 0453               sty    int_ptr   reset pointer  E276 E6   A0                 ldb    ,y+       command byte  REQUEST  E278 E7   09                 stb    tscmd,x   save for task  E27A EC   A1                 ldd    ,y++      sequence #    task ID  E27C ED   0A                 std    tsseq,x  E27E E6   A0                 ldb    ,y+       command specific DATA  E280 E7   0C                 stb    tstval,x  E282 EC   A1                 ldd    ,y++      associate with terminal major/minor  E284 ED   0D                 std    tsdev,x  E286 BD   E4EA               jsr    makrdy    make task ready to run                     *  E289 39            fiointe   rts              exit                                          *                     * fio_msg - Send a message via the FIO Mailbox                     * it is assumed that the FIO (DPR) sits at $0000                     *   B - Message code to send (one byte)                     *   fio_cpu1..3 already set up                     *                     * used for netblock/IOP and NWP purpose                     *  E28A 34   55       fio_msg   pshs   cc,b,x,u  save register  E28C                         seti  E28C 1A   50                 orcc   #FF|IF                               endm  E28E FE   E07D               ldu    fio_dsz  E291 33   5E                 leau   -2,u      one off top  E293 D7   09                 stb    fio_cpu   set up mailbox value                     * interrupt location  E295 E7   C4       5         stb    0,u       fio_cpuF, tell the message type                     *  E297 8E   0000     05        ldx    #0        time-out counter                     *  E29A A6   C4       10        lda    0,u       fio_cpuF   wait till value consumed  E29C 27   06                 beq    20f       jump if consumed                     *  E29E 30   1F                 leax   -1,x      time-out yet?  E2A0 26   F8                 bne    10b                     *  E2A2 20   F3                 bra    05b       try again                     *  E2A4 35   D5       20        puls   cc,b,x,u,pc                     *                                          *                     * this is the normal way the IOP sends data to the host CPU                     * fio_response - Return a response code/sequence #                     * it is assumed that the FIO (DPR) sits at $0000                     *    X = utask,                     *    B - Response code                     *    A - Transaction specific value                     *FIO Simulation Structure             16:02:54  Nov 28, 2024   Page   36FIO        Simulation Routines                        E2A6 34   16       fio_response pshs d,x  E2A8 8D   18                 bsr    FIO_get   access FIO  E2AA BE   0407               ldx    utask     task ID  E2AD EC   0A                 ldd    tsseq,x  E2AF DD   0A                 std    fio_cpu1  E2B1 EC   0D                 ldd    tsdev,x   device info  E2B3 DD   0D                 std    fio_cpu3  E2B5 A6   E4                 lda    0,s       get transaction specific value (i.e. error code)  E2B7 97   0C                 sta    fio_cpu2  E2B9 E6   61                 ldb    1,s       is RESPONSE code >E2BB BD   E28A               jsr    fio_msg  E2BE 8D   17                 bsr    FIO_rel   release FIO  E2C0 35   96                 puls   d,x,pc    return                                          *                     * FIO_get - Get access to FIO device                     * -- Sleep till available                     *  E2C2 34   76       FIO_get   pshs   d,x,y,u   save registers  E2C4 108E 0446     10        ldy    #FIO_lock is the device locked  E2C8 6D   A4                 tst    0,y  E2CA 27   07                 beq    20f       no - go get it                     *  E2CC C6   CE                 ldb    #FIOPRI   waiting for the FIO  E2CE BD   E518               jsr    sleep  E2D1 20   F1                 bra    10b       try again                     *  E2D3 6C   A4       20        inc    0,y       mark in use  E2D5 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIO_rel - Release access to FIO                     *  E2D7 34   76       FIO_rel   pshs   d,x,y,u  E2D9 108E 0446               ldy    #FIO_lock  E2DD 6F   A4                 clr    0,y  E2DF BD   E4F4               jsr    wakeup  E2E2 35   F6                 puls   d,x,y,u,pc return                                          *                     * FIFO_get - Fetch character from FIFO                     *   B - Character fetched                     *  E2E4 34   04       FIFOgeta  pshs   b  E2E6 8D   05                 bsr    FIFO_get  E2E8 35   02                 puls   a  E2EA 1E   89                 exg    a,b  E2EC 39                      rts                     *  E2ED 34   12       FIFO_get  pshs   a,x  E2EF DC   12                 ldd    fifo_cnt  any data?  E2F1 27   15                 beq    99f       no - exitFIO Simulation Structure             16:02:54  Nov 28, 2024   Page   37FIO        Simulation Routines                                           *  E2F3                         decd   yes       - adjust count  E2F3 104A                    fdb    $104a                               endm  E2F5 DD   12                 std    fifo_cnt  E2F7 9E   14                 ldx    fifo_get  get consumer pointer  E2F9 E6   88 20              ldb    fifo,x    fetch byte  E2FC 30   01                 leax   1,x       bump pointer  E2FE BC   E07B               cmpx   fio_fsz   end of fifo?  E301 26   03                 bne    10f                     *  E303 8E   0000               ldx    #0        reset pointer                     *  E306 9F   14       10        stx    fifo_get                     *  E308 35   92       99        puls   a,x,pc                                          *                     * FIFO_put - Place character into FIFO                     *   B - Character fetched                     *  E30A 34   04       FIFOputa  pshs   b  E30C 1F   89                 tfr    a,b  E30E 8D   02                 bsr    FIFO_put  E310 35   84                 puls   b,pc                     *  E312 34   16       FIFO_put  pshs   d,x  E314 9E   16                 ldx    fifo_put  get consumer pointer  E316 E7   88 20              stb    fifo,x    store byte  E319 30   01                 leax   1,x       bump pointer  E31B BC   E07B               cmpx   fio_fsz   end of FIFO?  E31E 26   03                 bne    10f                     *  E320 8E   0000               ldx    #0        reset pointer  E323 9F   16       10        stx    fifo_put                     *  E325 DC   12                 ldd    fifo_cnt  E327                         incd  E327 104C                    fdb    $104c                               endm  E329 DD   12                 std    fifo_cnt  E32B 35   96       99        puls   d,x,pcFIO Simulation Structure             16:02:55  Nov 28, 2024   Page   38IO         Command Handler                                               *                     *                     * IO_han - I/O Command Handler                     *   This routine comprises the main processing loop                     * for each task in the system.  Whenever an I/O command                     * is detected (via the message interrupt), a task will                     * be scheduled to process it.  This is that task.                     *   The command is saved in the "tscmd" field of the                     * task control block.                     *  E32D               IO_han                     *                     * we execute the task belonging to the transaction                     *  E32D                         clri  E32D 1C   AF                 andcc  #!(FF|IF)                               endm  E32F BE   0407               ldx    utask     get task control block address  E332 A6   09                 lda    tscmd,x   get I/O command                     *                     * The command byte is shifted and used as an index                     * in a DEV_XXXX tab                     *  E334 44                      lsra             isolate    command  E335 44                      lsra  E336 44                      lsra                     **        lsra  E337 81   20                 cmpa   #MAX_S_NUM  E339 22   64                 bhi    bad_cmd                     *  E33B 48                      lsla             --   word index on command  E33C 34   10                 pshs   x  E33E 8E   049B               ldx    #dev_tab  E341 AE   02                 ldx    dev_type,x get handler table address  E343 10AE 86                 ldy    a,x       get processor address  E346 35   10                 puls   x  E348 34   20                 pshs   y  E34A 10AE 0F                 ldy    tsagin,x  if 0, d nothing  E34D 27   0A                 beq    05f       else it is target ponter  E34F 10AF E4                 sty    0,s  E352 108E 0000               ldy    #0  E356 10AF 0F                 sty    tsagin,x  reset pointer  E359 35   20       05        puls   y         change address  E35B 4F                      clra                     *  E35C 8E   E384               ldx    #IO_end   interrupt handler address  E35F 34   10                 pshs   x  E361 BE   0407               ldx    utask     task pointer  E364 10EF 88 15              sts    umark1,x  E368 EE   0D                 ldu    tsdev,x   get sock refernce  E36A 1E   03                 exg    d,u  E36C 84   07                 anda   #%00000111 mask off address bitsFIO Simulation Structure             16:02:55  Nov 28, 2024   Page   39IO         Command Handler                            E36E 1E   03                 exg    d,u                     *                     * CALL HANDLER: X=utask, Y=handler address, U=sock address                     *  E370 AD   A4                 jsr    0,y       perform operation & return status  E372 32   62                 leas   2,s       clean up stack                     *                     * on return, Y= flag. -1 is resched, else end task                     *  E374 BE   0407               ldx    utask     restore task pointer  E377 108C FFFF               cmpy   #$ffff  E37B 26   04                 bne    20f                     * task is NOT done yet  E37D                         seti   set       interrupt mask  E37D 1A   50                 orcc   #FF|IF                               endm  E37F 20   18                 bra    91f       just escape (and come back)                     *                     * A=transaction value, B=response code, U=device reference                     * X = task pointer                     * in fio_response the task ID is added as sequence reference                     * SEND the response to the host CPU                     *                     *  E381 BD   E2A6     20        jsr    fio_response                     *                     * task is done                     *  E384               IO_end    seti   mask      interrupts  E384 1A   50                 orcc   #FF|IF                               endm  E386 BE   0407               ldx    utask     restore task control block address  E389 A7   0C                 sta    tstval,x  remember transaction value sent  E38B E7   09                 stb    tscmd,x   and command response  E38D 86   04                 lda    #TFREE    mark task "terminated & free"  E38F A7   04                 sta    tsstat,x  E391 86   FF                 lda    #$FF      disassociate from any terminal  E393 A7   0D                 sta    tsdev,x  E395 A7   0E                 sta    tsdev+1,x  E397 6F   08                 clr    tssgnl,x  no waiting signals                     *                     * exit here to rescheduling                     *  E399 BD   E4AB     91        jsr    rsched    run other tasks >E39C 16   FF8E               lbra   IO_han                                          *                     * Illegal command                     *  E39F               bad_cmd  E39F C6   81                 ldb    #E_BADCMD error code  E3A1 20   DE                 bra    20bFIO Simulation Structure             16:02:56  Nov 28, 2024   Page   40IO         Command Handler                                               *          rts          (bug in original code 240424)FIO Simulation Structure             16:02:56  Nov 28, 2024   Page   41Interrupt  Processing                                                                         *                     * This routine handles all IRQ interrupts                     *                     *               E3A3  IRQ_han   equ    *                     *                     * Check for FIO Mailbox interrupt                     *  E3A3 BE   E07D     10        ldx    fio_dsz  E3A6 30   1F                 leax   -1,x  E3A8 A6   84                 lda    0,x       cpu_fioF   see if mailbox interrupt  E3AA 27   03                 beq    99f       no - move on  E3AC BD   E220               jsr    fio_irq   call fio interrupt handler                     *                     *         lbsr    DB_main                     *  E3AF 3B            99        rti              return from interrupt                     *  E3B0 0D 49 4F 50   IRQmsg10  fcc    $d,'IOP Got: ',0  E3BB 2D 2D 20 4E   00        fcc    '-- No tasks!',0FIO Simulation Structure             16:02:56  Nov 28, 2024   Page   42Interrupt  All Tasks                                                                          *                     * Interrupt all tasks associated with a given device                     *   A - Device #                     *   jsr int_all                     * Note: The current task is skipped, along with                     * the system and the interrupt handler task (1).                     *  E3C8 34   36       int_all   pshs   d,x,y  E3CA F6   040C               ldb    NUM_TSK  E3CD C0   02                 subb   #2  E3CF 34   04                 pshs   b  E3D1 8E   04C1               ldx    #tsktab  E3D4 30   89 01AE            leax   2*TSKSIZ,x                     *  E3D8 EC   61       10        ldd    1,s  E3DA 10A3 0D                 cmpd   tsdev,x   is this guy associated with the device?  E3DD 26   0C                 bne    20f                     *  E3DF BC   0407               cmpx   utask     make sure I don't get blown away  E3E2 27   07                 beq    20f                     *  E3E4 34   16                 pshs   d,x  E3E6 BD   E54D               jsr    xmtint    interrupt task  E3E9 35   16                 puls   d,x                     *  E3EB 30   89 00D7  20        leax   TSKSIZ,x  next task  E3EF 6A   E4                 dec    0,s       more tasks?  E3F1 26   E5                 bne    10b  E3F3 32   61                 leas   1,s                     *  E3F5 35   B6                 puls   d,x,y,pc  returnFIO Simulation Structure             16:02:56  Nov 28, 2024   Page   43Terminal   Interrupt Handling Task                                                            *                     * SI_HAN Socket interrupt handler                     *  E3F7 108E 040E     SI_HAN    ldy    #SI_Q     Terminal Interrupt Queue  E3FB                         seti  E3FB 1A   50                 orcc   #FF|IF                               endm  E3FD FE   0444               ldu    SI_Q_ptr  get current Q ptr  E400 1183 040E               cmpu   #SI_Q     anything in Q?  E404 26   07                 bne    20f       yes - go process it                     *  E406 C6   D8                 ldb    #SIQPRI   wait for something to do  E408 BD   E518               jsr    sleep  E40B 20   EA                 bra    SI_HAN                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *  E40D E6   C2       20        ldb    0,-u      B = Interrupt #  E40F 34   04                 pshs   b  E411 EC   C3                 ldd    0,--u     A = Device #  E413 34   06                 pshs   d  E415 EC   C3                 ldd    0,--u     task ID  E417 34   06                 pshs   d         save registers  E419 FF   0444               stu    SI_Q_ptr  update pointer                     *                     * S[0][1]=task,U[2][3]=dev,U[4]=response                     *  E41C E6   63                 ldb    3,s       set up to flush all input for this terminal  E41E                         clri   allow     interrupts  E41E 1C   AF                 andcc  #!(FF|IF)                               endm                     *  E420 BD   E2C2               jsr    FIO_get   get access to FIO  E423 EC   E1                 ldd    0,s++     task ID  E425 DD   0A                 std    fio_cpu1  E427 EC   E1                 ldd    ,s++      terminal #  E429 DD   0D                 std    fio_cpu3  terminal  E42B E6   E0                 ldb    ,s+       interrupt #  E42D D7   0C                 stb    fio_cpu2  signal  E42F C6   07                 ldb    #R_INTRPT  E431 BD   E28A               jsr    fio_msg   send interrupt message  E434 BD   E2D7               jsr    FIO_rel   release access to FIO  E437 20   BE                 bra    SI_HAN    process more if needed                                          *                     * Send_SI - Send a socket interrupt                     *   B = Interrupt #                     *   X = task struct                     *   U= wzsock                     *   jsr send_SI                     *FIO Simulation Structure             16:02:57  Nov 28, 2024   Page   44Terminal   Interrupt Handling Task                    E439 34   76       send_SI   pshs   d,x,y,u   save registers  E43B EC   C8 26              ldd    wztype,u  E43E 85   02                 bita   #WFSPOC  E440 27   1F                 beq    99f                     *  E442 FE   0444               ldu    SI_Q_ptr  get Q head  E445 1183 0444               cmpu   #SI_Q_ptr check for overflow  E449 24   0F                 bhs    90f       exit if so - sorry                     *  E44B EC   0A                 ldd    tsseq,x   task ID @ master side  E44D ED   C1                 std    0,u++  E44F EC   0D                 ldd    tsdev,x   wzsock#  E451 ED   C1                 std    0,u++     place value in Queue  E453 E6   61                 ldb    1,s       old B  E455 E7   C0                 stb    0,u+  E457 FF   0444               stu    SI_Q_ptr  update pointer                     *                     * U[0]=int,U[1][2]=dev,U[3][4]=task                     *                     *  E45A 108E 040E     90        ldy    #SI_Q     wake up Queue server  E45E BD   E4F4               jsr    wakeup  E461 35   F6       99        puls   d,x,y,u,pc return                     FIO Simulation Structure             16:02:57  Nov 28, 2024   Page   45History    Entry Procedures                                                                   *                     * H_cpu - Place a transaction from the CPU into                     *         the history Queue.                     *  E463 34   16       H_cpu     pshs   d,x  E465 BE   0499               ldx    hstptr    get history queue pointer  E468 96   00                 lda    cpu_fio  E46A A7   84                 sta    hst_cmd,x  E46C 96   01                 lda    cpu_fio1  E46E A7   01                 sta    hst_seq,x  E470 96   04                 lda    cpu_fio3  E472 A7   02                 sta    hst_tty,x  E474 96   03                 lda    cpu_fio2  E476 A7   03                 sta    hst_val,x  E478 30   04                 leax   HRECSIZ,x  E47A 8C   0499               cmpx   #hstptr   end of Queue?  E47D 25   03                 blo    10f  E47F 8E   0459               ldx    #hstbuf  E482 BF   0499     10        stx    hstptr  E485 35   96                 puls   d,x,pc                                          *                     * H_fio - Place a transaction from the IOP into                     *         the history Queue.                     *  E487 34   16       H_fio     pshs   d,x  E489 BE   0499               ldx    hstptr    get history queue pointer  E48C 96   09                 lda    fio_cpu  E48E A7   84                 sta    hst_cmd,x  E490 96   0A                 lda    fio_cpu1  E492 A7   01                 sta    hst_seq,x  E494 96   0D                 lda    fio_cpu3  E496 A7   02                 sta    hst_tty,x  E498 96   0C                 lda    fio_cpu2  E49A A7   03                 sta    hst_val,x  E49C 30   04                 leax   HRECSIZ,x  E49E 8C   0499               cmpx   #hstptr   end of Queue?  E4A1 25   03                 blo    10f  E4A3 8E   0459               ldx    #hstbuf  E4A6 BF   0499     10        stx    hstptr  E4A9 35   96                 puls   d,x,pcFIO Simulation Structure             16:02:57  Nov 28, 2024   Page   46Scheduler  routines                                                                           *                     * All routines in this file pertain to scheduling                     * operations.                     *                                          *                     * rsched                     *                     * Rsched will reschedule the cpu giving control to                     * another ready task.  If no tasks are ready,                     * looping is done until one becomes ready.  Rsched                     * does not put the current task back on the ready list!                     * This routine returns one to the caller.  All registers                     * are destroyed.                     *                       E4AB               rsched    seti   mask      interrupts  E4AB 1A   50                 orcc   #FF|IF                               endm                     *  E4AD               rsched2   clri  E4AD 1C   AF                 andcc  #!(FF|IF)                               endm  E4AF 12                      nop  E4B0                         seti  E4B0 1A   50                 orcc   #FF|IF                               endm  E4B2 8D   1A                 bsr    stptsk  E4B4 8D   09                 bsr    gtsktb                     *  E4B6 A6   04                 lda    tsstat,x  ready?  E4B8 81   01                 cmpa   #TRUN  E4BA 26   F1                 bne    rsched2                     *  E4BC 8D   21                 bsr    swtchu    switch users top page  E4BE 39                      rts              return                                          *                     * select next (runnable) task                     *  E4BF 34   06       gtsktb    pshs   d         current index  E4C1 8E   04C1               ldx    #tsktab   task table  E4C4 F6   040B               ldb    tskindx  E4C7 86   D7                 lda    #TSKSIZ  E4C9 3D                      mul  E4CA 30   8B                 leax   d,x       select task  E4CC 35   86                 puls   d,pc                       E4CE 34   02       stptsk    pshs   a  E4D0 B6   040B               lda    tskindx   step index  E4D3 4C                      incaFIO Simulation Structure             16:02:58  Nov 28, 2024   Page   47Scheduler  routines                                   E4D4 B1   040C               cmpa   NUM_TSK  E4D7 25   01                 blo    01f       against max  E4D9 4F                      clra  E4DA B7   040B     01        sta    tskindx  E4DD 35   82                 puls   a,pc                                          *                     * Switch users                     *   X - Task entry for new task                     *  E4DF 35   20       swtchu    puls   y         get return address  E4E1 BF   0407               stx    utask     set up new running task  E4E4 10EE 88 13              lds    umark0,x  reset stack  E4E8 6E   A4                 jmp    0,y       return to caller                     FIO Simulation Structure             16:02:58  Nov 28, 2024   Page   48Scheduler  routines                                                                           *                     * makrdy                     *                     * Make a task ready to run.  Enter with x                     * pointing to task table entry.  If new tasks                     * priority is higher than current, set the                     * 'chproc' flag so the system can change tasks.                     *                       E4EA 86   01       makrdy    lda    #TRUN     set status  E4EC A7   04                 sta    tsstat,x  E4EE CC   0000               ldd    #0        clear events flag  E4F1 ED   06                 std    tsevnt,x                     *  E4F3 39            makrd6    rts              returnFIO Simulation Structure             16:02:58  Nov 28, 2024   Page   49Sleep      and Wakeup routines                                                                *                     * wakeup                     *                     * Wakeup all tasks waiting the event designated                     * in the y register.  The x reg is preserved.                     *                       E4F4 34   57       wakeup    pshs   cc,d,x,u  save registers  E4F6                         seti   mask      interupts  E4F6 1A   50                 orcc   #FF|IF                               endm  E4F8 CE   0403               ldu    #slplst  E4FB AE   42                 ldx    tsslnk,u  point to sleep list  E4FD 27   0B                 beq    wakeu4                     *  E4FF 10AC 06       wakeu2    cmpy   tsevnt,x  check event  E502 27   08                 beq    wakeu5  E504 33   84                 leau   0,x       mark this entry                     *  E506 AE   02       wakeu3    ldx    tsslnk,x  follow chain  E508 26   F5                 bne    wakeu2    end of list?                     *  E50A 35   D7       wakeu4    puls   cc,d,x,u,pc return                     *  E50C 34   70       wakeu5    pshs   x,y,u     save registers  E50E EC   02                 ldd    tsslnk,x  remove from list  E510 ED   42                 std    tsslnk,u  E512 8D   D6                 bsr    makrdy    put on ready list  E514 35   70                 puls   u,x,y  E516 20   EE                 bra    wakeu3    repeat                     FIO Simulation Structure             16:02:58  Nov 28, 2024   Page   50Sleep      and Wakeup routines                                                                *                     * sleep                     *                     * Sleep will put this task to sleep with priority                     * specified in the b register.  On entry, y is pointing                     * to the event which will be awakened.                     *  E518 34   51       sleep     pshs   cc,x,u    save registers  E51A BE   0407               ldx    utask     point to task  E51D 6D   08                 tst    tssgnl,x  any signals waiting?  E51F 26   1F                 bne    sleep7                     *  E521                         seti   mask      ints  E521 1A   50                 orcc   #FF|IF                               endm  E523 E7   05                 stb    tsprir,x  set priority  E525 10AF 06                 sty    tsevnt,x  set event  E528 86   02                 lda    #TSLEEP   set status  E52A A7   04                 sta    tsstat,x  E52C FC   0405               ldd    slplst+tsslnk get head of list  E52F ED   02                 std    tsslnk,x  set new link  E531 BF   0405               stx    slplst+tsslnk set new head  E534 17   FF74               lbsr   rsched    reschedule cpu                       E537 BE   0407     20        ldx    utask     get task entry  E53A 6D   08                 tst    tssgnl,x  any signals waiting?  E53C 26   02                 bne    sleep7                     *  E53E 35   D1                 puls   cc,x,u,pc return                     *  E540 BE   0407     sleep7    ldx    utask     reset signal  E543 6F   08                 clr    tssgnl,x  E545 EC   88 15              ldd    umark1,x  stack reset point  E548 35   51                 puls   cc,x,u    reset cc and registers  E54A 1F   04                 tfr    d,s       change stacks  E54C 39                      rts              returnFIO Simulation Structure             16:02:58  Nov 28, 2024   Page   51Sleep      and Wakeup routines                                                                *                     * xmtint - Send an interrupt to a task                     *  X - Task entry                     *  jsr xmtint                     *  E54D 34   76       xmtint    pshs   d,x,y,u   save registers  E54F A6   04                 lda    tsstat,x  get task state  E551 81   01                 cmpa   #TRUN     running?  E553 26   06                 bne    10f       no - try something else                     *  E555 86   01                 lda    #1        set signal  E557 A7   08                 sta    tssgnl,x  E559 20   0E                 bra    99f       exit                     *  E55B 81   02       10        cmpa   #TSLEEP   task sleeping?  E55D 26   0A                 bne    99f       no - can't send interrupt                     *  E55F 86   01                 lda    #1        set signal  E561 A7   08                 sta    tssgnl,x  E563 10AE 06                 ldy    tsevnt,x  wake task up >E566 17   FF8B               lbsr   wakeup                     *  E569 35   F6       99        puls   d,x,y,u,pc returnFIO Simulation Structure             16:02:59  Nov 28, 2024   Page   52Sleep      and Wakeup routines                                                                *                     * the routines in this file are specific                     * for the W5500 socket device                     * they are called from "wskhan" and "wskdrv" files                     *                     * wzsocket device table                     *  E56B               DEV_SOCK  E56B E39F                    fdb    bad_cmd   0  E56D E66D                    fdb    skopen    S_OPEN    1 open socket  E56F E712                    fdb    skclos    S_CLOSE   2 close socket  E571 E94E                    fdb    skreqwr   S_RQWR    3 request write to socket  E573 E9A3                    fdb    sksend    S_SEND    4 write data to socket  E575 E8B3                    fdb    skreqrd   S_RQRD    5 request read data from socket  E577 E90B                    fdb    skrecv    S_RECV    6 read data from socket  E579 E712                    fdb    skintrp   S_INTRPT  7 interrupt socket  E57B E75F                    fdb    skconn    S_CONNECT 8 connect socket  E57D E7F2                    fdb    skbind    S_BIND    9 bind socket  E57F E836                    fdb    sklist    S_LISTEN  10 listen on socket  E581 E872                    fdb    skacpt    S_ACCEPT  11 accept connection  E583 ED1F                    fdb    skdisc    S_DISCON  12 disconnect socket  E585 ED1F                    fdb    sksmac    S_SNDMAC  13 send mac  E587 ED1F                    fdb    skskep    S_SNDKEP  14 send keep alive  E589 EC5B                    fdb    skspcl    S_SPCL    15 special command  E58B E9E5                    fdb    skurrdf   S_RRDFRM  16 request read readfrom  E58D EA6A                    fdb    skurrd    S_RREAD   17 read data readfrom  E58F EA98                    fdb    skurwt    S_WRQSTO  18 request write sendto  E591 EB23                    fdb    skusnt    S_WSNDTO  19 write data sendto  E593 EADC                    fdb    skusnm    S_WSNDTM  20 write data send more  E595 E5CB                    fdb    sknone    21  E597 E5CB                    fdb    sknone    22  E599 E5CB                    fdb    sknone    23  E59B EBF1                    fdb    sknbsr    S_RQSBLK  24 netblock req send ext block  E59D EC2B                    fdb    sknbsd    S_SNDBLK  25 netblock send ext block  E59F EB5D                    fdb    sknbrr    S_RQRBLK  26 netblock req read ext block  E5A1 EBC2                    fdb    sknbrd    S_RDRBLK  27 netblock read ext block  E5A3 E5CB                    fdb    sknone    28  E5A5 E5CB                    fdb    sknone    29  E5A7 F40E                    fdb    netboot   30 network boot  E5A9 F3F6                    fdb    memp2ff   31 copy memory page to fifo                     *                     * check nwp_devtab.h !!                     *  E5AB E625                    fdb    skinthan  16 socket interrupt handler  E5AD E5B1                    fdb    skinit    17 socket initialization  E5AF E622                    fdb    sktest    18 test device present                     *                     *                     * this file contains all socket handlers                     *                     * when a wzsocket is opened, all locations are effectivelyFIO Simulation Structure             16:03:00  Nov 28, 2024   Page   53wz socket interface routines                                             * cleared to zero, with exception of the enumeration byte                     *                                    0200  BUFSIZ    equ    512       fifo and system buffer size                                          *                     * do everything to init the system                     *               E5B1  skinit    equ    *  E5B1 BD   ED26               jsr    spinit    set SPI  E5B4 C6   82                 ldb    #%10000010 software reset + force ARP  E5B6 BD   EDF7               jsr    PCRMR  E5B9 BD   EDE8     01        jsr    GCRMR  E5BC 5D                      tstb  E5BD 2B   FA                 bmi    01b                     *  E5BF C6   78                 ldb    #%01111000 power up  E5C1 BD   EFD5               jsr    PCRPHY    set the PHY part  E5C4 CC   8000               ldd    #32768  E5C7 FD   0457               std    wzanyp    set value for Source port  E5CA 39                      rts                                          *                     * sknone, return error, not implemented                     *  E5CB C6   81       sknone    ldb    #E_BADCMD  E5CD 39                      rts                                          *                     * check if ROM locations are preset, if not skip this here                     * else setup device with provided values                     *  E5CE 108E E000     skdvini   ldy    #wzifma   where mac address is to be found  E5D2 EC   A1       03        ldd    0,y++  E5D4 1083 FFFF               cmpd   #$ffff    not set  E5D8 26   07                 bne    02f  E5DA 108C E012               cmpy   #wzifga+4 past area  E5DE 25   F2                 blo    03b                     * ROM not initialized, do nothing  E5E0 39                      rts                                          *                     * values present, setup device                     *  E5E1 34   66       02        pshs   d,y,u  E5E3 DE   1A                 ldu    fifo_us1  E5E5 108E E006               ldy    #wzifip   source IP  E5E9 EC   A1                 ldd    0,y++  E5EB ED   C1                 std    0,u++  E5ED EC   A1                 ldd    0,y++  E5EF ED   C1                 std    0,u++  E5F1 108E E00A               ldy    #wzifnm   netmaskFIO Simulation Structure             16:03:00  Nov 28, 2024   Page   54wz socket interface routines                          E5F5 EC   A1                 ldd    0,y++  E5F7 ED   C1                 std    0,u++  E5F9 EC   A1                 ldd    0,y++  E5FB ED   C1                 std    0,u++  E5FD 108E E00E               ldy    #wzifga   gateway ip  E601 EC   A1                 ldd    0,y++  E603 ED   C1                 std    0,u++  E605 EC   A1                 ldd    0,y++  E607 ED   C1                 std    0,u++  E609 108E E000               ldy    #wzifma   mac address  E60D EC   A1                 ldd    0,y++  E60F ED   C1                 std    0,u++  E611 EC   A1                 ldd    0,y++  E613 ED   C1                 std    0,u++  E615 EC   A1                 ldd    0,y++  E617 ED   C1                 std    0,u++                     *  E619 C6   FF                 ldb    #$ff      set active  E61B E7   C4                 stb    0,u  E61D BD   EC8A               jsr    wzwdev    init device with settings  E620 35   E6                 puls   d,y,u,pc                                          *                     * test if device is present                     *  E622 1A   01       sktest    sec              yes  E624 39                      rts                                          *                     * skinthan, fromddevice table                     *               E625  skinthan  equ    *  E625 39                      rts                                          *                     * device signal handle, from master                     *               E626  sdev_sig  equ    *  E626 C6   07                 ldb    #R_INTRPT we saw it  E628 39                      rts                                          *                     * get a new source port                     *  E629 FC   0457     sknewp    ldd    wzanyp    else create one  E62C                         incd  E62C 104C                    fdb    $104c                               endm  E62E 1083 FFF0               cmpd   #$FFF0  E632 25   03                 blo    03f  E634 CC   8000               ldd    #$8000  E637 FD   0457     03        std    wzanypFIO Simulation Structure             16:03:00  Nov 28, 2024   Page   55wz socket interface routines                          E63A 39                      rts                                                               *                     * check if W5500 is active                     * wzdevt, device test, return Z if running, NZ if not                     *  E63B 34   22       wzdevt    pshs   a,y  E63D 109E 1A                 ldy    fifo_us1  device info  E640 A6   A8 12              lda    wzdsta,y  E643 81   FF                 cmpa   #$ff      open  E645 35   A2                 puls   a,y,pc                                          *                     * skfres, socket restore info, set E register                     *  E647 A6   C4       skfres    lda    wzenum,u  socket #, is remembered  E649                         trfr   A,E  E649 1F                      fcb    $1f  E64A 8E                      fcb    A<<4|E                               endm  E64B 6F   47                 clr    wzerr,u   init result  E64D 39                      rts                                          *                     * skctcp, check if in TCP mode                     * return zero if in TCP mode, non-zero if not                     * U = wzsock                     *  E64E 34   06       skctcp    pshs   d  E650 EC   C8 26              ldd    wztype,u  SOCK_STREAM  E653 C1   01                 cmpb   #SK_STRM  is TCP  E655 35   86                 puls   d,pc                                          *                     * skcudp, check if in UDP  mode                     * return zero if in UDP mode, non-zero if not                     * U = wzsock                     *  E657 34   06       skcudp    pshs   d  E659 EC   C8 26              ldd    wztype,u  SOCK_DGRAM  E65C C1   02                 cmpb   #SK_DGRM  is UDP  E65E 27   02                 beq    01f  E660 C1   04                 cmpb   #SK_IRAW  also allowed  E662 35   86       01        puls   d,pc                                          *                     * skraw, check if in RAW mode                     * return zero if in RAW mode, non-zero if not                     * U = wzsock                     *  E664 34   06       skcraw    pshs   dFIO Simulation Structure             16:03:01  Nov 28, 2024   Page   56wz socket interface routines                          E666 EC   C8 26              ldd    wztype,u  SOCK_DGRAM  E669 C1   03                 cmpb   #SK_MRAW  is RAW socket  E66B 35   86                 puls   d,pc                                          ****************************************************************                     *                     * here the socket is opened                     * X hold the TASK table                     * U holds the sock address                     *               E66D  skopen    equ    * >E66D BD   E647               jsr    skfres                     *                     * check if DEVICE is active                     * >E670 BD   E63B               jsr    wzdevt  E673 27   06                 beq    11f  E675 BD   E72D               jsr    skclin    NO, close internal and don't start >E678 16   0069     04        lbra   skoper1                     *                     * retry, we do all things                     *  E67B A6   42       11        lda    wzfsta,u  check if allocated by OS  E67D 2A   F9                 bpl    04b       error, do nothing                     *                     * check socket() call arguments                     *  E67F 6F   43                 clr    wzflg,u   erase flags  E681 6F   41                 clr    wzdctr,u  init counter  E683 EC   C8 24              ldd    wzfaml,u  E686 C1   02                 cmpb   #AF_INET  E688 26   EE                 bne    04b       not supported                     * wztype holds socket type AND socket flags (hibyte)  E68A EC   C8 26              ldd    wztype,u  E68D C1   01                 cmpb   #SK_STRM  SOCK_STREAM  E68F 27   22                 beq    01f  E691 C1   02                 cmpb   #SK_DGRM  SOCK_DGRAM  E693 27   1A                 beq    21f                     *        cmpb    #SK_MRAW        SOCK_RAW                     *        beq     41f  E695 C1   04                 cmpb   #SK_IRAW  IP_RAW  E697 26   4F                 bne    skoper2                     *                     * raw IP socket, set protocol register first                     * UDP and TCP are handled in a different way                     *  E699 EC   C8 28              ldd    wzprot,u  what is the protocol option?  E69C C1   06                 cmpb   #SP_TCP   not allowed  E69E 27   48                 beq    skoper2  E6A0 C1   11                 cmpb   #SP_UDP   not allowed  E6A2 27   44                 beq    skoper2  E6A4 BD   F138               jsr    PSRPROT   set protocol registerFIO Simulation Structure             16:03:01  Nov 28, 2024   Page   57wz socket interface routines                                             *  E6A7 C6   03                 ldb    #%00000011 IPRAW  E6A9 20   0A                 bra    07f                     * nacraw  E6AB C6   04       41        ldb    #%00000100 MACRAW  E6AD 20   06                 bra    07f                     * dgram  E6AF C6   02       21        ldb    #%00000010 UDP  E6B1 20   02                 bra    07f                     * TCP socket  E6B3 C6   01       01        ldb    #%00000001 TCP set source port in connect                     *                     * set socket mode register                     *  E6B5 BD   F002     07        jsr    PSRMR     set socket mode register                     *                     * here do the real OPEN,                     *  E6B8 C6   01                 ldb    #WCOPEN   open the device  E6BA E7   44                 stb    wzcmnd,u  copy command  E6BC BD   F020               jsr    PSRCR  E6BF 108E 0000               ldy    #0        nopoll                     *                     * interrupts not expected                     *               E6C3  skowfo    equ    * >E6C3 BD   E647               jsr    skfres    reset important info  E6C6 BD   F054     21        jsr    GSRSR     get status  E6C9 E7   45                 stb    wzstat,u  E6CB C1   00                 cmpb   #WSCLSD   not closed?  E6CD 26   0B                 bne    22f                     *  E6CF 6A   41                 dec    wzdctr,u  delay counter  E6D1 27   15                 beq    skoper2  E6D3 108E E6C3               ldy    #skowfo  E6D7 7E   E7D0               jmp    polext    switch tasks                     *  E6DA A6   42       22        lda    wzfsta,u  mark bind is needed  E6DC 8A   40                 ora    #WZWBND  E6DE A7   42                 sta    wzfsta,u  E6E0 4F                      clra  E6E1 C6   01                 ldb    #R_OPEN   response  E6E3 39            99        rts                     *  E6E4 86   01       skoper1   lda    #1        device not initialized  E6E6 20   02                 bra    12f  E6E8 86   02       skoper2   lda    #2        type error  E6EA C6   C0       12        ldb    #E_SOCKET  E6EC 20   F5                 bra    99b                                          *                     * convert number in bit positionFIO Simulation Structure             16:03:01  Nov 28, 2024   Page   58wz socket interface routines                                             * B = enum, B=bit                     *  E6EE 34   10       num2bt    pshs   x  E6F0 8E   E709               ldx    #bittab  E6F3 3A                      abx  E6F4 E6   84                 ldb    0,x  E6F6 35   90                 puls   x,pc                                          *                     * bit to nummer, offset byt one, entry should NOT be 0                     *  E6F8 34   10       bt2num    pshs   x  E6FA 8E   E709               ldx    #bittab  E6FD 6F   E2                 clr    0,-s  E6FF E1   80       02        cmpb   0,x+  E701 27   04                 beq    01f  E703 6C   E4                 inc    0,s  E705 20   F8                 bra    02b  E707 35   94       01        puls   b,x,pc                                          * table  E709 00            bittab    fcb    0  E70A 01 02 04 08             fcb    %00000001,%00000010,%00000100,%00001000  E70E 10 20 40 80             fcb    %00010000,%00100000,%01000000,%10000000                                                               ***************************************************************                     *                     * close the socket                     * X hold the task table                     * U holds the sock address                     *               E712  skclos    equ    *               E712  skintrp   equ    *         interrupt!  E712 BD   E647               jsr    skfres  E715 C6   08                 ldb    #WCDISC  E717 E7   44                 stb    wzcmnd,u  E719 BD   F020               jsr    PSRCR     send disconnect                     *  E71C 8D   0F                 bsr    skclin    internal close  E71E                         clrd  E71E 104F                    fdb    $104f                               endm  E720 ED   C8 24              std    wzfaml,u  E723 ED   C8 26              std    wztype,u  E726 ED   C8 28              std    wzprot,u                     *  E729 4F                      clra  E72A C6   02                 ldb    #R_CLOSE  response  E72C 39                      rts                                          *FIO Simulation Structure             16:03:02  Nov 28, 2024   Page   59wz socket interface routines                                             * wzclin, close interal                     *  E72D 34   06       skclin    pshs   d  E72F C6   10                 ldb    #WCCLOS   do close  E731 E7   44                 stb    wzcmnd,u  E733 BD   F020               jsr    PSRCR                     *                     * erase registers in device                     *  E736 CC   0000               ldd    #0  E739 BD   F072               jsr    PSRPORT   source port                     *  E73C A6   42                 lda    wzfsta,u  E73E 84   00                 anda   #0        mask (?)  E740 A7   42                 sta    wzfsta,u  E742 CC   0000               ldd    #0  E745 ED   48                 std    wzxfer,u  clear remaining size                     *  E747 BD   F054     91        jsr    GSRSR  E74A E7   45                 stb    wzstat,u  stat = 0 (closed)                     *  E74C CC   0000               ldd    #0  E74F ED   C8 10              std    wzsprt,u  erase old info  E752 ED   C8 14              std    wzipad,u  E755 ED   C8 16              std    wzipad+2,u  E758 ED   C8 12              std    wzdprt,u  E75B E7   43                 stb    wzflg,u   clear flags                     *  E75D 35   86                 puls   d,pc                                          ***************************************************************                     *                     * connect socket                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E75F  skconn    equ    *  E75F BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E762 BD   E63B               jsr    wzdevt  E765 27   06                 beq    01f >E767 BD   E712               jsr    skclos    NO, don't start >E76A 16   0077     02        lbra   skcner4  E76D BD   E64E     01        jsr    skctcp    not in tcp, illegal  E770 26   F8                 bne    02b                     *                     * check if socket has been set up                     *  E772 BD   F054     11        jsr    GSRSR     statusFIO Simulation Structure             16:03:02  Nov 28, 2024   Page   60wz socket interface routines                          E775 E7   45                 stb    wzstat,u  check if properly setup  E777 C1   13                 cmpb   #WSINIT   SHOULD BE >E779 1026 005F               lbne   skcner6                     *                     * check the info from the connect call                     *  E77D EC   C8 14              ldd    wzipad,u  check if dest IP == null  E780                         ordx   wzipad+2,IU  E780 10AA                    fdb    $10aa  E782                         doindx wzipad+2,IU  E782 C8 16                   fcb    $88+(IU<<5),(wzipad+2&$7f)                               endm                               endm  E784 27   62                 beq    skcner1   IP address == NULL                     * IP address = 0000  E786 EC   C8 14              ldd    wzipad,u  or FFFFFFFF  E789                         incd  E789 104C                    fdb    $104c                               endm  E78B 26   07                 bne    01f  E78D EC   C8 16              ldd    wzipad+2,u  E790                         incd  E790 104C                    fdb    $104c                               endm  E792 27   54                 beq    skcner1   IP address = FFFFFFFF                     *                     * valid IP                     *  E794 EC   C8 12    01        ldd    wzdprt,u  check destination port  E797 27   47                 beq    skcner5   is not set, error                     *  E799 BD   F0FC               jsr    PSRDPOR   set destination port  E79C 31   C8 14              leay   wzipad,u  load socket  E79F BD   F0D6               jsr    PSRDIP    set destination IP                     *                     * source port, create one, always unique                     *  E7A2 BD   E629               jsr    sknewp    get new  E7A5 ED   C8 10              std    wzsprt,u  tell us what you took  E7A8 BD   F072               jsr    PSRPORT   source port                     *                     * do the CONNECT here                     *  E7AB C6   04                 ldb    #WCCONN  E7AD E7   44                 stb    wzcmnd,u  E7AF BD   F020               jsr    PSRCR     do connect                     *                     *                     *  E7B2 BD   E647     conlb1    jsr    skfres  E7B5 BD   F054               jsr    GSRSR     update status  E7B8 E7   45                 stb    wzstat,uFIO Simulation Structure             16:03:02  Nov 28, 2024   Page   61wz socket interface routines                          E7BA C1   17                 cmpb   #WSESTB  E7BC 27   0E                 beq    90f  E7BE C1   00                 cmpb   #WSCLSD   is closed?  E7C0 27   16                 beq    skcner2  E7C2 C1   1C                 cmpb   #WSCLWT   close wait?  E7C4 27   12                 beq    skcner2  E7C6 108E E7B2               ldy    #conlb1  E7CA 20   04                 bra    polext                     *  E7CC 4F            90        clra  E7CD C6   08                 ldb    #R_CONNECT  E7CF 39            99        rts                                          *                     * polexit, Y=where to return                     *  E7D0 10AF 0F       polext    sty    tsagin,x  here to restart  E7D3 108E FFFF               ldy    #$ffFF  E7D7 39                      rts                       E7D8 C6   0C       skcner2   ldb    #R_DISCON  E7DA 20   F3                 bra    99b                       E7DC               skcner6  E7DC 86   0F                 lda    #15       not properly setup  E7DE 20   0E                 bra    09f  E7E0 86   0E       skcner5   lda    #14       destination port not set  E7E2 20   0A                 bra    09f  E7E4 86   0A       skcner4   lda    #10       device not initialized  E7E6 20   06                 bra    09f  E7E8 86   0B       skcner1   lda    #11       IP address invalid  E7EA 20   02                 bra    09f  E7EC 86   0D       skcner3   lda    #13  E7EE C6   C0       09        ldb    #E_SOCKET  E7F0 20   DD                 bra    99b                                          ***************************************************************                     *                     * bind request                     * X hold the task table                     * U holds the sock address                     * bindt() call fills in info in the sock structure                     *               E7F2  skbind    equ    *  E7F2 BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E7F5 BD   E63B               jsr    wzdevt  E7F8 1026 010A               lbne   rdrqer1  E7FC BD   E64E               jsr    skctcp    check TCP  E7FF 27   07                 beq    01fFIO Simulation Structure             16:03:03  Nov 28, 2024   Page   62wz socket interface routines                          E801 BD   E657               jsr    skcudp    check UDP >E804 1026 FFD4               lbne   skcner6  E808               01                     *                     * go on , the bind() call sets wzipad and wzsprt, this is for                     * a server, for a client it needs to set wzdprt                     * for as server IP is local, for a client IP is remote                     *                     *  E808 BD   F054               jsr    GSRSR     status  E80B E7   45                 stb    wzstat,u  E80D C1   22                 cmpb   #WSUDP    check  E80F 27   0F                 beq    03f  E811 C1   13                 cmpb   #WSINIT   should be >E813 1026 FFC5     04        lbne   skcner6                     *                     * set the network connection data                     *  E817 BD   E629               jsr    sknewp  E81A ED   C8 12              std    wzdprt,u  E81D BD   F0FC               jsr    PSRDPOR   destination port  E820 EC   C8 10    03        ldd    wzsprt,u  E823 BD   F072               jsr    PSRPORT   source port                     *  E826 31   C8 14              leay   wzipad,u  E829 BD   F0D6               jsr    PSRDIP    source IP                     *  E82C A6   42                 lda    wzfsta,u  we did BIND  E82E 84   BF                 anda   #255-WZWBND  E830 A7   42                 sta    wzfsta,u  E832 4F                      clra  E833 C6   09                 ldb    #R_BIND  E835 39                      rts                     *                                          ***************************************************************                     *                     * listen request                     * X hold the task table                     * U holds the sock address                     * listen() call waits for peer to connect                     *               E836  sklist    equ    *  E836 BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E839 BD   E63B               jsr    wzdevt  E83C 1026 00C6     02        lbne   rdrqer1  E840 BD   E64E               jsr    skctcp  E843 26   F7                 bne    02b                     *FIO Simulation Structure             16:03:04  Nov 28, 2024   Page   63wz socket interface routines                                             * go on                     *                     *  E845 BD   F054               jsr    GSRSR     status  E848 E7   45                 stb    wzstat,u                     *  E84A C1   00                 cmpb   #WSCLSD   closed?  E84C 27   19                 beq    80f  E84E C1   1C                 cmpb   #WSCLWT   close wait?  E850 27   15                 beq    80f  E852 C1   13                 cmpb   #WSINIT   opened  E854 26   15                 bne    90f                     *  E856 A6   42                 lda    wzfsta,u  did we BIND  E858 85   40                 bita   #WZWBND  E85A 26   0B                 bne    80f       no, error                     *  E85C C6   02                 ldb    #WCLIST  E85E E7   44                 stb    wzcmnd,u  E860 BD   F020               jsr    PSRCR                     *  E863 4F                      clra  E864 C6   0A                 ldb    #R_LISTEN  E866 39                      rts                                          *  E867 4F            80        clra  E868 C6   02                 ldb    #R_CLOSE  E86A 39                      rts                     *  E86B 108E E836     90        ldy    #sklist  E86F 7E   E7D0               jmp    polext                                          ***************************************************************                     *                     * accept request                     * X hold the task table                     * U holds the sock address                     * listen() call waits for peer to connect                     *               E872  skacpt    equ    *  E872 BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E875 BD   E63B               jsr    wzdevt  E878 1026 008A     02        lbne   rdrqer1  E87C BD   E64E               jsr    skctcp  E87F 26   F7                 bne    02b       wrong mode                     *                     * go on                     *FIO Simulation Structure             16:03:05  Nov 28, 2024   Page   64wz socket interface routines                          E881 BD   F054               jsr    GSRSR     status  E884 E7   45                 stb    wzstat,u  E886 C1   17                 cmpb   #WSESTB   connected  E888 26   16                 bne    01f                     *  E88A A6   42                 lda    wzfsta,u  did we BIND  E88C 85   40                 bita   #WZWBND  E88E 26   19                 bne    03f       no, error                     *  E890 BD   F0ED               jsr    GSRDPOR   fill in peer port  E893 ED   C8 12              std    wzdprt,u  E896 31   C8 14              leay   wzipad,u  E899 BD   F0BF               jsr    GSRDIP                     *  E89C 4F                      clra  E89D C6   0B                 ldb    #R_ACCEPT  E89F 39                      rts                     *  E8A0 C1   00       01        cmpb   #WSCLSD  E8A2 27   05                 beq    03f  E8A4 C1   1C                 cmpb   #WSCLWT  E8A6 26   04                 bne    02f  E8A8 4F                      clra  E8A9 C6   02       03        ldb    #R_CLOSE  E8AB 39                      rts                     *  E8AC 108E E872     02        ldy    #skacpt  E8B0 7E   E7D0               jmp    polext                                                               ***************************************************************                     *                     * read request  TCP only !!                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E8B3  skreqrd   equ    *  E8B3 BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E8B6 BD   E63B               jsr    wzdevt >E8B9 1026 0049     02        lbne   rdrqer1  E8BD BD   E64E               jsr    skctcp    check TCP  E8C0 26   F7                 bne    02b                     *                     * go on                     *  E8C2 BD   F054               jsr    GSRSR  E8C5 E7   45                 stb    wzstat,u  update status  E8C7 C1   17                 cmpb   #WSESTB   connection active?FIO Simulation Structure             16:03:05  Nov 28, 2024   Page   65wz socket interface routines                          E8C9 26   0B                 bne    82f                     * check data available  E8CB BD   F20B               jsr    GSRRXRS   data available?  E8CE ED   48                 std    wzxfer,u  E8D0 27   13                 beq    85f                     * data present  E8D2 4F            87        clra  E8D3 C6   05                 ldb    #R_RQRD  E8D5 39                      rts                     * not established  E8D6 E6   45       82        ldb    wzstat,u  E8D8 C1   00                 cmpb   #WSCLSD   closed?  E8DA 26   14                 bne    84f       (85f)241128                     * close socket and return  E8DC C6   06       81        ldb    #PIPES  E8DE BD   E439               jsr    send_SI   send to main CPU  E8E1 4F                      clra  E8E2 C6   02                 ldb    #R_CLOSE  E8E4 39                      rts                     * established but no data yet || not established and not closed  E8E5 EC   C8 26    85        ldd    wztype,u  check flags  E8E8 85   01                 bita   #WFNBLK   non block  E8EA 27   04                 beq    84f                     * non block ************************  E8EC 4F                      clra  E8ED C6   15                 ldb    #R_RQRDNB tell no data  E8EF 39                      rts                     *  E8F0 E6   45       84        ldb    wzstat,u  E8F2 C1   1C                 cmpb   #WSCLWT   last attempt  E8F4 26   09                 bne    86f       go poll                     * close wait active  E8F6 BD   F20B               jsr    GSRRXRS  E8F9 ED   48                 std    wzxfer,u  E8FB 26   D5                 bne    87b       last data  E8FD 20   DD                 bra    81b       close                     *  E8FF 108E E8B3     86        ldy    #skreqrd  E903 7E   E7D0               jmp    polext                                          *                     * error in socket status  E906 86   82       rdrqer1   lda    #130  E908 C6   C0                 ldb    #E_SOCKET  E90A 39                      rts                                          ***************************************************************                     *                     * get the data  U=wzsock, X=task struct                     *               E90B  skrecv    equ    *  E90B BD   E647               jsr    skfresFIO Simulation Structure             16:03:06  Nov 28, 2024   Page   66wz socket interface routines                                             *                     * is the DEVICE (still) active                     *  E90E BD   E63B               jsr    wzdevt >E911 1026 FFF1               lbne   rdrqer1  E915 BD   E64E     02        jsr    skctcp  E918 26   FB                 bne    02b                     *                     * we got info that data is present, get it                     * if here the main CPU already locked the fifo for us                     * on return D= xfreed count                     *  E91A BD   F20B               jsr    GSRRXRS   received size                     * D total aviable data  E91D 108E 0020               ldy    #fifo     target  E921 BD   F2DB               jsr    RDSK2FB   transfer datat to fifo  E924 ED   48                 std    wzxfer,u  save it                     *                     * here check if PROT_XLTEOF is set                     *  E926 6D   C8 28              tst    wzprot,u  PROT_XLTEOL is $8000  E929 2A   18                 bpl    01f                     *                     * do EOL conversion in fifo buffer                     *  E92B 34   36                 pshs   d,x,y  E92D 1F   01                 tfr    d,x       count  E92F 108E 0020               ldy    #fifo  E933 A6   A4       03        lda    0,y  E935 81   0A                 cmpa   #LF       is line feed  E937 26   02                 bne    02f  E939 86   0D                 lda    #CR       make it Return  E93B A7   A0       02        sta    0,y+  E93D 30   1F                 leax   -1,x      count  E93F 26   F2                 bne    03b  E941 35   36                 puls   d,x,y                     *                     *                     *  E943 C6   40       01        ldb    #WCRECV  E945 E7   44                 stb    wzcmnd,u  E947 BD   F020               jsr    PSRCR     tell sender we took it                       E94A C6   06                 ldb    #R_READ   tell data in fifo  E94C 4F                      clra  E94D 39                      rts                                          ***************************************************************                     *                     * write request                     * X hold the task table                     * U holds the sock addressFIO Simulation Structure             16:03:07  Nov 28, 2024   Page   67wz socket interface routines                                             * connect() call fills in info in the sock structure                     *               E94E  skreqwr   equ    *  E94E BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E951 BD   E63B               jsr    wzdevt >E954 1026 FFAE     02        lbne   rdrqer1  E958 BD   E64E               jsr    skctcp  E95B 26   F7                 bne    02b                     *                     * go on                     *  E95D BD   F054               jsr    GSRSR  E960 E7   45                 stb    wzstat,u  update status  E962 C1   17                 cmpb   #WSESTB  E964 26   0C                 bne    82f                     * connection active  E966 BD   F1BF     83        jsr    GSRTXFR   free size (remaining)  E969 10A3 4A                 cmpd   wzrqln,u  would it fit  E96C 25   13                 blo    85f                     * data space is enough  E96E 4F            88        clra  E96F C6   03                 ldb    #R_RQWR  E971 39                      rts                     * not established  E972 E6   45       82        ldb    wzstat,u  E974 C1   00                 cmpb   #WSCLSD  E976 26   09                 bne    85f                     * close socket and return  E978 C6   06       89        ldb    #PIPES  E97A BD   E439               jsr    send_SI   send to main CPU  E97D 4F                      clra  E97E C6   02                 ldb    #R_CLOSE  E980 39                      rts                     *  E981 EC   C8 26    85        ldd    wztype,u  E984 85   01                 bita   #WFNBLK  E986 27   04                 beq    86f                     * data space exhausted, would block  E988 4F                      clra  E989 C6   13                 ldb    #R_RQWRNB  E98B 39                      rts                     * not closed  E98C E6   45       86        ldb    wzstat,u  E98E C1   1C                 cmpb   #WSCLWT   try data  E990 26   0A                 bne    87f                     *  E992 BD   F1BF               jsr    GSRTXFR   free size (remaining)  E995 10A3 4A                 cmpd   wzrqln,u  would it fit  E998 24   D4                 bhs    88bFIO Simulation Structure             16:03:07  Nov 28, 2024   Page   68wz socket interface routines                          E99A 20   DC                 bra    89b                     *  E99C 108E E94E     87        ldy    #skreqwr  E9A0 7E   E7D0               jmp    polext                                          ***************************************************************                     *                     * write request                     * X hold the task table                     * U holds the sock address                     * connect() call fills in info in the sock structure                     *               E9A3  sksend    equ    *  E9A3 BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E9A6 BD   E63B               jsr    wzdevt  E9A9 1026 FF59     02        lbne   rdrqer1  E9AD BD   E64E               jsr    skctcp  E9B0 26   F7                 bne    02b                     *                     * we got info that data is present, get it                     * if here the main CPU already locked the fifo for us                     * on return D= xfreed count                     *  E9B2 EC   4A                 ldd    wzrqln,u  data to xfer                     * D = total available space  E9B4 6D   C8 28              tst    wzprot,u  check if PROT_XLTEOL is set  E9B7 2A   18                 bpl    01f                     *                     *  do EOL conversion in fifo buffer                     *  E9B9 34   36                 pshs   d,x,y  E9BB 1F   01                 tfr    d,x       count  E9BD 108E 0020               ldy    #fifo  E9C1 A6   A4       03        lda    0,y  E9C3 81   0D                 cmpa   #CR       Return?  E9C5 26   02                 bne    02f  E9C7 86   0A                 lda    #LF       make it Line feed  E9C9 A7   A0       02        sta    0,y+  E9CB 30   1F                 leax   -1,x      count  E9CD 26   F2                 bne    03b  E9CF 35   36                 puls   d,x,y                     *                     *                     *  E9D1 108E 0020     01        ldy    #fifo     target  E9D5 BD   F329               jsr    WRFB2SK   transfer from fifo to socket  E9D8 ED   48                 std    wzxfer,u  save it  E9DA C6   20                 ldb    #WCSEND  E9DC E7   44                 stb    wzcmnd,uFIO Simulation Structure             16:03:08  Nov 28, 2024   Page   69wz socket interface routines                          E9DE BD   F020               jsr    PSRCR     tell sender it is coming                       E9E1 C6   04                 ldb    #R_WRITE  tell data in fifo  E9E3 4F                      clra  E9E4 39                      rts                                          ***************************************************************                     * skurrdf, request readfrom                     *                     *                     * X hold the task table                     * U holds the sock address                     *                     * UDP type transfers have diffent W5500 buffer layouts for receive                     *                     * pure UDP  (WSUDP) returns                     *                     *  [sender-IP][sender-Port][data-len][data.............]                     *                     * IPRAW (WSIRAW) returns                     *                     *  [senser-IP][data-len][data.................]                     *                     *               E9E5  skurrdf   equ    *  E9E5 BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  E9E8 BD   E63B               jsr    wzdevt  E9EB 1026 FF17     02        lbne   rdrqer1  E9EF BD   E657               jsr    skcudp  E9F2 26   F7                 bne    02b                     *                     * no  packet data present, wait for it                     *  E9F4 BD   F054               jsr    GSRSR  E9F7 E7   45                 stb    wzstat,u  update status  E9F9 C1   22                 cmpb   #WSUDP  E9FB 27   21                 beq    81f                     *  E9FD C1   32                 cmpb   #WSIRAW   W55 state  E9FF 26   54                 bne    82f                     * IPRAW handling  EA01 EC   C8 20              ldd    wzurms,u  new data  EA04 26   45                 bne    83f       no                     * yes, read data details  EA06 BD   F20B               jsr    GSRRXRS   now full UDP size  EA09 ED   7E                 std    -2,s      test D  EA0B 27   48                 beq    82f                     * read [sender-IP][data-len]  EA0D 31   C8 1A              leay   wzuipa,uFIO Simulation Structure             16:03:08  Nov 28, 2024   Page   70wz socket interface routines                          EA10 CC   0006               ldd    #6  EA13 BD   ED7E               jsr    bmread                     * read data size  EA16 EC   C8 1E              ldd    wzuprt,u  here lands size  EA19 ED   C8 20              std    wzurms,u  EA1C 20   23                 bra    87f                     * pure UDP handling, check if BIND has been called before  EA1E A6   42       81        lda    wzfsta,u  EA20 85   40                 bita   #WZWBND   did we? BIND erases flag  EA22 1026 00FA               lbne   skuer1    we need for datagram server                     *  EA26 EC   C8 20              ldd    wzurms,u  new data?  EA29 26   20                 bne    83f       no                     * check data available  EA2B BD   F20B               jsr    GSRRXRS   data available?  EA2E ED   7E                 std    -2,s      test D  EA30 27   23                 beq    82f       keep waiting                     *                     * first data present, set [wzuipa(4), wzuprt(2), wzurms(2)]                     *                     * get header info from data  EA32 CC   0008               ldd    #8        size of header  EA35 31   C8 1A              leay   wzuipa,u  read 8 bytes from socketbuffer  EA38 BD   ED7E               jsr    bmread    copy data and update PSRRXRP!  EA3B EC   C8 1E              ldd    wzuprt,u  who sent it  EA3E ED   C8 12              std    wzdprt,u  EA41 C6   40       87        ldb    #WCRECV  EA43 E7   44                 stb    wzcmnd,u  process move pointer  EA45 BD   F020               jsr    PSRCR                     *                     * wzurms is fetched from socket buffer with bmread                     *  EA48 EC   C8 20    84        ldd    wzurms,u  EA4B 1083 05C0     83        cmpd   #MAX_UDP  max size  EA4F 22   16                 bhi    89f                     *  EA51 4F                      clra  EA52 C6   21                 ldb    #R_RDFRM  tell caller  EA54 39                      rts                                          * no data yet  EA55 EC   C8 26    82        ldd    wztype,u  check non-block  EA58 85   01                 bita   #WFNBLK  EA5A 26   07                 bne    90f                     *  EA5C 108E E9E5               ldy    #skurrdf  EA60 7E   E7D0               jmp    polext                     *  EA63 4F            90        clra  EA64 C6   15                 ldb    #R_RQRDNB  EA66 39                      rts                     *FIO Simulation Structure             16:03:09  Nov 28, 2024   Page   71wz socket interface routines                          EA67               89  EA67 C6   C0                 ldb    #E_SOCKET  EA69 39                      rts                                          ***************************************************************                     * skurrd,  data readfrom                     *                     *                     * X hold the task table                     * U holds the sock address                     *               EA6A  skurrd    equ    *  EA6A BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EA6D BD   E63B               jsr    wzdevt  EA70 1026 FE92     02        lbne   rdrqer1  EA74 BD   E657               jsr    skcudp  EA77 26   F7                 bne    02b                     *                     * go on                     *                     *                     * transfer at most fio_fsz bytes  EA79 EC   C8 20              ldd    wzurms,u  this is leading count                     * D = total available data  EA7C 108E 0020               ldy    #fifo     target  EA80 BD   F2DB               jsr    RDSK2FB   transfer data, update wzxfer  EA83 34   06                 pshs   d         xferred count  EA85 EC   C8 20              ldd    wzurms,u  update  EA88 A3   E1                 subd   0,s++  EA8A ED   C8 20              std    wzurms,u  new remaining                     *  EA8D C6   40       01        ldb    #WCRECV  EA8F E7   44                 stb    wzcmnd,u  set processed pointer  EA91 BD   F020               jsr    PSRCR                     *  EA94 4F                      clra  EA95 C6   22                 ldb    #R_RRDFD  EA97 39                      rts                                          ***************************************************************                     * skurwt,  request sendto                     *                     *                     * X hold the task table                     * U holds the sock address                     *               EA98  skurwt    equ    *  EA98 BD   E647               jsr    skfres                     *FIO Simulation Structure             16:03:10  Nov 28, 2024   Page   72wz socket interface routines                                             * is the DEVICE (still) active                     *  EA9B BD   E63B               jsr    wzdevt  EA9E 1026 FE64     02        lbne   rdrqer1  EAA2 BD   E657               jsr    skcudp  EAA5 26   F7                 bne    02b                     *                     * go on                     *  EAA7 EC   C8 14              ldd    wzipad,u  EAAA                         ordx   wzipad+2,IU  EAAA 10AA                    fdb    $10aa  EAAC                         doindx wzipad+2,IU  EAAC C8 16                   fcb    $88+(IU<<5),(wzipad+2&$7f)                               endm                               endm >EAAE 1027 006E               lbeq   skuer1                     * set network registers  EAB2 31   C8 14              leay   wzipad,u  EAB5 BD   F0D6               jsr    PSRDIP                     *  EAB8 EC   C8 12              ldd    wzdprt,u  check illegal port >EABB 1027 0061               lbeq   skuer1                     *  EABF EC   C8 12              ldd    wzdprt,u  EAC2 BD   F0FC               jsr    PSRDPOR                     * for IPRAW set only destination IP and port  EAC5 E6   45                 ldb    wzstat,u  EAC7 C1   32                 cmpb   #WSIRAW  EAC9 27   11                 beq    skusnm    special                     *                     * regulare UDP, set source port if not yet assigned  EACB EC   C8 10              ldd    wzsprt,u  already set?  EACE 26   09                 bne    16f  EAD0 BD   E629               jsr    sknewp    get new source port  EAD3 ED   C8 10              std    wzsprt,u  EAD6 ED   C8 1E              std    wzuprt,u  set also return port  EAD9 BD   F072     16        jsr    PSRPORT                     *                     * wait for data to go out loop                     *               EADC  skusnm    equ    *  EADC BD   E647     skuwr2    jsr    skfres    set socket base  EADF BD   E63B               jsr    wzdevt    devie active >EAE2 1026 FFB8               lbne   02b       no  EAE6 BD   E657               jsr    skcudp    check open method  EAE9 26   B3                 bne    02b                     *  EAEB BD   F054               jsr    GSRSR  EAEE E7   45                 stb    wzstat,u  update status  EAF0 C1   22                 cmpb   #WSUDP  EAF2 27   04                 beq    20fFIO Simulation Structure             16:03:11  Nov 28, 2024   Page   73wz socket interface routines                          EAF4 C1   32                 cmpb   #WSIRAW   IPRAW  EAF6 26   28                 bne    skuer1  EAF8 BD   F1BF     20        jsr    GSRTXFR   free size  EAFB 10A3 C8 20              cmpd   wzurms,u  set by driver  EAFF 24   12                 bhs    10f                     * no space yet                       EB01 EC   C8 26              ldd    wztype,u  EB04 85   01                 bita   #WFNBLK  EB06 26   07                 bne    21f                     *  EB08 108E EADC               ldy    #skuwr2  EB0C 7E   E7D0               jmp    polext    keep polling                     *  EB0F 4F            21        clra  EB10 C6   13                 ldb    #R_RQWRNB non block write  EB12 39                      rts                     *  EB13 EC   C8 20    10        ldd    wzurms,u  EB16 1083 05C0               cmpd   #MAX_UDP  too big  EB1A 22   04                 bhi    skuer1                     *  EB1C 4F                      clra  EB1D C6   23                 ldb    #R_RSNDTO  EB1F 39                      rts                       EB20               skuer1  EB20 C6   C0                 ldb    #E_SOCKET  EB22 39                      rts                                                               ***************************************************************                     * skusnt,  data sendto                     *                     *                     * X hold the task table                     * U holds the sock address                     *               EB23  skusnt    equ    *  EB23 BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EB26 BD   E63B               jsr    wzdevt  EB29 1026 FDD9     02        lbne   rdrqer1  EB2D BD   E657               jsr    skcudp  EB30 26   F7                 bne    02b                     *                     * go on                     *                     * transfer fifo to socket data register  EB32 EC   C8 20              ldd    wzurms,u  total dataFIO Simulation Structure             16:03:12  Nov 28, 2024   Page   74wz socket interface routines                                             *  EB35 108E 0020               ldy    #fifo     target  EB39 BD   F329               jsr    WRFB2SK   fifo to socket  EB3C 34   06                 pshs   d  EB3E EC   C8 20              ldd    wzurms,u  all loaded  EB41 A3   E1                 subd   0,s++  EB43 ED   C8 20              std    wzurms,u  EB46 26   11                 bne    01f                       EB48 EC   C8 22              ldd    wzuwrp,u  is it used  EB4B BD   F1FC               jsr    PSRTXWP   set write pointer                       EB4E C6   20                 ldb    #WCSEND  EB50 E7   44                 stb    wzcmnd,u  EB52 BD   F020               jsr    PSRCR  EB55 4F                      clra  EB56 C6   24                 ldb    #R_WSNDTO data taken  EB58 39                      rts                       EB59 4F            01        clra  EB5A C6   25                 ldb    #R_SNDTOM ask for more  EB5C 39                      rts                                          ***************************************************************                     *                     * netblock, read block                     * the method is special, we need to send a request                     * over the net first (send) before new data can be returned                     * request sits at fido_us2/fifo_us3                     * X=task struct, U=wzsock                     *                     * requires exclusive and permanent access to fifo and                     * therefore a CPU09GPP/09NET combo where for this device                     * the socket drivers are not active                     *                     ***************************************************************                                    EB5D  sknbrr    equ    *  EB5D BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EB60 BD   E63B               jsr    wzdevt  EB63 1026 FD9F     02        lbne   rdrqer1  EB67 BD   E64E               jsr    skctcp  EB6A 26   F7                 bne    02b                     *                     *                     *  EB6C BD   F054               jsr    GSRSR     get status  EB6F E7   45                 stb    wzstat,u  update sock  EB71 C1   17                 cmpb   #WSESTB   establishedFIO Simulation Structure             16:03:13  Nov 28, 2024   Page   75wz socket interface routines                          EB73 26   46                 bne    sknbe1    error                     *  EB75 BD   F1BF               jsr    GSRTXFR   get free space  EB78 1083 0004               cmpd   #NBRQLN  EB7C 25   37                 blo    sknbrp1   go poll                     *                     * read, send command info to server                     *  EB7E CC   0004               ldd    #NBRQLN   actual size of request  EB81 108E 001C               ldy    #fifo_us2 where request is present  EB85 BD   F329               jsr    WRFB2SK  EB88 C6   20                 ldb    #WCSEND   tell socket we put it  EB8A E7   44                 stb    wzcmnd,u  EB8C BD   F020               jsr    PSRCR                     *                     * read is 2 phase, receive response from server                     *  EB8F BD   E647     sknbrp2   jsr    skfres    reset important info  EB92 BD   F20B               jsr    GSRRXRS   check response  EB95 34   06                 pshs   d  EB97 EC   4A                 ldd    wzrqln,u  requested data  EB99 C3   0004               addd   #NBRQLN  EB9C 10A3 E1                 cmpd   0,s++     allows for other data packet sizes  EB9F 23   1D                 bls    01f  EBA1 BD   F054               jsr    GSRSR  EBA4 E7   45                 stb    wzstat,u  EBA6 C1   17                 cmpb   #WSESTB   check socket state  EBA8 26   11                 bne    sknbe1  EBAA C1   1C                 cmpb   #WSCLWT  EBAC 27   0D                 beq    sknbe1    bail out  EBAE 108E EB8F               ldy    #sknbrp2  wait until                     *                     * poll loop                     *  EBB2 7E   E7D0     02        jmp    polext                     *  EBB5 108E EB5D     sknbrp1   ldy    #sknbrr  EBB9 20   F7                 bra    02b                     *  EBBB C6   C0       sknbe1    ldb    #E_SOCKET  EBBD 39                      rts                     * we have data in socket  EBBE C6   82       01        ldb    #R_RQRBLK  EBC0 4F                      clra  EBC1 39                      rts                                          ***************************************************************                     * here data is moved from the socket to the fifo                     * write 4 bytes back to fifo_us2/fifo_us3                     ***************************************************************               EBC2  sknbrd    equ    *  EBC2 BD   E647               jsr    skfresFIO Simulation Structure             16:03:13  Nov 28, 2024   Page   76wz socket interface routines                          EBC5 BD   E63B               jsr    wzdevt  EBC8 1026 FD3A     02        lbne   rdrqer1  EBCC BD   E64E               jsr    skctcp  EBCF 26   F7                 bne    02b                     *                     * when we arrive here, the data has arrived                     *  EBD1 EC   4A       01        ldd    wzrqln,u  request sets the buffer size  EBD3 34   06                 pshs   d  EBD5 C3   0004               addd   #NBRQLN  EBD8 ED   4A                 std    wzrqln,u  fool RDSK2FB  EBDA 108E 001C               ldy    #fifo_us2 data contains cmd info  EBDE BD   F2DB               jsr    RDSK2FB  EBE1 C6   40                 ldb    #WCRECV   tell socket we took it  EBE3 E7   44                 stb    wzcmnd,u  EBE5 BD   F020               jsr    PSRCR                     * transfer only data part  EBE8 35   06                 puls   d  EBEA ED   48                 std    wzxfer,u  EBEC ED   4A                 std    wzrqln,u                     *  EBEE C6   83                 ldb    #R_RDRBLK tell caller, data in fifo_us2 and fifo  EBF0 39                      rts                                          ***************************************************************                     *                     * netblock, write block                     *                     ***************************************************************               EBF1  sknbsr    equ    *  EBF1 BD   E647               jsr    skfres                     *                     * is the DEVICE (still) active                     *  EBF4 BD   E63B               jsr    wzdevt  EBF7 1026 FD0B     02        lbne   rdrqer1  EBFB BD   E64E               jsr    skctcp  EBFE 26   F7                 bne    02b                     *  EC00 BD   F054               jsr    GSRSR     status  EC03 E7   45                 stb    wzstat,u  EC05 C1   17                 cmpb   #WSESTB   still there?  EC07 26   16                 bne    sknbe10                     *  EC09 BD   F1BF               jsr    GSRTXFR   get free space  EC0C 34   06                 pshs   d  EC0E CC   0004               ldd    #NBRQLN  EC11 E3   4A                 addd   wzrqln,u  EC13 10A3 E1                 cmpd   0,s++  EC16 23   0F                 bls    70f                     *  EC18 108E EBF1               ldy    #sknbsrFIO Simulation Structure             16:03:14  Nov 28, 2024   Page   77wz socket interface routines                          EC1C 7E   E7D0               jmp    polext                     *  EC1F CC   0000     sknbe10   ldd    #0  EC22 ED   48                 std    wzxfer,u  EC24 C6   C0                 ldb    #E_SOCKET  EC26 39                      rts                       EC27 4F            70        clra  EC28 C6   80                 ldb    #R_RQSBLK  EC2A 39                      rts                                          ***************************************************************                     *                     *                     ***************************************************************               EC2B  sknbsd    equ    *  EC2B BD   E647               jsr    skfres  EC2E BD   E63B               jsr    wzdevt  EC31 1026 FCD1     02        lbne   rdrqer1  EC35 BD   E64E               jsr    skctcp  EC38 26   F7                 bne    02b                                          *                     * data to write, cnd +data                     *  EC3A EC   4A       70        ldd    wzrqln,u  EC3C 34   06                 pshs   d  EC3E C3   0004               addd   #NBRQLN  EC41 ED   4A                 std    wzrqln,u  fool WFB2SK  EC43 108E 001C               ldy    #fifo_us2 where cmd sits  EC47 BD   F329               jsr    WRFB2SK  EC4A C6   20                 ldb    #WCSEND   send it now  EC4C E7   44                 stb    wzcmnd,u  EC4E BD   F020               jsr    PSRCR  EC51 35   06                 puls   d  EC53 ED   48                 std    wzxfer,u  make it correct  EC55 ED   4A                 std    wzrqln,u  EC57 4F                      clra  EC58 C6   81                 ldb    #R_SNDBLK tell host we did  EC5A 39                      rts                                          ***************************************************************                     *                     * special function, tstval,x is indicator                     * X hold the task table                     * U holds the SPECIAL sock address (NO wz....  access!)                     *               EC5B  skspcl    equ    *                     *  EC5B 34   10                 pshs   x  EC5D E6   0C                 ldb    tstval,x  get index  EC5F C1   03                 cmpb   #MAXTBLFIO Simulation Structure             16:03:15  Nov 28, 2024   Page   78wz socket interface routines                          EC61 22   18                 bhi    01f       illegal  EC63 58                      aslb  EC64 8E   EC82               ldx    #functb  EC67 10AE 85                 ldy    b,x       get special function  EC6A 27   0F                 beq    01f       not valid  EC6C 35   10                 puls   x                     *  EC6E AD   A4                 jsr    0,y       do function  EC70 26   05                 bne    90f                     *  EC72 4F                      clra  EC73 C6   0F                 ldb    #R_SPCL  EC75 20   0A                 bra    99f                     *  EC77 86   A2       90        lda    #162  EC79 20   04                 bra    02f                     *  EC7B 35   10       01        puls   x  EC7D 86   A1                 lda    #161  EC7F               02  EC7F C6   C0                 ldb    #E_SOCKET                     *  EC81 39            99        rts                       EC82 EC8A          functb    fdb    wzwdev    write device settings  EC84 EC8A                    fdb    wzwdev  EC86 ECB4                    fdb    wzrdev    read device settings  EC88 ECD0                    fdb    showrg               0003  MAXTBL    equ    ((*-functb)/2)-1                                          *                     * write W5500 basic device settings                     *                     * X hold the task table                     * U holds the special sock address                     *  EC8A               wzwdev  EC8A C6   08                 ldb    #8  EC8C                         trfr   B,E  EC8C 1F                      fcb    $1f  EC8D 9E                      fcb    B<<4|E                               endm  EC8E DE   1A                 ldu    fifo_us1  device info area  EC90 31   C4                 leay   0,u       myip  EC92 BD   EEB7               jsr    PCRSIP    source IP  EC95 31   44                 leay   4,u  EC97 BD   EE4B               jsr    PCRSNM    subnet mask  EC9A 31   48                 leay   8,u  EC9C BD   EE1D               jsr    PCRGA     gateway IP  EC9F 31   4C                 leay   12,u  ECA1 BD   EE81               jsr    PCRSHA    hardware address                     *FIO Simulation Structure             16:03:16  Nov 28, 2024   Page   79wz socket interface routines                          ECA4 A6   C8 12              lda    18,u      ON/OFF  ECA7 27   04                 beq    01f  ECA9 C6   F8                 ldb    #%11111000 all on  ECAB 20   02                 bra    02f  ECAD C6   78       01        ldb    #%01111000 all off  ECAF BD   EFD5     02        jsr    PCRPHY  ECB2 4F                      clra             no error return status  ECB3 39                      rts                                          *                     * read W5500 basic device settings                     *  ECB4               wzrdev  ECB4 C6   08                 ldb    #8  ECB6                         trfr   B,E       select first socket  ECB6 1F                      fcb    $1f  ECB7 9E                      fcb    B<<4|E                               endm  ECB8 DE   1A                 ldu    fifo_us1  ECBA 31   C4                 leay   0,u       overwrite what was set  ECBC BD   EEA0               jsr    GCRSIP  ECBF 31   44                 leay   4,u  ECC1 BD   EE34               jsr    GCRSNM  ECC4 31   48                 leay   8,u  ECC6 BD   EE06               jsr    GCRGA  ECC9 31   4C                 leay   12,u  ECCB BD   EE62               jsr    GCRSHA  ECCE 4F                      clra             no error return status  ECCF 39                      rts                                          *                     * debug service, read selected registers                     *  ECD0               showrg  ECD0 C6   08                 ldb    #8  ECD2                         trfr   B,E       select first socket  ECD2 1F                      fcb    $1f  ECD3 9E                      fcb    B<<4|E                               endm  ECD4 DE   1A                 ldu    fifo_us1  ECD6 33   C8 20              leau   32,u      skip network data area  ECD9 BD   EFF3               jsr    GSRMR  ECDC E7   C0                 stb    0,u+  ECDE BD   F054               jsr    GSRSR  ECE1 E7   C0                 stb    0,u+  ECE3 BD   F183               jsr    GSRRBFS  ECE6 E7   C0                 stb    0,u+                       ECE8 C6   3D                 ldb    #'=  ECEA E7   C0                 stb    0,u+                       ECEC 31   C4                 leay   0,uFIO Simulation Structure             16:03:17  Nov 28, 2024   Page   80wz socket interface routines                          ECEE BD   EEA0               jsr    GCRSIP  ECF1 33   44                 leau   4,u  ECF3 31   C4                 leay   0,u  ECF5 BD   EE06               jsr    GCRGA  ECF8 33   44                 leau   4,u                       ECFA C6   23                 ldb    #'#  ECFC E7   C0                 stb    0,u+                       ECFE 31   C4                 leay   0,u  ED00 BD   EE62               jsr    GCRSHA  ED03 33   46                 leau   6,u                       ED05 C6   23                 ldb    #'#  ED07 E7   C0                 stb    0,u+                       ED09 31   C4                 leay   0,u  ED0B BD   EE34               jsr    GCRSNM  ED0E 33   44                 leau   4,u                       ED10 C6   3D                 ldb    #'=  ED12 E7   C0                 stb    0,u+                       ED14 BD   EFE4               jsr    GCRVERS  ED17 ED   C1                 std    0,u++                       ED19 C6   23                 ldb    #'#  ED1B E7   C4                 stb    0,u  ED1D 4F                      clra                       ED1E 39                      rts                                                               * X hold the task table                     * U holds the sock address                     *   skintrp  ED1F               skdisc  ED1F               sksmac  ED1F               skskep  ED1F 86   FF                 lda    #255  ED21 A7   47                 sta    wzerr,u  ED23 C6   C0                 ldb    #E_SOCKET                                            ED25 39                      rts                                    ED26  oldorg    set    *                     *                     * hardware register orgaization                     *               8080  SPIBASE   equ    $8080     hardware base address                     FIO Simulation Structure             16:03:18  Nov 28, 2024   Page   81wzspi, basic spi routines                             0000                         org    0                     *  0000               spicmd    rmb    1         HW control register               0000  spista    equ    spicmd    HW status register  0001               spicon    rmb    1         [W]   HW aux control register  0002                         rmb    2         dummy not used                     * shift register access  0004               hibyta    rmb    1         [R/W] hibyte auto 8 clock pulses for SR  0005               lobyta    rmb    1         [R/W] lobyte auto 8 clock pulses for SR  0006               hibyts    rmb    1         [R/W] hibyte static (no clock)  0007               lobyts    rmb    1         [R/W] lobyte static (no clock)                     *               0080  QFF1      equ    %10000000 [R]                          X               0040  SPI_CS_   equ    %01000000 [R/W] spi chip CS_           1               0020  SPI_RST   equ    %00100000 [R/W] spi chip RST_          1               0010  SPI_IEN   equ    %00010000 [R/W] spi chip INT enabled   0               0008  SPI_AUT   equ    %00001000 [R/W] auto advance           0               0004  SPI_SR_   equ    %00000100 [R/W] shift register MR_     1               0002  SPI_HLD   equ    %00000010 [R/W] HOLD                   0               0001  SPI_CR_   equ    %00000001 [W]   HC163 MR_              1               0001  SPI_IRQ   equ    %00000001 [R]   /IRQ bit               1                     *               0003  RSVREG    equ    %00000011 reserved register address                       ED26                         org    oldorg                                          *                     * spinit, init the SPI hardware                     *               ED26  spinit    equ    *  ED26 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_ set idle  ED28 B7   8080               sta    SPIBASE+spicmd  ED2B 39                      rts                                          *                     * setup inital port for SPI access                     *                     * A,B are lost A=rwflag, F=register, X=offset                     * F=corrected register bits [7...3]                     * A= R/W flag 1=write/ 0= read                     * X,Y untouched                     *               ED2C  spistr2   equ    *  ED2C CE   8080               ldu    #SPIBASE  SPI base TODO  ED2F                         trfr   F,B  ED2F 1F                      fcb    $1f  ED30 F9                      fcb    F<<4|B                               endm  ED31 5D                      tstb             register pointer  ED32 27   09                 beq    01f       OK, valid  ED34 34   04                 pshs   b  ED36 C4   03                 andb   #RSVREG   reserved loctationFIO Simulation Structure             16:03:18  Nov 28, 2024   Page   82wzspi, basic spi routines                             ED38 5D                      tstb             xxx10xxx  is invalid!  ED39 35   04                 puls   b  ED3B 27   1A                 beq    09f       invalid access                     * adjust READ/WRITE bit  ED3D 4D            01        tsta             cmd flag  ED3E 27   04                 beq    04f  ED40 1A   01                 sec              write   100  ED42 20   02                 bra    05f  ED44 1C   FE       04        clc              read    000                     *  ED46 59            05        rolb             set READ/WRITE bit  [2...0]  ED47 58                      lslb             set variable length data [00]  ED48 58                      lslb                     *                     * here the actual SPI action starts                     *  ED49                         seti   disable   interrupts  ED49 1A   50                 orcc   #FF|IF                               endm  ED4B 12                      nop                     *       lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT+SPI_IEN low  ED4C 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT low  ED4E A7   C4                 sta    spicmd,u  ED50 AF   44                 stx    hibyta,u  and shift out  ED52 E7   44                 stb    hibyta,u  and shift out  ED54 1A   04                 sez  ED56 39                      rts  ED57 1C   FB       09        clz  ED59 39                      rts                                          *                     * X = offset, unchanged                     * F = register#                     * read BYTE from SPI                     * return B=value, D,X,Y,U preserved                     *               ED5A  byterd    equ    *  ED5A 34   47                 pshs   cc,d,u  ED5C 4F                      clra  ED5D 8D   CD                 bsr    spistr2 >ED5F 1026 007F               lbne   09f  ED63 E6   44                 ldb    hibyta,u  extra clocks for first data                     *  ED65 E6   45                 ldb    lobyta,u  read byte  ED67 4F                      clra  ED68 ED   61                 std    1,s  ED6A 20   6A                 bra    sprend                                          *                     * X = offset                     * F = register#                     * read WORD from SPIFIO Simulation Structure             16:03:18  Nov 28, 2024   Page   83wzspi, basic spi routines                                                * return D=value,  D,X,Y,U preserved                     *               ED6C  wordrd    equ    *  ED6C 34   47                 pshs   cc,d,u  ED6E 4F                      clra >ED6F BD   ED2C               jsr    spistr2  ED72 26   6E                 bne    09f  ED74 E6   44                 ldb    hibyta,u  extra clocks for first data                     *  ED76 A6   45                 lda    lobyta,u  read byte  ED78 E6   45                 ldb    lobyta,u  read byte  ED7A ED   61                 std    1,s  ED7C 20   58                 bra    sprend                                          *                     * bmread, spi to memory read xfer                     * Y=mem pointer, D=count (bytes)                     * F = register#                     * read bytes from SPI into memory location                     * return D,X,Y,U preserved                     *               ED7E  bmread    equ    *  ED7E 34   77                 pshs   cc,d,x,y,u  ED80                         pshsw  save      E:F  ED80 1038                    fdb    $1038                               endm  ED82 BD   F222               jsr    GSRRXRP   'read' pointer  ED85 1F   01                 tfr    d,x       keep  ED87 CE   8080               ldu    #SPIBASE  ED8A 34   40                 pshs   u         remember  ED8C 1A   50                 orcc   #$50  ED8E 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT  ED90 A7   C4                 sta    spicmd,u  start SPI  ED92 AF   44                 stx    hibyta,u  start address  ED94 BD   F2CC               jsr    tsk2rx    E => B  ED97 E7   44                 stb    hibyta,u  socket register  ED99 EC   65                 ldd    5,s       old D  ED9B                         trfr   D,W       transaction count  ED9B 1F                      fcb    $1f  ED9C 06                      fcb    D<<4|W                               endm  ED9D E7   44                 stb    hibyta,u  dummy, shift out  ED9F 10AE 69                 ldy    9,s       old Y, mem pointer  EDA2 33   45                 leau   lobyta,u  point to data register  EDA4                         tfm4   U,Y       U => Y++  EDA4 113B                    fdb    $113b  EDA6 32                      fcb    U<<4|Y                               endm  EDA7 35   40                 puls   u         restore SPIBASE  EDA9 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  EDAB A7   C4                 sta    spicmd,u  end SPI                     * X = old read pointer, 0,s byte wountFIO Simulation Structure             16:03:18  Nov 28, 2024   Page   84wzspi, basic spi routines                             EDAD 1F   10                 tfr    x,d       start pointer  EDAF E3   63                 addd   3,s       move pointer with # bytes  EDB1                         pulsw  restore   E:F  EDB1 1039                    fdb    $1039                               endm  EDB3 BD   F231               jsr    PSRRXRP   update pointer  EDB6 35   F7                 puls   cc,d,x,y,u,pc                                          *                     * X = offset                     * F = register#                     * write BYTE to SPI, D,X,Y,U preserved                     *               EDB8  bytewr    equ    *  EDB8 34   47                 pshs   cc,d,u  EDBA 86   01                 lda    #1  EDBC BD   ED2C               jsr    spistr2  EDBF 26   21                 bne    09f                     *  EDC1 A6   62                 lda    2,s  EDC3 A7   44                 sta    hibyta,u  EDC5 20   0F                 bra    sprend                                          *                     * X = offset                     * F = register#                     * write WORD to SPI, D,X,Y,U preserved                     *               EDC7  wordwr    equ    *  EDC7 34   47                 pshs   cc,d,u  EDC9 86   01                 lda    #1  EDCB BD   ED2C               jsr    spistr2  EDCE 26   12                 bne    09f                     *  EDD0 EC   61                 ldd    1,s  EDD2 A7   44                 sta    hibyta,u  EDD4 E7   44                 stb    hibyta,u                     *                     * common exit from SPI action                     *  EDD6 86   65       sprend    lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_                     *sprend  lda     #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_+SPI_IEN  EDD8 A7   C4                 sta    spicmd,u  EDDA A6   E4                 lda    0,s       sez  EDDC 8A   04                 ora    #4  EDDE A7   E4       02        sta    0,s  EDE0 35   C7                 puls   cc,d,u,pc                     *  EDE2 A6   E4       09        lda    0,s       clz  EDE4 84   FB                 anda   #255-4  EDE6 20   F6                 bra    02b                     FIO Simulation Structure             16:03:19  Nov 28, 2024   Page   85wzspi, basic spi routines                           FIO Simulation Structure             16:03:19  Nov 28, 2024   Page   86wzspi, basic spi routines                                                                     * register names and offset               0000  WZMR      equ    0               0001  WZGAR0    equ    1               0002  WZGAR1    equ    2               0003  WZGAR2    equ    3               0004  WZGAR3    equ    4               0005  WZSUBR0   equ    5               0006  WZSUBR1   equ    6               0007  WZSUBR2   equ    7               0008  WZSUBR3   equ    8               0009  WZSHAR0   equ    9               000A  WZSHAR1   equ    10               000B  WZSHAR2   equ    11               000C  WZSHAR3   equ    12               000D  WZSHAR4   equ    13               000E  WZSHAR5   equ    14               000F  WZSIPR0   equ    15               0010  WZSIPR1   equ    16               0011  WZSIPR2   equ    17               0012  WZSIPR3   equ    18               0013  WZILLT0   equ    19               0014  WZILLT1   equ    20               0015  WZIR      equ    21               0016  WZIMR     equ    22               0017  WZSIR     equ    23               0018  WZSIMR    equ    24               0019  WZRTR0    equ    25               001A  WZRTR1    equ    26               001B  WZRCR     equ    27               0028  WZUIPR0   equ    40               0029  WZUIPR1   equ    41               002A  WZUIPR2   equ    42               002B  WZUIPR3   equ    43               002C  WZUPRT0   equ    44               002D  WZUPRT1   equ    45               002E  WZPHY     equ    46               0039  WZVERS    equ    57                                          *                     * all commands to access common register set                     *                                          *                     * GCRMR, get byte from common registers mode register                     * return byte in B                     *  EDE8 34   56       GCRMR     pshs   d,x,u  EDEA 5F                      clrb  EDEB                         trfr   B,F  EDEB 1F                      fcb    $1f  EDEC 9F                      fcb    B<<4|FFIO Simulation Structure             16:03:19  Nov 28, 2024   Page   87wzspi, basic spi routines                                                          endm  EDED 8E   0000               ldx    #WZMR  EDF0 BD   ED5A               jsr    byterd  EDF3 ED   E4                 std    0,s  EDF5 35   D6                 puls   d,x,u,pc                                          *                     * PCRMR, put byte B into common registers mode register                     *  EDF7 34   16       PCRMR     pshs   d,x  EDF9 5F                      clrb  EDFA                         trfr   B,F  EDFA 1F                      fcb    $1f  EDFB 9F                      fcb    B<<4|F                               endm  EDFC 8E   0000               ldx    #WZMR  EDFF EC   E4                 ldd    0,s >EE01 BD   EDB8               jsr    bytewr  EE04 35   96                 puls   d,x,pc                                          *                     * GCRGA, get gateway address from common regsiters                     * Y=destination address (4 bytes)                     *  EE06 34   16       GCRGA     pshs   d,x  EE08 5F                      clrb  EE09                         trfr   B,F  EE09 1F                      fcb    $1f  EE0A 9F                      fcb    B<<4|F                               endm  EE0B 8E   0001               ldx    #WZGAR0  EE0E BD   ED6C               jsr    wordrd  EE11 ED   A4                 std    0,y  EE13 8E   0003               ldx    #WZGAR2  EE16 BD   ED6C               jsr    wordrd  EE19 ED   22                 std    2,y  EE1B 35   96                 puls   d,x,pc                                          *                     * PCRGW, put gateway address                     * Y=source address (4 bytes)                     *  EE1D 34   16       PCRGA     pshs   d,x  EE1F 5F                      clrb  EE20                         trfr   B,F  EE20 1F                      fcb    $1f  EE21 9F                      fcb    B<<4|F                               endm  EE22 8E   0001               ldx    #WZGAR0  EE25 EC   A4                 ldd    0,y >EE27 BD   EDC7               jsr    wordwr  EE2A 8E   0003               ldx    #WZGAR2FIO Simulation Structure             16:03:20  Nov 28, 2024   Page   88wzspi, basic spi routines                             EE2D EC   22                 ldd    2,y >EE2F BD   EDC7               jsr    wordwr  EE32 35   96                 puls   d,x,pc                                          *                     * GCRSNM, get subnet mask  from common regsiters                     * Y=destination address (4 bytes)                     *  EE34 34   16       GCRSNM    pshs   d,x  EE36 5F                      clrb  EE37                         trfr   B,F  EE37 1F                      fcb    $1f  EE38 9F                      fcb    B<<4|F                               endm  EE39 8E   0005               ldx    #WZSUBR0  EE3C BD   ED6C               jsr    wordrd  EE3F ED   A4                 std    0,y  EE41 8E   0007               ldx    #WZSUBR2  EE44 BD   ED6C               jsr    wordrd  EE47 ED   22                 std    2,y  EE49 35   96                 puls   d,x,pc                                          *                     * PCRSNM, put subnet mask address                     * Y=source address (4 bytes)                     *  EE4B 34   16       PCRSNM    pshs   d,x  EE4D 5F                      clrb  EE4E                         trfr   B,F  EE4E 1F                      fcb    $1f  EE4F 9F                      fcb    B<<4|F                               endm  EE50 8E   0005               ldx    #WZSUBR0  EE53 EC   A4                 ldd    0,y  EE55 BD   EDC7               jsr    wordwr  EE58 8E   0007               ldx    #WZSUBR2  EE5B EC   22                 ldd    2,y  EE5D BD   EDC7               jsr    wordwr  EE60 35   96                 puls   d,x,pc                                          *                     * GCRSHA, get gateway hardware address from common regsiters                     * Y=destination address (6 bytes)                     *  EE62 34   16       GCRSHA    pshs   d,x  EE64 5F                      clrb  EE65                         trfr   B,F  EE65 1F                      fcb    $1f  EE66 9F                      fcb    B<<4|F                               endm  EE67 8E   0009               ldx    #WZSHAR0  EE6A BD   ED6C               jsr    wordrdFIO Simulation Structure             16:03:20  Nov 28, 2024   Page   89wzspi, basic spi routines                             EE6D ED   A4                 std    0,y  EE6F 8E   000B               ldx    #WZSHAR2  EE72 BD   ED6C               jsr    wordrd  EE75 ED   22                 std    2,y  EE77 8E   000D               ldx    #WZSHAR4  EE7A BD   ED6C               jsr    wordrd  EE7D ED   24                 std    4,y  EE7F 35   96                 puls   d,x,pc                                          *                     * PCRSHA, put gateway hardware address                     * Y=source address (6 bytes)                     *  EE81 34   16       PCRSHA    pshs   d,x  EE83 5F                      clrb  EE84                         trfr   B,F  EE84 1F                      fcb    $1f  EE85 9F                      fcb    B<<4|F                               endm  EE86 8E   0009               ldx    #WZSHAR0  EE89 EC   A4                 ldd    0,y  EE8B BD   EDC7               jsr    wordwr  EE8E 8E   000B               ldx    #WZSHAR2  EE91 EC   22                 ldd    2,y  EE93 BD   EDC7               jsr    wordwr  EE96 8E   000D               ldx    #WZSHAR4  EE99 EC   24                 ldd    4,y  EE9B BD   EDC7               jsr    wordwr  EE9E 35   96                 puls   d,x,pc                                          *                     * GCRSIP, get source IP address from common regsiters                     * Y=destination address (4 bytes)                     *  EEA0 34   16       GCRSIP    pshs   d,x  EEA2 5F                      clrb  EEA3                         trfr   B,F  EEA3 1F                      fcb    $1f  EEA4 9F                      fcb    B<<4|F                               endm  EEA5 8E   000F               ldx    #WZSIPR0  EEA8 BD   ED6C               jsr    wordrd  EEAB ED   A4                 std    0,y  EEAD 8E   0011               ldx    #WZSIPR2  EEB0 BD   ED6C               jsr    wordrd  EEB3 ED   22                 std    2,y  EEB5 35   96                 puls   d,x,pc                                          *                     * PCRSIP, put gateway address                     * Y=source address (4 bytes)                     *FIO Simulation Structure             16:03:20  Nov 28, 2024   Page   90wzspi, basic spi routines                             EEB7 34   16       PCRSIP    pshs   d,x  EEB9 5F                      clrb  EEBA                         trfr   B,F  EEBA 1F                      fcb    $1f  EEBB 9F                      fcb    B<<4|F                               endm  EEBC 8E   000F               ldx    #WZSIPR0  EEBF EC   A4                 ldd    0,y  EEC1 BD   EDC7               jsr    wordwr  EEC4 8E   0011               ldx    #WZSIPR2  EEC7 EC   22                 ldd    2,y  EEC9 BD   EDC7               jsr    wordwr  EECC 35   96                 puls   d,x,pc                                          *                     * GCRILLT, get byte from interrup low level timer register                     * return word in D                     *  EECE 34   16       GCRILLT   pshs   d,x  EED0 5F                      clrb  EED1                         trfr   B,F  EED1 1F                      fcb    $1f  EED2 9F                      fcb    B<<4|F                               endm  EED3 8E   0013               ldx    #WZILLT0  EED6 BD   ED6C               jsr    wordrd  EED9 ED   E4                 std    0,s  EEDB 35   96                 puls   d,x,pc                                          *                     * PCRILLT, put word D into common registers mode register                     *  EEDD 34   16       PCRILLT   pshs   d,x  EEDF 5F                      clrb  EEE0                         trfr   B,F  EEE0 1F                      fcb    $1f  EEE1 9F                      fcb    B<<4|F                               endm  EEE2 8E   0013               ldx    #WZILLT0  EEE5 EC   E4                 ldd    0,s  EEE7 BD   EDC7               jsr    wordwr  EEEA 35   96                 puls   d,x,pc                                          *                     * GCRIR, get byte from common registers interrupt register                     * return byte in B                     *  EEEC 34   16       GCRIR     pshs   d,x  EEEE 5F                      clrb  EEEF                         trfr   B,F  EEEF 1F                      fcb    $1f  EEF0 9F                      fcb    B<<4|FFIO Simulation Structure             16:03:21  Nov 28, 2024   Page   91wzspi, basic spi routines                                                          endm  EEF1 8E   0015               ldx    #WZIR  EEF4 BD   ED5A               jsr    byterd  EEF7 ED   E4                 std    0,s  EEF9 35   96                 puls   d,x,pc                                          *                     * PCRIR, put byte B into common registers interrupt register                     *  EEFB 34   16       PCRIR     pshs   d,x  EEFD 5F                      clrb  EEFE                         trfr   B,F  EEFE 1F                      fcb    $1f  EEFF 9F                      fcb    B<<4|F                               endm  EF00 8E   0015               ldx    #WZIR  EF03 EC   E4                 ldd    0,s  EF05 BD   EDB8               jsr    bytewr  EF08 35   96                 puls   d,x,pc                                          *                     * GCRIMR, get byte from common registers interrupt mask register                     * return byte in B                     *  EF0A 34   16       GCRIMR    pshs   d,x  EF0C 5F                      clrb  EF0D                         trfr   B,F  EF0D 1F                      fcb    $1f  EF0E 9F                      fcb    B<<4|F                               endm  EF0F 8E   0016               ldx    #WZIMR  EF12 BD   ED5A               jsr    byterd  EF15 ED   E4                 std    0,s  EF17 35   96                 puls   d,x,pc                                          *                     * PCRIMR, put byte B into common registers interrupt mask register                     *  EF19 34   16       PCRIMR    pshs   d,x  EF1B 5F                      clrb  EF1C                         trfr   B,F  EF1C 1F                      fcb    $1f  EF1D 9F                      fcb    B<<4|F                               endm  EF1E 8E   0016               ldx    #WZIMR  EF21 EC   E4                 ldd    0,s  EF23 BD   EDB8               jsr    bytewr  EF26 35   96                 puls   d,x,pc                                          *                     * GCRSIR, get byte from common registers socket interrupt register                     * return byte in BFIO Simulation Structure             16:03:21  Nov 28, 2024   Page   92wzspi, basic spi routines                                                *  EF28 34   16       GCRSIR    pshs   d,x  EF2A 5F                      clrb  EF2B                         trfr   B,F  EF2B 1F                      fcb    $1f  EF2C 9F                      fcb    B<<4|F                               endm  EF2D 8E   0017               ldx    #WZSIR  EF30 BD   ED5A               jsr    byterd  EF33 ED   E4                 std    0,s  EF35 35   96                 puls   d,x,pc                                          *                     * PCRSIR, put byte B into common registers socket interrupt register                     *  EF37 34   16       PCRSIR    pshs   d,x  EF39 5F                      clrb  EF3A                         trfr   B,F  EF3A 1F                      fcb    $1f  EF3B 9F                      fcb    B<<4|F                               endm  EF3C 8E   0017               ldx    #WZSIR  EF3F EC   E4                 ldd    0,s  EF41 BD   EDB8               jsr    bytewr  EF44 35   96                 puls   d,x,pc                                          *                     * GCSIMR, get byte from common registers socket interrupt mask register                     * return byte in B                     *  EF46 34   16       GCRSIMR   pshs   d,x  EF48 5F                      clrb  EF49                         trfr   B,F  EF49 1F                      fcb    $1f  EF4A 9F                      fcb    B<<4|F                               endm  EF4B 8E   0018               ldx    #WZSIMR  EF4E BD   ED5A               jsr    byterd  EF51 ED   E4                 std    0,s  EF53 35   96                 puls   d,x,pc                                          *                     * PCRSIMR, put byte B into common registers socket interrupt mask register                     *  EF55 34   16       PCRSIMR   pshs   d,x  EF57 5F                      clrb  EF58                         trfr   B,F  EF58 1F                      fcb    $1f  EF59 9F                      fcb    B<<4|F                               endm  EF5A 8E   0018               ldx    #WZSIMR  EF5D EC   E4                 ldd    0,sFIO Simulation Structure             16:03:22  Nov 28, 2024   Page   93wzspi, basic spi routines                             EF5F BD   EDB8               jsr    bytewr  EF62 35   96                 puls   d,x,pc                                          *                     * GCRRTR, get word from common registers retry register                     * return word in D                     *  EF64 34   16       GCRRTR    pshs   d,x  EF66 5F                      clrb  EF67                         trfr   B,F  EF67 1F                      fcb    $1f  EF68 9F                      fcb    B<<4|F                               endm  EF69 8E   0019               ldx    #WZRTR0  EF6C BD   ED6C               jsr    wordrd  EF6F ED   E4                 std    0,s  EF71 35   96                 puls   d,x,pc                                          *                     * PCRRTR, put word D into common registers retry register                     *  EF73 34   16       PCRRTR    pshs   d,x  EF75 5F                      clrb  EF76                         trfr   B,F  EF76 1F                      fcb    $1f  EF77 9F                      fcb    B<<4|F                               endm  EF78 8E   0019               ldx    #WZRTR0  EF7B EC   E4                 ldd    0,s  EF7D BD   EDC7               jsr    wordwr  EF80 35   96                 puls   d,x,pc                                          *                     * GCRRCR, get byte from common registers retry count register                     * return byte in B                     *  EF82 34   16       GCRRCR    pshs   d,x  EF84 5F                      clrb  EF85                         trfr   B,F  EF85 1F                      fcb    $1f  EF86 9F                      fcb    B<<4|F                               endm  EF87 8E   001B               ldx    #WZRCR  EF8A BD   ED5A               jsr    byterd  EF8D ED   E4                 std    0,s  EF8F 35   96                 puls   d,x,pc                                          *                     * PCRRCR, put byte B into common registers retry count register                     *  EF91 34   16       PCRRCR    pshs   d,x  EF93 5F                      clrbFIO Simulation Structure             16:03:23  Nov 28, 2024   Page   94wzspi, basic spi routines                             EF94                         trfr   B,F  EF94 1F                      fcb    $1f  EF95 9F                      fcb    B<<4|F                               endm  EF96 8E   001B               ldx    #WZRCR  EF99 EC   E4                 ldd    0,s  EF9B BD   EDB8               jsr    bytewr  EF9E 35   96                 puls   d,x,pc                                          *                     * GCRURP, get word from common registers unreachable port register                     * return word in D                     *  EFA0 34   16       GCRURP    pshs   d,x  EFA2 5F                      clrb  EFA3                         trfr   B,F  EFA3 1F                      fcb    $1f  EFA4 9F                      fcb    B<<4|F                               endm  EFA5 8E   002C               ldx    #WZUPRT0  EFA8 BD   ED6C               jsr    wordrd  EFAB ED   E4                 std    0,s  EFAD 35   96                 puls   d,x,pc                                          *                     * GCRUIP, get unreachable IP address from common registers                     * Y=destination address (4 bytes)                     *  EFAF 34   16       GCRUIP    pshs   d,x  EFB1 5F                      clrb  EFB2                         trfr   B,F  EFB2 1F                      fcb    $1f  EFB3 9F                      fcb    B<<4|F                               endm  EFB4 8E   0028               ldx    #WZUIPR0  EFB7 BD   ED6C               jsr    wordrd  EFBA ED   A4                 std    0,y  EFBC 8E   002A               ldx    #WZUIPR2  EFBF BD   ED6C               jsr    wordrd  EFC2 ED   22                 std    2,y  EFC4 35   96                 puls   d,x,pc                                          *                     * GCRPHY, get byte from common registers PHY config register                     * return byte in B                     *  EFC6 34   56       GCRPHY    pshs   d,x,u  EFC8 8E   002E               ldx    #WZPHY  EFCB 5F                      clrb  EFCC                         trfr   B,F  EFCC 1F                      fcb    $1f  EFCD 9F                      fcb    B<<4|FFIO Simulation Structure             16:03:23  Nov 28, 2024   Page   95wzspi, basic spi routines                                                          endm  EFCE BD   ED5A               jsr    byterd  EFD1 ED   E4                 std    0,s  EFD3 35   D6                 puls   d,x,u,pc                                          *                     * PCRPHY, put byte B into common registers PHY config register                     *  EFD5 34   56       PCRPHY    pshs   d,x,u  EFD7 8E   002E               ldx    #WZPHY  EFDA 5F                      clrb  EFDB                         trfr   B,F  EFDB 1F                      fcb    $1f  EFDC 9F                      fcb    B<<4|F                               endm  EFDD EC   E4                 ldd    0,s  EFDF BD   EDB8               jsr    bytewr  EFE2 35   D6                 puls   d,x,u,pc                                          *                     * GCRVERS, get byte from common registers socket version register                     * return byte in B                     *  EFE4 34   56       GCRVERS   pshs   d,x,u  EFE6 8E   0039               ldx    #WZVERS  EFE9 5F                      clrb  EFEA                         trfr   B,F  EFEA 1F                      fcb    $1f  EFEB 9F                      fcb    B<<4|F                               endm  EFEC BD   ED5A               jsr    byterd  EFEF ED   E4                 std    0,s  EFF1 35   D6                 puls   d,x,u,pc                     *                     * all functions to access socket registers                     *                                          * socket register names and offsets               0000  SNMR      equ    0               0001  SNCR      equ    1               0002  SNIR      equ    2               0003  SNSR      equ    3               0004  SNPORT0   equ    4               0005  SNPORT1   equ    5               0006  SNDHAR0   equ    6               0007  SNDHAR1   equ    7               0008  SNDHAR2   equ    8               0009  SNDHAR3   equ    9               000A  SNDHAR4   equ    10               000B  SNDHAR5   equ    11               000C  SNDIPR0   equ    12               000D  SNDIPR1   equ    13FIO Simulation Structure             16:03:24  Nov 28, 2024   Page   96wzspi, basic spi routines                                          000E  SNDIPR2   equ    14               000F  SNDIPR3   equ    15               0010  SNDPOR0   equ    16               0011  SNDPOR1   equ    17               0012  SNMSSR0   equ    18               0013  SNMSSR1   equ    19               0014  SNPROTO   equ    20               0015  SNTOS     equ    21               0016  SNTTL     equ    22               001E  SNRBFSZ   equ    30               001F  SNTBFSZ   equ    31               0020  SNTXFR0   equ    32               0021  SNTXFR1   equ    33               0022  SNTXRP0   equ    34               0023  SNTXRP1   equ    35               0024  SNTXWP0   equ    36               0025  SNTXWP1   equ    37               0026  SNRXRZ0   equ    38               0027  SNRXRZ1   equ    39               0028  SNRXRP0   equ    40               0029  SNRXRP1   equ    41               002A  SNRXWP0   equ    42               002B  SNRXWP1   equ    43               002C  SNIMR     equ    44               002D  SNFRAG0   equ    45               002E  SNFRAG1   equ    46               002F  SNKATIM   equ    47                                                               *                     * all commands to access socket register set                     *                                                               *                     * GSRMR, get byte from socket registers mode register                     * E=socket#                     * return byte in B                     *  EFF3 34   16       GSRMR     psh    d,x  EFF5 BD   F2B1               jsr    tsk2rg  EFF8 8E   0000               ldx    #SNMR  EFFB BD   ED5A               jsr    byterd  EFFE ED   E4                 std    0,s  F000 35   96                 puls   d,x,pc                                          *                     * PSRMR, put byte B  to socket registers mode register                     * E=socket#                     *  F002 34   16       PSRMR     pshs   d,x  F004 BD   F2B1               jsr    tsk2rgFIO Simulation Structure             16:03:24  Nov 28, 2024   Page   97wzspi, basic spi routines                             F007 8E   0000               ldx    #SNMR  F00A EC   E4                 ldd    0,s  F00C BD   EDB8               jsr    bytewr  F00F 35   96                 puls   d,x,pc                                          *                     * GSRCR, get bytefrom socket registers command register                     * E=socket#                     * return byte in B                     *  F011 34   16       GSRCR     pshs   d,x  F013 BD   F2B1               jsr    tsk2rg  F016 8E   0001               ldx    #SNCR  F019 BD   ED5A               jsr    byterd  F01C ED   E4                 std    0,s  F01E 35   96                 puls   d,x,pc                                          *                     * PSRCR, put byte B in socket registers command register                     * E=socket#                     *  F020 34   16       PSRCR     pshs   d,x  F022 BD   F2B1               jsr    tsk2rg  F025 8E   0001               ldx    #SNCR  F028 EC   E4                 ldd    0,s  F02A BD   EDB8               jsr    bytewr  F02D 8D   E2       01        bsr    GSRCR  F02F 5D                      tstb  F030 26   FB                 bne    01b       wait command to be consumed  F032 E7   61                 stb    1,s       set return  F034 35   96                 puls   d,x,pc                                          *                     * GSRIR, get bytefrom socket registers interrupt register                     * E=socket#                     * return byte in B                     *  F036 34   16       GSRIR     pshs   d,x  F038 BD   F2B1               jsr    tsk2rg  F03B 8E   0002               ldx    #SNIR  F03E BD   ED5A               jsr    byterd  F041 ED   E4                 std    0,s  F043 35   96                 puls   d,x,pc                                          *                     * PSRIR, put byte B in socket registers interrupt register                     * E=socket#                     *  F045 34   16       PSRIR     pshs   d,x  F047 BD   F2B1               jsr    tsk2rg  F04A 8E   0002               ldx    #SNIR  F04D EC   E4                 ldd    0,sFIO Simulation Structure             16:03:25  Nov 28, 2024   Page   98wzspi, basic spi routines                             F04F BD   EDB8               jsr    bytewr  F052 35   96                 puls   d,x,pc                                          *                     * GSRSR, get bytefrom socket registers status register                     * E=socket#                     * return byte in B                     *  F054 34   16       GSRSR     pshs   d,x  F056 BD   F2B1               jsr    tsk2rg  F059 8E   0003               ldx    #SNSR  F05C BD   ED5A               jsr    byterd  F05F ED   E4                 std    0,s  F061 35   96                 puls   d,x,pc                                          *                     * GSRPORT, get word from socket registers source port                     * E=socket#                     * return word in D                     *  F063 34   16       GSRPORT   pshs   d,x  F065 BD   F2B1               jsr    tsk2rg  F068 8E   0004               ldx    #SNPORT0  F06B BD   ED6C               jsr    wordrd  F06E ED   E4                 std    0,s  F070 35   96                 pul    d,x,pc                                          *                     * PSRPORT, put word D into socket registers source port                     * E=socket#                     *  F072 34   16       PSRPORT   pshs   d,x  F074 BD   F2B1               jsr    tsk2rg  F077 8E   0004               ldx    #SNPORT0  F07A EC   E4                 ldd    0,s  F07C BD   EDC7               jsr    wordwr  F07F 35   96                 puls   d,x,pc                                          *                     * GSRDHAR, get destination hardware address into [Y]                     * F=sockt#, Y=destination                     *  F081 34   16       GSRDHAR   pshs   d,x  F083 BD   F2B1               jsr    tsk2rg  F086 8E   0006               ldx    #SNDHAR0  F089 BD   ED6C               jsr    wordrd  F08C ED   A4                 std    0,y  F08E 8E   0008               ldx    #SNDHAR2  F091 BD   ED6C               jsr    wordrd  F094 ED   22                 std    2,y  F096 8E   000A               ldx    #SNDHAR4  F099 BD   ED6C               jsr    wordrdFIO Simulation Structure             16:03:25  Nov 28, 2024   Page   99wzspi, basic spi routines                             F09C ED   24                 std    4,y  F09E 35   96                 puls   d,x,pc                                          *                     * PSRDHAR, put [Y] into destination hardware address                     * F=sockt#, Y=destination                     *  F0A0 34   16       PSRDHAR   pshs   d,x  F0A2 BD   F2B1               jsr    tsk2rg  F0A5 8E   0006               ldx    #SNDHAR0  F0A8 EC   A4                 ldd    0,y  F0AA BD   EDC7               jsr    wordwr  F0AD 8E   0008               ldx    #SNDHAR2  F0B0 EC   22                 ldd    2,y  F0B2 BD   EDC7               jsr    wordwr  F0B5 8E   000A               ldx    #SNDHAR4  F0B8 EC   24                 ldd    4,y  F0BA BD   EDC7               jsr    wordwr  F0BD 35   96                 puls   d,x,pc                                          *                     * GSRDIP. get destination IP address into [Y]                     * E=socket#                     *  F0BF 34   16       GSRDIP    pshs   d,x  F0C1 BD   F2B1               jsr    tsk2rg  F0C4 8E   000C               ldx    #SNDIPR0  F0C7 BD   ED6C               jsr    wordrd  F0CA ED   A4                 std    0,y  F0CC 8E   000E               ldx    #SNDIPR2  F0CF BD   ED6C               jsr    wordrd  F0D2 ED   22                 std    2,y  F0D4 35   96                 puls   d,x,pc                                          *                     * PSRDIP. put destination IP address into [Y]                     * E=socket#                     *  F0D6 34   16       PSRDIP    pshs   d,x  F0D8 BD   F2B1               jsr    tsk2rg  F0DB 8E   000C               ldx    #SNDIPR0  F0DE EC   A4                 ldd    0,y  F0E0 BD   EDC7               jsr    wordwr  F0E3 8E   000E               ldx    #SNDIPR2  F0E6 EC   22                 ldd    2,y  F0E8 BD   EDC7               jsr    wordwr  F0EB 35   96                 puls   d,x,pc                                          *                     * GSRDPOR, get word from socket registers destination port                     * E=socket#                     * return word in DFIO Simulation Structure             16:03:26  Nov 28, 2024   Page  100wzspi, basic spi routines                                                *  F0ED 34   16       GSRDPOR   pshs   d,x  F0EF BD   F2B1               jsr    tsk2rg  F0F2 8E   0010               ldx    #SNDPOR0  F0F5 BD   ED6C               jsr    wordrd  F0F8 ED   E4                 std    0,s  F0FA 35   96                 pul    d,x,pc                                          *                     * PSRDPOR, put word D into socket registers destination port                     * E=socket#                     *  F0FC 34   16       PSRDPOR   pshs   d,x  F0FE BD   F2B1               jsr    tsk2rg  F101 8E   0010               ldx    #SNDPOR0  F104 EC   E4                 ldd    0,s  F106 BD   EDC7               jsr    wordwr  F109 35   96                 puls   d,x,pc                                          *                     * GSRMSS, get word from socket registers max segment size                     * E=socket#                     * return word in D                     *  F10B 34   16       GSRMSS    pshs   d,x  F10D BD   F2B1               jsr    tsk2rg  F110 8E   0012               ldx    #SNMSSR0  F113 BD   ED6C               jsr    wordrd  F116 ED   E4                 std    0,s  F118 35   96                 pul    d,x,pc                                          *                     * PSRMSS, put word D into socket registers maximum segment size                     * E=socket#                     *  F11A 34   16       PSRMSS    pshs   d,x  F11C BD   F2B1               jsr    tsk2rg  F11F 8E   0012               ldx    #SNMSSR0  F122 EC   E4                 ldd    0,s  F124 BD   EDC7               jsr    wordwr  F127 35   96                 puls   d,x,pc                                          *                     * GSRPROT, get byte from socket registers PROTOCOL                     * E=socket#                     * return byte in B                     *  F129 34   16       GSRPROT   pshs   d,x  F12B BD   F2B1               jsr    tsk2rg  F12E 8E   0014               ldx    #SNPROTO  F131 BD   ED5A               jsr    byterd  F134 ED   E4                 std    0,sFIO Simulation Structure             16:03:27  Nov 28, 2024   Page  101wzspi, basic spi routines                             F136 35   96                 pul    d,x,pc                                          *                     * PSRPROT, put byte B into socket registers PROTOCOL                     * E=socket#                     *  F138 34   16       PSRPROT   pshs   d,x  F13A BD   F2B1               jsr    tsk2rg  F13D 8E   0014               ldx    #SNPROTO  F140 EC   E4                 ldd    0,s  F142 BD   EDB8               jsr    bytewr  F145 35   96                 puls   d,x,pc                                          *                     * GSRTOS, get byte from socket registers TOS                     * E=socket#                     * return byte in B                     *  F147 34   16       GSRTOS    pshs   d,x  F149 BD   F2B1               jsr    tsk2rg  F14C 8E   0015               ldx    #SNTOS  F14F BD   ED5A               jsr    byterd  F152 ED   E4                 std    0,s  F154 35   96                 pul    d,x,pc                                          *                     * PSRTOS, put byte B into socket registers TOS                     * E=socket#                     *  F156 34   16       PSRTOS    pshs   d,x  F158 BD   F2B1               jsr    tsk2rg  F15B 8E   0015               ldx    #SNTOS  F15E EC   E4                 ldd    0,s  F160 BD   EDB8               jsr    bytewr  F163 35   96                 puls   d,x,pc                                          *                     * GSRTTL, get byte from socket registers TTL                     * E=socket#                     * return byte in B                     *  F165 34   16       GSRTTL    pshs   d,x  F167 BD   F2B1               jsr    tsk2rg  F16A 8E   0016               ldx    #SNTTL  F16D BD   ED5A               jsr    byterd  F170 ED   E4                 std    0,s  F172 35   96                 pul    d,x,pc                                          *                     * PSRTTL, put byte B into socket registers TTL                     * E=socket#                     *FIO Simulation Structure             16:03:27  Nov 28, 2024   Page  102wzspi, basic spi routines                             F174 34   16       PSRTTL    pshs   d,x  F176 BD   F2B1               jsr    tsk2rg  F179 8E   0016               ldx    #SNTTL  F17C EC   E4                 ldd    0,s  F17E BD   EDB8               jsr    bytewr  F181 35   96                 puls   d,x,pc                                          *                     * GSRRBFS, get byte from socket registers rec buf size                     * E=socket#                     * return byte in B                     *  F183 34   16       GSRRBFS   pshs   d,x  F185 BD   F2B1               jsr    tsk2rg  F188 8E   001E               ldx    #SNRBFSZ  F18B BD   ED5A               jsr    byterd  F18E ED   E4                 std    0,s  F190 35   96                 pul    d,x,pc                                          *                     * PSRTBFS, put byte B into socket registers rec buf size                     * E=socket#                     *  F192 34   16       PSRRBFS   pshs   d,x  F194 BD   F2B1               jsr    tsk2rg  F197 8E   001E               ldx    #SNRBFSZ  F19A EC   E4                 ldd    0,s  F19C BD   EDB8               jsr    bytewr  F19F 35   96                 puls   d,x,pc                                          *                     * GSRTBFS, get byte from socket registers tx buf size                     * E=socket#                     * return byte in B                     *  F1A1 34   16       GSRTBFS   pshs   d,x  F1A3 BD   F2B1               jsr    tsk2rg  F1A6 8E   001F               ldx    #SNTBFSZ  F1A9 BD   ED5A               jsr    byterd  F1AC ED   E4                 std    0,s  F1AE 35   96                 puls   d,x,pc                                          *                     * PSRTBFS, put byte B into socket registers tx buf size                     * E=socket#                     *  F1B0 34   16       PSRTBFS   pshs   d,x  F1B2 BD   F2B1               jsr    tsk2rg  F1B5 8E   001F               ldx    #SNTBFSZ  F1B8 EC   E4                 ldd    0,s  F1BA BD   EDB8               jsr    bytewr  F1BD 35   96                 puls   d,x,pcFIO Simulation Structure             16:03:27  Nov 28, 2024   Page  103wzspi, basic spi routines                                                                     *                     * GSRTXFR, get word from socket registers TX free size                     * E=socket#                     * return word in D                     *  F1BF 34   16       GSRTXFR   pshs   d,x  F1C1 BD   F2B1               jsr    tsk2rg  F1C4 8E   0020               ldx    #SNTXFR0  [R]  F1C7 BD   ED6C               jsr    wordrd  F1CA ED   E4       01        std    0,s  F1CC BD   ED6C               jsr    wordrd  F1CF 10A3 E4                 cmpd   0,s       read more times and exit  F1D2 26   F6                 bne    01b       when 2 reads are equal  F1D4 35   96                 puls   d,x,pc                                          *                     * GSRTXRP, get word from socket registers TX read pointer                     * E=socket#                     * return word in D                     *  F1D6 34   16       GSRTXRP   pshs   d,x  F1D8 BD   F2B1               jsr    tsk2rg  F1DB 8E   0022               ldx    #SNTXRP0  [R]  F1DE BD   ED6C               jsr    wordrd  F1E1 ED   E4       01        std    0,s  F1E3 BD   ED6C               jsr    wordrd  F1E6 10A3 E4                 cmpd   0,s       read more times and exit  F1E9 26   F6                 bne    01b       when 2 reads are equal  F1EB 35   96                 puls   d,x,pc                                          *                     * GSRTXWP, get word from socket registers TX write pointer                     * E=socket#                     * return word in D                     *  F1ED 34   16       GSRTXWP   pshs   d,x  F1EF BD   F2B1               jsr    tsk2rg  F1F2 8E   0024               ldx    #SNTXWP0  [RW]  F1F5 BD   ED6C               jsr    wordrd  F1F8 ED   E4                 std    0,s  F1FA 35   96                 puls   d,x,pc                                          *                     * PSRTXWP, put word D into socket registers TX write pointer                     * E=socket#                     *  F1FC 34   16       PSRTXWP   pshs   d,x  F1FE BD   F2B1               jsr    tsk2rg  F201 8E   0024               ldx    #SNTXWP0  F204 EC   E4                 ldd    0,s  F206 BD   EDC7               jsr    wordwrFIO Simulation Structure             16:03:28  Nov 28, 2024   Page  104wzspi, basic spi routines                             F209 35   96                 puls   d,x,pc                                          *                     * GSRRXRS, get word from socket registers RX received size                     * E=socket#                     * return word in D                     *  F20B 34   16       GSRRXRS   pshs   d,x  F20D BD   F2B1               jsr    tsk2rg  F210 8E   0026               ldx    #SNRXRZ0  [R]  F213 BD   ED6C               jsr    wordrd  F216 ED   E4       01        std    0,s  F218 BD   ED6C               jsr    wordrd  F21B 10A3 E4                 cmpd   0,s       read more times and exit  F21E 26   F6                 bne    01b       when 2 reads are equal  F220 35   96                 puls   d,x,pc                                          *                     * GSRRXRP, get word from socket registers RX read pointer                     * E=socket#                     * return word in D                     *  F222 34   16       GSRRXRP   pshs   d,x  F224 BD   F2B1               jsr    tsk2rg  F227 8E   0028               ldx    #SNRXRP0  [RW]  F22A BD   ED6C               jsr    wordrd  F22D ED   E4                 std    0,s  F22F 35   96                 puls   d,x,pc                                          *                     * PSRRXRP, put word D into socket registers RX read pointer                     * E=socket#                     *  F231 34   16       PSRRXRP   pshs   d,x >F233 BD   F2B1               jsr    tsk2rg  F236 8E   0028               ldx    #SNRXRP0  F239 EC   E4                 ldd    0,s  F23B BD   EDC7               jsr    wordwr  F23E 35   96                 puls   d,x,pc                                          *                     * GSRRXWP, get word from socket registers RX write pointer                     * E=socket#                     * return word in D                     *  F240 34   16       GSRRXWP   pshs   d,x >F242 BD   F2B1               jsr    tsk2rg  F245 8E   002A               ldx    #SNRXWP0  [R]  F248 BD   ED6C               jsr    wordrd  F24B ED   E4       01        std    0,s  F24D BD   ED6C               jsr    wordrd  F250 10A3 E4                 cmpd   0,s       read more times and exitFIO Simulation Structure             16:03:28  Nov 28, 2024   Page  105wzspi, basic spi routines                             F253 26   F6                 bne    01b       when 2 reads are equal  F255 35   96                 puls   d,x,pc                                          *                     * GSRIMR, get byte from socket registers interrupt mask                     * E=socket#                     * return byte in B                     *  F257 34   16       GSRIMR    pshs   d,x >F259 BD   F2B1               jsr    tsk2rg  F25C 8E   002C               ldx    #SNIMR  F25F BD   ED5A               jsr    byterd  F262 ED   E4                 std    0,s  F264 35   96                 puls   d,x,pc                                          *                     * PSRIMS, put byte B into socket registers interrupt mask                     * E=socket#                     *  F266 34   16       PSRIMR    pshs   d,x >F268 BD   F2B1               jsr    tsk2rg  F26B 8E   002C               ldx    #SNIMR  F26E EC   E4                 ldd    0,s  F270 BD   EDB8               jsr    bytewr  F273 35   96                 puls   d,x,pc                                          *                     * GSRFRAG, get word from socket registers FRAG                     * E=socket#                     * return word in D                     *  F275 34   16       GSRFRAG   pshs   d,x >F277 BD   F2B1               jsr    tsk2rg  F27A 8E   002D               ldx    #SNFRAG0  F27D BD   ED6C               jsr    wordrd  F280 ED   E4                 std    0,s  F282 35   96                 puls   d,x,pc                                          *                     * PSRGRAG, put word D into socket registers FRAG                     * E=socket#                     *  F284 34   16       PSRFRAG   pshs   d,x >F286 BD   F2B1               jsr    tsk2rg  F289 8E   002D               ldx    #SNFRAG0  F28C EC   E4                 ldd    0,s  F28E BD   EDC7               jsr    wordwr  F291 35   96                 puls   d,x,pc                                          *                     * GSRKATM, get byte from socket registers keep alive timer                     * E=socket#FIO Simulation Structure             16:03:28  Nov 28, 2024   Page  106wzspi, basic spi routines                                                * return byte in B                     *  F293 34   16       GSKATM    pshs   d,x >F295 BD   F2B1               jsr    tsk2rg  F298 8E   002F               ldx    #SNKATIM  F29B BD   ED5A               jsr    byterd  F29E ED   E4                 std    0,s  F2A0 35   96                 puls   d,x,pc                                          *                     * PSRKATM, put byte B into socket registers keep alive timer                     * E=socket#                     *  F2A2 34   16       PSRKATM   pshs   d,x >F2A4 BD   F2B1               jsr    tsk2rg  F2A7 8E   002F               ldx    #SNKATIM  F2AA EC   E4                 ldd    0,s  F2AC BD   EDB8               jsr    bytewr  F2AF 35   96                 puls   d,x,pc                     *                     * data handling routines                     *                                          * translate socket register in partial address                     * prepares bits [7...5][4...3]                     * E=socket#, F=lost, B=lost               F2B1  tsk2rg    equ    *  F2B1                         trfr   E,B  F2B1 1F                      fcb    $1f  F2B2 E9                      fcb    E<<4|B                               endm  F2B3 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F2B4 1C   FE                 clc              make reg bits + '01'  F2B6 59                      rolb             socket register  F2B7 1A   01                 sec  F2B9 59                      rolb             xxx 01 ...                     *  F2BA                         trfr   B,F  F2BA 1F                      fcb    $1f  F2BB 9F                      fcb    B<<4|F                               endm  F2BC 39                      rts                                          *                     * translate socket register in final address (data xfer)                     * prepares bit [7...0]                     *               F2BD  tsk2tx    equ    *  F2BD                         trfr   E,B  F2BD 1F                      fcb    $1f  F2BE E9                      fcb    E<<4|BFIO Simulation Structure             16:03:29  Nov 28, 2024   Page  107wzspi, basic spi routines                                                          endm  F2BF 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F2C0 1A   01                 sec              make reg bits + '10'  F2C2 59                      rolb             sock TX buffer  F2C3 1C   FE                 clc  F2C5 59                      rolb                     *  F2C6 1A   01                 sec  F2C8 59                      rolb             write bit     '1'                     *  F2C9 58                      lslb             variable size '00'  F2CA 58                      lslb             xxx 10 100                     *  F2CB 39                      rts                                          *                     * translate socket register in rx buffer address (data xfer)                     * prepares bit [7...0]                     *               F2CC  tsk2rx    equ    *  F2CC                         trfr   E,B  F2CC 1F                      fcb    $1f  F2CD E9                      fcb    E<<4|B                               endm  F2CE 5A                      decb             wzenum= 1...8, sn= 0...7                     *  F2CF 1A   01                 sec              make reg bits + '11'  F2D1 59                      rolb             sock RX buffer  F2D2 1A   01                 sec              make reg bits + '11'  F2D4 59                      rolb                     *  F2D5 1C   FE                 clc  F2D7 59                      rolb             read bit     '0'                     *  F2D8 58                      lslb             variable size '00'  F2D9 58                      lslb             xxx 11 000  F2DA 39                      rts                                          *                     * rdsk2fb, read socket data in fifo buffer                     * Y=target, U=sock info                     * E=socket#                     * entry D= available count                     * return, D=xferred count                     *  F2DB 34   76       RDSK2FB   pshs   d,x,y,u                     *  F2DD 10A3 4A                 cmpd   wzrqln,u  has fio max size incorporated  F2E0 23   02                 bls    01f  F2E2 EC   4A                 ldd    wzrqln,u  mandatory size  F2E4 1F   01       01        tfr    D,X       save for laterFIO Simulation Structure             16:03:30  Nov 28, 2024   Page  108wzspi, basic spi routines                             F2E6 ED   E4                 std    0,s       save xfrerred old  D  F2E8 ED   48                 std    wzxfer,u  F2EA 27   3B                 beq    15f       no data                     *  F2EC BD   F222               jsr    GSRRXRP  F2EF 34   06                 pshs   d         save socket read pointer [5,6]  F2F1 1F   02                 tfr    D,Y                     *  F2F3 CE   8080               ldu    #SPIBASE  F2F6 34   01                 pshs   cc        [4]  F2F8                         pshsw  [2,3]  F2F8 1038                    fdb    $1038                               endm  F2FA 34   40                 pshs   u         [0,1]  F2FC 1A   50                 orcc   #$50      disable interrupts  F2FE 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT set CS low  F300 A7   C4                 sta    spicmd,u  F302 10AF 44                 sty    hibyta,u  start address                      >F305 BD   F2CC               jsr    tsk2rx    SOCK# to buffer address                       F308 E7   44                 stb    hibyta,u  F30A 10AE 6B                 ldy    11,s      target  F30D E7   44                 stb    hibyta,u  shift out first data byte  F30F 33   45                 leau   lobyta,u  lobyte is the first byte shifted in  F311                         trfr   X,W  F311 1F                      fcb    $1f  F312 16                      fcb    X<<4|W                               endm  F313                         tfm4   U,Y  F313 113B                    fdb    $113b  F315 32                      fcb    U<<4|Y                               endm  F316 35   40                 puls   u         [0,1]  F318 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  F31A A7   C4                 sta    spicmd,u  F31C                         pulsw  restore   E:F              [2,3]  F31C 1039                    fdb    $1039                               endm  F31E 35   01                 puls   cc        [4]                     *  F320 35   06                 puls   d         old read pointer         [5,6]  F322 E3   E4                 addd   0,s       adjust transferred  F324 BD   F231               jsr    PSRRXRP   update pointer                     *  F327 35   F6       15        puls   d,x,y,u,pc                                                               *                     * wrfb2sk,write fifo buffer to socket buffer                     * Y=target                     * E=socket#FIO Simulation Structure             16:03:31  Nov 28, 2024   Page  109wzspi, basic spi routines                                                * on entry D= total amount to xfer                     * on return D= xferred count                     *  F329 34   76       WRFB2SK   pshs   d,x,y,u  F32B 10A3 4A                 cmpd   wzrqln,u  has fio max size incorporated  F32E 23   02                 bls    01f  F330 EC   4A                 ldd    wzrqln,u  F332 1F   01       01        tfr    d,x  F334 ED   E4                 std    0,s  F336 ED   48                 std    wzxfer,u  report size  F338 27   57                 beq    15f                     *  F33A 10AE C8 22              ldy    wzuwrp,u  0 if not UDP or never written  F33E 26   05                 bne    24f  F340 BD   F1ED               jsr    GSRTXWP   get write pointer  F343 20   02                 bra    25f  F345 1F   20       24        tfr    y,d                     *  F347 34   06       25        pshs   d  F349 1F   02                 tfr    D,Y                     *  F34B CE   8080               ldu    #SPIBASE  F34E 34   01                 pshs   cc  F350                         pshsw  save      E:F  F350 1038                    fdb    $1038                               endm  F352 34   40                 pshs   u  F354 1A   50                 orcc   #$50  F356 86   2D                 lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT set CS low  F358 A7   C4                 sta    spicmd,u  F35A 10AF 44                 sty    hibyta,u  start address                       F35D BD   F2BD               jsr    tsk2tx                       F360 E7   44                 stb    hibyta,u  F362 10AE 6B                 ldy    11,s      target  F365 33   44                 leau   hibyta,u  the first to shift out  F367                         trfr   X,W  F367 1F                      fcb    $1f  F368 16                      fcb    X<<4|W                               endm  F369                         tfm3   Y,U  F369 113A                    fdb    $113a  F36B 23                      fcb    Y<<4|U                               endm  F36C 35   40                 puls   u  F36E 86   65                 lda    #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  F370 A7   C4                 sta    spicmd,u  F372                         pulsw  restore   E:F!!  F372 1039                    fdb    $1039                               endm  F374 35   01                 puls   ccFIO Simulation Structure             16:03:32  Nov 28, 2024   Page  110wzspi, basic spi routines                                                *  F376 35   06                 puls   d         old write pointer  F378 E3   E4                 addd   0,s  F37A EE   66                 ldu    6,s       restore U  F37C AE   C8 26              ldx    wztype,u  F37F 8C   0002               cmpx   #SK_DGRM  F382 27   0A                 beq    10f  F384 8C   0004               cmpx   #SK_IRAW  F387 27   05                 beq    10f  F389 BD   F1FC     11        jsr    PSRTXWP   update pointer  F38C 20   03                 bra    15f                       F38E ED   C8 22    10        std    wzuwrp,u  set RAM pointer                     *                     *  F391 35   F6       15        puls   d,x,y,u,pcFIO Simulation Structure             16:03:32  Nov 28, 2024   Page  111Debug Interface Routines                                                   F393               DB_main  F393 8D   4F                 bsr    DB_test   see if debug routines present  F395 6E   9F C002            jmp    [DEBUGROM+2]  F399               DB_pdata  F399 8D   49                 bsr    DB_test   see if debug routines present  F39B 6E   9F C004            jmp    [DEBUGROM+4]  F39F               DB_phex  F39F 8D   43                 bsr    DB_test   see if debug routines present  F3A1 6E   9F C006            jmp    [DEBUGROM+6]  F3A5               DB_phex2  F3A5 8D   3D                 bsr    DB_test   see if debug routines present  F3A7 6E   9F C008            jmp    [DEBUGROM+8]  F3AB               DB_pcrlf  F3AB 8D   37                 bsr    DB_test   see if debug routines present  F3AD 6E   9F C00A            jmp    [DEBUGROM+10]  F3B1               DB_check  F3B1 8D   31                 bsr    DB_test   see if debug routines present  F3B3 6E   9F C00C            jmp    [DEBUGROM+12]  F3B7               DB_config  F3B7 8D   2B                 bsr    DB_test   see if debug routines present  F3B9 6E   9F C00E            jmp    [DEBUGROM+14]  F3BD 34   17       DB_msg    pshs   cc,d,x  F3BF AE   65                 ldx    1+2+2,s   get return address  F3C1 EC   81                 ldd    ,x++      get mask word  F3C3 B4   0401               anda   DB_cntrl  F3C6 F4   0402               andb   DB_cntrl+1  F3C9 34   04                 pshs   b  F3CB AA   E0                 ora    ,s+  F3CD 27   04                 beq    10f       jump if flag not set  F3CF 30   02                 leax   2,x       skip over false address & fall through  F3D1 20   02                 bra    20f  F3D3 AE   84       10        ldx    ,x        get false branch label  F3D5 AF   65       20        stx    1+2+2,s   fix up return address  F3D7 35   97                 puls   cc,d,x,pc return                     *  F3D9               DB_pspace  F3D9               DB_outsp  F3D9 34   16                 pshs   d,x  F3DB 8E   F3E2               ldx    #00f  F3DE 8D   B9                 bsr    DB_pdata  F3E0 35   96                 puls   d,x,pc  F3E2 20 00         00        fcc    ' ',0                       F3E4 34   07       DB_test   pshs   cc,d  F3E6 FC   C000               ldd    DEBUGROM  Debug rom present?  F3E9 1083 1234               cmpd   #$1234    special marker  F3ED 27   05                 beq    99f       yes - exit  F3EF 35   07                 puls   cc,d      no - abort DB_xx function  F3F1 32   62                 leas   2,s  F3F3 39                      rts  F3F4 35   87       99        puls   cc,d,pc   returnFIO Simulation Structure             16:03:32  Nov 28, 2024   Page  112Debug Interface Routines                                                 *                     * nwpspecial, routines that communicate a bit differently                     *                                                                                                                              *********************************************************************                     *                     * memp2ff, mem pointer to fifo                     * copy 512 bytes addressed by fifo_us3 to fifo                     *                     * X=taskstruct                     * U=wzsock address                     *                     *                     *********************************************************************               F3F6  memp2ff   equ    *  F3F6 DC   1E                 ldd    fifo_us3  get address  F3F8 1F   98                 tfr    b,a  F3FA 5F                      clrb  F3FB 48                      lsla             512 byte chunks  F3FC 1F   01                 tfr    d,x  F3FE FC   E07B               ldd    fio_fsz  F401                         trfr   D,W  F401 1F                      fcb    $1f  F402 06                      fcb    D<<4|W                               endm  F403 108E 0020               ldy    #fifo  F407                         tfm1   X,Y  F407 1138                    fdb    $1138  F409 12                      fcb    X<<4|Y                               endm  F40A 4F                      clra  F40B C6   05                 ldb    #R_RDOK  F40D 39                      rts                                                         F40E  netboot   equ    *  F40E 39                      rts                                          ****************************************************************                     *                     * placeholder                     *                     ****************************************************************  FC00                         org    $fc00     command F8 only works with 512 boundaries! >FC00 16   0015     nboot     lbra   nboot1  FC03 0D            names     fcb    $0d  FC04 75 6E 69 66             fcc    "uniflexn"  FC0C 0000 0000               fdb    0,0,0,0,0,0FIO Simulation Structure             16:03:33  Nov 28, 2024   Page  113Debug Interface Routines                                                   FC18 30   8C E8    nboot1    leax   names,pcr  FC1B AD   9F F80A            jsr    [$f80a]  FC1F 3F                      swi                                                               ****************************************************************                                                                         end    rom_initFIO Simulation Structure             16:03:33  Nov 28, 2024   Page  114Debug Interface Routines                            Symbol Table:Absolute Symbols:A        0008   AF_INET  0002   AF_UNIX  0001   AF_UNSP  0000   B        0009   BUFSIZ   0200   CC       000A   CI_CFL   0080   CI_MP    0010   CI_POC   0020   CI_UNR   0040   CPU2DEV  0022   CPU_down E05E   CPUtraps FFF0   CR       000D   D        0000   DBG_8274 0002   DBG_CMD  0100   DBG_HAN  0020   DBG_INIT 0400   DBG_INT  0004   DBG_IO   0010   DBG_MSG  0200   DBG_OPEN 0800   DBG_SLP  0040   DBG_SYS  0001   DBG_TASK 0080   DBG_TRMI 0008   DB_check F3B1   DB_cntrl 0401   DB_confi F3B7   DB_iflg  0400   DB_main  F393   DB_msg   F3BD   DB_outsp F3D9   DB_pcrlf F3AB   DB_pdata F399   DB_phex  F39F   DB_phex2 F3A5   DB_pspac F3D9   DB_test  F3E4   DBmsg00  E012   DBmsg01  E02A   DBmsg02  E04A   DEBUG    0D04   DEBUGROM C000   DEBUG_CO 0000   DEV2CPU  0021   DEV_SIZE 0006   DEV_SOCK E56B   DO_HISTO 0001   DP       000B   DPR_BASE 0000   D_END    0046   D_func0  0000   D_func1  0002   D_func10 0020   D_func11 0022   D_func12 0024   D_func13 0026   D_func14 0028   D_func15 002A   D_func16 002C   D_func17 002E   D_func18 0030   D_func19 0032   D_func1A 0034   D_func1B 0036   D_func1C 0038   D_func1D 003A   D_func1E 003C   D_func1F 003E   D_func2  0004   D_func3  0006   D_func4  0008   D_func5  000A   D_func6  000C   D_func7  000E   D_func8  0010   D_func9  0012   D_funcA  0014   D_funcB  0016   D_funcC  0018   D_funcD  001A   D_funcE  001C   D_funcF  001E   D_init   0042   D_inthan 0040   D_test   0044   E        000E   E_ABORT  00BF   E_BADCMD 0081   E_BADDEV 0084   E_DEVBSY 0085   E_INTRPT 00BE   E_IOERR  0086   E_NTOPEN 0083   E_SOCKET 00C0   E_SYSBSY 0082   F        000F   FF       0040   FIFO_get E2ED   FIFO_put E312   FIFOgeta E2E4   FIFOputa E30A   FIOPRI   FFCE   FIO_get  E2C2   FIO_lock 0446   FIO_rel  E2D7   GCRGA    EE06   GCRILLT  EECE   GCRIMR   EF0A   GCRIR    EEEC   GCRMR    EDE8   GCRPHY   EFC6   GCRRCR   EF82   GCRRTR   EF64   GCRSHA   EE62   GCRSIMR  EF46   GCRSIP   EEA0   GCRSIR   EF28   GCRSNM   EE34   GCRUIP   EFAF   GCRURP   EFA0   GCRVERS  EFE4   GSKATM   F293   GSRCR    F011   GSRDHAR  F081   GSRDIP   F0BF   GSRDPOR  F0ED   GSRFRAG  F275   GSRIMR   F257   GSRIR    F036   GSRMR    EFF3   GSRMSS   F10B   GSRPORT  F063   GSRPROT  F129   GSRRBFS  F183   GSRRXRP  F222   GSRRXRS  F20B   GSRRXWP  F240   GSRSR    F054   GSRTBFS  F1A1   GSRTOS   F147   GSRTTL   F165   GSRTXFR  F1BF   GSRTXRP  F1D6   GSRTXWP  F1ED   HANGS    0001   HRECSIZ  0004   H_cpu    E463   H_fio    E487   IF       0010   INTS     0002   IO_end   E384   IO_han   E32D   IRQ_han  E3A3   IRQmsg10 E3B0   IS       0003   IU       0002   IX       0000   IY       0001   LF       000A   MAXHIST  0010   MAXTBL   0003   MAX_DEV  0001   MAX_S_NU 0020   MAX_TI   0009   MAX_UDP  05C0   MAX_WZ   0008   MOD_SIZE 0004   NBRQLN   0004   NBSIZE   0204   NET      0001   NUM_TSK  040C   O_CLOSE  0020   O_INTRPT 0038   O_OPEN   0010   O_PGETD  00D0   O_PSETD  00E0   O_READ   0060   O_RQRD   0050   O_RQWR   0030   O_TTYG   00A0   O_TTYS   0090   O_WR1C   0080   O_WRITE  0040   PACK_COM 0000   PACK_FIR 0080   PACK_REM 0001   PC       0005   PCRGA    EE1D   PCRILLT  EEDD   PCRIMR   EF19   PCRIR    EEFB   PCRMR    EDF7   PCRPHY   EFD5   PCRRCR   EF91   PCRRTR   EF73   PCRSHA   EE81   PCRSIMR  EF55   PCRSIP   EEB7   PCRSIR   EF37   PCRSNM   EE4B   PF_INET  0002   PF_UNIX  0001   PIPES    0006   POLPRI   FFBA   PROT_EGP 0008   PROT_ICM 0001   PROT_IGM 0002   PROT_XLT 8000   PSRCR    F020   PSRDHAR  F0A0   PSRDIP   F0D6   PSRDPOR  F0FC   PSRFRAG  F284   PSRIMR   F266   PSRIR    F045   PSRKATM  F2A2   PSRMR    F002   PSRMSS   F11A   PSRPORT  F072   PSRPROT  F138   PSRRBFS  F192   FIO Simulation Structure             16:03:36  Nov 28, 2024   Page  115Debug Interface Routines                            PSRRXRP  F231   PSRTBFS  F1B0   PSRTOS   F156   PSRTTL   F174   PSRTXWP  F1FC   QFF1     0080   QUITS    0003   RAMend   3EFF   RAMorg   0400   RAMscrat 7000   RAMscren 7E00   RDSK2FB  F2DB   REJECT   0080   ROMLOorg E000   ROM_ERR  E0D3   ROM_VERS 0020   ROMstack 7FE0   RSVREG   0003   RUNPRI   0046   R_ACCEPT 000B   R_BIND   0009   R_CLOCK  000E   R_CLOSE  0002   R_CONNEC 0008   R_DISCON 000C   R_ERRBLK 0084   R_INTRPT 0007   R_LISTEN 000A   R_OPEN   0001   R_PDATA  000B   R_RD1C   0009   R_RDFRM  0021   R_RDOK   0005   R_RDRBLK 0083   R_READ   0006   R_READM  000C   R_REQOK  0003   R_RESET  000F   R_RQRBLK 0082   R_RQRD   0005   R_RQRDNB 0015   R_RQSBLK 0080   R_RQWR   0003   R_RQWRNB 0013   R_RRDFD  0022   R_RSNDTO 0023   R_SNDBLK 0081   R_SNDKEP 000E   R_SNDMAC 000D   R_SNDTOM 0025   R_SPCL   000F   R_TTY    000D   R_WR1C   0008   R_WRITE  0004   R_WSNDTO 0024   S        0004   SIQPRI   FFD8   SI_CON   0001   SI_DIS   0002   SI_HAN   E3F7   SI_Q     040E   SI_Q_ptr 0444   SI_RCV   0004   SI_SOK   0010   SI_TIM   0008   SKADLN   0010   SKPRI    FFC4   SK_DGRM  0002   SK_IRAW  0004   SK_MRAW  0003   SK_NONBL 0100   SK_SPONC 0200   SK_STRM  0001   SNCR     0001   SNDHAR0  0006   SNDHAR1  0007   SNDHAR2  0008   SNDHAR3  0009   SNDHAR4  000A   SNDHAR5  000B   SNDIPR0  000C   SNDIPR1  000D   SNDIPR2  000E   SNDIPR3  000F   SNDPOR0  0010   SNDPOR1  0011   SNFRAG0  002D   SNFRAG1  002E   SNIMR    002C   SNIR     0002   SNKATIM  002F   SNMR     0000   SNMSSR0  0012   SNMSSR1  0013   SNPORT0  0004   SNPORT1  0005   SNPROTO  0014   SNRBFSZ  001E   SNRXRP0  0028   SNRXRP1  0029   SNRXRZ0  0026   SNRXRZ1  0027   SNRXWP0  002A   SNRXWP1  002B   SNSR     0003   SNTBFSZ  001F   SNTOS    0015   SNTTL    0016   SNTXFR0  0020   SNTXFR1  0021   SNTXRP0  0022   SNTXRP1  0023   SNTXWP0  0024   SNTXWP1  0025   SPIBASE  8080   SPI_AUT  0008   SPI_CR_  0001   SPI_CS_  0040   SPI_HLD  0002   SPI_IEN  0010   SPI_IRQ  0001   SPI_RST  0020   SPI_SR_  0004   SP_EGP   0008   SP_GMP   0002   SP_ICMP  0001   SP_TCP   0006   SP_UDP   0011   S_ACCEPT 0058   S_BIND   0048   S_CLOSE  0010   S_CONNEC 0040   S_DISCON 0060   S_INTRPT 0038   S_LISTEN 0050   S_NETBOO 00F0   S_OPEN   0008   S_PG2FIF 00F8   S_RDRBLK 00D8   S_READ   0030   S_RQRBLK 00D0   S_RQRD   0028   S_RQSBLK 00C0   S_RQWR   0018   S_RRDFRM 0080   S_RREAD  0088   S_SNDBLK 00C8   S_SNDKEP 0070   S_SNDMAC 0068   S_SPCL   0078   S_WRITE  0020   S_WRQSTO 0090   S_WSNDTM 00A0   S_WSNDTO 0098   TFREE    0004   TRUN     0001   TSKSIZ   00D7   TSLEEP   0002   TSYS     0005   TWAIT    0003   U        0003   USTSIZ   00C0   V        0007   W        0006   WCACCP   0086   WCBIND   0085   WCCLOS   0010   WCCONN   0004   WCDISC   0008   WCLIST   0002   WCOPEN   0001   WCRECV   0040   WCRRQD   0081   WCSEND   0020   WCSKEP   0022   WCSNAC   0021   WCSPEC   0080   WCXMDR   0082   WFNBLK   0001   WFSPOC   0002   WRFB2SK  F329   WSCLSD   0000   WSCLSG   001A   WSCLWT   001C   WSESTB   0017   WSFWAI   0018   WSINIT   0013   WSIRAW   0032   WSLACK   001D   WSLIST   0014   WSMRAW   0042   WSRNBL   001E   WSRRQF   0081   WSSPEC   0080   WSSYNR   0016   WSSYNS   0015   WSTIMW   001B   WSUDP    0022   WSWNBL   001F   WSXMDD   0082   WZ5_name E1D5   WZBUSY   0080   WZGAR0   0001   WZGAR1   0002   WZGAR2   0003   WZGAR3   0004   WZILLT0  0013   WZILLT1  0014   WZIMR    0016   WZIR     0015   WZLCSZ   0016   WZMR     0000   WZNETOF  0370   WZPHY    002E   WZRCR    001B   WZRTR0   0019   WZRTR1   001A   WZSHAR0  0009   WZSHAR1  000A   WZSHAR2  000B   WZSHAR3  000C   WZSHAR4  000D   WZSHAR5  000E   WZSIMR   0018   WZSIPR0  000F   WZSIPR1  0010   WZSIPR2  0011   WZSIPR3  0012   WZSIR    0017   WZSIZE   002A   WZSKOFF  0220   WZSLCK   0001   WZSUBR0  0005   WZSUBR1  0006   WZSUBR2  0007   WZSUBR3  0008   WZUIPR0  0028   WZUIPR1  0029   WZUIPR2  002A   WZUIPR3  002B   WZUPRT0  002C   WZUPRT1  002D   WZVERS   0039   WZWBND   0040   WZWLCK   0010   X        0001   Y        0002   bad_cmd  E39F   bittab   E709   bmread   ED7E   bt2num   E6F8   byterd   ED5A   bytewr   EDB8   chproc   040A   clock_ti 0455   conlb1   E7B2   cpu_fio  0000   cpu_fio1 0001   cpu_fio2 0003   cpu_fio3 0004   FIO Simulation Structure             16:03:36  Nov 28, 2024   Page  116Debug Interface Routines                            cpu_fio4 0006   cpu_fio5 0008   cpu_fioF 0024   dev_addr 0000   dev_brbu 0004   dev_tab  049B   dev_type 0002   end_vars 3EFF   fifo     0020   fifo_cnt 0012   fifo_get 0014   fifo_put 0016   fifo_us0 0018   fifo_us1 001A   fifo_us2 001C   fifo_us3 001E   fio_cpu  0009   fio_cpu1 000A   fio_cpu2 000C   fio_cpu3 000D   fio_cpu4 000F   fio_cpu5 0011   fio_cpuF 0023   fio_dsz  E07D   fio_fsz  E07B   fio_irq  E220   fio_msg  E28A   fio_rese E1E0   fio_resp E2A6   fio_star E09B   fio_wait E203   fiointe  E289   functb   EC82   gtsktb   E4BF   hibyta   0004   hibyts   0006   hst_cmd  0000   hst_seq  0001   hst_tty  0002   hst_val  0003   hstbuf   0459   hstptr   0499   idle     040D   int_all  E3C8   int_buf  0447   int_ptr  0453   jobpri   0409   lobyta   0005   lobyts   0007   lstram   115A   makrd6   E4F3   makrdy   E4EA   max_trn  E07F   memp2ff  F3F6   mod_name 0002   mod_tbl  E1CF   mod_type 0000   names    FC03   nboot    FC00   nboot1   FC18   netboot  F40E   no_dev   E153   num2bt   E6EE   nwp_strt 0000   oldorg   ED26   polext   E7D0   rdrqer1  E906   rom_bad  E0D1   rom_firq E0A4   rom_init E080   rom_int  E0C6   rom_nmi  E09E   rom_swi  E0AB   rom_swi2 E0B1   rom_swi3 E0B8   rom_trap E0BF   rsched   E4AB   rsched2  E4AD   sa_dat   0002   sa_fam   0000   sdev_sig E626   send_SI  E439   set_tabl E111   showrg   ECD0   sin_addr 0014   sin_fam  0010   sin_port 0012   skacpt   E872   skbind   E7F2   skclin   E72D   skclos   E712   skcner1  E7E8   skcner2  E7D8   skcner3  E7EC   skcner4  E7E4   skcner5  E7E0   skcner6  E7DC   skconn   E75F   skcraw   E664   skctcp   E64E   skcudp   E657   skdisc   ED1F   skdvini  E5CE   skfres   E647   skinit   E5B1   skinthan E625   skintrp  E712   sklist   E836   sknbe1   EBBB   sknbe10  EC1F   sknbrd   EBC2   sknbrp1  EBB5   sknbrp2  EB8F   sknbrr   EB5D   sknbsd   EC2B   sknbsr   EBF1   sknewp   E629   sknone   E5CB   skopen   E66D   skoper1  E6E4   skoper2  E6E8   skowfo   E6C3   skrecv   E90B   skreqrd  E8B3   skreqwr  E94E   sksend   E9A3   skskep   ED1F   sksmac   ED1F   skspcl   EC5B   sktest   E622   skuer1   EB20   skurrd   EA6A   skurrdf  E9E5   skurwt   EA98   skusnm   EADC   skusnt   EB23   skuwr2   EADC   sleep    E518   sleep7   E540   slplst   0403   spicmd   0000   spicon   0001   spiint   0456   spinit   ED26   spista   0000   spistr2  ED2C   sprend   EDD6   stbinit  E0E0   sto_chk  E15A   stptsk   E4CE   swtchu   E4DF   sys_vars 0400   tim_base 8400   tim_rest 8401   timerack E1C3   timerchk E1C9   timerin  E1BD   tsagin   000F   tscmd    0009   tsdev    000D   tsevnt   0006   tsk2rg   F2B1   tsk2rx   F2CC   tsk2tx   F2BD   tskindx  040B   tskinit  E168   tsktab   04C1   tslink   0000   tsprir   0005   tsseq    000A   tssgnl   0008   tsslnk   0002   tsstat   0004   tstval   000C   umark0   0013   umark1   0015   usp      0011   utask    0407   wakeu2   E4FF   wakeu3   E506   wakeu4   E50A   wakeu5   E50C   wakeup   E4F4   wlocip   0370   wnboot   03B0   wordrd   ED6C   wordwr   EDC7   wzanyp   0457   wzcmnd   0004   wzdctr   0001   wzdevt   E63B   wzdma1   000C   wzdma2   000E   wzdprt   0012   wzdsta   0012   wzenum   0000   wzerr    0007   wzfaml   0024   wzflg    0003   wzfsta   0002   wzgwad   0008   wzhwad   000C   wzifga   E00E   wzifip   E006   wzifma   E000   wzifnm   E00A   wzipad   0014   wzmyip   0000   wzprio   0006   wzprot   0028   wzrdev   ECB4   wzrqln   000A   wzsbnm   0004   wzsflg   0018   wzsk1    0346   wzsk2    031C   wzsk3    02F2   wzsk4    02C8   wzsk5    029E   wzsk6    0274   wzsk7    024A   wzsk8    0220   wzsprt   0010   wzstat   0005   wzswap   0020   wztype   0026   wzuipa   001A   wzuprt   001E   wzurms   0020   wzuwrp   0022   wzwdev   EC8A   wzxfer   0008   xmtint   E54D   