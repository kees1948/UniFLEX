        sttl    wzspi, basic spi routinesoldorg  set     *** hardware register orgaization*SPIBASE equ     $8080           hardware base address        org     0*spicmd  rmb     1             HW control registerspista  equ     spicmd        HW status registerspicon  rmb     1       [W]   HW aux control register        rmb     2       dummy not used* shift register accesshibyta  rmb     1       [R/W] hibyte auto 8 clock pulses for SRlobyta  rmb     1       [R/W] lobyte auto 8 clock pulses for SRhibyts  rmb     1       [R/W] hibyte static (no clock)lobyts  rmb     1       [R/W] lobyte static (no clock)*QFF1    equ     %10000000 [R]                          XSPI_CS_ equ     %01000000 [R/W] spi chip CS_           1SPI_RST equ     %00100000 [R/W] spi chip RST_          1SPI_IEN equ     %00010000 [R/W] spi chip INT enabled   0SPI_AUT equ     %00001000 [R/W] auto advance           0SPI_SR_ equ     %00000100 [R/W] shift register MR_     1SPI_HLD equ     %00000010 [R/W] HOLD                   0SPI_CR_ equ     %00000001 [W]   HC163 MR_              1SPI_IRQ equ     %00000001 [R]   /IRQ bit               1*RSVREG  equ     %00000011       reserved register address        org     oldorg** spinit, init the SPI hardware*spinit  equ     *        lda     #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_  set idle        sta     SPIBASE+spicmd        rts** setup inital port for SPI access** A,B are lost A=rwflag, F=register, X=offset* F=corrected register bits [7...3]* A= R/W flag 1=write/ 0= read* X,Y untouched*spistr2 equ     *        ldu     #SPIBASE        SPI base TODO        trfr    F,B        tstb                    register pointer        beq     01f             OK, valid        pshs    b        andb    #RSVREG         reserved loctation        tstb                    xxx10xxx  is invalid!        puls    b        beq     09f             invalid access* adjust READ/WRITE bit01      tsta                    cmd flag        beq     04f        sec                     write   100        bra     05f04      clc                     read    000*05      rolb                    set READ/WRITE bit  [2...0]        lslb                    set variable length data [00]        lslb** here the actual SPI action starts*        seti                    disable interrupts        nop*       lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT+SPI_IEN low        lda    #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT low        sta    spicmd,u        stx    hibyta,u        and shift out        stb    hibyta,u        and shift out        sez        rts09      clz        rts** X = offset, unchanged* F = register#* read BYTE from SPI* return B=value, D,X,Y,U preserved*byterd  equ     *        pshs    cc,d,u        clra        bsr     spistr2        lbne    09f        ldb     hibyta,u    extra clocks for first data*        ldb     lobyta,u    read byte        clra        std     1,s        bra     sprend** X = offset* F = register#* read WORD from SPI* return D=value,  D,X,Y,U preserved*wordrd  equ     *        pshs    cc,d,u        clra        jsr     spistr2        bne     09f        ldb     hibyta,u    extra clocks for first data*        lda     lobyta,u    read byte        ldb     lobyta,u    read byte        std     1,s        bra     sprend** bmread, spi to memory read xfer* Y=mem pointer, D=count (bytes)* F = register#* read bytes from SPI into memory location* return D,X,Y,U preserved*bmread  equ     *        pshs    cc,d,x,y,u        pshsw                   save E:F        jsr     GSRRXRP         'read' pointer        tfr     d,x             keep        ldu     #SPIBASE        pshs    u               remember        orcc    #$50        lda     #SPI_RST+SPI_SR_+SPI_CR_+SPI_AUT        sta     spicmd,u        start SPI        stx     hibyta,u        start address        jsr     tsk2rx          E => B        stb     hibyta,u        socket register        ldd     5,s             old D        trfr    D,W             transaction count        stb     hibyta,u        dummy, shift out        ldy     9,s             old Y, mem pointer        leau    lobyta,u        point to data register        tfm4    U,Y             U => Y++        puls    u               restore SPIBASE        lda     #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_        sta     spicmd,u        end SPI* X = old read pointer, 0,s byte wount        tfr     x,d             start pointer        addd    3,s             move pointer with # bytes        pulsw                   restore E:F        jsr     PSRRXRP         update pointer        puls    cc,d,x,y,u,pc** X = offset* F = register#* write BYTE to SPI, D,X,Y,U preserved*bytewr  equ     *        pshs    cc,d,u        lda     #1        jsr     spistr2        bne     09f*        lda     2,s        sta     hibyta,u        bra     sprend** X = offset* F = register#* write WORD to SPI, D,X,Y,U preserved*wordwr  equ     *        pshs    cc,d,u        lda     #1        jsr     spistr2        bne     09f*        ldd     1,s        sta     hibyta,u        stb     hibyta,u** common exit from SPI action*sprend  lda     #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_*sprend  lda     #SPI_CS_+SPI_RST+SPI_SR_+SPI_CR_+SPI_IEN        sta   spicmd,u        lda     0,s             sez        ora     #402      sta     0,s        puls    cc,d,u,pc*09      lda     0,s             clz        anda    #255-4        bra     02b