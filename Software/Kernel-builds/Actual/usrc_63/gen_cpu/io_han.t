          sttl    IO         Command Handler          pag*** IO_han - I/O Command Handler**   This routine comprises the main processing loop* for each task in the system.  Whenever an I/O command* is detected (via the message interrupt), a task will* be scheduled to process it.  This is that task.*   The command is saved in the "tscmd" field of the* task control block.*IO_han** we execute the task belonging to the transaction*          clri          ldx     utask      get task control block address          lda     tscmd,x    get I/O command          ldb     tsdtix,x   get device table selector** The command byte is shifted and used as an index* in a DEV_XXXX tab, max 32 commands allowed*          lsra                  isolate    command          lsra          lsra*          cmpb    #MAX_DEV      invalid device?          blo     00f          ldb     #E_BADDEV          bra     20f*00        cmpa    #MAX_FCMD     max. fifo commands          blo     01f          ldb     #E_BADCMD          bra     20f** build 16 bit index in table*01        lsla                  --   word index on command          pshs    x             TASK info          pshs    a          ldx     #dev_tab          lda     #DEV_SIZE          mul          leax    d,x           right table selected          ldx     dev_type,x get handler table address          puls    a          ldy     a,x        get processor address          puls    x          pshs    y          can be changed on stack..** Y=function code address, X = task*          ldy     tsagin,x   if 0, d nothing          beq     05f        else it is target ponter          sty     0,s        code asks for rerun, overwrite          ldy     #0          sty     tsagin,x   reset pointer** TOS now holds correct execution address*05        puls    y          change address          clra*          ldx     #IO_end    interrupt handler address          pshs    x          ldx     utask      task pointer          sts     umark1,x          ldu     tsdev,x    get sock reference** CALL HANDLER: X=utask, Y=handler address, U=device reference* can be maj/min or wzsock address*          jsr     0,y        perform operation & return status          leas    2,s        clean up stack** on return, Y= flag. -1 is resched, else end task* B = status , A = danta, X,U are lost*          ldx     utask      restore task pointer          cmpy    #$ffff          bne     20f* task is NOT done yet, don't stop it! re-schedule          seti               set interrupt mask          bra     91f        just escape (and come back)** A=transaction value, B=response code, U=device reference* X = task pointer* in fio_response the task ID is added as sequence reference* SEND the response to the host CPU**20        jsr     fio_response** task is done*IO_end    seti    mask       interrupts          ldx     utask      restore task control block address          sta     tstval,x   remember transaction value sent          stb     tscmd,x    and command response          lda     #TFREE     mark task "terminated & free"          sta     tsstat,x          lda     #$FF       disassociate from any terminal          sta     tsdev,x          sta     tsdev+1,x          clr     tssgnl,x   no waiting signals** exit here to rescheduling*91        jsr     rsched     run other tasks          lbra    IO_han** not implemented*bad_cmd   ldb   #E_BADCMD    error code          rts