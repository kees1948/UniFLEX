** driver to set/get terminal speed settings** in CPU io-space it scans the device tables** in IOP space it communicates with special datagrams** C. Schoenmakers 2020 (c)** this special driver has no read/write provisions but works* entirely via ttyset / ttyget handshakes. It isolates kernel* space from users and don't need access to it.*        opt     nol         lib     environment.h         lib    ../include/macdefs.h         lib     ../include/sysdefs.h         lib    ../include/inttab.h         lib    ../include/fio.h         lib    ../include/fio_ctrl.h         lib    ../include/iop_dev.h        opt     lis        data        name    tspddrvr        global  tspdopn,tspdcls,tspdspcl* housekeeping datatspd_dev fdb   $ffff               device codetspd_dptr fdb  $ffff               inttab pointertspd_flg  fcb  0* for IOP serial devices keep a backup copy of the baudrate latches here          if    (IOP=1)** this table MUST have the same length as brbupr in tty_acia.t in iop_cpu* baudrate table for 24 IOP ports,check max*tspd_iop          fdb  $ffff,$ffff,$ffff,$ffff   acia 9,10,11,12 (IOP)          fdb  $ffff,$ffff,$ffff,$ffff   acia 13,14,15,16 (IOP)          fdb  $ffff,$ffff,$ffff,$ffff   acia 17,18,19,20 (IOP)*MAX_IOPS  equ  (*-tspd_iop)/2            max ports allowed          endif** drivers should be used exclusieve, i.e. single access* which is not a problem because the handling time is very short*tspdopn tst     tspd_flg         test for single open        bne     01f        inc     tspd_flg        lbsr    tspd_ini         init driver vars        rts01      lda     #EBSY            already (short time) in use        sta     uerror        rts*tspdcls tst     tspd_flg        beq     01f        clr     tspd_flg        rts01      lda     #EPRM        sta     uerror        rts** this is the ttyset/ttyget entry, it does all the work* the method is* ttyset (with serial port ID)* ttyget to tell the current setting to i.e. portbaud* ttyset to set a baudrate* on ntry D= device maj/min, X=0flags, Y=chrtab entry* first check for valid device*tspdspcl equ     *        tfr     x,y             save flag        cmpy    #0        lbne     tspd_get*  get data from usargx, do SET here        ldx     tspd_dev        first time here?        cmpx    #$ffff        lbne    set2nd          no** 1st stage                     yes*set1st  ldd     usarg0          device info        cmpa    #LCLTTY         is this a valid tty device        bne     71f* valid local ttys        lbsr    tspdfdev        find device entry10      stx     tspd_dptr       points to device table entry        cmpx    #$ffff          or not if there was an error        lbeq    tspd_er1        not found* set we did the initial steps        ldd     usarg0          set we initialized it        std     tspd_dev        rts                     ok, phase 1 finished* check for IOP ports?71        if      (IOP=1)        cmpa    #IOPTTY         IOP port?        bne     tspd_er2        subb    #IOPTDMIN       first IOP tty device        blo     tspd_er2        pshs    x,y        ldy     #IOP0        ldx     fifo_us0,y      application data        ldy     fio_dba,y        addr    Y,X            Y + X -> X        cmpb    NUM_TRM,x        puls    x,y        bhs     tspd_er2* yes* fill buffer with request        ldx     #tspd_iop       communicate via the fifo        lslb        abx        stx     tspd_dptr      set occupied* get the info from the IOP        ldd     usarg0        ldx     #xfrbuf        jsr     iop_getd       get data from IOP*        ldx     tspd_dptr        lda     xfrbuf          latch contents        sta     0,x             for 2 ports* set we did initial steps        ldd     usarg0        std     tspd_dev        set we did it        rts        endiftspd_er2 lbsr tspd_er1        rts************************************************************        if      (IOP=1)** update an IOP port baudrate*iop_spd equ     *        lda     tspd_dev+1    get minor        suba    #IOPTDMIN        tfr     a,b           save it        bita    #%00000001        bne     01f        lda     #$f0        bra     02f01      lda     #$0f02      anda    0,x           old value        pshs    a        lda     usarg1+1      get new        bitb    #%00000001        beq     03f        asla        asla        asla        asla03      ora     0,s+        ldx     tspd_dptr        sta     0,x             update table in driver        clrb        sta     xfrbuf        ldx     #xfrbuf        ldd     usarg0        jsr     iop_setd        write to IOP        rts        endif** now, we have reported the current setting, now update*set2nd  ldx     tspd_dptr       get pointer to device info        cmpx    #$ffff        beq     tspd_er1* update tty table        pshs    d,x        ldd     usarg0          device no        jsr     updtb2          updata tbaud2        puls    d,x*        if      (IOP=1)        ldd     usarg0          ports info        cmpa    #IOPTTY        beq     iop_spd        endif** find out more of the target port*        ldd     inbrbu,x        does it have baudrate hw?        beq     tspd_er1        can't set*        ldd     usarg0          check if we did well        cmpd    indev,x        bne     tspd_er1** create new latch setting*        ldy     inbrbu,x        get pointer to data byte        ldb     usarg1+1        fetch low byte        andb    #$0f        stb     inspcl,x        update default setting        lda     inbrmsk+1,x        coma                    invert mask        anda    0,y        pshs    a               save intermediate data        lda     inbrmsk+1,x       original mask bits again        cmpa    #$0f        beq     01f             low or high nibble        lslb                                                A        lslb        lslb        lslb01      orab    0,s+            set new data in backup location        stb     0,y             save it*        ldy     instat,x        get ACIA address        stb     2,y             go set latch        rts*tspd_er1 equ    *        lda     #EBDEV        sta     uerror        rts** on the next ttyget, we return the current baudrate info** put data to Y, do get here, report the baudratetspd_get equ     *        ldd     tspd_dev        device vector        std     0,y++        cmpd    #$ffff          is it unset?        beq     01f        pshs    y        ldx     tspd_dptr        if      (IOP=1)        cmpa    #IOPTTY        beq     ts_get02        endif** report baudrate setting for CPU serial port*        ldy     inbrmsk,x       get mask        ldx     inbrbu,x        baudrate info        beq     02f             no brg        clra        ldab    0,x        cmpy    #$000f          low nible        beq     40f        lsrb        lsrb        lsrb        lsrb40      andb    #$0f        puls    y        bra     10f02      puls    y               ttyset buffer to portbaud01      ldd     #-1*10        std     0,y++           either baudrate or invalid        rts** report baudrate from IOP port*ts_get02 ldb    0,x             has info for 2 ports         lda    tspd_dev+1      get minor         suba   #IOPTDMIN         bita   #%00000001      EVEN/ODD         beq    01f         lsrb         lsrb         lsrb         lsrb01       clra         bra    40b** locate device info in inttab, for local ACIA's only* D contains maj/min of device* on return X point to entry* $ffff if not found*tspdfdev equ    *        pshs    d        ldx     #inttab        ldb     0,x+            # of entries        pshs    b        beq     15f             none?*05      ldd     1,s        cmpd    indev,x         check it        beq     10f        leax    INTSIZ,x        next netry        dec     0,s        bne     05b15      ldx     #$ffff          not found10      leas    1,s             purge counter        puls    d,pc** set everything afresh, makes testing easy*tspd_ini equ    *        ldd     #$ffff        std     tspd_dev        set device invalid        std     tspd_dptr        rts** update tty table*updtb2  lda     #TTYSIZ        ldx     ttytab        mul        leax    d,x        lda     usarg1+1        baudrate byte        sta     tbaud2,x        rtsxfrbuf  rzb     4       data transfer from/to  IOP ports        end