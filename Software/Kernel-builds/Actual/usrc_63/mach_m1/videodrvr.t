        opt     nol        lib     ../include/video.h        lib     ./gendrvr.h        opt     lis,exp        if      (VID=1)        name    videodrvr        sttl    Video Driver        data** this is the UniFLEX driver for the CPU09VID board* this board provides 512x472 pixels B/W** The videoboard has an IO range which is to be decoded* from $FF008...$FF00F** $FF008 is the HD63B21 piad base address* $FF00C is the HD63B45 video controller* $FF00E is the HD63B50 acia base address** the video memory is accessible from $F8000...$F8FFF* this is a 4K page, where via the pia one out of 8 such* can be selected*** the low level initialisation has to be done in 'mach.t' !!*        global  vdopen,vdclos,vdread,vdwrit,vdspcl*vidsel  rzb     1               open statusvid000  rzb     VIDLEN** the video device may only opened exclusively****vdopen  equ     *        tstb                    check minor        bne     vider1        tst     vidsel          already open?        bne     vider2        inc     vidsel        rts***vdclos  equ     *        clr     vidsel        rts*vider1  lda     #EBARG        bra     viderxvider2  lda     #EBSYviderx  sta     uerror        rts** read from a 32KByte video array into user space*vdread  equ     *        pshs    d,x,y   save registers        ldu     #vid000        bsr     chkbnd        bne     vider01 correct stack first        lda     #$ff    set read98      sta     vidflg,u        bsr     doxfer99      puls    d,x,y,pc*vider01 lda     #EBARG        sta     uerror        bra     99b** write to 32 KByte video array from user space*vdwrit  equ     *        pshs    d,x,y        ldu     #vid000        bsr     chkbnd          check boundaries        bne     vider01        lda     #0        bra     98b** bndchk, check if writing beyond video buffer*chkbnd  ldd     uipos           should be zero        bne     vider01        ldd     uicnt        addd    uipos+2         max 30208 bytes        cmpd    #MAXVAD max video address        bhi     21f*        ldd     uistrt        addd    uicnt        bcs     21f             overflow        cmpd    #$fe00          max user address        bhs    21f*        clra        rts21      lda     #1        rts** here the whole xfer is done* calc page offsets* U holds variable array*doxfer  equ     *        ldd     uicnt           any to process?        bne     01f        rts*01      ldd     uistrt          memory start address        anda    #$0f            4 K page        pshs    a        ora     #$D0            set Xbuffer        tfr     d,y             Y is user memory pointer        puls    a        coma        comb        anda    #$0f            4096 max        addd    #1        std     uspcnt,u        remaining bytes        ldb     uistrt        ldx     #umem        andb    #$f0            get memory page        clc        rorb        rorb        rorb        rorb        lda     b,x        sta     uscpag,u        current memory page*        ldd     uipos+2         offset in video buffer        anda    #$0f            4 K page        pshs    a        ora     #$E0            video page        tfr     d,x             video pointer        puls    a        coma        comb        anda    #$0f        addd    #1              4096 max        std     vdpcnt,u        remaining count*        lda     uipos+2         create video page select        anda    #$70        clc        rora        rora        rora        rora        pshs    a        lda     piadra        anda    #%11111000        ora     0,s+        sta     piadra          set access page*        ldd     uicnt        cmpd    uspcnt,u        find smallest        bls     02f        ldd     uspcnt,u02      cmpd    vdpcnt,u        bls     12f        ldd     vdpcnt,u12      trfr    D,W             W holds count        std     vidcnt,u        store this too*        tst     vidflg,u        test direction        bmi     03f        exg     x,y*03      pshs    cc        sei        bsr     setpag          map in        tfm1    X,Y             do xfer        bsr     respag          map out        puls    cc              re-enable ints*        ldd     uicnt        subd    vidcnt,u        tell what we did        std     uicnt        ldd     uistrt        addd    vidcnt,u        std     uistrt          bump memory pointer        ldd     vidcnt,u        addd    uipos+2        std     uipos+2         bump video pointer* done this part        lbra    doxfer          check again** set kernel D page with user memory chunk* set kernel E page with video buffer chunk*setpag  lda     DATBOX+$D       curret value        sta     vidsav,u        lda     uscpag,u        user page        sta     DATBOX+$D        lda     #VIDMAP         video page        sta     DATBOX+$E        rts** restore the old settings for the* kernel map*respag  lda     vidsav,u        sta     DATBOX+$D        lda     #IOMAP        sta     DATBOX+$E        rts***vdspcl  equ     *        rts        endif