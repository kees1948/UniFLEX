        opt     nol        lib     ../mach_m1/sysconfig.h        lib     ./gendrvr.h        lib     ../include/blktab.h        lib     ../include/wzsock.h        lib     ../include/fio.h        lib     ../include/fio_ctrl.h        lib     ../include/nwp_codes.h        lib     ../include/socket.h        lib     ../include/ust.h        lib     ./netblock.h        opt     lis,exp        if       (NETBLCK=1)        if       (NET<>1)        err     "netdrivers not present!!!        endif        sttl     netblock Driver        pag        data        name    netblockdrvr        global  nbopn,nbcls,nbio,nbdata        global  nbcopen,nbcclos,nbcspcl,nbcrd,nbcwrREPORT  set     0**************************************************************** netblock driver, allow a remote block device or diksimage file* to be accessed as a local filesystem** uses a socket connection with the remote part***************************************************************NBtbl  fdb     0               Block Device Table addressnbdata  rzb     NBPSIZ*2       all details are kept here* Block driver part, no equivalent device driver**************************************************************** open the netblock disk drive* B contains device minor* here the devices run from 0 up to max***************************************************************nbopn   pshs    d,x        ldx     #nbdata         all there is to know        cmpb    #MXNBDV        bhs     nbop12        lda     #NBPSIZ        mul        leax    d,x             point to right data set* set in use        ldy     #NWP0        lda     nbflgs,x        bita    #NB_OPEN        bne     nbop3           if open do not initialize*        ldd     #0        std     nbsock,x        init        jsr     nbskin          init socket, set nbsock        bne     nbop2* U=wzsock        jsr     nbskop          open socket        bne     nbop2        lda     nbflgs,x        ora     #NB_OPEN        sta     nbflgs,x*        jsr     nbskcn          try connect        bne     nbop21* connection made        ldb     #NB_ESTB        established        orb     nbflgs,x        stb     nbflgs,x        bra     nbop3* Y=NWP0, X=nbdatanbop21  ldu     nbsock,x        jsr     wskcl           close        bra     nbop2           error*nbop12  lda     #EBDEV        sta     uerror        bra     nbop3* set error and closednbop2   lda      #EBARG          no image file set01      sta      uerror*nbop4   ldd      #0        std      nbsock,xnbcl3   lda     nbflgs,x        anda    #255-(NB_OPEN+NB_ESTB)        sta     nbflgs,xnbop3   puls     d,x,pc          return**************************************************************** nb close D=device***************************************************************nbcls   pshs    d,x        ldx     #nbdata         all items        cmpb    #MXNBDV        bhs     nbop12        lda     #NBPSIZ        mul        leax    d,x             point to right data set*        ldu     nbsock,x        beq     nbcl3*        jsr     wskcl        bra     nbop4*************************************************************** X=nbdata, Y=NWP0, U=xxxx* init socket data, check local device active**************************************************************nbskin  pshs    x,y,u        jsr     wzsock          allocate a wzsock        bne     nbske1* U=wzsock        ldx     0,s             nbdata        stu     nbsock,x        set wzsock        clra*02      puls    x,y,u,pc*nbske1  ldd     #0        ldx     0,s             nbdata        std     nbsock,x        lda     #$ff        bra     02b*************************************************************** X=nbdata, Y=NWP0, U=wzsock* open socket**************************************************************nbskop  pshs    x,y,u        ldu     nbsock,x        ldd     #AF_INET        std     wzfaml,u        ldd     #SK_STRM|SK_SPONCL      signal @ disconnect        std     wztype,u        ldd     #0        std     wzprot,u        jsr     wskop           open the socket        puls    x,y,u,pc        pass error in D*************************************************************** X=nbdata, Y=NWP0, U=wzsock* open socket**************************************************************nbskcn  pshs    x,y,u        ldu     nbsock,x        ldd     nbipad,x        transfer network settings        std     wzipad,u        ldd     nbipad+2,x        std     wzipad+2,u        ldd     nbport,x        std     wzdprt,u        ordx    nbipad+2,IX      X via macro!        ordx    nbipad,IX       check        beq     nbcne1           not set* try connect, bail out when peer is absent        jsr     wskcn           peer should be there01      puls    x,y,u,pc        pass error via Dnbcne1  ldd     #-1        bra     01b**************************************************************** X = ptr to block device struct* Y = buf header* devices run from 0 up to max***************************************************************nbio    stx     NBtbl         save Block Device Table address        inc     nblkdt+dtbusy    mark busy*        ldx     #nbdata        ldb     bfdvn+1,y       device minor        cmpb    #MXNBDV        bhs     02f        lda     #NBPSIZ        mul        leax    d,x             point to right data set*        sty     nbbufh,x        save bufhdr        ldu     nbsock,x        get wzsock        bne     01f** error return*02      ldb     #EBARG          wzsock missing!!        bra     07f* closed connection16      ldb     #ENOFL        bra     06f** clean up stack first*32      puls    x,y,u*06      pshs    b        ldy     #NWP0        jsr     FIFO_unlock        puls    b07      lbra    nbdone          return** tests passed (almost)*01      ldb     wzstat,u        cmpb    #WSESTB         established        bne     16b** X=nbdata, Y=bufhdr, U=wzsock* nbdata holds a number of items*04      pshs    x,y,u           X=nbdata,Y=bufhdr,U=wzsock*        clr     wzflg,u         init flag        tfr     y,x        jsr     mapxpt* X=XBUFFER+OFFSET        ldd     bfxfc,y         safety check        std     wzswap,u        save it        cmpd    #MAXPAGES        bhi     24f        inc     wzflg,u         set swap        ldd     #0              clear upfront        std     wzswap,u        lda     bfadr,y        jsr     mapxbf          map XBUFFER in        ldx     #XBUFFR* X=XBUFFER + 024      cmpd    #BUFSIZ        bls     05f             allow 128,256,512** multi session loop*swplop  ldd     #BUFSIZ* we can skip a couple of tests as it is al system05      std     wzrqln,u        trfr    D,W             set xfer*        ldu     #NWP0        ldu     fio_dba,u       fifo base address        ldd     bfblck,y        std     fifo_us3,u        lda     bfflag,y        write command        ldb     bfblch,y        std     fifo_us2,u      and 'disk' address        ldu     4,s             restore wzsock* X=XBUFFER+OFFSET, U=wzsock, Y=NWP0, A=bfflag*        ldy     #NWP0           for fifo access        bita    #BFRWF          1 = read        beq     nbwrt** X=nbdata Y=NWP0, U=wzsock, READ function*        ldb     #S_RQRBLK       tell GPP I want to data        jsr     fio_msg         then it should tell the peer        cmpb    #R_RQRBLK        lbne    32b             to arrive, on return it has arrived*        jsr     get_F_S         allocate fifo        ldb     #S_RDRBLK       tell we are ready for it        jsr     fio_msg        cmpb    #R_RDRBLK        lbne    32b** X=XBUFFER+OFFSET ,Y=NWP0, W=count, U=wzsock*        ldy     fio_dba,y        leay    fifo,y        tfm1    Y,X             fifo > buffer (XBUFFER)        ldy     #NWP0        jsr     FIFO_unlock        puls    x,y,u           restore regs        ldb     wzflg,u        beq     nbdone          swap busy** swap update*nbupdp  pshs    x,y,u        ldd     bfblck,y        bump block #        incd        std     bfblck,y        ldx     #BUFSIZ        ldd     wzswap,u        addr    X,D             X +D > D        std     wzswap,u        cmpd    #PAGSIZ        beq     47f        ldx     #XBUFFR        addr    D,X             D+X >X        bra     swplop47      puls    x,y,u        ldd     #0        bra     nbdone** X=nbdata Y=NWP0, U=wzsock, WRITE function*nbwrt   ldb     #S_RQSBLK       tell GPP I want to send data        jsr     fio_msg         on return it ready to get it        cmpb    #R_RQSBLK       response        lbne    32b        jsr     get_F_S         allocate fifo** X=XBUFFER+OFFSET, Y=NWP0, W=count, U=wzsock, D=count*        ldy     fio_dba,y       Y= fifo (memory address)        leay    fifo,y        tfm1    X,Y             buffer > fifo (XBUFFER)        ldy     #NWP0*        ldu     4,s             restore wzsock        ldb     #S_SNDBLK       tell GPP data is in fifo        jsr     fio_msg        cmpb    #R_SNDBLK        lbne    32b        jsr     FIFO_unlock        puls    x,y,u        ldb     wzflg,u        bne     nbupdp** done, update the caller bufhdr for error return* no interrupts are to be handled in this code*nbdone  ldy     nblkdt+dtqfl    get last transaction        stb     uerror        beq     01f        lda     bfflag,y        ora     #BFERR        sta     bfflag,y*01      clr     nblkdt+dtbusy    set unbusy        clr     nblkdt+dtrtry    clear funtion        ldx     NBtbl        jmp     BDioend        pag* nb-control,  a character interface driver**  character open*  open the /dev/nbctl with minor 0*  A/B = device , Y = FND ptr, single (exclusive) open*nbcopen  equ     *        ldx     #nbdata        cmpb    #MXNBDV        bhs     21f        lda     #NBPSIZ        mul        leax    d,x             point to right data set*        lda     nbflgs,x         and nb-control is to be        bita    #NB_OPEN        if open we should not do anything        bne     02f        bita    #NC_OPEN        exclusively open for each        bne     02f             /dev/nbx instance*nbcop10 ora     #NC_OPEN        mark open state        sta     nbflgs,x        bra     05f*21      lda     #EBDEV        bra     03f*02      lda     #EBSY           tel caller to wait03      sta     uerror05      rts** character close**nbcclos  ldx    #nbdata        cmpb    #MXNBDV        bhs     21b        lda     #NBPSIZ        mul        leax    d,x             point to right data set*        lda     nbflgs,x          the right details        anda    #255-NC_OPEN     erase open state        sta     nbflgs,x        rts** nbcrd, character read*nbcrd   equ     *        pshs    d       save device info        ldy     #nbchbf private buffer        jsr     blkgtb  get device buffer        puls    d        jsr     nbchcn  configure buffer        tst     uerror  OK?        beq     nbchr4*nbche1  pshs    y        ldy     #nbchbf        jsr     blkfrb  release buffer        puls    y,pc*nbchr4  pshs    a        orb     #BFRWF  set read        stb     bfflag,y        bra     nbchio** nbcwr, character write*nbcwr   equ     *        pshs    d       save device info        ldy     #nbchbf        jsr     blkgtb        puls    d        jsr     nbchcn  configure        tst     uerror  OK        bne     nbche1*        pshs    anbchio  ldb     #NBmajor        jmp     blkcio*nbchcn  std     bfdvn,y        ldd     uicnt        std     bfxfc,y        cmpd    #BUFSIZ        beq     nbch5*        lda     #EBARG        sta     uerror        rts*nbch5   jmp     blkcnf** D=major minor, X=data area*nbcspcl pshs    d,x,y,u* is sock allocated?        tfr     x,y        cmpb    #MXNBDV        bhs     21f        ldx     #nbdata        lda     #NBPSIZ        mul        leax    d,x             point to right data set* don't change when in use        ldu     nbsock,x        bne     12f             in use*        tfr     x,u*        cmpy    #0              get/set indicator        bne     01f******************************************************* set (usarg0,usarg1,usarg2)* read user space via pointer* usarg0 =* usarg1 = pointer to sock_addr* usarg2 =* U=wzsock********************************************************        ldx     usarg1          memory pointer        cmpx    #MXUMEM         check bounds        bhs     11f*        jsr     gtuwrd          get data from [X] !!        cmpd    #AF_INET        bne     11f        leax    2,x             same sockaddr_in struct        jsr     gtuwrd        std     nbipad,u        as in other code        leax    2,x        jsr     gtuwrd        std     nbipad+2,u        leax    2,x        jsr     gtuwrd        std     nbport,u*        bra     10f******************************************************* get (0,y 1,y 2,y 3,y 4,y 5,y)* write data via pointer into user space* 0,x =* 2,x = pointer to sock_addr* 4,x =* U= wzsock*******************************************************01        ldx     2,y        cmpx    #MXUMEM         check valid memory location        bhs     11f*        ldd     nbipad,u        std     0,y             put data to user        ldd     nbipad+2,u        std     2,y        ldd     nbport,u        std     4,y*        bra     10f*12      lda     #EBSY        bra     14f*21      lda     #EBDEV        bra     14f*11      lda     #EBARG         error return14      sta     uerror*10      puls    d,x,y,u,pc        endif        end