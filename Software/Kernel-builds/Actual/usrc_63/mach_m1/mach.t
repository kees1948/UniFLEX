 lib environment.h lib ../include/macdefs.h lib ../include/inttab.h lib ../include/sysdefs.h lib ../include/fio.h lib ../include/fio_ctrl.h lib ../include/iop_dev.h lib ./ramdrvr.h        data        sttl   Machine Dependent Routines pag        name   mach        global clkinz,mchint,endinit        fcc     "should be before $B000 !!"*************************************************************** all these routines are run ONE time* when the boot process is about to complete* the purpose is to setup all hardware******************************************************************************************************************************* clkinz, run from Init, when kernel is about to start** Initialize system clock.***************************************************************clkinz  ldb    #0      clear out lbolt counter        stb    lbolt        lda    stup    set auto update counter        sta    tmtuct        lda    #1      select timer 1        sta    timdata        clra           reset the clock        sta    timdata        lda    #$05        sta    timctrl        rts            return        pag**************************************************************** mchint, run from Init very early just after console has been setup** Initialize all hardware junk and try to find* the existing acias.  The ones that aren't there* need to have their mask bits cleared.***************************************************************mchint       clr    strm     # terminals calculated here!       lda    cputyp    get cpu info from UniBUG       bita   #%01000000 is it 50 HZ?       beq    mchin1       sta    sphz     set 50 HZ flagmchin1       ldx    #inttab    point to int table       ldb    ,x+        pick up number of devices       pshs   b* loopmchin3       ldd    indev,x    check device # for TTYxx  maj/min       cmpd   #$0100       bhs    0f         skip if not TTYxx*       inc    strm*0      lda    intype,x   get interrupt device type       cmpa   #0         ACIA?       bne    mchin4     no** Initialize ACIA ports*       ldu    instat,x   get ACIA address       clr    2,u        baudrate latch       lda    #$43       set up reset code       sta    0,u        reset acia       pshs   d          delay       puls   d       lda    0,u        check response       beq    0f*       anda   #%11110011       beq    0f*       clr    inmask,x   zero int mask*0      cmpu   scon       was this the system console       bne    1f         no - continue*       pshs   x          save registers       jsr    syscon     yes - go reinitialize console       puls   x          restore registers*1      lbra   mchin10    continue initialization** Initialize PIA ports*mchin4 cmpa   #1         PIA?       bne    mchin5     no*       clr    inmask,x    zero int mask0      lbra   mchin10     continue initializationmchin5** Initialize 8274 port*       cmpa   #5          8274 port?       bne    mchin6      no*mchin6** Initialize NEC port*        cmpa     #3        NEC special        bne      mchin7mchin7****mchin10 leax     INTSIZ,x  bump to next entry        dec      0,s       end?        lbne     mchin3        puls     b         reset stack* done initializing IO hardware in kernel space** before kernel starts to setup tables for ttys* modify strm so that the total incl IOP is adjusted* later this is undone for the normal setup*        if      (IOP=1)        lda     #IOPTDMIN        sta     strm4iop*        pshs    x,y        ldy     #IOP0         base parms        ldu     fio_dba,y     offset to application data        ldx     fifo_us0,u        addr    U,X           U + X > X        adda    NUM_TRM,x        puls    x,y*        sta     strm       create right number of tables        endif** attempt to remove any possible IRQ from present boards* this should reset all th INT's from DualPortRam devices*        lda     $E3FE      remove interrupts        lda     $E7FE      from GPP type devices        lda     $EBFE        lda     $EFFE      if present*        lda     $F2FE      same for IOP        lda     $F3FE*** if the system has the CPU09VID board, it should be setup here*        if      (VID=1)        lib     ../include/video.h        data** initialise the video hardware*        ldu     #piadra        lda     #$ff       set output        sta     0,u        anda    #$03        sta     2,u        lda     #$04        sta     1,u        sta     3,u       pia now set        ldx     #vidtab   configuration constants        clrb41      stb     4,u       HD63b45 address register        lda     0,x+        sta     5,u       HD63b45 data register        incb        cmpb    #17       all done        bne     41b*        endif** if the RAMDISK driver is included, check for the hardware* and if found, set it up*        if      (RAMDSK=1)** init RAM DISK if present*        clrd        ldx     #rambuf access to ramdisk        ldy     #$99aa  test pattern*02      stb     ramblo        sta     rambhi        ldu     $55,x   save contents        sty     $55,x        exg     x,y        exg     x,y        cmpy    $55,x        bne     01f    (end of) ram?        stu     $55,x   restore contents        addd    #1        cmpd    #MXRAMD        blo     02b*01      std     mxramd         set actual size        std     ramd00+ramsiz  tel user        endif** if netboot is used*        if      (NETBLCK=1)        lib     ./netblock.h        ldx     #NWP0BASE        ldd     nbbipad,x         area where network details        beq     01f             should be (if used)        ldd     nbbipad+2,x        beq     01f        ldu     #nbdata         transfer settings into driver        ldd     nbbipad,x       so that it can be opened        std     nbipad,u        right away        ldd     nbbipad+2,x        std     nbipad+2,u        ldd     nbbport,x        std     nbport,u01        endif***************************************************************** done with first part of hardware initialization****************************************************************        rts        if      (VID=1)**  video controller setup*vidtab  fcb     $69,64,$53,8,$7d,16,118,118,16,3,0,0,0,0,0,0,0,0        endif       pag***************************************************************** here the final stage of initialization is reached********************************************************************************************************************************* end of machine initialisation* init has build all the kernel tables* add here code for specific hardware that should be setup* 'just' before the kernel is fired up****************************************************************endinit tst $f000  reset interrupts     console*** undo the strm change we did above*       if       (IOP=1)       lda      strm4iop       ldb      strm       sta      strm       stb      strm4iop  save value        endif** in case we use a 'debug' acia, which falls outside* the regular tty devices*   if     (DBG=1)    jsr debugini   endif** last duties before the kernel starts*        ldd     timdata        std     rndval          try to 'seed' the random numbers* arm the memory traps        pshs    cc        orcc    #$50        lda     #$05        sta     trpctrl          enable mem trap        sta     timctrl          start timer        lda     trpdata          remove relic        puls  cc,pc              DONE!