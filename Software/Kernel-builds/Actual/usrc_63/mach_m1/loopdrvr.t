        opt     nol        lib     ../include/blktab.h        lib     ./gendrvr.h        lib     ./loopdrvr.h*        lib     tellme.t    DEBUG        opt     lis,exp        if      (LOOP=1)        sttl     loop Driver        pag        name    loopdrvr        global  loopopn,loopcls,loopio        global  lpcopen,lpcclos,lpcspclREPORT  set     0**************************************************************** loop driver, allow a file to be accessed as a block device* experimental addition** the way it works:* the loopdevice consists of 2 parts:* the block driver and the loop-control device** losetup /dev/loop0 name_of_imagefile** losetup fetches the file status of imagefile and passes* the device and fdn of it via ttyset/ttyget calls to the* loopdevice blockdriver** after opening of the right blockdriver where an imagefile* has been attached to, the code assigns an in-core fdn for the* imagefile, from the offset of the caller the absolute block#* of the imagefile is found. This block is read in and copied over* to the buffer of the caller. For writes, an free buffer is* allocated, to contents from the caller are copied over to this* buffer and the buffer is wriiten to the imagefile at the* absolute block that is determined by te offset from the caller***************************************************************LOOPtbl fdb     0               Block Device Table address** to avoid complicated includes we define part of fdn.h here!!*ffwdl  equ      0      should be adapted when fdn.h changes!fstat  equ      2fdevic equ      3fnumbr equ      5frefct equ      7fmode  equ      8facces equ      9fdirlc equ      10fouid  equ      11fsize   equ     13*lpcfunc rzb     2       preset function for  ttygetlpcfdev rzb     2       preset device   for  ttyget* Block driver part, no equivalent device driver**************************************************************** open the loop disk drive* B contains device minor* here the devices run from 0 up to max***************************************************************loopopn pshs    d        ldx     #loopopt        incb        cmpb    #LPMAX          LPMAX-1        bhs     loopop2         illegal        decb                    undo for test        lda     #LOPSIZ        mul        leax    d,x*        lda     lpflg,x         check status        bita    #LS_BOPN        bne     loopop3         is already open*        bita    #LS_LNKD        beq     loopop2         no secundary file*        ora     #LS_BOPN        set open        sta     lpflg,x        bra     loopop3*loopop2  lda    #EBARG          no image file set         sta    uerrorloopop3  puls    d,pc            retuen**************************************************************** loop close***************************************************************loopcls        ldx     #loopopt        incb        cmpb    #LPMAX          LPMAX-1        bhs     loopcl1         illegal        decb                    undo for test        lda     #LOPSIZ        mul        leax    d,x*        lda     lpflg,x        clear open status        anda    #255-LS_BOPN        sta     lpflg,xloopcl1  rts                     return**************************************************************** X = ptr to block device struct* Y = buf header* devices run from 0 up to max***************************************************************loopio  stx     LOOPtbl         save Block Device Table address        inc     loopdt+dtbusy    mark busy*        ldb     bfdvn+1,y        device minor        ldu     #loopopt        lda     #LOPSIZ        mul        leau    d,u             U points to local loop variables        pshs    u               save reference** U points to local parameter area* [Y] bufhdr contains the block address and size of data*        sty     lpbfhi,u        save incoming buff header ptr*        lda     bfflag,y        check what we will do        anda    #BFRWF          1 = read        eora    #BFRWF          0 = read        sta     umaprw          for bmap*        ldd     bfxfc,y         safety check        cmpd    #BUFSIZ        lbne    loopbarg** allocate a inode in-core for the image file*        ldd     lpdev,u         set by losetup, our imagefile        ldy     lpfdn,u         same        jsr     asnfdn          allocate an fdn for this        ldu     0,s             restore U        stx     lpfnod,u        save this fdn pointer too        lbeq    loopba1         none available, bail out        jsr     unlfdn          unlock it** now we have realtime data of our image file* we check the block number againt the size of the* image file*        ldy     lpbfhi,u        input parms from caller        ldx     lpfnod,u        in core fdn        clr     0,-s            lowest byte        ldd     bfblck,y        bit 23...8        pshs    d        ldb     bfblch,y        highest        pshs    b* in stack now BH, BM, BL, 00        bmi     10f             too high  >7FFFFFFF        asl     2,s             shift left whole 24 bit        rol     1,s        rol     0,s             blocks into offset* check access byond size of imagefile        ldd     0,s        cmpd    fsize,x         either end of file reached        bne     11f        ldd     2,s        cmpd    fsize+2,x       or unmatching read-ahead        blo     11f*10      leas    4,s             tell user he went too far        lda     #EDFUL        sta     uerror        bra     loopdon         not for this one*11      leas    4,s             drop aux regs** map input block into file block on device*        ldd     lpfnod,u        allocated fdn        pshs    d               will be in 'U'        ldx     lpbfhi,u        input data        clra        ldb     bfblch,x        to Y from input        pshs    d               will be in 'Y'        ldd     bfblck,x        to X from input        pshs    d               will be in 'X'        puls    x,y,u        jsr     mapfil          translate relative block# in absolute** on return x,y contain the ACTUAL block number on the virtual device*        beq     loopba1         not available        ldu     0,s             renew U** now we have the absolute block# in Y.X of image device        ldd     lpdev,u         get device* for write we need to copy buffers first        tst     umaprw        beq     03f** write, D=device, Y.X=block allocate new buffer*        jsr     alocbf          get buffer for this device/block#        ldu     0,s        sty     lpbfho,u        to, save local buffer header*        ldx     lpbfhi,u        from,        exg     x,y        jsr     cpybuf          copy contents of buffer over        ldu     0,s        ldy     lpbfho,u        write buffer to imagefile        jsr     wrbuf        bra     doend           done** read D=device, Y.X=block*03      jsr     rdbuf           into buffer now pointed by Y        lda     bfflag,y        bita    #BFERR        lbne    loopba1*        ldu     0,s        sty     lpbfho,u        from, save local buffer header        ldx     lpbfhi,u        to        jsr     cpybuf          copy contents of buffer        ldu     0,s        ldx     lpbfho,u        jsr     freebf          free the buffer*doend   ldu     0,s        ldx     lpfnod,u        free the (temorary) in-core fdn        jsr     frefdn        clra                    set status** done, update the caller bufhdr for error return*loopdon leas    2,s             drop U from stack        ldy     loopdt+dtqfl    get last transaction        tsta        beq     01f        lda     bfflag,y        ora     #BFERR        sta     bfflag,y01      clr     loopdt+dtbusy    set unbusy        clr     loopdt+dtrtry    clear funtion        ldx     LOOPtbl        jmp     BDioend* we has (some) error and aborted the processloopba1 ldu     0,s              renew U        ldx     lpfnod,u         undo fdn        jsr     frefdnloopbarg lda    #EBARG        sta     uerror        bra     loopdon        pag* loop-control,  a character interface driver**  character open*  open the /dev/loopctl with minor 0*  A/B = device , Y = FND ptr, single (exclusive) open* use loopopt[0] for character device open check*lpcopen  equ     *        ldx     #loopopt        tstb                    ony ONE driver as char driver        bne     01f*        lda     lpflg,x         and loop-control is to be        bita    #LS_COPN        exclusively open for each        bne     02f             /dev/loopx instance*lpcop10 ora     #LS_COPN        mark open state        sta     lpflg,x        bra     05f*02      lda     #EBSY           tel caller to wait        bra     03f*01      lda     #EBARG          something went wrong                [03      sta     uerror05      rts** character close**lpcclos  ldx    #loopopt        tstb        bne     02b              only ONE loop-control exists*        lda     lpflg,x          the right details        anda    #255-LS_COPN     erase open state        sta     lpflg,x        rts** as there is no read or write function available, all the* hard work is done in the ttyget/ttyset part (special)** lopspcl, A,B should be 0, X=ptr. if 0 then set* from usarg0,usarg1,usarg2, else* get to 0,X, 2,X, 4,X (or Y)* this is where the magic is to happen* usarg0 = A=cmd, B= minor to operate on* usarg1 = device for loopfile* usarg2 = fdn for loopfile*lpcspcl pshs    d,x,y,u*        tfr     x,y        cmpy    #0              get/set indicator        bne     01f******************************************************* set (usarg0,usarg1,usarg2)******************************************************        ldd     usarg0          A=cmd, B=minor        incb        cmpb    #LPMAX          LPMAX-1        bhs     11f             check validity        decb                    undo offset        stb     lpcfdev         set device*        ldx     #lsfunc        'set' cmd list        bra     02f******************************************************** get (0,y 1,y 2,y 3,y 4,y 5,y)*******************************************************01      lda     lpcfunc         did a 'set' before        ldx     #lgfunc         'get' cmd list* comman part for table walk-up02      tst     0,x             scan get command table        beq     11f        cmpa    0,x             match command        beq     03f        leax    LPCSIZ,x        bra     02b*03      jsr     [1,x]          do func        bra     10f*11      lda     #EBARG         error return        sta     uerror*10      puls    d,x,y,u,pc**************************************************************************************************************lpcscmd equ     *** commands valid for 'set'*lsfunc  fcb     LC_ATCH         attach loopfile        fdb     attachLPCSIZ  equ     *-lsfunc        fcb     LC_DETC         detach loopfile        fdb     detach        fcb     LC_SETG         set command for 'get'        fdb     setgetf        fcb     0      end of list* commands valid for 'get'lgfunc  fcb     LC_STAT        fdb     rptstat        not mounted        fcb     LC_ISFR        fdb     rptstat        fcb     0              end of list** we can't select 'WHAT' to get with ttyget* so we say with ttyset what the next 'get' will return*setgetf ldb     usarg0+1      cmd + device        stb     lpcfdev        lda     usarg1        next cmd        sta     lpcfunc        rts** select proper dataset, return into 'U'*getdev  ldb     lpcfdev        lda     #LOPSIZ        mul        ldu     #loopopt        leau    d,u        rts* is loopdevice 'busy' i.e. opened?** return status for the loop device*rptstat bsr     getdev*        ldd     lpdev,u         file major/minor        std     2,y        ldd     lpfdn,u         file fdn        std     4,y        lda     0,u             flags        sta     0,y        ldb     lpcfdev         loop minor        stb     1,y        rts***************************************************************** 'attach' image file****************************************************************attach  pshs    x,y,u        bsr     getdev          right dataset*        lda     0,u             check        bita    #LS_LNKD        already attached        bne     01f*        ora     #LS_LNKD        set attched now        sta     0,u*        ldd     usarg1          'image' Device        std     lpdev,u        ldy     usarg2          'image' FDN        sty     lpfdn,u         make file busy        puls    x,y,u,pc*01      lda     #EBSY           some errors03      sta     uerror        puls    x,y,u,pc02      lda     #EBARG        bra     03b***************************************************************** 'detach' image file****************************************************************detach  pshs    x,y,u        bsr     getdev         right dataset*        lda     0,u        bita    #LS_BOPN       in use, as block device?        bne     02b             yes, don't detachdeter1  ldb     #LOPSIZ        remove all traces        tfr     u,x09      clr     0,x+        decb        bne     09b        puls    x,y,u,pc*        endif        end