* use wzdma2 internally for task id. save that* during transfers and restore after. this is for compatibility reasons                lib     ../mach_m1/sysconfig.h                if      (NET=1)                lib     ../include/macdefs.h                lib     ../include/params.h                lib     ../include/sysdefs.h                lib     ../include/wzsock.h                lib     ../include/fio.h                lib     ../include/fio_ctrl.h                lib     ../include/fio_nwp.h                lib     ../include/fio_codes.h                lib     ../include/nwp_codes.h                lib     ../include/sockerr.h                lib     ../include/task.h                data                global  wzsock,wskcl,wskcn,nw_int                global  wskrd,wskwr,wskop,wskbi,wskli,wskac                global  wskrecv,wsksnd                global  wzdebug,wzpollLF              equ     $aWZPRIO          equ     -5  wz socket prio***************************************************************** wzdrvr.t driver for w5500 module via CPU09GPP* at return U = wzsock address* kernel treats this register as (pseudo) inode pointer*wzsock          equ     *                pshs    d,x,y,u                ldy     #NWP0                ldu     fio_dba,y** find first free wzsock*                ldx     fifo_us0,u      first wzsock                addr    X,U             X + U -> U                clrb03              tst     wzfsta,u                beq     01f             is free                leau    WZSIZE,u                incb                cmpb    #MAX_WZ                blo     03b                bra     04f01              lda     wzfsta,u                ora     #WZBUSY                sta     wzfsta,u                stu     6,s             U = sock address* clear remainder of wzsock                leax    wzcmnd,u                leay    wzprot,u                pshs    y44              clr     0,x+                cmpx    0,s                bne     44b                leas    2,s             clear stack** found empty wzsock,  successful return B=0*wzokrt                ldd     #0              OK return                std     0,s                puls    d,x,y,u,pc** out of wzsock's*04              ldb     #EBSY           busy, come back later15              stb     uerror                stb     1,s                puls    d,x,y,u,pc***************************************************************** open the socket now* U = wzsock address setup by kernel    TCP and UDP*wskop           equ     *                pshs    d,x,y,u        ldx     utask        ldd     tstid,x        std     wzdma2,u                ldy     #NWP002              clra                ldb     #S_OPEN                jsr     fio_msg        wz fio handler                tstb                bmi     04f            abort waiting on error                cmpb    #R_OPEN        matching response?                bne     02b** common return socket functions*wzskrt          tstb                    normal response                bpl     wzokrt* error return04              jsr     sockerr                bra     cbexit         close on error***************************************************************** close the socket actively* U = sock address setup by kernel      TCP and UDP*wskcl           equ     *                pshs    d,x,y,u                ldy     #NWP0* internal closewskicl          clra                ldb     #S_CLOSE        this will erase all info                jsr     fio_msg         tell GPP                leax    0,u                jsr     unlfdn          tell OS to drop too*** clear wzsock busy, return non -zero*cbexit          lda     wzfsta,u                anda    #(255-WZBUSY)    unbusy                sta     wzfsta,u                tstb                bpl     wzokrt                stb     1,s             B = error                puls    d,x,y,u,pc***************************************************************** do CONNECT socket* U = wzsock address setup by kernel    TCP* wzsock already updated with connection info by kernel*wskcn           equ     *                pshs    d,x,y,u                ldy     #NWP002              clra                ldb     #S_CONNECT                jsr     fio_msg                cmpb    #R_CONNECT                beq     wzskrt                cmpb    #R_DISCON                bne     02b*                lda     #EBADF                sta     uerror                bra     cbexit***************************************************************** do BIND socket                        TCP and UDP* U = wzsock address setup by kernel*wskbi           equ     *                pshs    d,x,y,u                ldy     #NWP0                clra                ldb     #S_BIND                jsr     fio_msg                cmpb    #R_BIND                bne     01f                lbra    wzskrt*01              ldb     #S_CLOSE                jsr     fio_msg                lda     #EBADF                sta     uerror                lbra    cbexit***************************************************************** do LISTEN socket                      TCP* U = sock address setup by kernel*wskli           equ     *                pshs    d,x,y,u                ldy     #NWP0                clra                ldb     #S_LISTEN                jsr     fio_msg                cmpb    #R_LISTEN                bne     01f                lbra    wzskrt*01              cmpb    #R_CLOSE                lbeq    wskicl                lda     #EBADF                sta     uerror                lbra    cbexit***************************************************************** do ACCEPT socket                      TCP* U = wzsock address setup by kernel*wskac           equ     *                pshs    d,x,y,u                ldy     #NWP0                clra                ldb     #S_ACCEPT                jsr     fio_msg                cmpb    #R_ACCEPT                bne     01f                lbra    wzskrt*01              cmpb    #R_CLOSE                lbeq    wskicl                lda     #EBADF                sta     uerror                lbra    cbexit***************************************************************** wzpoll, poll socket for read data* U = wzsock address****************************************************************wzpoll          equ     *                pshs    x,y,u                ldy     #NWP0                clra                ldb     #S_POLLRD                jsr     fio_msg                cmpb    #R_POLLRD                bne     01f                ldd     #1                puls    x,y,u,pc*01              cmpb    #R_CLOSE                beq     02f                lda     #EBADF                sta     uerror02              clrd                puls    x,y,u,pc***************************************************************** wskrd, read data from socket, straight into process memory* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* U = wzsock address, setup by kernel   TCP* uicnt holds total of transfer*wskrd           equ     *                pshs    d,x,y,u                ldy     #NWP0           fio hardware parameters*                ldd     uicnt           not for zero bytes                beq     wzokex                cmpd    fio_fsz,y                blo     01f                ldd     fio_fsz,y01              std     wzrqln,u        set maximum for xfer** start waiting for data*                ldb     #S_RQRD         tell GPP                jsr     fio_msg                tstb                lbmi    17f             error                cmpb    #R_RQRDNB                beq     wzokex          non block return*                cmpb    #R_CLOSE        is socket closed?                bne     16f                bra     wzokex*16              jsr     get_F_S         allocate slot + fifo** tell GPP I am ready collect the data and fill the fifo*                ldb     #S_READ                jsr     fio_msg         data to fifo                tstb                bmi     17f** data in fifo,* check page boundary crossing during transfer*                ldd     wzxfer,u        actual count51              ldx     wzdma2,u        task ID                pshs    x                jsr     wzckpb          wzrqln, wzdma1, wzdma2** move data now*                jsr     wzff2mem        pseudo DMA                puls    x                stx     wzdma2,u*20              jsr     FIFO_unlock    free the fifo for GPP** common exit, setup remaining uicnt*wzrwex          ldd     uicnt         updated processed count                subd    wzxfer,u                std     uicnt*wzokex          ldy     utask                clr     tsact,y         lowest activity99              puls    d,x,y,u,pc** some socket error*17              ldb     #SESKINI        device not active                jsr     sockerr                jsr     FIFO_unlock                bra     99b**************************************************************** wskrecv,*** U = wzsock address    UDP!!!*wskrecv         pshs    d,x,y,u                ldy     #NWP0           fio hardware parameters*                ldd     uicnt           not for zero data                beq     wzokex                cmpd    fio_fsz,y                blo     01f                ldd     fio_fsz,y01              std     wzrqln,u        set maximum for xfer** start waiting for data*                ldb     #S_RRDFRM       tell GPP                jsr     fio_msg                tstb                lbmi    17b             error*                cmpb    #R_RQRDNB                beq     wzokex          non block return*                cmpb    #R_CLOSE        is socket closed?                bne     16f                bra     wzrwex*16              jsr     get_F_S         allocate slot + fifo** tell GPP I am ready collec the data and fill the fifo*                ldb     #S_RREAD                jsr     fio_msg         data to fifo                tstb                bmi     17b** check page boundary crossing during transfer*                ldd     wzxfer,u        actual count            ldx     wzdma2,u            pshs    x                jsr     wzckpb          wzrqln, wzdma1, wzdma2** move data now*                jsr     wzff2mem        pseudo DMA        puls    x        stx     wzdma2,u*                jsr     FIFO_unlock    free the fifo for GPP*                ldd     uistrt          update memory address                addd    wzxfer,u                std     uistrt                ldd     uicnt           update transferred                subd    wzxfer,u                std     uicnt*77              bra     wzokex          normal exit**************************************************************** wskwr, write data from process memory, straight into fifo buffer* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* W=count, D=mem addr, Y=NWP0, U=wzsock TCP** U = sock addresswskwr           equ     *                pshs    d,x,y,u                ldy     #NWP0** check page boundary crossing in transfer*                ldd     uicnt                beq     10f                cmpd    fio_fsz,y                blo     01f                ldd     fio_fsz,y01              std     wzrqln,u        set maximum for xfer** all checked, good to go*                ldb     #S_RQWR         tell NWP we have data                jsr     fio_msg                tstb                bmi     80f             socket error*                cmpb    #R_RQWRNB                lbeq     wzokex          non block return*                cmpb    #R_CLOSE                bne     16f             for now*10              lbra    wzokex*16              jsr     get_F_S         allocate FIFO + transaction slot** move data now*                ldd     wzrqln,u        ldx     wzdma2,u        pshs    x                jsr     wzckpb                jsr     wzmem2ff        data from user mem to fifo        puls    x        stx     wzdma2,u** fifo filled, now send it*25              ldb     #S_WRITE                jsr     fio_msg         transfer                cmpb    #E_SYSBSY                beq     25b** transfer completed*                jsr     FIFO_unlock*                lbra    wzrwex          + restore regs** error ?*80              lda     #ESOCK                sta     uerror                jsr     FIFO_unlock                puls    d,x,y,u,pc**************************************************************** wsksnd, write data from process memory, straight into fifo buffer* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* W=count, D=mem addr, Y=NWP0, U=wzsock UDP** U = sock addresswsksnd           equ     *                pshs    d,x,y,u                ldy     #NWP0                ldd     #0                std     wzuwrp,u        initialize                ldd     uicnt                beq     10f                std     wzurms,u        how big is transfer** check page boundary crossing in transfer*55              cmpd    fio_fsz,y                blo     01f                ldd     fio_fsz,y01              std     wzrqln,u        set maximum for xfer** all checked, good to go*                ldb     #S_WRQSTO       tell NWP we have data82              jsr     fio_msg                tstb                bmi     80f             socket error*                cmpb    #R_RQWRNB                lbeq     wzokex          non block return*                cmpb    #R_CLOSE                bne     16f             for now*10              lbra    wzokex** repeat ext data*81              ldb     #S_WSNDTM                bra     82b*16              jsr     get_F_S         allocate FIFO + transaction slot** move data now*                ldd     wzrqln,u        ldx     wzdma2,u        pshs    x                jsr     wzckpb                jsr     wzmem2ff        data from user mem to fifo        puls    x        stx     wzdma2,u** fifo filled, now send it*25              ldb     #S_WSNDTO                jsr     fio_msg         transfer                cmpb    #E_SYSBSY                beq     25b*** transfer completed*20              jsr     FIFO_unlock                pshs    b                ldd     uistrt                addd    wzxfer,u                std     uistrt                ldd     uicnt                subd    wzxfer,u                std     uicnt* check if all data sits in socket                puls    b                cmpb    #R_SNDTOM        more data                beq     81b                ldd     wzurms,u           zero?                bne     55b*                lbra    wzokex             + restore regs** error ?*80              lda     #ESOCK                sta     uerror                jsr     FIFO_unlock                puls    d,x,y,u,pc***************************************************************** wzckpb, check page boundary crossing* set wzrqln, wzdma1 and wzdma2* X is actual xfer count* exit: C=set when data is 0, else C=clear*wzckpb          pshs    y,u                std     wzdma1,u        set initial value                clra                clrb                    one full transation                std     wzdma2,u** check if a 4K page boundary is to be crossed                ldd     uistrt          start address in process space                anda    #$0f            4K                addd    wzrqln,u        add the amount of data                bita    #$f0            4K page overflow?                beq     00f             no, will not cross* it does cross ! cut it in two                ldd     uistrt          first part                pshs    d                negd                anda    #$0f            remaining size in STARTING 4K page                std     wzdma1,u        first part                puls    d                addd    wzrqln,u        remaining size in NEXT 4K page                anda    #$01                std     wzdma2,u00              clc90              puls    y,u,pc88              sec                bra     90b***************************************************************** wzff2mem, move fifo data into user memory* X, Y=NWP0, U=wzsock*wzff2mem        pshs    d,x,y,u         save regs                ldd     wzdma1,u        U still wzsock                trfr    D,W                ldu     fio_dba,y      fifo hardware base address                leau    fifo,u         fifo actual address                ldd     uistrt         process memory address                jsr     mapua2x        D > D offset in XBUFFER                tfr     d,x            set pointer                tfm1    U,X            block move* old U had wzsock address                ldy     6,s             old U from stack                ldd     wzdma2,y        2nd part?                trfr    D,W                beq     01f             nothing to do* W= (second) count ,(X), wzsock                ldd     wzdma1,y        first size (done)                addd    uistrt         update memory address                jsr     mapua2x        D >D in XBUFFER                tfr     d,x            set pointer again                tfm1    U,X            block move01              puls    d,x,y,u,pc***************************************************************** wzmem2ff, move user memory data to fifo* X, Y=NWP0, U=wzsock*wzmem2ff        pshs    d,x,y,u         save regs                ldd     wzdma1,u        U still wzsock                trfr    D,W                ldu     fio_dba,y                leau    fifo,u          fifo address                ldd     uistrt          user memory address                jsr     mapua2x                tfr     d,x                tfm1    X,U* old U had wzsock address                ldy     6,s                ldd     wzdma2,y                trfr    D,W                beq     01f*                ldd     wzdma1,y        first size(done)                addd    uistrt                jsr     mapua2x                tfr     d,x                tfm1    X,U01              puls    d,x,y,u,pc***************************************************************** nw_int, send signal to socket task* X= taskID, B=signal, only when SOCK_SIGPIPECLS is set*nw_int          equ     *                pshs    d,x,y       save pointer                ldx     tsktab          find task                ldd     2,s02              cmpd    tstid,x                beq     01f                leax    TSKSIZ,x                cmpx    tskend          end of table                blo     02b                bra     09f01              ldb     1,s                clra                jsr     xmtint09              puls    d,x,y,pcwzdebug         pshs    d,x                ldx     #mydebug                jsr     sysmsg                puls    d,x,pcmydebug         fcb     $d,$a                fcc     "**debug**",$d,$a,0* if NET                else                data                nop* if ! NET                endif