** use wzdma2 internally for task id. save that* during transfers and restore after. this is for compatibility reasons                lib     ../mach_m1/sysconfig.h                if      (NET=1)                lib     ../include/macdefs.h                lib     ../include/params.h                lib     ../include/sysdefs.h                lib     ../include/wzsock.h                lib     ../include/fio.h                lib     ../include/fio_ctrl.h                lib     ../include/fio_nwp.h                lib     ../include/fio_codes.h                lib     ../include/nwp_codes.h                lib     ../include/sockerr.h                lib     ../include/task.h                data                global  wzsock,wskcl,wskcn,nw_int                global  wskrd,wskwr,wskop,wskbi,wskli,wskac                global  wskrecv,wsksnd                global  wzdebug,wzpollLF              equ     $aWZPRIO          equ     -5  wz socket prio***************************************************************** wzdrvr.t driver for w5500 module via CPU09GPP* at return U = wzsock address* kernel treats this register as (pseudo) inode pointer*wzsock          equ     *                pshs    d,x,y,u                ldy     #NWP0                ldu     fio_dba,y** find first free wzsock*                ldx     fifo_us0,u      first wzsock                addr    X,U             X + U -> U                clrb03              tst     wzfsta,u                beq     01f             is free                leau    WZSIZE,u                incb                cmpb    #MAX_WZ                blo     03b                bra     04f01              lda     wzfsta,u                ora     #WZBUSY                sta     wzfsta,u                stu     6,s             U = sock address* clear remainder of wzsock                leax    wzcmnd,u                leay    wzprot,u                pshs    y44              clr     0,x+                cmpx    0,s                bne     44b                leas    2,s             clear stack** found empty wzsock,  successful return B=0*wzokrt                ldd     #0              OK return                std     0,s                puls    d,x,y,u,pc** out of wzsock's*04              ldb     #EBSY           busy, come back later15              stb     uerror                stb     1,s                puls    d,x,y,u,pc***************************************************************** open the socket now* U = wzsock address setup by kernel    TCP and UDP*wskop           equ     *                pshs    d,x,y,u        ldx     utask                   save taskid in wzsock        ldd     tstid,x                 requires careful handling!!        std     wzdma2,u                ldy     #NWP002              clra                ldb     #S_OPEN                jsr     fio_msg        wz fio handler                tstb                bmi     04f            abort waiting on error                cmpb    #R_OPEN        matching response?                bne     02b** common return socket functions*wzskrt          tstb                    normal response                bpl     wzokrt* error return04              jsr     sockerr                bra     cbexit         close on error***************************************************************** close the socket actively* U = sock address setup by kernel      TCP and UDP*wskcl           equ     *                pshs    d,x,y,u                ldy     #NWP0* internal closewskicl          clra                ldb     #S_CLOSE        this will erase all info                jsr     fio_msg         tell GPP                leax    0,u                jsr     unlfdn          tell OS to drop too*** clear wzsock busy, return non -zero*cbexit          lda     wzfsta,u                anda    #(255-WZBUSY)    unbusy                sta     wzfsta,u                tstb                bpl     wzokrt                stb     1,s             B = error                puls    d,x,y,u,pc***************************************************************** do CONNECT socket* U = wzsock address setup by kernel    TCP* wzsock already updated with connection info by kernel*wskcn           equ     *                pshs    d,x,y,u                ldy     #NWP002              clra                ldb     #S_CONNECT                jsr     fio_msg                cmpb    #R_CONNECT                beq     wzskrt                cmpb    #R_DISCON                bne     02b*                lda     #EBADF                sta     uerror                bra     cbexit***************************************************************** do BIND socket                        TCP and UDP* U = wzsock address setup by kernel*wskbi           equ     *                pshs    d,x,y,u                ldy     #NWP0                clra                ldb     #S_BIND                jsr     fio_msg                cmpb    #R_BIND                bne     01f                lbra    wzskrt*01              ldb     #S_CLOSE                jsr     fio_msg                lda     #EBADF                sta     uerror                lbra    cbexit***************************************************************** do LISTEN socket                      TCP* U = sock address setup by kernel*wskli           equ     *                pshs    d,x,y,u                ldy     #NWP0                clra                ldb     #S_LISTEN                jsr     fio_msg                cmpb    #R_LISTEN                bne     01f                lbra    wzskrt*01              cmpb    #R_CLOSE                lbeq    wskicl                lda     #EBADF                sta     uerror                lbra    cbexit***************************************************************** do ACCEPT socket                      TCP* U = wzsock address setup by kernel*wskac           equ     *                pshs    d,x,y,u                ldy     #NWP0                clra                ldb     #S_ACCEPT                jsr     fio_msg                cmpb    #R_ACCEPT                bne     01f                lbra    wzskrt*01              cmpb    #R_CLOSE                lbeq    wskicl                lda     #EBADF                sta     uerror                lbra    cbexit***************************************************************** wzpoll, poll socket for read data* U = wzsock address****************************************************************wzpoll          equ     *                pshs    x,y,u                ldy     #NWP0                clra                ldb     #S_POLLRD                jsr     fio_msg                cmpb    #R_POLLRD                bne     01f                ldd     #1                puls    x,y,u,pc*01              cmpb    #R_CLOSE                beq     02f                lda     #EBADF                sta     uerror02              clrd                puls    x,y,u,pc***************************************************************** wskrd, read data from socket, straight into process memory* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* U = wzsock address, setup by kernel   TCP* uicnt holds total of transfer*wskrd           equ     *                pshs    d,x,y,u                ldy     #NWP0           fio hardware parameters*                ldd     uicnt           not for zero bytes                beq     wzokex                cmpd    fio_fsz,y                blo     01f                ldd     fio_fsz,y01              std     wzrqln,u        set maximum for xfer** start waiting for data*                ldb     #S_RQRD         tell GPP                jsr     fio_msg                tstb                lbmi    17f             error                cmpb    #R_RQRDNB                beq     wzokex          non block return*                cmpb    #R_RQRD                beq     16f*                cmpb    #R_CLOSE        is socket closed?                beq     wzokex                lbra    17f             some sort of error*16              jsr     get_F_S         allocate slot + fifo** tell GPP I am ready collect the data and fill the fifo*                ldb     #S_READ                jsr     fio_msg         data to fifo                tstb                bmi     17f** data in fifo,* check page boundary crossing during transfer* save original contents (TASKID) in wzdma2 and only* AFTER wzffmem has been executed, put it back*                ldd     wzxfer,u        actual count51              ldx     wzdma2,u        task ID****                pshs    x                jsr     wzckpb          wzrqln, wzdma1, wzdma2                jsr     wzff2mem        pseudo DMA                puls    x****                stx     wzdma2,u*20              jsr     FIFO_unlock    free the fifo for GPP** common exit, setup remaining uicnt*wzrwex          ldd     uicnt         updated processed count                subd    wzxfer,u                std     uicnt*wzokex          ldy     utask                clr     tsact,y         lowest activity99              puls    d,x,y,u,pc** some socket error*17              ldb     #SESKINI        device not active                jsr     sockerr                jsr     FIFO_unlock                bra     99b**************************************************************** wskrecv,*** U = wzsock address    UDP!!!*wskrecv         pshs    d,x,y,u                ldy     #NWP0           fio hardware parameters*                ldd     uicnt           not for zero data                beq     wzokex                cmpd    fio_fsz,y                blo     01f                ldd     fio_fsz,y01              std     wzrqln,u        set maximum for xfer** start waiting for data*                ldb     #S_RRDFRM       tell GPP                jsr     fio_msg                tstb                lbmi    17b             error*                cmpb    #R_RQRDNB                beq     wzokex          non block return*                cmpb    #R_CLOSE        is socket closed?                bne     16f                bra     wzrwex*16              jsr     get_F_S         allocate slot + fifo** tell GPP I am ready collec the data and fill the fifo*                ldb     #S_RREAD                jsr     fio_msg         data to fifo                tstb                bmi     17b** check page boundary crossing during transfer*                ldd     wzxfer,u        actual count            ldx     wzdma2,u****            pshs    x                jsr     wzckpb          wzrqln, wzdma1, wzdma2                jsr     wzff2mem        pseudo DMA        puls    x****        stx     wzdma2,u*                jsr     FIFO_unlock    free the fifo for GPP*                ldd     uistrt          update memory address                addd    wzxfer,u                std     uistrt                ldd     uicnt           update transferred                subd    wzxfer,u                std     uicnt*77              bra     wzokex          normal exit**************************************************************** wskwr, write data from process memory, straight into fifo buffer* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* W=count, D=mem addr, Y=NWP0, U=wzsock TCP** U = sock addresswskwr           equ     *                pshs    d,x,y,u                ldy     #NWP0** check page boundary crossing in transfer*                ldd     uicnt                beq     10f                cmpd    fio_fsz,y                blo     01f                ldd     fio_fsz,y01              std     wzrqln,u        set maximum for xfer** all checked, good to go*                ldb     #S_RQWR         tell NWP we have data                jsr     fio_msg                tstb                bmi     80f             socket error*                cmpb    #R_RQWRNB                lbeq     wzokex          non block return*                cmpb    #R_CLOSE                bne     16f             for now*10              lbra    wzokex*16              jsr     get_F_S         allocate FIFO + transaction slot** move data now*                ldd     wzrqln,u        ldx     wzdma2,u****        pshs    x                jsr     wzckpb                jsr     wzmem2ff        data from user mem to fifo        puls    x****        stx     wzdma2,u** fifo filled, now send it*25              ldb     #S_WRITE                jsr     fio_msg         transfer                cmpb    #E_SYSBSY                beq     25b** transfer completed*                jsr     FIFO_unlock*                lbra    wzrwex          + restore regs** error ?*80              lda     #ESOCK                sta     uerror                jsr     FIFO_unlock                puls    d,x,y,u,pc**************************************************************** wsksnd, write data from process memory, straight into fifo buffer* use the block move capabilities of the 63X09* special care must be taken when transfer crosses 4K memory* page boudaries! then transfer is split in two parts* W=count, D=mem addr, Y=NWP0, U=wzsock UDP** U = sock addresswsksnd           equ     *                pshs    d,x,y,u                ldy     #NWP0                ldd     #0                std     wzuwrp,u        initialize                ldd     uicnt                beq     10f                std     wzurms,u        how big is transfer** check page boundary crossing in transfer*55              cmpd    fio_fsz,y                blo     01f                ldd     fio_fsz,y01              std     wzrqln,u        set maximum for xfer** all checked, good to go*                ldb     #S_WRQSTO       tell NWP we have data82              jsr     fio_msg                tstb                bmi     80f             socket error*                cmpb    #R_RQWRNB                lbeq     wzokex          non block return*                cmpb    #R_CLOSE                bne     16f             for now*10              lbra    wzokex** repeat ext data*81              ldb     #S_WSNDTM                bra     82b*16              jsr     get_F_S         allocate FIFO + transaction slot** move data now*                ldd     wzrqln,u        ldx     wzdma2,u****        pshs    x                jsr     wzckpb                jsr     wzmem2ff        data from user mem to fifo        puls    x****        stx     wzdma2,u** fifo filled, now send it*25              ldb     #S_WSNDTO                jsr     fio_msg         transfer                cmpb    #E_SYSBSY                beq     25b*** transfer completed*20              jsr     FIFO_unlock                pshs    b                ldd     uistrt                addd    wzxfer,u                std     uistrt                ldd     uicnt                subd    wzxfer,u                std     uicnt* check if all data sits in socket                puls    b                cmpb    #R_SNDTOM        more data                beq     81b                ldd     wzurms,u           zero?                bne     55b*                lbra    wzokex             + restore regs** error ?*80              lda     #ESOCK                sta     uerror                jsr     FIFO_unlock                puls    d,x,y,u,pc***************************************************************** wzckpb, check page boundary crossing* set wzrqln, wzdma1 and wzdma2* X is actual xfer count* exit: C=set when data is 0, else C=clear*wzckpb          pshs    y,u                std     wzdma1,u        set initial value                clra                clrb                    one full transation                std     wzdma2,u        used by wzff2mem, wfmem2ff** check if a 4K page boundary is to be crossed                ldd     uistrt          start address in process space                anda    #$0f            4K                addd    wzrqln,u        add the amount of data                bita    #$f0            4K page overflow?                beq     00f             no, will not cross* it does cross ! cut it in two                ldd     uistrt          first part                pshs    d                negd                anda    #$0f            remaining size in STARTING 4K page                std     wzdma1,u        first part                puls    d                addd    wzrqln,u        remaining size in NEXT 4K page                anda    #$01                std     wzdma2,u00              clc90              puls    y,u,pc88              sec                bra     90b***************************************************************** wzff2mem, move fifo data into user memory* X, Y=NWP0, U=wzsock*wzff2mem        pshs    d,x,y,u         save regs                ldd     wzdma1,u        U still wzsock                trfr    D,W                ldu     fio_dba,y      fifo hardware base address                leau    fifo,u         fifo actual address                ldd     uistrt         process memory address                jsr     mapua2x        D > D offset in XBUFFER                tfr     d,x            set pointer                tfm1    U,X            block move* old U had wzsock address                ldy     6,s             old U from stack                ldd     wzdma2,y        2nd part?                trfr    D,W                beq     01f             nothing to do* W= (second) count ,(X), wzsock                ldd     wzdma1,y        first size (done)                addd    uistrt         update memory address                jsr     mapua2x        D >D in XBUFFER                tfr     d,x            set pointer again                tfm1    U,X            block move01              puls    d,x,y,u,pc***************************************************************** wzmem2ff, move user memory data to fifo* X, Y=NWP0, U=wzsock*wzmem2ff        pshs    d,x,y,u         save regs                ldd     wzdma1,u        U still wzsock                trfr    D,W                ldu     fio_dba,y                leau    fifo,u          fifo address                ldd     uistrt          user memory address                jsr     mapua2x                tfr     d,x                tfm1    X,U* old U had wzsock address                ldy     6,s                ldd     wzdma2,y                trfr    D,W                beq     01f*                ldd     wzdma1,y        first size(done)                addd    uistrt                jsr     mapua2x                tfr     d,x                tfm1    X,U01              puls    d,x,y,u,pc***************************************************************** nw_int, send signal to socket task* X= Device#, B=signal, only when SOCK_SIGPIPECLS is set*nw_int          equ     *                pshs    d,x,y       save pointer                ldx     2,s         wzsock                ldd     wzdma2,x    task ID* find corresponding task                ldx     tsktab      find task02              cmpd    tstid,x     same                beq     01f                leax    TSKSIZ,x                cmpx    tskend                blo     02b                bra     09f* found it, send signal01              ldb     1,s             [B]                clra                jsr     xmtint*09              puls    d,x,y,pc* just show on console when calledwzdebug         pshs    d,x                ldx     #mydebug                jsr     sysmsg                puls    d,x,pcmydebug         fcb     $d,$a                fcc     "**debug**",$d,$a,0* if NET                else                data                nop* if ! NET                endif