        opt     nol        lib     ../include/flpdrvr.h        lib     ../include/blktab.h        lib     ./gendrvr.h        opt     lis,exp        if      (FLP=1)        sttl     Floppy Drivers        pag        name    flpdrvr        global  flpopen,flpclos,flpio,flpirq        global  flopen,flclos,flread,flwrit,flspcl*FDtable fdb     0               Block Device Table addressswpbtp  rzb     2               swap page table pointer** per drive tables* flpcot[], flpopt[], flpsts[], flpstd[]flptab  rzb     FLTBSZ         per drive details* ttyget/ttyset areaflpwrk  fcb     0,0,0,0,0,0** open the flp disk drive - insure the device is online, etc.* B contains device minor*flpopen pshs    d        cmpb    #MAXDEV         total max devices        lbhs    flpaer          invalid drive*        ldx     #flptab        abx        tfr     x,u        tst     flpopt,u        beq     flpop2        inc     flpopt,u        bra     flpop3dvbsye  puls    b        lda     #EBSY        lbra    flpext*flpop2  inc     flpopt,u        set open        clr     flpsts,u        clr     flpstd,u        lda     #1        sta     flpdpr+flnwop  new open        cmpb    #MAXFLP        bhs     flpop3          skip test** try to read disk as 8" SD, 8" DD, 5" SD and 5" DD* As we want to read the SIR, which is block 1 there is no* worry about side select. If SIR is read, the real SIDE/SIZE/DENS* info is taken from the SIR*flpop7  ldd     0,s             get device#        bsr     frdsir          read SIR SD/8"        beq     flpop4        clr     uerror        jsr     freebf          free the buffer*        lda     flpstd,u        eora    #%00000001        sta     flpstd,u        toggle dens*        ldd     0,s             get device# again        bsr     frdsir          read SIR DD/8"        beq     flpop4          no error        clr     uerror        jsr     freebf*        lda     flpstd,u        eora    #%00000001        sta     flpstd,u        toggle dens*        lda     flpsts,u        eora    #%01000000      5/8" select        sta     flpsts,u        anda    #%01000000      done already        bne     flpop7*        ldd     0,s        bsr     flpclos*flpaer  lda     #EIO            set IO errorflpext  sta     uerror*flpop3  puls    d,pc            return*flpop4  pshs    y,u             save buffer        ldx     0,s             buf ptr        ldy     #flpwrk         destination data location        ldu     #sdenf          source data, offset in SIR        ldd     #2              2 bytes(ttyget/set)        jsr     cpybts        ldu     2,s             device info        lda     flpwrk+1        sta     flpsts,u        side info        lda     flpwrk        sta     flpstd,u        dens info        puls    y,u        jsr     freebf        puls    d,pc* flp closeflpclos        ldx     #flptab        abx        dec     flpopt,x        dec open counter        bpl     flpcl1        clr     flpopt,x        clear open statusflpcl1  rts                     return** frdsir, read floppy SIR into a buffer* D is device* Y.X is block number*frdsir  pshs    u        ldx     #1        ldy     #0        jsr     rdbuf        lda     bfflag,y        bita    #BFERR        puls    u,pc** fire up FLP operation to initiate transfer* Y = buf header* most is done in interrupt handler*flpio   stx     FDtable         save Block Device Table address        inc     flpdt+dtbusy    mark busy        ldu     #flpdpr        ldd     bfdvn,y         get device #        stb     fldriv,u        sta     fltdev,u        full device info*        lda     #1              set func        sta     flpdt+dtrtry*        ldx     #flptab        abx        lda     flpsts,x        sta     fltsid,u        lda     flpstd,x       get dens flpstd        sta     fltden,u** 'standard' sizes 128/256/512        ldx     #0              init field        stx     fltxfr,u* set action        lda     bfflag,y        R/W        sta     flrflg,u*        ldx     bfxfc,y         get transfer count        stx     fltsiz,u        TOTAL size        cmpx    #16             swap?        lbls    doswap** single block read/write*        bita    #BFRWF        bne     02f             read=1, go wait** write, transfer data to FIFO first**        pshs    d               make space for size        ldb     DATBOX+SBUF     save DAT setting        pshs    b,x,y,u        ldd     bfxfc,y        cmpd    #BUFSIZ         max data xfer in DPR        bls     01f*splb01  ldd     #BUFSIZ01      std     7,s             count [D]*        addd    fltxfr,u        actual xfer        std     fltxfr,u** use kernel functions for transfer*        ldd     7,s             count [D]        leay    flpfifo,u       system target        ldu     #0              offset        ldx     3,s             bufhdr [Y]        pshs    cc        seti        jsr     cpybts        puls    cc        puls    b,x,y,u        stb     DATBOX+SBUF     save DAT setting*        lda     bfflag,y        bita    #BFSPC          special function        beq     11f** adjust for (bulk) data transfer*        ldd     bfxfc,y         decrease transfer count        subd    0,s             deduct that we do now        std     bfxfc,y        ldd     bfadr,y         buffer (memory) address        addd    0,s             update pointer        std     bfadr,y         updated memory address        bcc     11f        inc     bfxadr,y        hibyte  (A16...A19)11      puls    d               empty stack** read, send command, in interrupt data is there (or not)*02      lda     bfblch,y        BLOCK# H/M/L        sta     flblkh,u        ldd     bfblck,y        std     flblkm,u*        lda     #$ff            set command location GPP        sta     flptel,u        rts** some error had occurred*01      lda    #EBDEV        sta    uerror        lda    bfflag,y        ora    #BFERR        sta    bfflag,y*flpfin  clr     flpdt+dtrtry    erase function        rtsdoswap  lda     #2              set swap mode        sta     flpdt+dtrtry        ldd     bfadr,y         save address of swap page table        std     swpbtp        jsr     flsetba         make current bufhdr to point        lbne    flpdon          to memory page(s)** bufhdr now points to memory page*        ldx     #PAGSIZ         page size        stx     fltsiz,u        TOTAL size        ldx     #0              init field        stx     fltxfr,u*        lda     bfflag,y        read/write?        bita    #BFRWF        beq     03f        ldd     #BUFSIZ        std     fltxfr,u        bra     02b* load 1st buffer03      pshs    d               create space        pshs    b,x,y,u        lbra    splb01          write** flsetba, flop setup bufhdr for swap transfer*flsetba pshs    x        ldx     swpbtp          copy of original bfaddr        ldb     0,x+            get page#        stx     swpbtp        cmpb    DSKTRM          passed last age?        bne     01f        clrb                    set end        puls    x,pc*01      lda     #16             shift page left by 4 into D        mul        std     bfxadr,y        set real memory address A19...A8        clr     bfadr+1,y       A7...A0        clz        puls    x,pc** IRQ, here most things are done (success or fail)*flpirq  equ     *        ldu     #flpdpr         hardware base address        clr     flpint,u          set we saw it*        ldy     flpdt+dtqfl     get last transaction        beq     flpfin          Y = bufhdr        lda     bfflag,y        get bufhfr flags        ldb     flstat,u        result        bne     flprr1*        bita    #BFSPC          special action (bulk)        bne     flirrw*        ldx     fltsiz,u        special action (swap)        cmpx    #PAGSIZ        lbeq    intswp          do swap** single block transfers, Write= done, Read is get data*        bita    #BFRWF          read=1        beq     03f             for write we're finished** interrupt context, be careful, buffer may be in use* READ*        ldb     DATBOX+SBUF     save DAT setting        pshs    b,x,y,u        ldd     bfxfc,y        cmpd    #BUFSIZ         max data xfer        bls     10f        ldd     #BUFSIZ10      std     fltxfr,u        count        leay    flpfifo,u       system target        ldu     #0              offset        ldx     3,s             bufhdr [Y]        jsr     cpystb        puls    b,x,y,u        stb     DATBOX+SBUF    restore DAT setting** for write (and single read), we're done*03      bra     flpdon* handle errors A= bfflagflprr1  stb     bfstat,y       device status byte        ora     #BFERR        sta     bfflag,y       set error result bit        bitb    #%01000000     write protect        beq     01f            2793        lda     #EPRM        bra     02f01      bitb    #%00010000     not found        beq     03f            2793        lda     #EBADF        bra     02f03      lda     #EIO           all others02      sta     uerror** wrap up and return form call*flpdon  clr     flpdt+dtbusy    set unbusy        clr     flpdt+dtrtry    clear funtion        ldx     FDtable        jmp     BDioend** BULK data transfer* for Read and Write, tranfer next data block(s)* A=bfflag*flirrw  equ     *        anda    #BFRWF        pshs    a               +1 direction flag        beq     09f* BULK Read        ldd     fltxfr,u        what we got already        cmpd    fltsiz,u        set by read command        bhs     11f* BULK  Read/Write09      ldd     bfxfc,y         any data ?        bne     10f** transfer completed, bail out*11      leas    1,s             clean stack        bra     flpdon** common code for Read/Write*10      cmpd    #BUFSIZ        bls     02f        ldd     #BUFSIZ* transfer next block02      pshs    d              +2 count*        ldb     DATBOX+SBUF     save old value        pshs    b,x,y,u        +7*swpinx  tfr     y,x             bufhdr        leay    flpfifo,u       system target        ldd     7,s             count [D]        ldu     #0              offset* function to do        tst     9,s             0 = write, <>0 is read        beq     14f            read: DPR -> mem        jsr     cpystb        bra     15f*14      jsr     cpybts          write: mem > DPR*15      puls    b,x,y,u        -7, leave counts and flag in stack        stb     DATBOX+SBUF* count and flag still on stack        lda     bfflag,y        bita    #BFSPC        beq     06f** adjust for transferred data*        ldd     bfxfc,y        process data done        subd    0,s            always less then 65K        std     bfxfc,y        ldd     bfadr,y        update memory pointer        addd    0,s        std     bfadr,y        bcc     06f        inc     bfxadr,y*06      ldd     fltxfr,u        addd    0,s++          -2, correct stack        std     fltxfr,u*        puls    a               cleanup stack        lda     #$ff        sta     flptel,u        rts**  U=fifo address, X=data size, Y=bufhdr*intswp  equ     *               do swap operations        ldx     fltxfr,u        cmpx    fltsiz,u        is updated each transfer set to PAGSIZ        beq     01f             try next page** swap per block*02      ldd     bfblck,y        select next block        incd        std     bfblck,y        std     flblkm,u        set new block select*        lda     bfflag,y        anda    #BFRWF        pshs    a               +1 build stack        ldd     #BUFSIZ        pshs    d               +2*        ldb     DATBOX+SBUF     save old value        pshs    b,x,y,u         +7        bra     swpinx** one page finished*01      jsr     flsetba         setup for next PAGE        lbeq    flpdon          zero is done*        ldx     #0              reset transferred        stx     fltxfr,u        bra     02b**  character open*flopen  equ     *        cmpb    #MAXDEV        bhs     flchop4        ldx     #flptab        abx        tst     flpcot,x        bne     flchop5 don't touch settings        inc     flpcot,x        tst     flpopt,x     is block driver alrady open?        bne     flchop5 yes, don't do anything        clr     flpsts,x     clear side/size info        clr     flpstd,x     clear dens info        bra     flchop5*flchop4 lda     #EBARG        sta     uerrorflchop5 rts** character close*flclos  ldx     #flptab        abx        clr     flpcot,x        rts** flchrd*flread  equ     *        pshs    d       save device number        ldy     #fchbuf        jsr     blkgtb  get device buffer        puls    d        jsr     fchcn   configure buffer        tst     uerror  OK?        beq     fchrd4        pshs    y        ldy     #fchbuf        jsr     blkfrb  free the buffer        puls    y,pc    error returnfchrd4  pshs    a       save task mode byte        orb     #BFRWF  set read        stb     bfflag,y save        bra     fchio** flchwr*flwrit  equ     *        pshs    d       save device info        ldy     #fchbuf        jsr     blkgtb  get device buffer        puls    d        jsr     fchcn   configure        tst     uerror  OK        beq     fchwr4        pshs    y        ldy     #fchbuf        jsr     blkfrb  free the buffer        puls    y,pc    error returnfchwr4  pshs    a       save task mode bytefchio   ldb     #FLmajor        jmp     blkcio** fchcn** Configure the buffer header pointed at by Y.* This routine sets up the character device info* from the user block and puts it in the buffer* header such that the device drivers can use* the informationfor the transfer* this routine is specific for the floppy driver*fchcn   std     bfdvn,y save device info        ldd     uicnt   xfr count        std     bfxfc,y        cmpd    #128    check valid numbers        beq     fcnch4        cmpd    #256        beq     fcnch4        cmpd    #512        beq     fcnch4** above are valid sector sizes*        pshs    x        ldx     #tsztabfcnctb  cmpd    0,x++        beq     fcnch2        tst     0,x        bne     fcnctb        puls    x*fcnch8  lda     #EBARG  set error        sta     uerror        rts*fcnch2  puls    x        ldd     uistrt   (big) buffer aligned at 512        bitdi   $01ff    byte boundary?        bne     fcnch8*        lda     bfflag,y        ora     #BFSPC  special bit for drivers        sta     bfflag,y** do the remainder in the common code* seek offset and real memory address*fcnch4  jmp     blkcnf** valid track sizes* 5" SD, 8" SD, 5" DD, 8" DD, HD, (legay) 5" SD, 8" SD, 5" DD, 8" DD, HD RTRK*tsztab  fdb     3125,5187,6250,10375,12500,3050,5100,6100,10200,12200,12500,0** flspcl*flspcl        tfr     x,y        ldx     #flptab        side info table        abx* set/get?        cmpy    #0        bne     01f* set        ldd     usarg0        sta     flpsts,x             set side        stb     flpstd,x             set dens        ldd     usarg2               hardware        std     flpdpr+flpstp        rts* get01      lda     flpsts,x             get side        ldb     flpstd,x             get dens        std     0,y        lda     flpdpr+flstat        sta     2,y        clr     3,y        ldd     flpdpr+flpstp        std     4,y        endif        end