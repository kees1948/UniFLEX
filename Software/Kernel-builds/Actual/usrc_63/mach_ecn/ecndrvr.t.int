        opt     nol        lib     ./gendrvr.h        lib     ../mach_ecn//ecndrvr.h        opt     lis,exp        if      (ECN=1)        sttl     Econet Drivers        pag        name    ecndrvr** simple driver to interface  GPP/ECN with system*        data        global  ecn_open,ecn_close,ecn_read,ecn_write,ecn_spcl        global  ecn_irq,dprecn,ecn_cpuFecnrdb  rzb     HDRSIZecnwrb  rzb     HDRSIZ*ecnopt  fcb     0,0,0,0        eco open tableecnsts  rzb     2** open the ecn driver* B contains device minor*ecn_open   pshs    d        ldx     #ecnopt        lda     b,x        bne     ecnop2          exclusive open        inc     b,x        bra     ecnop3*ecnop2  lda     #EBARG        sta     uerrorecnop3  puls    d,pc            return** ecn close*ecn_close        ldx     #ecnopt        clr     b,x             clear open status        rts                     return** IRQ, here something has been done (success or fail)*ecn_irq  equ     *        ldu     #dprecn        ldb     ecn_cpuF,u      this resets the IRQ        bitb    #ECNRDI        beq     ecnir1        pshs    b,u        ldy     #ecnrdb        jsr     wakeup        puls    b,u*ecnir1  bitb    #ECNWRI        beq     ecnri2        pshs    b,u        ldy     #ecnwrb        jsr     wakeup        puls    b,u*ecnri2  clr     ecn_cpuF,u        set we saw it        rts** ecn_read*ecn_read   equ     *        pshs    cc,d    save device number        sei        ldy     #ecnrdb        jsr     blkgtb  get device buffer        ldd     1,s        jsr     ecncn   configure buffer        tst     uerror  OK?        beq     ecnrd4*        pshs    y        ldy     #ecnrdb        jsr     blkfrb  free the buffer        puls    cc,d,y,pc    error return** wait for data*ecnrd4  ldu     #dprecn        sei        lda     #$ff        sta     ecnrda,u        tell we are there        lda     ecn_dprF,u        ora     #ECNRDI        sta     ecn_dprF,u      tell him loudly        pshs    y,u        save registers        ldd     umark1  setup to allow interuptable sleep        pshs    d        ldx     #ecnrdi  interrupted        pshs    x        sts     umark1     save SP        ldb     #TTYIPR    interruptable*       ldb     #ECNPRI    set interruptable priority        jsr     sleep        puls    d,x,y,u        stx     umark1   restore        bra     ecnconecnrdi  puls    x,y,u   INTERRUPT happened (D already popped)        stx     umark1  restore stack mark        lda     ecn_dprF,u        ora     #ECNRII        sta     ecn_dprF,u      we bail out        lds     umark1        rts** data should be there*ecncon        ldd     ecnrct,u        beq     ecnrd7      nothing, go exit        cmpd    uicnt        bhi     ecnrd0    is not going to fit in user buffer        std     uicnt     set actual*ecnrd8  trfr    D,W         count        pshs    x,u        tfr     y,x        jsr     mapbpt        leau    ecnrff,u   read fifo        tfm1    U,X        move to user U->X        puls    x,u        bra     ecnrd7*ecnrd0  ldd     #0         null read        std     uicnt        bra     ecnrdeecnrd7  clr     ecnrda,u     say we took it        ldb     ecnrer,u     error from network        beq     ecnrd6*ecnrde  ldb     bfflag,y        orb     #BFERR        stb     bfflag,y        ldb     #EIO        stb     uerror*ecnrd6  jsr     blkfrb          free buffer and return        puls    cc,d,pc** ecn_write*ecn_write   equ     *        pshs    d       save device info        ldy     #ecnwrb        jsr     blkgtb  get device buffer        puls    d        jsr     ecncn   configure and check        tst     uerror  OK        beq     ecnwr4*        pshs    y        ldy     #ecnwrb        jsr     blkfrb  free the buffer        puls    y,pc    error return** store the data*ecnwr4  ldu     #dprecn        ldd     uicnt        std     ecnwct,u        trfr    D,W        pshs    x,u        tfr     y,x        jsr     mapbpt        leau    ecnrff,u        tfm1    X,U             X->U        puls    x,u*        pshs    cc        sei        lda     #$ff            set flag        sta     ecnwra,u        lda     ecn_dprF,u        ora     #ECNWRI         signal from xmit        sta     ecn_dprF,u        pshs    y,u        save registers        ldb     #ECNPRI    set interruptable priority        jsr     sleep        puls    y,u    restore registers        puls    cc*ecnwr9  jmp     blkfrb          free buffer and return*ecnwre  ldb     bfflag,y        orb     #BFERR        stb     bfflag,y        ldb     #EIO        stb     uerror        bra     ecnwr9** configure buffer*ecncn   equ     *        std     bfdvn,y         device        ldd     uicnt           xfer count        cmpd    #ECNFSZ        bhi     ecnce1        std     bfxfc,y        ldd     uistrt          user address        std     bfadr,y        jsr     mapupg          map page        std     bfxadr,y* check if whole buffer remains within one page* whether the buffer is big or small        ldd     bfadr,y        anda    #%00001111      round to 4K        addd    uicnt        bita    #%11110000        bne     ecnce1           overflow        rts*ecnce1  lda     #EBARG        sta     uerror        rts** ecn_spcll*ecn_spcl        tfr     x,y        ldx     #ecnsts         side info table        abx                     correct entry        cmpy    #0        bne     01f*        ldd     usarg0        sta     0,x             set side        stb     1,x             set dens        rts01      lda     0,x             get side        ldb     1,x             get dens        std     0,y        endif        end