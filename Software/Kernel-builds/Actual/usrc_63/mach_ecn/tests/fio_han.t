          opt     nol          lib     ./environment.h        if      (ECN=1)          lib     ../include/macdefs.h          lib     ../include/task.h          lib     ../include/sysdefs.h          lib     ../include/ecn_dev.h          lib     ../include/fio.h          lib     ../include/fio_codes.h        data          opt     lis        sttl    ECN FIFO Routines        global  ecn_irq,ecn_msg        global  ECN_SMSZ,ECN_FSZecn_wait  fcb     0          Count of tasks waiting for FIO access (global)** ecn_irq - Process ECN interrupt, testing for INT already reset the IRQ*   U - FIO address*   Y - FIO Control structure*ecn_irq   pshs    x,y,u          ldu     fio_dba,y  U - dual port RAM address          lda     fio_cpu2,u move transaction data (interrupt#)          pshs    a          -- Transaction specific value          clr     ,-s        ** Filler **          lda     fio_cpu1,u                       (terminal#)          pshs    a          -- Sequence #          lda     fio_cpu,u                        (response)          pshs    a          -- Response code          ldx     fio_dsz,y          leax    -FIOTVSZ,x          addr    U,X        U + X -> X          clr     fio_cpuF,x indicate message received** 0,s - response code* 1,s - sequence #* 3,s - transaction specific returned value*10        ldb     fio_mxtrn,y  MAX_TRAN          leay    fio_tran,y point to transaction list          pshs    b15        lda     2,s        check transaction #          beq     16f        empty?          cmpa    tran_seq,y match?          beq     20f        yes - go*16        leay    TRAN_SIZ,y next transaction          dec     0,s        any more?          bne     15b* -- Unsolicited response!          leas    5,s        clean up stack          bra     99f        exit*20        puls    b          clean up stack          lda     0,s        get response code          sta     tran_resp,y save response code          lda     3,s        get response value          sta     tran_val,y          leas    4,s        clean up stack          jsr     wakeup     wake up sender99        puls    x,y,u,pc   return** ecn_msg - Send a value via the FIO Mailbox & wait for response*   U - maj/min*   D - Value to send (B = Command, A = Specific data)*   Y - FIO control block*   jsr fio_msg*   D - Value returned (B = Error response, A = Specific data)*ecn_msg   pshs    cc,d,x,y,u save registers* -- Find an empty transaction box10        seti               turn off interrupts          ldy     5,s        get FIO control address          jsr     MBX_lock   get access to FIO          lbsr    find_slot  go find a slot          beq     15f        jump if one found*          ldy     5,s        restore FIO structure pointer          jsr     MBX_unlock give up FIO until slot available          lbsr    find_slot  make sure no slots available          beq     10b        jump if there is one*          ldy     5,s        get FIO pointer          leay    fio_tflg,y sleep on transaction slots          ldb     #FIOPRI          jsr     Q_sleep    wait for available message slot          bra     10b        try for a transaction slot*15        ldb     utask+1    set sequence # in slot ???          orb     #1          stb     tran_seq,y          ldb     0,s        enable (old) interrupts          tfr     b,cc          pshs    y          save transaction slot pointer          ldb     4,s        restore message code (B)          lda     3,s        restore specific data (A)          exg     d,u          lda     utask+1          ora     #1         set sequence #          stb     tran_dev,y   minor device          exg     d,u          sta     tran_oval,y                         (A)          stb     tran_msg,y                          (B)          ldy     7,s        restore FIO structure pointer          lbsr    fio_send          jsr     MBX_unlock release mailbox*20        puls    y          get transaction slot address          seti               mask interrupts          tst     tran_resp,y any response yet?          bne     30f        yes - go process*          ldx     5,s        get FIO control address          ldd     fio_fifo,x does this task own the FIFO?          bne     25f        yes - don't allow interrupts!*          pshs    y,u        save registers          ldd     umark1     set up to allow interruptable sleep          pshs    d          ldx     #27f       interrupt handling label          pshs    x          sts     umark1          ldb     #TTYIPR    set interruptable priority          jsr     A_sleep    wait for IO_CPU response          puls    d,x,y,u    restore registers          stx     umark1     restore interrupt point          bra     30f        continue*27        puls    x,y,u      Interrupt happened! - (D) already popped          stx     umark1     restore stack mark          lda     #E_ABORT   aborted transaction!          sta     tran_resp,y          ldb     #O_INTRPT          pshs    y          save transaction slot pointer          ldy     7,s        restore FIO control pointer          jsr     MBX_lock   get access to mailbox          jsr     fio_send          jsr     MBX_unlock release mailbox          puls    y          restore transaction slot pointer          bra     30f*25        ldb     #FIOPRI          pshs    x,y,u      save registers          jsr     A_sleep          puls    x,y,u      restore registers*30        ldx     utask          seti               turn off interrupts while fiddling with transaction slots* -- See if there is a response.  It is possible to* -- get here without one if an interrupt happened which* -- was being ignored.  In this case, the IO_CPU doesn't* -- need to be notified of any interrupt, but we must* -- wait for the IO_CPU response to actually arrive.          ldb     tran_resp,y get response code          bne     35f        jump if response present*          pshs    y          reset stack          bra     20b        wait for response*35        clra               release transaction slot          sta     tran_seq,y          clr     tran_resp,y          lda     tran_val,y get response value          std     1,s        set return value (resp val,resp. code)          ldy     5,s        wake anybody waiting for this slot          leay    fio_tflg,y          jsr     wakeup          lda     2,s        interrupted transaction?          cmpa    #E_ABORT          bne     50f        no continue*          lds    umark1     yes, get out          rts*50        puls    cc,d,x,y,u,pc return** Q_sleep - Sleep until event with decreased activity*Q_sleep   jmp     sleep** A_sleep - Sleep until event with no decrease in activity*A_sleep   jsr     sleep      wait for event          rts        else        dataecn_wait  fcb     0          Count of tasks waiting for ECN access (global)          endif          end