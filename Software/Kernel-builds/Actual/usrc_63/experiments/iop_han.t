          lib     ./environment.h          opt     nol          lib     ../include/macdefs.h          lib     ../include/inttab.h          lib     ../include/task.h          lib     ../include/tty.h          lib     ../include/sysdefs.h          opt     lis          lib     ../include/fio.h          lib     ../include/fio_codes.h          sttl    IOP        Interface          pag          global  NUM_TRM,NUM_TSKACT_COST  set     2          Activity cost for IOP transaction          data          global  fio_int,map_io,map_iop          global  iop_open,iop_close,iop_write,iop_read,iop_spcl          global  iop_waitiop_wait  fcb     0          Count of tasks waiting for IOP access (global)          lib     ./fio_sim.t** fio_int - Process IOP interrupt*   U - FIO address*   Y - IOP Control structure*fio_int   pshs    x,y          lda     iop_cpu2   move transaction data          pshs    a          -- Transaction specific value          clr     ,-s        ** Filler **          lda     iop_cpu1          pshs    a          -- Sequence #          lda     iop_cpu          pshs    a          -- Response code          clr     iop_cpuF   indicate message received*         tst     irq_gen    clear interrupt          lda     0,s        get response code          cmpa    #R_INTRPT          beq     05f**          cmpa    #R_CLOCK   clock tick?*          bne     10f        bra   10f*          jsr     map_io     -- restore MAP in case we lose control!          jsr     clkint     process clock interrupt          leas    4,s        clean up stack          bra     99f        exit*05        ldb     1,s        relative terminal #          jsr     find_dn    compute absolute terminal #          ldx     ttytab     compute TTY table address          lda     #TTYSIZ          mul          leax    d,x          clra          ldb     3,s        get interrupt code          jsr     intrpt send interrupt to this terminal          leas    4,s        clean up stack          bra     99f        exit* 0,s - response code* 1,s - sequence #* 3,s - transaction specific returned value10        leay    iop_tran,y point to transaction list          ldb     NUM_TRAN   # transactions          pshs    b15        lda     2,s        check transaction #          cmpa    tran_seq,y match?          beq     20f        yes - go*          leay    TRAN_SIZ,y next transaction          dec     0,s        any more?          bne     15b* -- Unsolicited response!          bra     99f        exit*20        puls    b          clean up stack          lda     0,s        get response code          sta     tran_resp,y save response code          lda     3,s        get response value          sta     tran_val,y          leas    4,s        clean up stack          jsr     wakeup     wake up sender99        puls    x,y,pc     return** fio_msg - Send a value via the FIO Mailbox & wait for response*   D - Value to send (B = Command, A = Specific data)*   Y - Interlock table*   jsr fio_msg*   D - Value returned (B = Error response, A = Specific data)*fio_msg   pshs    cc,d,x,y,u save registers* -- Find an empty transaction box10        seti    turn       off interrupts          ldy     5,s        get IOP control address          jsr     MBX_lock   get access to IOP          lbsr    find_slot  go find a slot          beq     15f        jump if one found*          ldy     5,s        restore IOP structure pointer          jsr     MBX_unlock give up IOP until slot available          lbsr    find_slot  make sure no slots available          beq     10b        jump if there is one*          ldy     5,s        get IOP pointer          leay    iop_tflg,y sleep on transaction slots          ldb     #IOPPRI          jsr     Q_sleep    wait for available message slot          bra     10b        try for a transaction slot*15        ldb     utask+1    set sequence # in slot ???          orb     #1          stb     tran_seq,y          ldb     0,s        enable (old) interrupts          tfr     b,cc          pshs    y          save transaction slot pointer          ldb     4,s        restore message code          lda     3,s        restore specific data          exg     d,u          lda     utask+1          ora     #1         set sequence #          stb     tran_dev,y          exg     d,u          sta     tran_oval,y          stb     tran_msg,y          ldy     7,s        restore IOP structure pointer          lbsr    fio_send          jsr     MBX_unlock release mailbox*20        puls    y          get transaction slot address          seti    mask       interrupts          tst     tran_resp,y any response yet?          bne     30f        yes - go process*          ldx     5,s        get IOP control address          ldd     iop_fifo,x does this task own the FIFO?          bne     25f        yes - don't allow interrupts!*          pshs    y,u        save registers          ldd     umark1     set up to allow interruptable sleep          pshs    d          ldx     #27f       interrupt handling label          pshs    x          sts     umark1          ldb     #TTYIPR    set interruptable priority          jsr     A_sleep    wait for IOP response          puls    d,x,y,u    restore registers          stx     umark1     restore interrupt point          bra     30f        continue*27        puls    x,y,u      Interrupt happened! - (D) already popped          stx     umark1     restore stack mark          lda     #E_ABORT   aborted transaction!          sta     tran_resp,y          ldb     #O_INTRPT          pshs    y          save transaction slot pointer          ldy     7,s        restore IOP control pointer          jsr     MBX_lock   get access to mailbox          jsr     fio_send          jsr     MBX_unlock release mailbox          puls    y          restore transaction slot pointer          bra     30f*25        ldb     #IOPPRI          pshs    x,y,u      save registers          jsr     A_sleep          puls    x,y,u      restore registers*30        ldx     utask          seti    turn       off interrupts while fiddling with transaction slots* -- See if there is a response.  It is possible to* -- get here without one if an interrupt happened which* -- was being ignored.  In this case, the IOP doesn't* -- need to be notified of any interrupt, but we must* -- wait for the IOP response to actually arrive.          ldb     tran_resp,y get response code          bne     35f        jump if response present*          pshs    y          reset stack          bra     20b        wait for response*35        clra    release    transaction slot          sta     tran_seq,y          clr     tran_resp,y          lda     tran_val,y get response value          std     1,s        set return value          ldy     5,s        wake anybody waiting for this slot          leay    iop_tflg,y          jsr     wakeup          lda     2,s        interrupted transaction?          cmpa    #E_ABORT          bne     50f        no - continue*          lds     umark1     yes - get out          rts*50        puls    cc,d,x,y,u,pc return** find_slot - find a transaction slot*   Y - IOP control address*   jsr find_slot*   Y - Transaction slot*   <NE> if none available*find_slot pshs    x,y save register          leay    iop_tran,y point to transactions          ldb     NUM_TRAN          pshs    b*10        lda     utask+1    check for busy entries          ora     #1          cmpa    tran_seq,y          beq     30f        yes - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     10b*          ldy     3,s        restore IOP pointer          leay    iop_tran,y point to transactions          ldb     NUM_TRAN          stb     0,s*20        lda     tran_seq,y entry busy?          beq     30f        no - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     20b*          lda     #1         return NE - no slot          bra     99f*30        sty     3,s        return value          clra    return     EQ - slot found*99        puls    b,x,y,pc   clean stack & return**  get_F_S - Allocate a transaction slot and the FIFO*    Y - IOP control*get_F_S   pshs    cc,d,x,y,u save registers          seti    mask       interrupts          jsr     find_slot  allocate transaction slot          beq     10f        jump if one found*          ldy     5,s        wait for slot          leay    iop_tflg,y          ldb     #IOPPRI          jsr     Q_sleep          puls    cc,d,x,y,u restore registers          bra     get_F_S    try again*10        ldb     utask+1    "allocate" slot          orb     #1          stb     tran_seq,y          puls    cc,d,x,y,u restore interrupts/registers          jmp     FIFO_lock  lock FIO access** iop_open - Open a terminal on the IOP*   D = Device #*iop_open  pshs    d,x,y,u          lbsr    iop_fdv    compute device #          bcc     00f        jump if OK to open*          ldb     #TTYOPR    hang up task          ldy     iop_open   ** this will never happen! **          jsr     sleep*00        pshs    d,u,y      save IOP parameters*05        ldb     #O_OPEN    send "open device" request          jsr     fio_msg          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     10f*          jsr     p_iop_bsy  print message          bra     05b*10        cmpb    #E_BADDEV  illegal device?          bne     15f*-- Hang up device - 2/20/85          ldb     #TTYOPR    hang up task          ldy     iop_open   ** this will never happen! **          jsr     sleep          ldd     #EBDEV     yes - return error          std     uerror          bra     20f*15        ldy     utask      set controlling terminal          ldd     tstty,y          bne     20f        jump if already set*          ldd     6,s        restore device code          cmpb    strm       is this a terminal?          bhs     20f        no - don't screw up the tables*          ldx     ttytab     compute "TTY" table address          lda     #TTYSIZ          mul          leax    d,x          stx     tstty,y    set controlling terminal          ldd     6,s        restore device #          std     tdevic,x   set fake entry in TTY table20        puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** iop_close - Close a terminal at the IOP*iop_close pshs    d,x,y,u          lbsr    iop_fdv    compute device #          bcs     99f        jump if error          pshs    d,u,y      save IOP parameters*00        ldb     #O_CLOSE   send "close device" request          jsr     fio_msg          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     10f*          jsr     p_iop_bsy  print message          bra     00b*10        puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** iop_write - Write data to a terminal on the IOP*iop_write pshs    d,x,y,u          lbsr    iop_fdv    compute device #          bcs     99f        jump if error*          pshs    d,u,y      save IOP parameters*00        ldd     uicnt      any data left?          beq     90f        no - exit*          cmpd    #1         single character write?          beq     50f        yes - special case*          ldb     #O_RQWR    send "request write data" request          jsr     fio_msg          cmpb    #E_IOERR   I/O Error? (possible on printers)          beq     80f*          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     05f*          jsr     p_iop_bsy  print message          bra     00b*05        jsr     get_F_S    allocate FIFO and a transaction slot          lda     #0         start queueing characters*10        pshs    a,x,y,u    save registers          lbsr    cpass      get character          puls    a,x,y,u    restore registers          bmi     20f        jump if no more*          jsr     FIFO_put   place character in FIFO          inca    update     count          cmpa    #FIFO_SIZE          bne     10b*20        tsta    anything   in FIFO?          beq     30f        no - exit*25        ldb     #O_WRITE   set Write code          jsr     fio_msg    signal IOP          cmpb    #E_SYSBSY  if IOP saturated, try again          bne     27f*          jsr     p_iop_bsy  print message          bra     25b*27        jsr     FIFO_unlock release interlock          bra     00b        continue*30        jsr     FIFO_unlock release FIFO          bra     90f        exit* -- Special case for single character write50        pshs    x,y,u      save registers          lbsr    cpass      fetch character from user          puls    x,y,u      restore registers          lda     #O_WRC     write single character          exg     a,b        a=data, b=command          jsr     fio_msg    issue command          cmpb    #E_IOERR          bne     90f*80        lda     #EIO       some sort of I/O error          sta     uerror*90        puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** iop_read - Read data from a terminal at the IOP*iop_read  pshs    d,x,y,u          lbsr    iop_fdv    get IOP params          lbcs    99f        exit if error*          pshs    d,y,u      save IOP params*00        ldd     uicnt      how many more characters needed          beq     90f        exit if none*          ldb     #O_RQRD    inform IOP we need data          jsr     fio_msg          cmpb    #R_RD1C    single character returned?          beq     50f        yes - go process it*          jsr     get_F_S    allocate FIFO          ldd     uicnt      how much data to read?          cmpd    #FIFO_SIZE can move no more than FIFO          blo     05f*          ldd     #FIFO_SIZE*05        tfr     b,a        set request max size          ldb     #O_SEND    tell IOP to send data          pshs    a          save size of request          jsr     fio_msg          cmpa    #0         EOF?          beq     20f        yes - go process it*          pshs    a,b        save input count, response type*10        pshs    a,x,y,u    save registers          jsr     FIFO_get   get character          lbsr    passc send to user          puls    a,x,y,u    restore registers          deca    any        more this load?          bne     10b        yes - go get 'em*          jsr     FIFO_unlock & release it to world          puls    a,b        a=size returned, b=response code          cmpa    ,s+        less than requested amount          bne     90f        exit if not the same (must be less)*          cmpb    #R_SNDMC   Make sure there are more chars available          beq     00b*          bra     90f        exit* -- IOP returned EOF20        jsr     FIFO_unlock          puls    a          clean up stack          bra     90f        exit* -- Single character returned50        tfr     a,b        get character          pshs    x,y,u      save registers          lbsr    passc move to user          puls    x,y,u      restore registers90        puls    d,y,u      clean up stack* -- Try to even loading          ldy     utask          clr     tsact,y* --99        puls    d,x,y,u,pc** iop_spcl - Perform TTYSET/TTYGET for an IOP terminal*  X - =0 if doing ttyset*     <>0 if ttyget*iop_spcl  pshs    d,x,y,u          lbsr    iop_fdv    compute device #          bcs     99f        jump if error*00        pshs    d,y,u      save registers          jsr     get_F_S    allocate FIFO and a transaction slot          ldx     6+2,s      get ttyset/get parameter          cmpx    #0         ttyset?          bne     50f        no - do ttyget*          lda     #6         move ttyset data into FIFO          ldx     #usarg0*10        ldb     ,x+        move data          jsr     FIFO_put   into FIFO          deca          bne     10b*          ldb     #O_TTYS    send "ttyset" request          jsr     fio_msg          bra     90f        exit*50        ldb     #O_TTYG    send "ttyget" request          jsr     fio_msg          lda     #6         move data from FIFO into buffer*60        jsr     FIFO_get   get data from FIFO          stb     ,x+          deca          bne     60b*90        jsr     FIFO_unlock release FIFO buffer          puls    d,u,y      clean up stack*99        puls    d,x,y,u,pc** findBRG - Find Baud rate generators*findBRG   rts** MBX_lock - Lock the IOP interface*    Y - IOP Control address*MBX_lock  pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     iop_mbx,y  mailbox already locked?          beq     10f        no - go check FIFO*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     iop_fifo,y FIFO locked?          beq     50f        no - go lock mailbox*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        inc     iop_wait          ldb     #IOPPRI          pshs    y          preserve register          jsr     Q_sleep    yes - sleep until available          puls    y          restore register          dec     iop_wait          puls    cc,d,x,y,u restore environ          bra     MBX_lock   try again*50        ldd     tstid,x    lock mailbox          std     iop_mbx,y          clr     iop_int,y  no missed interrupts*99        puls    cc,d,x,y,u,pc return** MBX_unlock - unlock the IOP interface**    Y - IOP Control address*MBX_unlock pshs    cc,d,x,y,u          seti    turn       off interrupts          lda     iop_int,y  did we miss an interrupt?          beq     05f        no - continue*          jsr     fio_int    yes - pretend we're seeing it now!*05        clr     iop_int,y  reset flag          ldd     #0          std     iop_mbx,y  reset lock          jsr     wakeup     wake up anybody waiting on this IOP          ldy     5,s        restore pointer          lda     iop_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return** FIFO_lock - Lock the IOP FIFO buffer*    Y - IOP Control address*FIFO_lock pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     iop_fifo,y FIFO locked?          beq     10f        no - go check mailbox*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     iop_mbx,y  mailbox already locked?          beq     50f        no - go lock FIFO*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        ldb     #IOPPRI          inc     iop_wait   mark somebody waiting          pshs    y          save pointer          jsr     Q_sleep    yes - sleep until available          puls    y          restore pointer          dec     iop_wait          puls    cc,d,x,y,u restore environ          bra     FIFO_lock  try again*50        ldd     tstid,x    lock FIFO          std     iop_fifo,y*99        puls    cc,d,x,y,u,pc return** FIFO_unlock - unlock the IOP FIFO buffer**    Y - IOP Control address*FIFO_unlock pshs    cc,d,x,y,u          seti    turn       off interrupts          ldd     #0          std     iop_fifo,y reset lock          jsr     wakeup     wake up anybody waiting on this FIFO          ldy     5,s        restore pointer          lda     iop_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return** Q_sleep - Sleep until event with decreased activity*Q_sleep   jmp     sleep** A_sleep - Sleep until event with no decrease in activity*A_sleep   jsr     sleep      wait for event          pshs    a,x        upgrade activity          ldx     utask          lda     tsact,x          adda    #ACT_COST          bcc     00f*          lda     #$FF*00        sta     tsact,x          puls    a,x,pc** iop_fdv - Find device info for IOP terminal*    D - device #*    jsr iop_fdv*    B - device # (0..N)*    U - Sequence #/Terminal #*    Y - FIO interlock*    <Carry> if illegal device #*iop_fdv   pshs    d          save device #          ldu     0,s        get device code          ldy     #IOP0          clc     no         error99        puls    d,pc       return** find_dn - compute device # for a terminal on an IOP*   B - relative device #*   Y - IOP control address*   jsr find_dn*   D - absolute device #*find_dn   pshs    d,x,y,u    save registers          clra          std     0,s        set return value          puls    d,x,y,u,pc return*00        fcc     $d,'IOP Saturated!',0p_iop_bsy pshs    d,x,y,u          ldx     #00f          jsr     Pdata          ldx     #$FFFF10        leax    -1,x          bne     10b*99        puls    d,x,y,u,pc*00        fcc     $d,'IOP Saturated!',0        defineIOP0    rzb     IOP_SIZENUM_TRAN fcb    0 #transactions allowed        enddef        enddef          end