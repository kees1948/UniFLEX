        lib     maphndlrs.h        sttl    Map and Mapping Handlers        pag        name    map_handlers        global  swtchu,xmapsp,mapbuf,mapxbf,mapsbf        global  mapupg,mapupg2,instbf        global  mapspg,mapbpt,mapbf2,mapxpt** All routines in this file are machine dependent.* Most of them deal with the memory swapping* scheme.*** swtchu** Switch users top page* kernel stack is replaced!*swtchu  puls   y              get return address        stb    usrtop         set new top page        stb    DATBOX+USRLOC  set map reg        stb    sysmap+USRLOC  set new system map        lds    umark0         reset kernel sp's        jmp    0,y            do return** xmapsp** Map in new user-block which is in B.* Kernel stack is replaced*xmapsp  puls   x              get return address        stb    DATBOX+USRLOC  set new user loc        stb    sysmap+USRLOC  set in system map        stb    usrtop         set user top too ****** ?? ******* 4-11-80        jmp    0,x            return pag** mapbuf** Map a system buffer into SBUFFR space.  On* entry, x is pointing to a system buffer header.*mapbuf  ldd    bfxadr,x       get extended part of addrmapbf2  andb   #%11110000     mask top 4 bits        eorb   DATsense       make bits true        lsld        lsld        lsld        lsld*!* sld 4 shift left 4 timesmapsbf  sta    DATBOX+SBUF    set into SBUFFR        rts                   return** mapbfx** Map a system buffer into XBUFFR space.  On* entry, x is pointing to a system buffer header.*mapbfx  ldd     bfxadr,x        get extended part of address        andb    #%11110000      mask top 4 bits        eorb    DATsense        lsld        lsld        lsld        lsld** mapxbf** Map a user segment into the XBUFFR soace.*  Returns carry set if illegal page.*mapxbf  cmpa   BLKHOL         legal page?        bne    00f            yes - jump        pshs   d,x            no - blow the guy away        ldb    #FALTS        ldx    utask        jsr    xmtint         send SIGNAL to task        puls   d,x        lda    WHTHOL         use a good page        sec        bra    01f*00      clc                  no mapping errors01      sta    DATBOX+XBUF   set into XBUFFR        sta    sysmap+XBUF   save in system map copy        rts                  return** mapspg** Map the segment in B into system space at A offset.*mapspg  pshs   x             save x        ldx    #DATBOX       point to datbox        stb    a,x           set in segment        puls   x,pc          return** mapxpt** Map in buffer in X.  Return X pointing to buffer* in XBUFFER and D has offset.*mapxpt  bsr    mapbfx        map in buffer        ldd    bfadr,x       get address A15...A0        anda   #%00001111    mask out top bits        ldx    #XBUFFR       point to SBUFFR        leax   d,x           point to buffer        rts                  return** mapbpt** Map in buffer in X.  Return X pointing to buffer* in SBUFFER and D has offset.*mapbpt  bsr    mapbuf        map in buffer        ldd    bfadr,x       get address A15...A0        anda   #%00001111    mask out top bits        ldx    #SBUFFR       point to SBUFFR        leax   d,x           point to buffer        rts                  return** mapupg** Return the extended address bits in A:B which* represent the physical address of the virtual* address in D.*mapupg  ldx    #umem         point to memory mapmapupg2 tfr    a,b           save a        andb   #%00001111    mask low 4 bits        pshs   b             save it        lsra                 get segment number index        lsra        lsra        lsra        ldb    a,x           get actual page number        pshs   b             save it        eorb   DATsense        lslb                 get back to bigh nibble        lslb        lslb        lslb        orb    1,s           or in with low part        stb    1,s           save result        puls   d             A=page, B=A15...A8        lsra                 get 4 bits only        lsra        lsra        lsra                 A=A19...A16        rts                  return pag** instbf** Install the next available buffer into the* buffer header pointed to by Y.  Systmp points* to the current segment address and sbpag* has the current segment offset.*instbf  ldx    systmp        point to segment        lda    sbpag         get offset (index)        cmpa   #8            end of segment?        bne    instb2        clr    sbpag         reset to 0 offset (index)        leax   1,x           point to next segment        stx    systmp        save pointerinstb2  clr    bfadr+1,y     low word of address is always 0        ldb    0,x           get segment number        clra                 get into machine dependent form        lsld        lsld        lsld        lsld*!* sld 4        eorb   DATsense        andb   #%11110000        lsl    sbpag         index        orb    sbpag        lsr    sbpag         index        std    bfxadr,y      set in extended address        inc    sbpag         bump offset byte        rts                  return