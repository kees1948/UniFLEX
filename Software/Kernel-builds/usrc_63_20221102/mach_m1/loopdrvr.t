        opt     nol        lib     ../include/blktab.h        lib     ./gendrvr.h        lib     ./loopdrvr.h        opt     lis,exp        if      (LOOP=1)        sttl     loop Driver        pag        name    loopdrvr        global  loopopn,loopcls,loopio        global  lpcopen,lpcclos,lpcspcl        global  loopdt**************************************************************** loop driver, allow a file to be accessed as a block device****************************************************************** Device Tables** dtdfl rmb     2       device buffer fwd link* dtdbl rmb     2       device buffer bwd link* dtqfl rmb     2       device io queue fwd link* dtqbl rmb     2       device io queue bwd link* dtbusy        rmb     1       device busy flag* dtrtry        rmb     1       device error retry count* dtspr rmb     2       device spare byteloopdt   rzb     DVTSIZ          device table*LOOPtbl fdb     0               Block Device Table address** to avoid complicated includes we define part of fdn.h here*ffwdl  equ      0fstat  equ      2fdevic equ      3fnumbr equ      5frefct equ      7fmode  equ      8facces equ      9fdirlc equ      10fouid  equ      11fsize   equ     13*lpcfunc rzb     2       preset function for  ttygetlpcfdev rzb     2       preset device   for  ttyget* Block driver part**************************************************************** open the loop disk drive* B contains device minor* here the devices run from 0 up to max***************************************************************loopopn pshs    d        ldx     #loopopt        cmpb    #1              LPMAX-1        bhi     loopop2         illegal        lda     #LOPSIZ        mul        leax    d,x*        lda     lpflg,x         check status        bita    #LS_BOPN        bne     loopop3         is already open*        bita    #LS_LNKD        beq     loopop2         no secundary file*        ora     #LS_BOPN        set open        sta     lpflg,x        bra     loopop3*loopop2  lda    #EBARG          no image file set         sta    uerrorloopop3  puls    d,pc            retuen**************************************************************** loop close***************************************************************loopcls        ldx     #loopopt        cmpb    #1              LPMAX-1        bhi     loopcl1         illegal        lda     #LOPSIZ        mul        leax    d,x*        lda     lpflg,x        clear open status        anda    #255-LS_BOPN        sta     lpflg,xloopcl1  rts                     return**************************************************************** X = ptr to block device struct* Y = buf header* devices run from 0 up to max***************************************************************loopio  stx     LOOPtbl         save Block Device Table address        inc     loopdt+dtbusy    mark busy*        ldb     bfdvn+1,y        device minor        ldu     #loopopt        lda     #LOPSIZ        mul        leau    d,u             U points to local variables        pshs    u               save reference** U points to local parameter area* bufhdr contains the block address and size of data*        sty     lpbfhi,u        save incoming buff header*        lda     bfflag,y        anda    #BFRWF          1 = read        eora    #BFRWF          0 = read        sta     umaprw          for bmap*        ldd     bfxfc,y        cmpd    #BUFSIZ        lbne    loopbarg** allocate a inode in-core for the image file*        ldd     lpdev,u         set by losetup        ldy     lpfdn,u         same        jsr     asnfdn          allocate an fdn for this        ldu     0,s             restore U        stx     lpfnod,u        save fdn info        lbeq    loopba1         none available        jsr     unlfdn          unlock it** now we have realtime data of our image file* we check the block number againt the size of the* image file*        ldy     lpbfhi,u        input parms        ldx     lpfnod,u        in core fdn        clr     0,-s            lowest byte        ldd     bfblck,y        bit 23...8        pshs    d        ldb     bfblch,y        highest        pshs    b* blocks in stack        bmi     10f             too high        asl     2,s        rol     1,s        rol     0,s             blocks into size        ldd     0,s        cmpd    fsize,x         either end of file reached        bne     11f        ldd     2,s        cmpd    fsize+2,x       or unmatching read-ahead        blo     11f*10      leas    4,s        lda     #EDFUL        sta     uerror        bra     loopdon         not for this one*11      leas    4,s             aux regs** map input block into file block on device*        ldd     lpfnod,u        pshs    d               to 'U'        ldx     lpbfhi,u        input        clra        ldb     bfblch,x        to Y from input        pshs    d               to 'Y'        ldd     bfblck,x        to X from input        pshs    d               to 'X'        puls    x,y,u        jsr     mapfil          translate relative block# in absolute** on return x,y contain the ACTUAL block number on the virtual device* as read-ahead is undiscrimitary against block device* some are filtered out*        beq     loopba1         not available        ldu     0,s             renew U** now we have the absolute block# in Y.X of image device        ldd     lpdev,u        get device* for write we need to copy buffers first        tst     umaprw        beq     03f** write, D=device, Y.X=block allocate new buffer*        jsr     alocbf          get buffer for this device/block#        ldu     0,s        sty     lpbfho,u        to, save local buffer header*        ldx     lpbfhi,u        from        exg     x,y        jsr     cpybuf        ldu     0,s        ldy     lpbfho,u        jsr     wrbuf        bra     doend** read D=device, Y.X=block*03      jsr     rdbuf           into buffer now pointed by Y        lda     bfflag,y        bita    #BFERR        lbne    loopba1*        ldu     0,s        sty     lpbfho,u        from, save local buffer header        ldx     lpbfhi,u        to        jsr     cpybuf        ldu     0,s        ldx     lpbfho,u        jsr     freebf*doend   ldu     0,s        ldx     lpfnod,u        jsr     frefdn        clra                    set status** done, update bufhdr for error return*loopdon leas    2,s             drop U from stack        ldy     loopdt+dtqfl    get last transaction        tsta        beq     01f        lda     bfflag,y        ora     #BFERR        sta     bfflag,y01      clr     loopdt+dtbusy    set unbusy        clr     loopdt+dtrtry    clear funtion        ldx     LOOPtbl        jmp     BDioendloopba1 ldu     0,s              renew U        ldx     lpfnod,u         undo fdn        jsr     frefdnloopbarg lda    #EBARG        sta     uerror        bra     loopdon* character driver part**  character open*  open the /dev/loopctl with minor 0*  A/B = device , Y = FND ptr, single (exclusive) open*lpcopen  equ     *        ldx     #loopopt        tstb        bne     01f*        lda     #LOPSIZ        mul        leax    d,x        lda     lpflg,x        bita    #LS_COPN        bne     02f*lpcop10 ora     #LS_COPN        sta     lpflg,x        bra     05f*02      lda     #EBSY        bra     03f*01      lda     #EBARG03      sta     uerror05      rts** character close**lpcclos  ldx    #loopopt        tstb        bne     02b*        lda     #LOPSIZ        mul        leax    d,x        lda     lpflg,x        anda    #255-LS_COPN        sta     lpflg,x        rts** lopspcl, A,B should be 0, X=ptr. if 0 then set* from usarg0,usarg1,usarg2, else* get to 0,X, 2,X, 4,X (or Y)* this is where the magic is to happen* usarg0 = A=cmd, B= minor to operate on* usarg1 = device for loopfile* usarg2 = fdn for loopfile*lpcspcl pshs    d,x,y,u*        tfr     x,y        cmpy    #0        bne     01f******************************************************* set (usarg0,usarg1,usarg2)******************************************************        ldd     usarg0          A=cmd, B=minor        cmpb    #1              LPMAX-1        bhi     11f        stb     lpcfdev         set device*        ldx     #lsfunc         'set' cmd list        bra     02f******************************************************** get (0,y 1,y 2,y 3,y 4,y 5,y)*******************************************************01      lda     lpcfunc         did a 'set' before        ldx     #lgfunc         'get' cmd list*02      tst     0,x             scan get command table        beq     11f        cmpa    0,x             match command        beq     03f        leax    LPCSIZ,x        bra     02b*03      jsr     [1,x]          do func        bra     10f*11      lda     #EBARG        sta     uerror*10      puls    d,x,y,u,pc**************************************************************************************************************lpcscmd equ     ** commands valid for 'set'lsfunc  fcb     LC_ATCH         attach loopfile        fdb     attachLPCSIZ  equ     *-lsfunc        fcb     LC_DETC         detach loopfile        fdb     detach        fcb     LC_SETG         set command for 'get'        fdb     setgetf        fcb     0      end of list* commands valid for 'get'lgfunc  fcb     LC_STAT        fdb     rptstat        not mounted        fcb     LC_ISFR        fdb     rptstat        fcb     0              end of list*setgetf ldb     usarg0+1      cmd + device        stb     lpcfdev        lda     usarg1        next cmd        sta     lpcfunc        rts*getdev  ldb     lpcfdev     walk table        lda     #LOPSIZ        mul        ldu     #loopopt        leau    d,u        rts* is loopdevice 'busy' i.e. opened?rptstat bsr     getdev*        ldd     lpdev,u file major/minor        std     2,y        ldd     lpfdn,u file fdn        std     4,y        lda     0,u             flags        sta     0,y        ldb     lpcfdev        stb     1,y        rts***************************************************************** 'attach' image file****************************************************************attach  pshs    x,y,u        bsr     getdev*        lda     0,u        bita    #LS_LNKD        already attached        bne     01f*        ora     #LS_LNKD        sta     0,u*        ldd     usarg1          'image' device        std     lpdev,u        ldy     usarg2          'image' fdn        sty     lpfdn,u         make file busy        puls    x,y,u,pc*01      lda     #EBSY03      sta     uerror        puls    x,y,u,pc02      lda     #EBARG        bra     03b***************************************************************** 'detach' image file****************************************************************detach  pshs    x,y,u        bsr     getdev*        lda     0,u        bita    #LS_BOPN       in use?        bne     02b             yes, don't detachdeter1  ldb     #LOPSIZ        tfr     u,x09      clr     0,x+        decb        bne     09b        puls    x,y,u,pc*        endif        end