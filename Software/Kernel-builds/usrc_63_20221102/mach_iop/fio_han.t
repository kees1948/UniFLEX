          lib     ./environment.h        if      ((IOP|UIO)=1)          opt     nol          lib     ../include/macdefs.h          lib     ../include/task.h          lib     ../include/sysdefs.h          lib     ../include/fio_dev.h          lib     ../include/fio.h          lib     ../include/fio_codes.h        data          opt     lis        sttl    FIO RoutinesTRM_IOP equ     NUM_TRM      decouple defined items form global namesu        global  fio_irq,fio_msg        global  TRM_IOP,FIO_FSZ* keep this at zero if you share normal serial ports with IO_CPU portsACT_COST  set     0          Activity cost for IO_CPU transactionfio_wait  fcb     0          Count of tasks waiting for FIO access (global)** fio_irq - Process FIO interrupt, testing for INT already reset the IRQ*   Y - FIO Control structure*fio_irq   pshs    x,y,u          ldu     fio_dba,y          lda     fio_cpu2,u move transaction data (interrupt#)          pshs    a          -- Transaction specific value          clr     ,-s        ** Filler **          lda     fio_cpu1,u                       (terminal#)          pshs    a          -- Sequence #          lda     fio_cpu,u                        (response)          pshs    a          -- Response code          ldx     fio_dsz,y          leax    -FIOTVSZ,x      begin of area on TOP of DPR          addr    U,X        U + X -> X          clr     fio_cpuF,x indicate message received** stack contains resp code, seq#, fil, data, x ,y*          lda     0,s        get response code          cmpa    #R_INTRPT          bne     10f** handle INTERRUPT from tty, now bytes have different meaning*05        ldb     1,s        relative terminal #          jsr     find_dn    compute absolute terminal #          ldx     ttytab     compute TTY table address          lda     #TTYSIZ          mul          leax    d,x          clra          ldb     3,s        get interrupt code          jsr     intrpt send interrupt to this terminal          leas    4,s        clean up stack          bra     99f        exit** 0,s - response code* 1,s - sequence #* 2,s  dummy* 3,s - transaction specific returned value*10        ldb     fio_mxtrn,y   MAX_TRAN          leay    fio_tran,y point to transaction list          pshs    b15        lda     2,s        check transaction #          beq     16f        empty?          cmpa    tran_seq,y match?          beq     20f        yes - go*16        leay    TRAN_SIZ,y next transaction          dec     0,s        any more?          bne     15b* -- Unsolicited response!          leas    5,s        clean up stack          bra     99f        exit*20        puls    b          clean up stack          lda     0,s        get response code          sta     tran_resp,y save response code          lda     3,s        get response value          sta     tran_val,y          leas    4,s        clean up stack          jsr     wakeup     wake up sender99        puls    x,y,u,pc     return** fio_msg - Send a value via the FIO Mailbox & wait for response*   U - maj/min*   D - Value to send (B = Command, A = Specific data)*   Y - FIO control block*   jsr fio_msg*   D - Value returned (B = Error response, A = Specific data)*fio_msg   pshs    cc,d,x,y,u save registers* -- Find an empty transaction box10        seti               turn off interrupts          ldy     5,s        get FIO control address          jsr     MBX_lock   get access to FIO          lbsr    find_slot  go find a slot          beq     15f        jump if one found*          ldy     5,s        restore FIO structure pointer          jsr     MBX_unlock give up FIO until slot available          lbsr    find_slot  make sure no slots available          beq     10b        jump if there is one*          ldy     5,s        get FIO pointer          leay    fio_tflg,y sleep on transaction slots          ldb     #FIOPRI          jsr     Q_sleep    wait for available message slot          bra     10b        try for a transaction slot*15        ldb     utask+1    set sequence # in slot ???          orb     #1          stb     tran_seq,y          ldb     0,s        enable (old) interrupts          tfr     b,cc          pshs    y          save transaction slot pointer          ldb     4,s        restore message code (B)          lda     3,s        restore specific data (A)          exg     d,u          lda     utask+1          ora     #1         set sequence #          stb     tran_dev,y   minor device          exg     d,u          sta     tran_oval,y                         (A)          stb     tran_msg,y                          (B)          ldy     7,s        restore FIO structure pointer          lbsr    fio_send          jsr     MBX_unlock release mailbox*20        puls    y          get transaction slot address          seti               mask interrupts          tst     tran_resp,y any response yet?          bne     30f        yes - go process*          ldx     5,s        get FIO control address          ldd     fio_fifo,x does this task own the FIFO?          bne     25f        yes - don't allow interrupts!*          pshs    y,u        save registers          ldd     umark1     set up to allow interruptable sleep          pshs    d          ldx     #27f       interrupt handling label          pshs    x          sts     umark1          ldb     #TTYIPR    set interruptable priority          jsr     A_sleep    wait for IO_CPU response          puls    d,x,y,u    restore registers          stx     umark1     restore interrupt point          bra     30f        continue*27        puls    x,y,u      Interrupt happened! - (D) already popped          stx     umark1     restore stack mark          lda     #E_ABORT   aborted transaction!          sta     tran_resp,y          ldb     #O_INTRPT          pshs    y          save transaction slot pointer          ldy     7,s        restore FIO control pointer          jsr     MBX_lock   get access to mailbox          jsr     fio_send          jsr     MBX_unlock release mailbox          puls    y          restore transaction slot pointer          bra     30f*25        ldb     #FIOPRI          pshs    x,y,u      save registers          jsr     A_sleep          puls    x,y,u      restore registers*30        ldx     utask          seti               turn off interrupts while fiddling with transaction slots* -- See if there is a response.  It is possible to* -- get here without one if an interrupt happened which* -- was being ignored.  In this case, the IO_CPU doesn't* -- need to be notified of any interrupt, but we must* -- wait for the IO_CPU response to actually arrive.          ldb     tran_resp,y get response code          bne     35f        jump if response present*          pshs    y          reset stack          bra     20b        wait for response*35        clra               release transaction slot          sta     tran_seq,y          clr     tran_resp,y          lda     tran_val,y get response value          std     1,s        set return value (resp val,resp. code)          ldy     5,s        wake anybody waiting for this slot          leay    fio_tflg,y          jsr     wakeup          lda     2,s        interrupted transaction?          cmpa    #E_ABORT          bne     50f        no - continue*          lds     umark1     yes - get out          rts*50        puls    cc,d,x,y,u,pc return** generic FIO routines*** Q_sleep - Sleep until event with decreased activity*Q_sleep   jmp     sleep** A_sleep - Sleep until event with no decrease in activity*A_sleep   jsr     sleep      wait for event          pshs    a,x        upgrade activity          ldx     utask          lda     tsact,x          adda    #ACT_COST          bcc     00f*          lda     #$FF*00        sta     tsact,x          puls    a,x,pc        else        datafio_wait  fcb     0          Count of tasks waiting for FIO access (global)          endif*       if      ((IOP|UIO|ECN)=1)        if      ((IOP|UIO)=1)        global  fio_send,FIFO_get,FIFOgeta,FIFO_put,FIFOputa        global  MBX_lock,MBX_unlock,find_slot        global  get_F_S,FIFO_put,FIFO_get,FIFO_unlock** fio_send - Send a message via the FIO Mailbox*   Y - FIO control block*   B - Message code to send (one byte)*   A - Message specific data*   U - Sequence #/Terminal #*   bsr fio_send*fio_send pshs   cc,d,x,u        save register        ldu     fio_dba,y        seti                    mask interrupts!        LEDON   LB_FIO0        stb     cpu_fio,u         set up mailbox value        sta     cpu_fio2,u        message specific data        ldd     5,s              (old U) sequence #/terminal #        sta     cpu_fio1,u        stb     cpu_fio3,u        lda     #$FF            tell IO_CPU mailbox full        ldx     fio_dsz,y        leax    -FIOTVSZ,x* X will be used where U can't        addr    X,U             X + U > U        sta     cpu_fioF,u         let the IO_CPU know it's there* LOOP until IO_CPU consumes malibox05      ldx     #$FFFF          time-out counter10      lda     cpu_fioF,u      wait till value consumed        beq     20f             jump if consumed        leax    -1,x            time-out yet?        bne     10b        bra     05b             try again20        LEDOFF  LB_FIO0        puls    cc,d,x,u,pc** FIFO_get - Fetch character from FIFO*   Y - FIO control block*   B - Character fetched*FIFOgeta pshs   b        bsr     FIFO_get        puls    a        exg     a,b        rts**   Y - FIO control block*-- Pointers in FIFO are relative to 0*FIFO_get pshs cc,x,y,u        seti                    -- interrupts must be masked        ldu     fio_dba,y       point to hardware        ldb     fifo_cnt,u      any data?        beq     99f             no - exit*        decb                    yes - adjust count        stb     fifo_cnt,u        ldx     fifo_get,u      get consumer pointer        pshs    x        addr    U,X             U+X => X        ldb     fifo,x          fetch byte        puls    x        leax    1,x             bump pointer        cmpx    fio_fsz,y       end of fifo?        blo     10f*        ldx     #0              reset pointer*10      stx     fifo_get,u*99      puls    cc,x,y,u,pc** FIFO_put - Place character into FIFO*   Y - FIO control block*   B - Character fetched*FIFOputa pshs   b        tfr     a,b        bsr     FIFO_put        puls    b,pc**   Y - FIO control block*FIFO_put pshs   cc,x,u        seti                    -- interrups must be masked        ldu     fio_dba,y       point to hardware        ldx     fifo_put,u      get consumer pointer        pshs    x        addr    U,X             U + X => X        stb     fifo,x          store byte        puls    x        leax    1,x             bump pointer        cmpx    fio_fsz,y       end of fifo?        blo     10f        ldx     #0              reset pointer*10      stx     fifo_put,u        inc     fifo_cnt,u      update count*99      puls    cc,x,u,pc** find_slot - find a transaction slot*   Y - FIO control address*   jsr find_slot*   Y - Transaction slot*   <NE> if none available*find_slot pshs    d,y      save register          ldb     fio_mxtrn,y  MAX_TRAN          leay    fio_tran,y point to transactions          tstb          pshs    b          beq     40f* look for OUR slot first10        lda     utask+1    check for busy entries          ora     #1          cmpa    tran_seq,y          beq     30f        yes - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     10b*          ldy     3,s        restore FIO pointer          ldb     fio_mxtrn,y  MAX_TRAN          leay    fio_tran,y point to transactions          stb     0,s          beq     40f* next search free slot20        lda     tran_seq,y entry busy?          beq     30f        no - use it!          leay    TRAN_SIZ,y          dec     0,s        any more?          bne     20b*40        lda     #1         return NE - no slot          bra     99f*30        sty     3,s        return slot          clra               return EQ - slot found*99        leas    1,s        remove counter          puls    d,y,pc     clean stack & return**  get_F_S - Allocate a transaction slot and the FIFO*    Y - FIO control*get_F_S   pshs    cc,d,x,y,u save registers          seti    mask       interrupts          jsr     find_slot  allocate transaction slot          beq     10f        jump if one found*          ldy     5,s        wait for slot          leay    fio_tflg,y          ldb     #FIOPRI          jsr     Q_sleep          puls    cc,d,x,y,u restore registers          bra     get_F_S    try again*10        ldb     utask+1    "allocate" slot          orb     #1          stb     tran_seq,y          puls    cc,d,x,y,u restore interrupts/registers          jmp     FIFO_lock  lock FIO access** MBX_lock - Lock the FIO interface*    Y - FIO Control address*MBX_lock  pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     fio_mbx,y  mailbox already locked?          beq     10f        no - go check FIFO*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     fio_fifo,y FIFO locked?          beq     50f        no - go lock mailbox*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        inc     fio_wait          ldb     #FIOPRI          pshs    y          preserve register          jsr     Q_sleep    yes - sleep until available          puls    y          restore register          dec     fio_wait          puls    cc,d,x,y,u restore environ          bra     MBX_lock   try again*50        ldd     tstid,x    lock mailbox          std     fio_mbx,y          clr     fio_ict,y  no missed interrupts*99        puls    cc,d,x,y,u,pc return** MBX_unlock - unlock the FIO interface**    Y - FIO Control address*MBX_unlock pshs    cc,d,x,y,u          seti               turn off interrupts          lda     fio_ict,y  did we miss an interrupt?          beq     05f        no - continue*          jsr     fio_irq    yes - pretend we're seeing it now!*05        clr     fio_ict,y  reset flag          ldd     #0          std     fio_mbx,y  reset lock          jsr     wakeup     wake up anybody waiting on this FIO          ldy     5,s        restore pointer          lda     fio_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return** FIFO_lock - Lock the FIO FIFO buffer*    Y - FIO Control address*FIFO_lock pshs    cc,d,x,y,u save registers          seti    mask       interrupts          ldx     utask      get task pointer          ldd     fio_fifo,y FIFO locked?          beq     10f        no - go check mailbox*          cmpd    tstid,x    locked by me?          bne     20f        no - must wait*10        ldd     fio_mbx,y  mailbox already locked?          beq     50f        no - go lock FIFO*          cmpd    tstid,x    locked by me?          beq     50f        yes - still OK*20        ldb     #FIOPRI          inc     fio_wait   mark somebody waiting          pshs    y          save pointer          jsr     Q_sleep    yes - sleep until available          puls    y          restore pointer          dec     fio_wait          puls    cc,d,x,y,u restore environ          bra     FIFO_lock  try again*50        ldd     tstid,x    lock FIFO          std     fio_fifo,y*99        puls    cc,d,x,y,u,pc return** FIFO_unlock - unlock the FIO FIFO buffer**    Y - FIO Control address*FIFO_unlock pshs    cc,d,x,y,u          seti               turn off interrupts          ldd     #0          std     fio_fifo,y reset lock          jsr     wakeup     wake up anybody waiting on this FIFO          ldy     5,s        restore pointer          lda     fio_wait   was anybody waiting?          beq     10f        no - exit          ldx     utask      reset priority          jsr     fixpri          jsr     change     let somebody else run*10        puls    cc,d,x,y,u,pc return          endif          end