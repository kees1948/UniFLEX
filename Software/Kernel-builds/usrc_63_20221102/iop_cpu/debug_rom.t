          ttl     SWTPc      IOP Debug ROM          sttl    Hardware   Definitions          abs               pag               lib     environment          sttl    System     Debug Code          pag     USE_8274  set     0         TEST_PORT set     0         TEST_ONLY set     0         TEST_ROM  set     0                   if      TEST_ROM            org     $FFF0               fdb     DB_main             fdb     DB_main             fdb     DB_main             fdb     DB_main             fdb     DB_main             fdb     DB_main             fdb     DB_main             fdb     DB_main             org     ROMorg              else              org     DEBUGROM            endif   ** Vector of entry points*          fdb     $1234      -- ROM present flag          fdb     DB_main    Interractive debug monitor          fdb     DB_pdata            fdb     DB_phex             fdb     DB_phex2            fdb     DB_pcrlf            fdb     DB_check            fdb     DB_config           sttl    Debug      Routines          pag     ** Debug driver*DB_main             if      TEST_ROM            seti    turn       off interrupts          if      TEST_PORT *-- Brute force characters          if      USE_8274            ldx     #SYS_8274           lda     #$18       reset channel A          sta     2,x                 mul               mul               mul               ldu     #syscnf    point to configure string10        lda     0,u+       get byte          beq     20f        end of list?          sta     2,x        send to port          lda     0,u+       get byte          sta     2,x                 bra     10b        repeat20        lda     #$10       finish config          sta     2,x       30        lda     #$20      40        ldb     #$10       do port setup          stb     2,x                 ldb     2,x                 bitb    #$04       xmit busy?          beq     40b                 sta     0,x        output char          ldb     #80       45        decb              bne     45b                 inca              cmpa    #$7E                bne     40b                 if      TEST_ONLY           bra     30b                 endif             else              ldx     #SYS_ACIA  -- Initialize ACIA          lda     #$03                sta     csr,x               mul               mul               lda     #$15                sta     csr,x     10        ldb     #$20      20        lda     csr,x               bita    #ACTBSY             beq     20b                 stb     dbuf,x              incb              cmpb    #$7E                bne     20b                 if      TEST_ONLY           bra     10b                 endif             endif             endif             lds     #ROMstack           clr     DB_iflg             endif             pshs    cc,d,x,y,u save all registers          ldx     #00f                lbsr    DB_pdata  10        ldx     #01f       print prompt          lbsr    DB_pdata            lbsr    DB_inch    get character          pshs    a          save character          lda     #'         let the guy know I saw it          lbsr    DB_putch            puls    a          restore character          ldy     #DB_cmds   process command20        tst     0,y        end of table?          beq     30f        yes - error          cmpa    0,y        command match?          bne     25f        no - try next one          jsr     [1,y]      yes - go process it          bra     10b        next command25        leay    3,y        next command entry          bra     20b       30        ldx     #02f       illegal command          bsr     DB_pdata            bra     10b       *00        fcc     $d,'IOP Debug',001        fcc     $d,'>>',0 02        fcc     ' ??',0** Debug command table*DB_cmds             fcb     'Q         Quit - return to normal operation          fdb     quit                fcb     'E         Examine system memory          fdb     examine             fcb     'M         Modify system memory          fdb     modify              fcb     'T         Dump TTY Tables          fdb     dmp_tty             fcb     'S         Dump Task tables          fdb     dmp_task            fcb     'R         Print registers at time of entry to IOP DEBUG          fdb     dmp_regs            fcb     'D         Change display parameters          fdb     display             fcb     'C         Display configuration          fdb     DB_config           fcb     'N         Dump NEC tables          fdb     dmp_nec             fcb     'H         Print transaction history          fdb     prt_hist            fcb     0          end of table* -- Quit debug modequit      puls    x          return address from command processor          puls    cc,d,x,y,u,pc return to interrupt context** This file contains routines for debug purposes.*DB_init   pshs    d,x        save registers          tst     DB_iflg    terminal initialized?          bne     99f        yes - exit          lda     #1                  sta     DB_iflg             if      USE_8274            ldx     #SYS_8274           lda     #$18       reset channel A          sta     2,x                 pshs    d,x,y,u    delay some here          mul               mul               mul               puls    d,x,y,u             pshs    u          save u reg          ldu     #syscnf    point to configure string10        lda     0,u+       get byte          beq     20f        end of list?          sta     2,x        send to port          lda     0,u+       get byte          sta     2,x                 bra     10b        repeat20        lda     #$10       finish config          sta     2,x                 puls    u          reset u reg          else              ldx     #SYS_ACIA           lda     #$03       reset code          sta     csr,x               lda     #$15+ENBRIN config byte          sta     csr,x               endif   99        puls    d,x,pc              if      USE_8274  syscnf    fcb     $01,$00,$02,$04,$04,$4c,$03,$c1,$05,$ee,$00          endif   * Print character in (A) on debug portDB_putch  pshs    d,x                 bsr     DB_init    initialize terminal if necessary          if      USE_8274            ldx     #SYS_8274 10        ldb     #$10       do port setup          stb     2,x                 ldb     2,x                 bitb    #$04       xmit busy?          beq     10b                 sta     0,x        output char          else              ldx     #SYS_ACIA 10        ldb     csr,x      get acia status          bitb    #ACTBSY    xmit busY?          beq     10b                 sta     dbuf,x     output char          endif             puls    d,x,pc    * Print string (pointed to by X) on debug portDB_pdata  pshs    d,x       10        lda     ,x+        get next character          beq     99f        exit at end of string          cmpa    #CR        map carriage returns to CR/LF          bne     15f                 bsr     DB_putch            lda     #NL        send LF15        bsr     DB_putch            bra     10b       99        puls    d,x,pc     return* Print character in (A) in HexDB_phex   pshs    d,x                 ldx     #00f       string of nibbles          lsra              lsra              lsra              lsra              lda     a,x                 bsr     DB_putch   print character          lda     0,s                 anda    #$0F                lda     a,x                 bsr     DB_putch   print character          puls    d,x,pc    *00        fcc     '0123456789ABCDEF' * Print the value in (D) in HexDB_phex2  pshs    d           bsr     DB_phex print (A)          lda     1,s                 bsr     DB_phex    print (B)          puls    d,pc       return* Print a spaceDB_outsp  lda     #'                  bra     DB_putch  ** Read & Echo one character*   DB_inch - Character in A*DB_inch   pshs    x          save registers          if      USE_8274            ldx     #SYS_8274 10        lda     2,x        data available?          bita    #1                  beq     10b                 lda     0,x        fetch character          else              ldx     #SYS_ACIA  get port address10        lda     csr,x      wait for character present          bita    #ACRBSY             beq     10b                 lda     dbuf,x     get character          endif             anda    #$7F       strip parity          cmpa    #'a        map lower case -> upper case          blo     20f                 anda    #!$20     20        puls    x          restore register          bra     DB_putch   print character** DB_check - Check for special conditions*   jsr DB_check*   CS if ^C*   Also handles escape for hold mode*DB_check  pshs    a,x                 if      USE_8274            ldx     #SYS_8274 10        lda     2,x        data available?          bita    #1                  beq     95f                 lda     0,x        fetch character          else              ldx     #SYS_ACIA  get port address10        lda     csr,x      wait for character present          bita    #ACRBSY             beq     95f                 lda     dbuf,x     get character          endif             cmpa    #$03       Control-C?          beq     90f                 cmpa    #$1B       escape = HOLD output          bne     95f        no - ingore it* -- wait for another escape          if      USE_8274            ldx     #SYS_8274 20        lda     2,x        data available?          bita    #1                  beq     20b                 lda     0,x        fetch character          else              ldx     #SYS_ACIA  get port address20        lda     csr,x      wait for character present          bita    #ACRBSY             beq     20b                 lda     dbuf,x     get character          endif             cmpa    #$1B       wait for escape          bne     20b                 bra     95f        exit - no ^C90        sec     --         Control-C exit          bra     99f       95        clc     99        puls    a,x,pc    ** Dump a range of memory (X..Y)*DB_dump   pshs    d,x,y,u   ** Print one line (16 bytes) of data*10        lbsr    DB_pcrlf   start a new print line          ldd     2,s        print address          lbsr    DB_phex2            ldb     #2                  lbsr    spaces              ldx     2,s                 ldb     #16        print 16 bytes          pshs    b         20        lda     ,x+        get next byte to print          lbsr    DB_phex             lbsr    DB_outsp            dec     0,s        done?          bne     20b        no - go back          ldx     1+2,s      now print characters          ldb     #2                  lbsr    spaces              ldb     #16                 stb     0,s       30        lda     ,x+        get next byte          cmpa    #$20       printable?          blo     35f        no          cmpa    #$7F                blo     40f        go print character35        lda     #'.        print period for unprintable40        lbsr    DB_putch   print character          dec     0,s        done?          bne     30b                 leas    1,s        clean up stack          lbsr    DB_check   see if abort          bcs     99f        exit if so          stx     2,s        update address          cmpx    4,s        any more?          bls     10b        yes - go to it99        lbsr    DB_pcrlf            puls    d,x,y,u,pc return** DB_pcrlf - print carriage return/line feed*DB_pcrlf  pshs    d,x        save registers          ldx     #CRLF               lbsr    DB_pdata            puls    d,x,pc     returnCRLF      fcc     $d,0           sttl    DEBUG - Memory Modify Command          pag     ** Modify system memory*modify              leas    -2,s       reserve temp space          lbsr    DB_getadr  get starting address          bcs     mod99      exit if error          std     0,s        save address*mod10     ldx     #modm00             lbsr    DB_pdata            ldd     0,s        print address          lbsr    DB_phex2            lbsr    DB_outsp            ldx     0,s        get byte address          lda     0,x        get value          pshs    a          save current value          lbsr    DB_phex    output it          lbsr    DB_outsp   print a space          lbsr    DB_gethex  get a hex digit          bcs     mod30      jump if error          asla              asla              asla              asla              sta     0,s        update value          lbsr    DB_gethex  get second hex digit          bcs     mod40      exit if error          ora     ,s+        compute total valuemod20     ldx     0,s        get memory address          sta     ,x+        update memory          stx     0,s        update address          bra     mod10      continue with next byte*mod30     cmpa    #'.        is it "go on" char?          bne     mod40      no - exit          puls    a          restore original value          bra     mod20      yes - move to next address*mod40     leas    1,s        clean up stackmod99     puls    x,pc       return*modm00    fcc     $d,' - ',0          sttl    Memory     Examine Command          pag     ** Examine memory (system)*examine             leas    -4,s       reserve temp space          lbsr    DB_getadr  get low address          bcs     99f                 std     0,s        save low limit          lda     #'-                 lbsr    DB_putch            lbsr    DB_getadr  get high address          bcs     99f                 std     2,s        save high limit          puls    x,y        get limit registers          lbsr    DB_dump    go dump memory          rts     exit      99        puls    x,y,pc     return - error** get 4 hex digit address*   return value in D*DB_getadr ldb     #4         number of digits          pshs    b                   ldd     #0         starting value          pshs    d         10        lbsr    DB_gethex  get a hex digit (in B)          bcs     90f        jump if error          pshs    a                   ldd     1,s        fix up value          aslb              rola              aslb              rola              aslb              rola              aslb              rola              orb     ,s+                 std     ,s                  dec     2,s        done?          bne     10b                 clc     90        puls    d          get value          leas    1,s        clean up stack          rts     return    ** DB_gethex - get one hex digit*DB_gethex lbsr    DB_inch    read character          cmpa    #'0        check for legal digit          blo     90f                 cmpa    #'9                 bls     10f                 cmpa    #'A        legal digit?          blo     90f        no - error          cmpa    #'F                 bhi     90f                 adda    #9         add bias10        anda    #$0F       strip ASCII stuff          clc               rts     all        done - no error90        sec     illegal             rts     exit                sttl    Dump       TTY Tables          pag     ** dmp_tty - dump TTY table*dmp_tty   pshs    d,x,y,u             ldy     TTYTABS    TTY table base address          lda     NUM_TRM    # TTYs in system          pshs    a                   ldx     #00f                lbsr    DB_pdata  10        lbsr    DB_check   get out?          lbcs    20f                 lbsr    DB_pcrlf            tfr     y,d        table address          lbsr    DB_phex2            lbsr    spc_2               ldd     tqin,y              lbsr    DB_phex2            ldx     #04f                lbsr    DB_pdata            lda     [tqin,y]            lbsr    DB_phex             lbsr    spc_2               ldd     tqout,y             lbsr    DB_phex2            ldx     #04f                lbsr    DB_pdata            ldd     [tqout,y]           lbsr    DB_phex2            lbsr    spc_2               lda     tflags,y            lbsr    DB_phex             lbsr    spc_2               ldd     tstate,y            lbsr    DB_phex2            lbsr    spc_2               ldd     tsold,y             lbsr    DB_phex2            leay    TTYSIZ,y   next entry          dec     0,s        any more tables?          bne     10b       20        puls    a          clean stack99        puls    d,x,y,u,pc*00        fcc     $d,'TTY In Q Out Q Flag State Sold',004        fcc     '/',0           sttl    Dump Task Tables          pag     ** dmp_tasks - Print task tables*dmp_tasks pshs    d,x,y,u             ldx     #00f                lbsr    DB_pdata            lbsr    DB_pcrlf            lda     #1         1=Busy, 0=Free          pshs    a         05        ldy     tsktab    10        lda     tsstat,y   get task state          tst     0,s        free or busy tasks?          beq     11f        jump for free          cmpa    #TFREE     skip free tasks this time          beq     20f                 bra     12f        go print info11        cmpa    #TFREE     skip non-free tasks this time          bne     20f       12        tfr     y,d                 lbsr    DB_phex2            lbsr    spc_2               ldd     tsstat,y            lbsr    DB_phex2            bsr     spc_2               ldu     umark0,y            lda     tsstat,y   task sleeping?          cmpa    #TSLEEP             bne     13f        no          ldd     0+7,u      PC - in sleep          bra     15f       13        ldd     0,u        PC - from interrupt15        lbsr    DB_phex2            bsr     spc_2               ldd     tsevnt,y            lbsr    DB_phex2   event          bsr     spc_2               lda     tsdev,y             lbsr    DB_phex             bsr     spc_2               lda     tscmd,y             lbsr    DB_phex             bsr     spc_2               lda     tsseq,y             lbsr    DB_phex             bsr     spc_4               lda     tstval,y            lbsr    DB_phex             lbsr    DB_pcrlf  20        leay    TSKSIZ,y            lbsr    DB_check            bcs     25f                 cmpy    tskend              bne     10b                 dec     0,s        next pass          bpl     05b       25        puls    a          clean stack99        puls    d,x,y,u,pc00        fcc     $d,'Task State PC Event TTY CMD SEQ# VAL',001        fcc     ' ',0spc_2     ldx     #01b                lbra    DB_pdata  *spc_4     bsr     spc_2               bra     spc_2               sttl    Dump       IOP Registers          pag     dmp_regs            ldx     #00f                jsr     DB_pdata            leay    2,s        point to stacked regs          lda     ,y+        CC          jsr     DB_phex             ldx     #01f                jsr     DB_pdata            ldd     ,y++       D          jsr     DB_phex2            ldx     #02f                jsr     DB_pdata            ldd     ,y++       X          jsr     DB_phex2            ldx     #03f                jsr     DB_pdata            ldd     ,y++       Y          jsr     DB_phex2            ldx     #04f                jsr     DB_pdata            ldd     ,y++       U          jsr     DB_phex2            ldx     #05f                jsr     DB_pdata            tfr     y,d                 jsr     DB_phex2            ldx     #06f                jsr     DB_pdata            ldd     ,y++       D          jsr     DB_phex2            rts     *00        fcc     $d,'CC = ',001        fcc     ', D = ',002        fcc     ', X = ',003        fcc     ', Y = ',004        fcc     ', U = ',005        fcc     ', S = ',006        fcc     ', PC = ',0          sttl    Set/Change Display Parameters          pag     ** Set/Change Display parameters*display             ldy     #DEBUG_tbl cycle through all flags00        ldx     2,y        get string          jsr     DB_pcrlf            jsr     DB_pdata            ldd     0,y        get flag byte          bsr     disp_YN    get/set yes/no answer          bcs     00b        retry if error          leay    4,y        next entry          cmpy    #DEBUG_end          bne     00b                 rts     *disp_YN   pshs    d,x,y,u             anda    DB_cntrl   see if flag is set          andb    DB_cntrl+1          pshs    b                   ora     ,s+                 bne     10f                 ldx     #00f       'N'          bra     20f       10        ldx     #01f       'Y'20        jsr     DB_pdata            jsr     DB_inch    get response          cmpa    #CR        -- leave alone          beq     90f                 cmpa    #'Y        -- set flag          beq     30f                 cmpa    #'N        -- reset flag          beq     40f                 sec     --         illegal character          bra     99f       30        ldd     0,s        set flag          ldx     #DB_cntrl           ora     ,x                  sta     ,x+                 orb     ,x                  stb     ,x+                 bra     90f       40        ldd     0,s        reset flag          coma              comb              ldx     #DB_cntrl           anda    ,x                  sta     ,x+                 andb    ,x                  stb     ,x+       90        clc     -          valid input99        puls    d,x,y,u,pc*00        fcc     ' (N)? ',001        fcc     ' (Y)? ',0*DEBUG_tbl           fdb     DBG_SYS,00f          fdb     DBG_8274,01f          fdb     DBG_INT,02f          fdb     DBG_TRMI,03f          fdb     DBG_IO,04f          fdb     DBG_HAN,05f          fdb     DBG_SLP,06f          fdb     DBG_TASK,07f          fdb     DBG_CMD,08f          fdb     DBG_MSG,09f          fdb     DBG_INIT,10f          fdb     DBG_OPEN,11fDEBUG_end *00        fcc     'Debug system (scheduler, etc)',001        fcc     'Debug PORT drivers',002        fcc     'Debug Interrupt routine',003        fcc     'Debug terminal interrupts',004        fcc     'Debug I/O Main routine',005        fcc     'Debug terminal handler',006        fcc     'Debug Sleep/Wakeup',007        fcc     'Debug tasking',008        fcc     'Debug I/O tasks',009        fcc     'Debug high level messages',010        fcc     'Print initialization messages',011        fcc     'Debug Open actions',0          sttl    Display    System Configuration          pag     DB_config           ldx     #00f                lbsr    DB_pdata            ldx     #01f                lbsr    DB_pdata            lda     NUM_TSK             lbsr    DB_phex             ldx     #02f                lbsr    DB_pdata            lda     NUM_TRM             lbsr    DB_phex             ldx     #06f                lbsr    DB_pdata            lda     NUM_PPR             lbsr    DB_phex             ldx     #03f                lbsr    DB_pdata            lda     NUM_CL              lbsr    DB_phex             ldx     #04f                lbsr    DB_pdata            ldd     OBUF_SIZE           lbsr    DB_phex2            ldx     #05f                lbsr    DB_pdata            ldd     #RAMend+1           subd    tskend              lbsr    DB_phex2            ldx     #10f                jsr     DB_pdata            ldy     #slot_tbl           ldu     #BASE_SLOT          lda     #NUM_SLOTS          pshs    a         50        lbsr    DB_pcrlf            lbsr    spc_2               lda     #NUM_SLOTS          suba    0,s                 lbsr    DB_phex             lbsr    spc_2               tfr     u,d                 lbsr    DB_phex2            lbsr    spc_2               ldx     0,y++               lbsr    DB_pdata            leau    NEXT_SLOT,u          dec     0,s                 bne     50b                 puls    a                   rts     *00        fcc     $d,'IOP Configuration:',001        fcc     $d,' Number of tasks = $',002        fcc     $d,' Number of terminals = $',006        fcc     $d,' Number of printers = $',003        fcc     $d,' Number of CLISTs = $',004        fcc     $d,' Output buffer size = $',005        fcc     $d,' Unused memory = $',010        fcc     $d,' Slot Address Type',0          sttl    Display    NEC Control Tables          pag     00        fcc     ' = ',0dmp_nec             ldu     NECstr     get pointer to NEC structure          cmpu    #0                  beq     99f        jump if none          ldy     #NEC_tbl            clrb    10        lda     ,y         get offset          cmpa    #$FF                beq     99f        exit          pshs    b                   tstb              bne     12f                 jsr     DB_pcrlf  12        ldx     2,y        get string name          jsr     DB_pdata            ldx     #00b                jsr     DB_pdata            lda     0,y        get offset          ldb     1,y        get size          cmpb    #1                  bne     15f                 lda     a,u        get value          jsr     DB_phex             jsr     spc_2               bra     20f       15        ldd     a,u        get value          jsr     DB_phex2  20        leay    4,y        next table entry          puls    b                   comb              bra     10b       99        rts     *NEC_tbl             fcb     necarg0,2           fdb     00f                 fcb     necarg1,2           fdb     01f                 fcb     necarg2,2           fdb     02f                 fcb     necpos,2            fdb     03f                 fcb     necold,2            fdb     04f                 fcb     carage,2            fdb     05f                 fcb     necfps,2            fdb     06f                 fcb     nectrc,2            fdb     07f                 fcb     necssp,2            fdb     08f                 fcb     necsfp,2            fdb     09f                 fcb     necsnd,2            fdb     10f                 fcb     necsct,1            fdb     11f                 fcb     necbsy,1            fdb     12f                 fcb     necflg,1            fdb     13f                 fcb     neclef,1            fdb     14f                 fcb     necpch,1            fdb     15f                 fcb     necdep,1            fdb     16f                 fcb     necfrm,1            fdb     17f                 fcb     necwid,1            fdb     18f                 fcb     pitch,1             fdb     19f                 fcb     depth,1             fdb     20f                 fcb     margin,2            fdb     21f                 fcb     frmlen,2            fdb     22f                 fcb     normal,2            fdb     23f                 fcb     rtlimt,2            fdb     24f                 fcb     $FF        -- End of table00        fcc     'necarg0',0 01        fcc     'necarg1',0 02        fcc     'necarg2',0 03        fcc     'necpos ',004        fcc     'necold ',005        fcc     'carage ',006        fcc     'necfps ',007        fcc     'nectrc ',008        fcc     'necssp ',009        fcc     'necsfp ',010        fcc     'necsnd ',011        fcc     'necsct ',012        fcc     'necbsy ',013        fcc     'necflg ',014        fcc     'neclef ',015        fcc     'necpch ',016        fcc     'necdep ',017        fcc     'necfrm ',018        fcc     'necwid ',019        fcc     'pitch ',020        fcc     'depth ',021        fcc     'margin ',022        fcc     'frmlen ',023        fcc     'normal ',024        fcc     'rtlimt ',0          sttl    History    Transaction Queue Output          pag     prt_hist            ldx     #00f                jsr     DB_pdata            ldy     hstptr    10        jsr     DB_pcrlf            ldb     #7                  bsr     spaces              lda     hst_cmd,y           jsr     DB_phex             ldb     #8                  bsr     spaces              lda     hst_seq,y           jsr     DB_phex             ldb     #6                  bsr     spaces              lda     hst_tty,y           jsr     DB_phex             ldb     #7                  bsr     spaces              lda     hst_val,y           jsr     DB_phex             leay    HRECSIZ,y           cmpy    #hstptr             blo     20f                 ldy     #hstbuf   20        cmpy    hstptr     all Queue printed?          bne     10b                 rts     *00        fcc     $d,'Transaction History:'          fcc     $d,' Cmd/Resp Seq # TTY # Value',0** Print (B) spaces*spaces              lbsr    DB_outsp            decb              bne     spaces              rts     