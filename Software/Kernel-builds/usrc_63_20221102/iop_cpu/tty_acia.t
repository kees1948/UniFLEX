          sttl    ACIA       interface routines          pag* The routines in this file are specific to an ACIA (6850).* They are called from the "ttyhan" and "ttydrv" files.** 6850 Device table*DEV_6850          fdb     bad_cmd    0 -          fdb     open_tty   1 -          fdb     close_tty  2 -          fdb     ttyset     3 -          fdb     ttyget     4 -          fdb     req_write  5 -          fdb     write_data 6 -          fdb     wrt_sc     7 -          fdb     req_read   8 -          fdb     read_data  9 -          fdb     bad_cmd    10 -          fdb     get_pdat   11 -          fdb     set_pdat   12 -          fdb     bad_cmd    13 -          fdb     bad_cmd    14 -          fdb     bad_cmd    15 -  * clock_on          fdb     SR4_IRQ          fdb     SR4_init          fdb     SR4_test*          fdb     SR4ttconf          fdb     SR4ttputc          fdb     SR4ttgetc          fdb     SR4ttnxr          fdb     SR4ttdisx          fdb     SR4ttnr          fdb     SR4ttnx          fdb     SR4ttnno          fdb     SR4ttxbsy          fdb     SR4ttstx          fdb     SR4ttiscts          fdb     SR4ttstr          fdb     SR4ttstb          fdb     SR4ttsts          fdb     SR4ttstc          fdb     SR4ttstd          fdb     SR4ttste          fdb     SR4ttnd          fdb     SR4ttwcts          fdb     SR4ttwdcd** preset table for baudrates at each port** baudrate latch backup bytes, for 2 acia's each** CB B2 B1 B0 CA A2 A1 A0       C=/CTS override, 0 = active* X2 X1 X0 are baudrate select bits 0K3/0K6/1K2/2K4/4K8/9K6/19K2/38K4* 111 is highest baudrate, 000 is lowest.*brbupr    fcb     $77           acia 0 and 1 board 1          fcb     $77           acia 2 and 3          fcb     $77           acia 4 and 5 board 2          fcb     $77           acia 6 and 7          fcb     $77           acia 8 and 9 board3          fcb     $77           acia 10 and 11BRTBSIZ   equ     *-brbupr          if      BRTBSIZ<(MAX_TTY/2)          err     "tty baudrate table mismatch, correct table"          endif** Check for and process an ACIA interrupt*  D - Device #*  X - Device address*SR4_IRQ    pshs    d,x,y,u    save registers just in case          lda     csr,x      check for interrupt          bita    #AS_IRQ          beq     10f        jump if no interrupt*          clrb          pshs    d*          ldd     2,s        restore device #          jsr     tintr      go process interrupt          leas    2,s        remove device status          sec     --         interrupt processed          bra     99f*10        clc     --         no interrupt processed*99        puls    d,x,y,u,pc** Initialize ACIA port*   B - Device #*   X - Device address*SR4_init   pshs    d,x,y,u          clr     2,x        init baudrate latch          lda     #AC_DRTS+AC_MRES   set up reset code          sta     0,x        reset acia          pshs    d          delay          puls    d          puls    d,x,y,u,pc** Determine if CPU09SR4 ACIA board is present*  D - ACIA port address*  Y - Device table address*  <CS> if present & ACIA*SR4_test   pshs    d,x,u          tfr     d,u          lda     #AC_DRTS+AC_MRES   set up reset code          sta     0,u        reset acia          pshs    d          delay          puls    d          lda     0,u        check response          beq     00f*          anda    #%11110011 todo: bit names          beq     00f*          clc     --         not an 6350          bra     99f** found an ACIA, fill in the port info*00        lda     NUM_TRM    compute device table address          ldb     #DEV_SIZE          mul          ldy     #dev_tab          leay    d,y          lda     NUM_TRM          rora               2 ports for each baudrate backup          ldu     #brbutb    address of table          leau    a,u* account for 4 ports CPU09SR4          ldb     NUM_TRM          addb    #4          stb     NUM_TRM*          ldd     0,s          port address          ldx     #DEV_6850          std     dev_addr,y   device address          stx     dev_type,y   handler dispatch table          stu     dev_brbu,y   baudrate latch backup          pshs    a          lda     (brbupr-brbutb),u  get rom preset          sta     0,u          puls    a          leay    DEV_SIZE,y          addd    #4            offset to next ACIA          std     dev_addr,y          stx     dev_type,y          stu     dev_brbu,y          leay    DEV_SIZE,y          addd    #4          leau    1,u          next backup location          std     dev_addr,y          stx     dev_type,y          stu     dev_brbu,y          pshs    a          lda     (brbupr-brbutb),u  get rom preset          sta     0,u          puls    a          leay    DEV_SIZE,y          addd    #4          std     dev_addr,y          stx     dev_type,y          stu     dev_brbu,y          leay    DEV_SIZE,y          sec99        puls    d,x,u,pc** ttconf** Configure the port pointed at by the Y register.  The X* register is pointing to the terminal table.  All registers* except D should be preserved.*SR4ttconf  lda     #AC_MRES   reset the acia          sta     csr,y          pshs    d          delay some here          puls    d          lda     csr,y      get status - see if acia is really here          beq     2f         if 0 status - then ok*          bita    #$f3       see if funny status is ok  todo: bit names          bne     4f*2         lda     tbaud,x    get configuration word from table          ora     #AC_DV16   set up full configuration          sta     csr,y      (no ints enabled & RTS brought high)*          pshs   d,x          lda     tdevic,x   get terminal id          ldb   #DEV_SIZE          mul          ldx   #dev_tab          leax  d,x          ldx   dev_brbu,x   set baudrate latch          lda   0,x          sta   brr,y          puls  d,x          lda     csr,y      get new status          bita    #AS_NCTS   is CTS ok?          beq     6f*4         sez                set        false status          clc                show       wait for CTS          rts                return*6         clz                set        true status          rts                return** ttputc** Send the character in the B register to the ACIA.  All* registers should be preserved.  Y points to the device.*SR4ttputc  stb     dbuf,y     send character          rts     return** ttgetc** Get the character from the device and return in the B* register.  Y points to the device and all registers* should be preserved.*SR4ttgetc  ldb     dbuf,y     get the character          rts     return** ttenxr** Enable the transmit interrupts and leave the receive* interrupt enabled (it is enabled upon routine entry).* Y points to the device and X points to to the terminal* table entry.  Preserve all registers but D.**SR4ttnxr  lda     tbaud,x    get configuration          ora     #AC_TEIN+AC_REIN+AC_DV16 enable int bits          sta     csr,y      send to acia          rts     return** ttdisx** Disable the transmit interrupt and leave the receive* interrupt enabled.  Y points to the device and X points* to the terminal table entry.  Preserve all but D.*SR4ttdisx  lda     tbaud,x    get configuration word          ora     #AC_REIN+AC_DV16  set bits          sta     csr,y      send to acia          rts     return** ttenr** Enable the receive interrupts only.  The transmit* interrupts should be turned off.  Y points to the device* and X point to the terminal table entry.  Preserve all* but the D register.*SR4ttnr   lda     tbaud,x    get configuration word          ora     #AC_REIN+AC_DV16  set bits          sta     csr,y      send to acia          rts     return** ttenx** Enable the transmit interrupts only.  The receive* interrupts should be left disabled.  Y points to the* device and X points to the terminal table entry.* All registers but D shoud be preserved.*SR4ttnx   lda     tbaud,x    get configuration word          ora     #AC_TEIN+AC_DV16 set bits          sta     csr,y      send to acia          rts     return** ttenno** Disable all interrupts from device and drop the RTS* line.  Y points to the device and X points to the* terminal table entry.  Preserve all but D register.*SR4ttnno  lda     tbaud,x    get configuration word          ora     #AC_DRTS+AC_DV16   set bits          sta     csr,y      send to acia          rts     return** ttxbsy** Test if the transmit buffer is empty.  Return TRUE if* it is empty (N.E. status). Y points to the device and* all but A needs preserved.*SR4ttxbsy  lda     csr,y      get status          bita    #AS_TDRE    is it busy?          rts     return** tttstx** Test device pointed at by Y for a transmit interrupt.* Return TRUE if interrupt present.  Preserve all but* the A register.*SR4ttstx  lda     csr,y      get status          bita    #AS_TDRE          bne     SR4true          bra     SR4false** ttiscts** Test device pointed at by X for "Clear to Send"* -- Return TRUE (not equal) if yes*SR4ttiscts          bita    #AS_NCTS    is CTS down?          bne     SR4falseSR4true    clz     no         - return TRUE          rtsSR4false   sez     yes        - return FALSE          rts** tttstr** Test device pointed at by Y for a receive interrupt.* Return TRUE if interrupt present.  Preserve all but* the A register.*SR4ttstr  lda     csr,y          bita    #AS_RDRF          bne     SR4true          bra     SR4false** tttstb** Test device pointed at by Y for a "break" condition.* Return TRUE if found.  Preserve all registers but A* and return NULL in B (for break character).*SR4ttstb  bita    #AS_OVRN+AS_FRME   check for break condition          beq     2f         ZERO = false*          ldb     dbuf,y     get character from acia          pshs    d,x,y,u    delay some here          puls    d,x,y,u          lda     dbuf,y     get next garbage char if any          clz     set        TRUE*2         rts     return** tttsts** Test device for "CTS" interrupt.*SR4ttsts  bra     SR4false    not currently implemented** tttstc** Test device pointed at by Y for drop "Carrier Detect"* type interrupt.  Return TRUE if so.  Preserve all registers* but A.*SR4ttstc  bita    #AS_NDCD   check for carrier drop          beq     1f         jump if no error*          ldb     dbuf,y     read reg to reset status          clz     return     true*1         rts     return** tttste** Test device pointed at by Y for error conditions.* Handle all errors local to this routine - no status* returned.  Preserve all but A.*SR4ttste  lda     dbuf,y     read data register to clear any interrupt conditions          sez                return false clz     return     true          rts     return** tttstd - Test for drop in DTR*SR4ttstd  sez     --         not supported by hardware          rts** ttend** Terminate i/o operation for device pointed at by Y.* Preserve all but D.*SR4ttnd   rts     return     (nothing for acia)** ttwcts** Wait for CTS to go high (sleep on it).*SR4ttwcts  bsr     SR4ttnx    enable xmit ints only          ldb     #TTYOPR    set priority          ldy     tqout,x    point to output q          jmp     sleep      sleep on CTS** ttwdcd** Wait for DCD to go high (sleep on it).*SR4ttwdcd  rts     currently  not implemented